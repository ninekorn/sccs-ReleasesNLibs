using System;
using System.Collections.Generic;
using System.Text;

using SharpDX;
using SCCoreSystems.SC_Graphics;
using Jitter;
using Jitter.Dynamics;
using Jitter.Collision;
using Jitter.LinearMath;
using Jitter.Collision.Shapes;
using Jitter.Forces;

using scmessageobject = SCCoreSystems.scmessageobject.scmessageobject;
using scmessageobjectjitter = SCCoreSystems.scmessageobject.scmessageobjectjitter;
using scgraphicssecpackage = SCCoreSystems.scmessageobject.scgraphicssecpackage;

using System.Collections.Generic;
using System.Collections;
using System.ComponentModel;
using System.Diagnostics;
using System.Threading;
using System.Threading.Tasks;
using Ab3d.OculusWrap;
using SC_WPF_RENDER;
using SC_WPF_RENDER.SC_Graphics;
using SC_WPF_RENDER.SC_Graphics.SC_Grid;

using SCCoreSystems.SC_Graphics;
using Ab3d.OculusWrap.DemoDX11;

using System.Runtime.InteropServices;

using System.IO;

using System.Security;
using System.Security.Permissions;

using Jitter.DataStructures;
using SingleBodyConstraints = Jitter.Dynamics.Constraints.SingleBody;
//using Jitter.Dynamics.Constraints.SingleBody;
//using Jitter.LinearMath;
using Jitter.Dynamics.Constraints;
//using Jitter.Dynamics.Joints;
//using Jitter.Forces;

//using DeltaEngine.Datatypes;
//using DeltaEngine.Core;
//using DeltaEngine.Extensions;

using Vector2 = SharpDX.Vector2;
using Vector3 = SharpDX.Vector3;
using Vector4 = SharpDX.Vector4;
using Quaternion = SharpDX.Quaternion;
using Matrix = SharpDX.Matrix;
using Plane = SharpDX.Plane;
using Ray = SharpDX.Ray;

using SCCoreSystems.SC_Graphics.SC_Grid;
using System.Text;
using System.IO;
using SharpDX.Multimedia;
using SharpDX.IO;
using System.Xml;
using SharpDX.XAudio2;
using System.Linq;
using SharpDX.Direct3D11;
using SharpDX.DXGI;

//using System.Windows.Forms;
using System.IO.Ports;

using SharpDX.D3DCompiler;

namespace SCCoreSystems.sc_console
{
    public class sc_graphics_sec //: SC_Update//SC_Intermediate_Update
    {
        scgraphicssecpackage scgraphicssecpackagemessage;

        int playerusebrush = -1; //0
        int brushsizelx = 0;
        int brushsizely = 0;
        int brushsizelz = 0;

        int brushsizerx = 1;
        int brushsizery = 1;
        int brushsizerz = 1;


        public struct worldsize
        {
            public int xl;
            public int xr;
            public int yl;
            public int yr;
            public int zl;
            public int zr;
        }

        //FROM MY VOID EXPANSE 9sMODs series. I DEVELOPPED THIS MYSELF.
        //FROM MY VOID EXPANSE 9sMODs series. I DEVELOPPED THIS MYSELF.
        public Vector3 getGridWorldPosition(Vector3 initialPos, Vector3 seekerPos, worldsize gridWorldSize)
        {
            int menuscrollerstopwatchcounter = 0;

            var diffX = Math.Round(Math.Abs(Math.Abs(seekerPos.X) - Math.Abs(initialPos.X)));
            var diffY = Math.Round(Math.Abs(Math.Abs(seekerPos.Y) - Math.Abs(initialPos.Y)));
            var diffZ = Math.Round(Math.Abs(Math.Abs(seekerPos.Z) - Math.Abs(initialPos.Z)));

            float currentGridPosX;
            float currentGridPosY;
            float currentGridPosZ;
            float dividerDecimal = 0;

            if ((gridWorldSize.xl + gridWorldSize.xr + 1) == 5)
            {
                dividerDecimal = 0.2f;
            }
            else if ((gridWorldSize.xl + gridWorldSize.xr + 1) == 10)
            {
                dividerDecimal = 0.1f;
            }
            else if ((gridWorldSize.xl + gridWorldSize.xr + 1) == 20)
            {
                dividerDecimal = 0.05f;
            }
            else if ((gridWorldSize.xl + gridWorldSize.xr + 1) == 8)
            {
                dividerDecimal = 0.125f;
            }
            else if ((gridWorldSize.xl + gridWorldSize.xr + 1) == 6)
            {
                dividerDecimal = 0.16666666666666666666666666666667f;
            }
            else if ((gridWorldSize.xl + gridWorldSize.xr + 1) == 4)
            {
                dividerDecimal = 0.25f;
            }

            var totalRemainsDivX = (diffX * dividerDecimal);
            var flooredRemainsDivX = Math.Floor(totalRemainsDivX);
            var lastRemainsDivX = totalRemainsDivX - flooredRemainsDivX;

            var testX00 = diffX - gridWorldSize.xl - (flooredRemainsDivX * (gridWorldSize.xl + gridWorldSize.xr + 1));
            var testX01 = diffX - gridWorldSize.xr - (flooredRemainsDivX * (gridWorldSize.xl + gridWorldSize.xr + 1));

            if (seekerPos.X < initialPos.X)
            {
                if (testX00 > 0)
                {
                    flooredRemainsDivX = flooredRemainsDivX + 1;
                }
                currentGridPosX = (float)Math.Round(initialPos.X - ((gridWorldSize.xl + gridWorldSize.xr + 1) * flooredRemainsDivX));
            }
            else if (seekerPos.X > initialPos.X)
            {
                if (testX01 > 0)
                {
                    flooredRemainsDivX = flooredRemainsDivX + 1;
                }
                currentGridPosX = (float)Math.Round(initialPos.X + ((gridWorldSize.xl + gridWorldSize.xr + 1) * flooredRemainsDivX));
            }
            else
            {
                currentGridPosX = (float)Math.Round(initialPos.X);
            }

            var totalRemainsDivY = (diffY * dividerDecimal);
            var flooredRemainsDivY = (float)Math.Floor(totalRemainsDivY);
            var lastRemainsDivY = totalRemainsDivY - flooredRemainsDivY;

            var testY00 = diffY - gridWorldSize.yl - (flooredRemainsDivY * (gridWorldSize.xl + gridWorldSize.xr + 1));
            var testY01 = diffY - gridWorldSize.yr - (flooredRemainsDivY * (gridWorldSize.xl + gridWorldSize.xr + 1));

            if (seekerPos.Y < initialPos.Y)
            {
                if (testY00 > 0)
                {
                    flooredRemainsDivY = flooredRemainsDivY + 1;
                }
                currentGridPosY = (float)Math.Round(initialPos.Y - ((gridWorldSize.yl + gridWorldSize.yr + 1) * flooredRemainsDivY));
            }
            else if (seekerPos.Y > initialPos.Y)
            {
                if (testY01 > 0)
                {
                    flooredRemainsDivY = flooredRemainsDivY + 1;
                }
                currentGridPosY = (float)Math.Round(initialPos.Y + ((gridWorldSize.yl + gridWorldSize.yr + 1) * flooredRemainsDivY));
            }
            else
            {
                currentGridPosY = (float)Math.Round(initialPos.Y);
            }

            var totalRemainsDivZ = (diffZ * dividerDecimal);
            var flooredRemainsDivZ = (float)Math.Floor(totalRemainsDivZ);
            var lastRemainsDivZ = totalRemainsDivZ - flooredRemainsDivZ;

            var testZ00 = diffZ - gridWorldSize.zl - (flooredRemainsDivZ * (gridWorldSize.zl + gridWorldSize.zr + 1));
            var testZ01 = diffZ - gridWorldSize.zr - (flooredRemainsDivZ * (gridWorldSize.zl + gridWorldSize.zr + 1));

            if (seekerPos.Z < initialPos.Z)
            {
                if (testZ00 > 0)
                {
                    flooredRemainsDivZ = flooredRemainsDivZ + 1;
                }
                currentGridPosZ = (float)Math.Round(initialPos.Z - ((gridWorldSize.zl + gridWorldSize.zr + 1) * flooredRemainsDivZ));
            }
            else if (seekerPos.Z > initialPos.Z)
            {
                if (testZ01 > 0)
                {
                    flooredRemainsDivZ = flooredRemainsDivZ + 1;
                }
                currentGridPosZ = (float)Math.Round(initialPos.Z + ((gridWorldSize.zl + gridWorldSize.zr + 1) * flooredRemainsDivZ));
            }
            else
            {
                currentGridPosZ = (float)Math.Round(initialPos.Z);
            }

            return new Vector3(currentGridPosX, currentGridPosY, currentGridPosZ);
            //return { x: currentGridPosX, y: currentGridPosY, gridX: flooredRemainsDivX, gridY: flooredRemainsDivY }; // 
        }
        //FROM MY VOID EXPANSE 9sMODs series. I DEVELOPPED THIS MYSELF.
        //FROM MY VOID EXPANSE 9sMODs series. I DEVELOPPED THIS MYSELF.

        Stopwatch keyboardclickstopwatch = new Stopwatch();

        float _dist_between = 1.0f;
        float _mass = 1.0f;
        int resetvoxelladdercounter = 1;
        int resetvoxelladder = 0;

        //TO STABILIZE THE MOUSE CURSOR ON THE SCREEN.
        const int _MaxArraySize0 = 15; //50
        const int _MaxArraySize1 = 14; //49
        //TO STABILIZE THE MOUSE CURSOR ON THE SCREEN.

        object _some_data_0;
        World _thejitter_world;

        int somechunkplayerspatiallocationscenesw = 1;
        int somechunkplayerspatiallocationscenesh = 1;
        int somechunkplayerspatiallocationscenesd = 1;
        SC_instancedChunkPrim[] somechunkplayerspatiallocationscene;
        SC_GlobalsVoxelInstancing someglobalsplayerspatiallocation;

        int somechunkmeshswidth = 1;
        int somechunkmeshsheight = 1;
        int somechunkmeshsdepth = 1;
        SC_instancedChunkPrim[] somechunkmesh;
        SC_GlobalsVoxelInstancing someglobalschunkmesh;

        int somechunkmeshgridsw = 1;
        int somechunkmeshgridsh = 1;
        int somechunkmeshgridsd = 1;
        SC_instancedChunkPrim[] somechunkmeshgrid;
        SC_GlobalsVoxelInstancing someglobalschunkmeshgrid;

        int somechunkkeyboardw = 1;
        int somechunkkeyboardh = 1;
        int somechunkkeyboardd = 1;
        SC_instancedChunkPrim[] somechunkkeyboard;
        SC_GlobalsVoxelInstancing somechunkkeyboardglobals;

        int somechunkkeyboardsgridw = 1;
        int somechunkkeyboardsgridh = 1;
        int somechunkkeyboardsgridd = 1;
        SC_instancedChunkPrim[] somechunkkeyboardgrid;
        SC_GlobalsVoxelInstancing somechunkkeyboardglobalsgrid;

        int somevoxelvirtualdesktopw = 1;
        int somevoxelvirtualdesktoph = 1;
        int somevoxelvirtualdesktopd = 1;
        SC_instancedChunkPrim[] somevoxelvirtualdesktop;
        SC_GlobalsVoxelInstancing somevoxelvirtualdesktopglobals;

        int somevoxelvirtualdesktopgridw = 1;
        int somevoxelvirtualdesktopgridh = 1;
        int somevoxelvirtualdesktopgridd = 1;
        SC_instancedChunkPrim[] somevoxelvirtualdesktopgrid;
        SC_GlobalsVoxelInstancing somevoxelvirtualdesktopglobalsgrid;

        int somevoxelroomw = 1;
        int somevoxelroomh = 1;
        int somevoxelroomd = 1;
        SC_instancedChunkPrim[] somevoxelroom;
        SC_GlobalsVoxelInstancing somevoxelroomglobals;

        int somevoxelroomgridw = 1;
        int somevoxelroomgridh = 1;
        int somevoxelroomgridd = 1;
        SC_instancedChunkPrim[] somevoxelroomgrid;
        SC_GlobalsVoxelInstancing somevoxelroomgridglobals;

        //somechunkplayerspatiallocationscene

        float vertoffsetx;
        float vertoffsety;
        float vertoffsetz;
        Matrix _tempMatroxer;

        int someinstancebytesindex = 0;
        int swtciscontained = -1;
        int somecounterfordeleteblock = 0;
        int somecounterfordeleteblockmax = 100;
        int consolewritecounter = 0;
        int consolewritecountermax = 0;
        int consolewritecounterswtc = 0;

        FastNoise fastNoise = new FastNoise();

        int somechunkresetcounter = 0;
        int somechunkplayerspatiallocationresetcounter = 0;

        //int somecounterresetcountermax = 5;

        double m11 = 0;
        double m12 = 0;
        double m13 = 0;
        double m14 = 0;
        double m21 = 0;
        double m22 = 0;
        double m23 = 0;
        double m24 = 0;
        double m31 = 0;
        double m32 = 0;
        double m33 = 0;
        double m34 = 0;
        double m41 = 0;
        double m42 = 0;
        double m43 = 0;
        double m44 = 0;

        double m11b = 0;
        double m12b = 0;
        double m13b = 0;
        double m14b = 0;
        double m21b = 0;
        double m22b = 0;
        double m23b = 0;
        double m24b = 0;
        double m31b = 0;
        double m32b = 0;
        double m33b = 0;
        double m34b = 0;
        double m41b = 0;
        double m42b = 0;
        double m43b = 0;
        double m44b = 0;

        double m11c = 0;
        double m12c = 0;
        double m13c = 0;
        double m14c = 0;
        double m21c = 0;
        double m22c = 0;
        double m23c = 0;
        double m24c = 0;
        double m31c = 0;
        double m32c = 0;
        double m33c = 0;
        double m34c = 0;
        double m41c = 0;
        double m42c = 0;
        double m43c = 0;
        double m44c = 0;

        double m11d = 0;
        double m12d = 0;
        double m13d = 0;
        double m14d = 0;
        double m21d = 0;
        double m22d = 0;
        double m23d = 0;
        double m24d = 0;
        double m31d = 0;
        double m32d = 0;
        double m33d = 0;
        double m34d = 0;
        double m41d = 0;
        double m42d = 0;
        double m43d = 0;
        double m44d = 0;





        Quaternion _testQuater;

        int[] arrayOfPixData;
        int setArray = 0;

        [System.Runtime.InteropServices.DllImport("gdi32.dll")]
        public static extern bool DeleteObject(IntPtr hObject);

        int writeProcess = 0;

        [StructLayout(LayoutKind.Sequential)]
        public struct DHeightMapType
        {
            public float x, y, z;
        }
        //[DllImport("user32.dll")]
        //[return: MarshalAs(UnmanagedType.Bool)]
        //static extern bool GetWindowRect(HandleRef hWnd, out RECT lpRect);
        //[DllImport("user32.dll", SetLastError = true)]
        //static extern bool GetWindowRect(IntPtr hwnd, out RECT lpRect);

        [DllImport("user32.dll")]
        public static extern long GetWindowRect(IntPtr hWnd, ref System.Drawing.Rectangle lpRect);

        [StructLayout(LayoutKind.Sequential)]
        public struct RECT
        {
            public int Left;        // x position of upper-left corner
            public int Top;         // y position of upper-left corner
            public int Right;       // x position of lower-right corner
            public int Bottom;      // y position of lower-right corner
        }

        Rectangle myRect = new Rectangle();


        IntPtr MSEdgeHandle;

        [DllImport("user32.dll")]
        private static extern bool EnumWindows(EnumWindowsProc enumProc, IntPtr lParam);

        [DllImport("user32.dll", CharSet = CharSet.Unicode, SetLastError = true)]
        private static extern int GetWindowText(IntPtr hWnd, StringBuilder lpString, int nMaxCount);

        [DllImport("user32.dll", CharSet = CharSet.Unicode)]
        private static extern int GetWindowTextLength(IntPtr hWnd);

        [DllImport("user32.dll", SetLastError = true, CharSet = CharSet.Auto)]
        private static extern int GetClassName(IntPtr hWnd, StringBuilder lpClassName, int nMaxCount);

        [DllImport("user32.dll", ExactSpelling = true, CharSet = CharSet.Auto)]
        private static extern bool ShowWindow(IntPtr hWnd, int nCmdShow);

        public delegate bool EnumWindowsProc(IntPtr hWnd, IntPtr lParam);


        public const int SW_HIDE = 0;
        public const int SW_SHOWNORMAL = 1;
        public const int SW_SHOWMINIMIZED = 2;
        public const int SW_SHOWMAXIMIZED = 3;


        //https://stackoverflow.com/questions/61451756/how-to-check-if-a-user-has-a-browser-open-in-c-sharp user Metzgermeister
        internal class BrowserDetector
        {
            private readonly Dictionary<string, string> browsers = new Dictionary<string, string>
            {
                {
                    "firefox", "Mozilla Firefox"
                },
                {
                    "chrome", "Google Chrome"
                },
                {
                    "iexplore", "Internet Explorer"
                },
                {
                    "MicrosoftEdgeCP", "Microsoft Edge"
                }
                ,
                {
                    "msedge", "Microsoft Edge"
                }
                 ,
                {
                    "MicrosoftEdge", "Microsoft Edge"
                }

                // add other browsers
            };

            public bool BrowserIsOpen()
            {
                return Process.GetProcesses().Any(this.IsBrowserWithWindow);
            }

            private bool IsBrowserWithWindow(Process process)
            {
                return this.browsers.TryGetValue(process.ProcessName, out var browserTitle) && process.MainWindowTitle.Contains(browserTitle);
            }
        }




        //[DllImport("user32.dll")]
        //public static extern bool GetWindowRect(IntPtr hwnd, ref Rect rectangle);
        //Rect r = new Rect();
        //GetWindowRect(hwnd, ref r);




        [DllImport("user32.dll", EntryPoint = "FindWindow", SetLastError = true)]
        static extern IntPtr FindWindowByCaption(IntPtr ZeroOnly, string lpWindowName);

        [DllImport("user32.dll", CharSet = CharSet.Auto, ExactSpelling = true)]
        public static extern IntPtr GetForegroundWindow();

        //[DllImport("user32.dll")]
        //private static extern bool GetWindowRect(IntPtr hWnd, Rectangle rect);


        float heightmapscale = 0.001f;
        float heightmapscaleMin = 0.0001f;
        float heightmapscaleMax = 100f;


        public DColorShader ColorShader { get; set; }
        public DFontShader FontShader { get; set; }


        float totalDiffX = 0;
        float totalDiffY = 0;
        float totalDiffZ = 0;

        public static double touchRXLast = 0;
        public static double touchRYLast = 0;
        public static double touchRZLast = 0;


        public static double touchRX = 0;
        public static double touchRY = 0;
        public static double touchRZ = 0;

        Matrix grabbedBodyMatrix = Matrix.Identity;


        double pitchTouchRer = 0;
        double yawTouchRer = 0;
        double rollTouchRer = 0;

        Matrix rotMatForPelvis = SharpDX.Matrix.Identity;



        Vector3 current_rotation_of_torso_pivot_forward = Vector3.Zero;
        Vector3 current_rotation_of_torso_pivot_right = Vector3.Zero;
        Vector3 current_rotation_of_torso_pivot_up = Vector3.Zero;


        Vector3 rayDirUp = Vector3.Zero;
        Vector3 rayDirRight = Vector3.Zero;
        Vector3 rayDirForward = Vector3.Zero;


        double grabrotX = 0;
        double grabrotY = 0;
        double grabrotZ = 0;


        double grabrotDiffx = 0;
        double grabrotDiffy = 0;
        double grabrotDiffz = 0;


        /*protected override void SC_Init_DirectX() //DSystemConfiguration configuration, IntPtr Hwnd, sc_console.sc_console_writer _writer
        {
            base.SC_Init_DirectX(); //configuration, Hwnd, _writer
        }*/

        /*public override scmessageobjectjitter[][] scwritetobuffer(scmessageobjectjitter[][] _sc_jitter_tasks)
        {
            return _sc_jitter_tasks;
            //base.scwritetobuffer(_sc_jitter_tasks);
        }

        public override scmessageobjectjitter[][] loop_worlds(scmessageobjectjitter[][] _sc_jitter_tasks)
        {
            return _sc_jitter_tasks;
            //base.scwritetobuffer(_sc_jitter_tasks);
        }
        public override scmessageobjectjitter[][] workOnSomething(scmessageobjectjitter[][] _sc_jitter_tasks, Matrix viewMatrix, Matrix projectionMatrix, Vector3 OFFSETPOS, Matrix originRot, Matrix rotatingMatrix, Matrix rotatingMatrixForPelvis, Matrix _rightTouchMatrix, Matrix _leftTouchMatrix, Posef handPoseRight, Posef handPoseLeft)
        {
            return _sc_jitter_tasks;
            //base.scwritetobuffer(_sc_jitter_tasks);
        }
        public override scmessageobjectjitter[][] _sc_create_world_objects(scmessageobjectjitter[][] _sc_jitter_tasks)
        {
            return _sc_jitter_tasks;
            //base.scwritetobuffer(_sc_jitter_tasks);
        }


        protected override scmessageobjectjitter[][] init_update_variables(scmessageobjectjitter[][] _sc_jitter_tasks, SCCoreSystems.sc_core.sc_system_configuration configuration, IntPtr hwnd, sc_console.sc_console_writer _writer)
        {

        }
        protected override scmessageobjectjitter[][] Update(_sc_jitter_physics[] _sc_jitter_physics, scmessageobjectjitter[][] _sc_jitter_tasks)
        {
            base.Update(_sc_jitter_physics, _sc_jitter_tasks);
        }*/

        Vector3 direction_feet_forward_ori = Vector3.Zero;
        Vector3 direction_feet_right_ori = Vector3.Zero;
        Vector3 direction_feet_up_ori = Vector3.Zero;

        int sc_menu_scroller = 0;
        int sc_menu_scroller_counter = 0;

        Vector4 ambientColor = new Vector4(0.45f, 0.45f, 0.45f, 1.0f);
        Vector4 diffuseColour = new Vector4(1, 1, 1, 1);
        Vector3 lightDirection = new Vector3(0, -1, -1);
        Vector3 dirLight = new Vector3(0, -1, 0);
        Vector3 lightpos = new Vector3(0, 20, 0);

        SharpDX.Matrix _oculusR_Cursor_matrix = SharpDX.Matrix.Identity;
        Stopwatch _updateFunctionStopwatchRightThumbstickGoRight = new Stopwatch();
        Stopwatch _updateFunctionStopwatchRightThumbstickGoLeft = new Stopwatch();
        Stopwatch _updateFunctionStopwatchLeftThumbstick = new Stopwatch();
        Stopwatch _updateFunctionStopwatchRight = new Stopwatch();

        int frame_counter_4_buttonY = 45;
        int display_grid_type = 0;

        int gravity_swtch_counter = 45;
        int gravity_swtch = 0;

        Matrix hmd_matrix_current = Matrix.Identity;
        Matrix hmdmatrixcurrentforpelvis = Matrix.Identity;

        SharpDX.Matrix _intersectTouchRightMatrix = SharpDX.Matrix.Identity;
        SharpDX.Matrix _intersectTouchLeftMatrix = SharpDX.Matrix.Identity;

        Matrix final_hand_pos_right_locked;
        Matrix final_hand_pos_left_locked;
        Matrix tempMatrix = Matrix.Identity;// tempMatrix
        Matrix _last_screen_pos = Matrix.Identity;
        int had_locked_screen = -1;
        int _tier_logic_swtch_lock_screen = 0;
        Matrix _current_screen_pos = Matrix.Identity;

        //OCULUS TOUCH SETTINGS 
        Ab3d.OculusWrap.Result resultsRight;
        uint buttonPressedOculusTouchRight;
        Vector2f[] thumbStickRight;
        float[] handTriggerRight;
        float[] indexTriggerRight;

        float indexTriggerRightLastAbs;
        float indexTriggerLeftLastAbs;

        Ab3d.OculusWrap.Result resultsLeft;
        uint buttonPressedOculusTouchLeft;
        Vector2f[] thumbStickLeft;
        float[] handTriggerLeft;
        float[] indexTriggerLeft;
        Posef handPoseLeft;
        SharpDX.Quaternion _leftTouchQuat;
        Posef handPoseRight;
        SharpDX.Quaternion _rightTouchQuat;
        Matrix _leftTouchMatrix = Matrix.Identity;
        Matrix _rightTouchMatrix = Matrix.Identity;
        //OCULUS TOUCH SETTINGS

        float disco_sphere_rot_speed = 0.15f;
        float force_4_voxel = 0.0015f;
        float force_4_cubes = 0.0015f;
        float force_4_screen = 0.0015f;
        int _has_locked_screen_pos = 0;
        int _has_locked_screen_pos_counter = 0;
        Matrix _direction_offsetter;
        Matrix _screen_direction_offsetter_two;
        float sizeWidtherer = 0.0f;
        float sizeheighterer = 0.0f;
        Matrix[] worldMatrix_Cloth_instances;

        PseudoCloth sc_jitter_cloth;
        double RotationScreenY { get; set; }
        double RotationScreenX { get; set; }
        double RotationScreenZ { get; set; }

        Matrix originRotScreen;
        Matrix rotatingMatrixScreen;
        float oriRotationScreenY { get; set; }
        float oriRotationScreenX { get; set; }
        float oriRotationScreenZ { get; set; }

        struct _rigid_data
        {
            public RigidBody _body;
            public Matrix position;
            public Vector3 directionToGrabber;
            public Vector3 rayGrabDir;
            public float rayGrabDirLength;
            public Vector3 grabHitPoint;
            public float grabHitPointLength;
            public float dirDiffX;
            public float dirDiffY;
            public float dirDiffZ;

            public int _index;
            public int _physics_engine_index;
        }

        _rigid_data _grab_rigid_data;
        float _size_screen;
        int[][][] swtch_for_last_pos;
        int tempIndex = 0;
        int _inactive_counter_cubes = 0;
        int _inactive_counter_voxels = 0;

        int _static_counter = 0;
        Quaternion quat_buffers;

        //SCREEN SETTINGS
        int _inst_screen_x = 1;
        int _inst_screen_y = 1;
        int _inst_screen_z = 1;

        float _screen_size_x = 2; //0.0115f //1.5f
        float _screen_size_y = 2; //0.0115f //1.5f
        float _screen_size_z = 0.0035f; //0.0025f

        float mulScreen = 0.85f;

        int _inst_screen_assets_x = 3;
        int _inst_screen_assets_y = 1;
        int _inst_screen_assets_z = 3;

        float _screen_assets_size_x = 0.005f; //0.0115f //1.5f
        float _screen_assets_size_y = 0.005f; //0.0115f //1.5f
        float _screen_assets_size_z = 0.025f;

        bool is_static = false;
        //END OF

        //HUMAN RIG
        int tempMultiInstancePhysicsTotal = 1;
        int _human_inst_rig_x = 1;
        int _human_inst_rig_y = 1;
        int _human_inst_rig_z = 1;
        const int _addToWorld = 0;

        //the physics engine can run 4000 objects enabled and having angularOrLinear velocities but the voxels lag a bit at that many objects. but loading as many as 475000 cubes
        //having 36 vertices each and 72 triangles each but at that point it will also lag. will try later to improve the performance.
        float _voxel_mass = 100;

        int _inst_voxel_cube_x = 10;
        int _inst_voxel_cube_y = 1;
        int _inst_voxel_cube_z = 1;

        float _voxel_cube_size_x = 0.15f;//0.0115f //restitution
        float _voxel_cube_size_y = 0.15f;//0.0115f //static friction
        float _voxel_cube_size_z = 0.15f;//0.0015f //kinetic friction

        float voxel_general_size = 0.0025f;
        int voxel_type = -1;

        float _voxel_rig_cube_size_x = 0.15f;//0.0115f //restitution
        float _voxel_rig_cube_size_y = 0.15f;//0.0115f //static friction
        float _voxel_rig_cube_size_z = 0.15f;//0.0015f //kinetic friction

        //1,024‬
        //1,024‬
        //1,024‬
        //1,024‬
        //1,024‬
        //1,024‬

        //PHYSICS CUBES
        int _inst_cube_x = 2;
        int _inst_cube_y = 2;
        int _inst_cube_z = 2;

        int _inst_other_x = 1;
        int _inst_other_y = 1;
        int _inst_other_z = 1;

        float _cube_size_x = 0.025f; //0.0115f //1.5f
        float _cube_size_y = 0.025f; //0.0115f //1.5f
        float _cube_size_z = 0.025f;
        //END OF

        //PHYSICS GRID
        int _inst_grid_x = 1;
        int _inst_grid_y = 1;
        int _inst_grid_z = 1;
        float _grid_size_x = 10; //0.0115f //1.5f
        float _grid_size_y = 1; //0.0115f //1.5f
        float _grid_size_z = 10;
        //END OF

        //float _voxel_cube_size_x = 0.0515f;
        //float _voxel_cube_size_y = 0.0515f;
        //float _voxel_cube_size_z = 0.0515f;


        //SPECTRUM
        //SPECTRUM
        //SPECTRUM
        const int _inst_spectrum_x = 42; // 36 // 210 //75 // 420
        const int _inst_spectrum_y = 1;
        const int _inst_spectrum_z = 21; // 36 // 210 //75 //5625 //210
        float _spectrum_size_x = 0.0015f; //0.001115f
        float _spectrum_size_y = 0.0015f;
        float _spectrum_size_z = 0.0015f;
        byte[] _sound_byte_array = new byte[_inst_spectrum_x * _inst_spectrum_z]; //44100
        byte[] _sound_byte_array_instant = new byte[_inst_spectrum_x * _inst_spectrum_z]; //44100 //176400
        int has_spoken_main = 0;
        int has_spoken_sec = 0;
        int has_spoken_tier = 0;
        int has_spoken_quart = 0;
        string last_xml_filepath = "";
        string last_wave_filepath = "";
        DateTime _time_of_recording_start = DateTime.Now;
        DateTime _time_of_recording_end = DateTime.Now;
        int sc_can_start_rec_counter = 0;
        int sc_can_start_rec_counter_before_add_index = 0;
        int sc_play_file = 0;
        int sc_play_file_counter = 0;
        int sc_save_file = 0;
        int sc_save_file_counter = 0;
        int sc_start_recording = 0;
        int sc_start_recording_counter = 0;
        string short_path = "";
        string instant_short_path = "";
        float spectrum_noise_value = 0;
        SoundPlayer _sound_player = new SoundPlayer();
        Matrix spectrum_mat = Matrix.Identity;
        static XmlTextWriter writer = new XmlTextWriter(Console.Out);
        string path;
        int _records_counter = 0;
        int _records_instant_counter = 0;
        int _frames_to_access_counter = 0;
        int _spectrum_work = 0;
        int _spectrum_work_counter = 0;
        int _has_recorded = 0;

        public static int GetSoundLength(string fileName)
        {
            StringBuilder lengthBuf = new StringBuilder(32);
            mciSendString(string.Format("open \"{0}\" type waveaudio alias wave", fileName), null, 0, IntPtr.Zero);
            mciSendString("status wave length", lengthBuf, lengthBuf.Capacity, IntPtr.Zero);
            mciSendString("close wave", null, 0, IntPtr.Zero);
            int length = 0;
            int.TryParse(lengthBuf.ToString(), out length);
            return length;
        }
        int swtchinstantsound = -1;
        //END OF
        //END OF
        //END OF

        [DllImport("winmm.dll")]
        private static extern long mciSendString(string strCommand, StringBuilder strReturn, int iReturnLength, IntPtr hwndCallback);




        //static cubes 
        int _inst_terrain_tile_x = 1;
        int _inst_terrain_tile_y = 1;
        int _inst_terrain_tile_z = 1;
        float _terrain_tile_size_x = 0.015f;
        float _terrain_tile_size_y = 0.05f;
        float _terrain_tile_size_z = 0.015f;

        //main terrain.
        float _terrain_size_x = 3;
        float _terrain_size_y = 0.095f; //0.02f too small objects go through
        float _terrain_size_z = 3;


        //main terrain.
        float _platform_size_x = 3;
        float _platform_size_y = 2; //0.02f too small objects go through
        float _platform_size_z = 3;


        //main terrain.
        float _floor_size_x = 13;
        float _floor_size_y = 13;
        float _floor_size_z = 13;

        //float _size__neg_x = 1.175494351F - 38;
        //float _size__pos_x = 3.402823466F + 38;
        int _type_of_cube = 3;


        object _some_data_00;
        World _jitter_world;


        Matrix WorldMatrix = Matrix.Identity;
        Matrix _object_worldmatrix = Matrix.Identity;

        Matrix heightMapWorldMatrix = Matrix.Identity;


        //HUMAN RIG
        /*int _inst_p_upper_l_leg_x = _human_inst_rig_x;
        int _inst_p_upper_l_leg_y = _human_inst_rig_y;
        int _inst_p_upper_l_leg_z = _human_inst_rig_z;
        int _inst_p_upper_r_leg_x = _human_inst_rig_x;
        int _inst_p_upper_r_leg_y = _human_inst_rig_y;
        int _inst_p_upper_r_leg_z = _human_inst_rig_z;
        int _inst_p_lower_l_leg_x = _human_inst_rig_x;
        int _inst_p_lower_l_leg_y = _human_inst_rig_y;
        int _inst_p_lower_l_leg_z = _human_inst_rig_z;
        int _inst_p_lower_r_leg_x = _human_inst_rig_x;
        int _inst_p_lower_r_leg_y = _human_inst_rig_y;
        int _inst_p_lower_r_leg_z = _human_inst_rig_z;
        int _inst_p_l_foot_x = _human_inst_rig_x;
        int _inst_p_l_foot_y = _human_inst_rig_y;
        int _inst_p_l_foot_z = _human_inst_rig_z;
        int _inst_p_r_foot_x = _human_inst_rig_x;
        int _inst_p_r_foot_y = _human_inst_rig_y;
        int _inst_p_r_foot_z = _human_inst_rig_z;*/

        /*int _inst_p_l_hand_x = _human_inst_rig_x;
        int _inst_p_l_hand_y = _human_inst_rig_y;
        int _inst_p_l_hand_z = _human_inst_rig_z;*/


        /*int _inst_p_l_shoulder_x = _human_inst_rig_x;
        int _inst_p_l_shoulder_y = _human_inst_rig_y;
        int _inst_p_l_shoulder_z = _human_inst_rig_z;*/

        /*int _inst_p_r_pelvisjoint_x = _human_inst_rig_x;
        int _inst_p_r_pelvisjoint_y = _human_inst_rig_y;
        int _inst_p_r_pelvisjoint_z = _human_inst_rig_z;
        int _inst_p_l_pelvisjoint_x = _human_inst_rig_x;
        int _inst_p_l_pelvisjoint_y = _human_inst_rig_y;
        int _inst_p_l_pelvisjoint_z = _human_inst_rig_z;*/


        /*int _inst_p_l_upperarm_x = _human_inst_rig_x;
        int _inst_p_l_upperarm_y = _human_inst_rig_y;
        int _inst_p_l_upperarm_z = _human_inst_rig_z;*/

        /*int _inst_p_l_lowerarm_x = _human_inst_rig_x;
        int _inst_p_l_lowerarm_y = _human_inst_rig_y;
        int _inst_p_l_lowerarm_z = _human_inst_rig_z;*/
        /*int _inst_p_head_x = _human_inst_rig_x;
        int _inst_p_head_y = _human_inst_rig_y;
        int _inst_p_head_z = _human_inst_rig_z;*/





        sc_voxel_pchunk[] arrayOfPlanetChunk;
        //Matrix[] worldMatrix_instances_voxel_pchunk;
        Matrix[][][][] worldMatrix_instances_voxel_pchunk;















        sccsikvoxellimbs[] ikarmvoxel;
        //Matrix[][][][] worldMatrix_instances_ikarmvoxel;
        int somechunkpriminstancesikarmvoxelwidthR = 2;
        int somechunkpriminstancesikarmvoxelheightR = 2;
        int somechunkpriminstancesikarmvoxeldepthR = 0;
        int somechunkpriminstancesikarmvoxelwidthL = 0;
        int somechunkpriminstancesikarmvoxelheightL = 0;
        int somechunkpriminstancesikarmvoxeldepthL = 0;



        public static sccsikvoxellimbs[] ikvoxelbody;
        // Matrix[][][][] worldMatrix_instances_ikvoxelbody;
        int somechunkpriminstancesikvoxelbodywidthR = 1;
        int somechunkpriminstancesikvoxelbodyheightR = 0;
        int somechunkpriminstancesikvoxelbodydepthR = 0;
        int somechunkpriminstancesikvoxelbodywidthL = 0;
        int somechunkpriminstancesikvoxelbodyheightL = 0;
        int somechunkpriminstancesikvoxelbodydepthL = 0;






        /*sc_voxel voxel_cuber_l_hand_grab;
        sc_voxel voxel_cuber_r_lower_leg;
        sc_voxel voxel_cuber_l_lower_leg;
        sc_voxel voxel_cuber_r_foot;
        sc_voxel voxel_cuber_l_foot;
        sc_voxel voxel_cuber_r_upper_leg;
        sc_voxel voxel_cuber_l_upper_leg;
        sc_voxel voxel_cuber_l_targ_knee;
        sc_voxel voxel_cuber_r_targ_knee;
        sc_voxel voxel_cuber_l_targ_two_knee;
        sc_voxel voxel_cuber_r_targ_two_knee;*/

        //sc_voxel voxel_cuber_l_hnd;

        //sc_voxel voxel_cuber_l_up_arm;

        //sc_voxel voxel_cuber_l_low_arm;


        //sc_voxel voxel_cuber_l_shld;


        //sc_voxel voxel_cuber_l_pelvisjoint;
        //sc_voxel voxel_cuber_r_pelvisjoint;

        //sc_voxel voxel_cuber_l_targ;

        //sc_voxel voxel_cuber_l_targ_two;


        /*Matrix[] voxel_sometester_l_hand_grab;
        Matrix[] voxel_sometester_r_upper_leg;
        Matrix[] voxel_sometester_l_upper_leg;
        Matrix[] voxel_sometester_r_lower_leg;
        Matrix[] voxel_sometester_l_lower_leg;
        Matrix[] voxel_sometester_r_foot;
        Matrix[] voxel_sometester_l_foot;*/

        //Matrix[] voxel_sometester_l_hnd;
        //Matrix[] voxel_sometester_l_up_arm;

        //Matrix[] voxel_sometester_l_low_arm;

        //Matrix[] voxel_sometester_l_shld;



        //Matrix[] voxel_sometester_l_pelvisjoint;
        //Matrix[] voxel_sometester_r_pelvisjoint;

        //Matrix[] voxel_sometester_l_targ;

        //Matrix[] voxel_sometester_l_targ_two;

        /* Matrix[] voxel_sometester_l_targ_knee;
         Matrix[] voxel_sometester_r_targ_knee;
         Matrix[] voxel_sometester_l_targ_two_knee;
         Matrix[] voxel_sometester_r_targ_two_knee;*/







        //sc_voxel.DLightBuffer[] _SC_modL_l_hand_grab_BUFFER = new sc_voxel.DLightBuffer[1];
        /*sc_voxel.DLightBuffer[] _SC_modL_r_upper_leg_BUFFER = new sc_voxel.DLightBuffer[1];
        sc_voxel.DLightBuffer[] _SC_modL_l_upper_leg_BUFFER = new sc_voxel.DLightBuffer[1];
        sc_voxel.DLightBuffer[] _SC_modL_r_lower_leg_BUFFER = new sc_voxel.DLightBuffer[1];
        sc_voxel.DLightBuffer[] _SC_modL_l_lower_leg_BUFFER = new sc_voxel.DLightBuffer[1];*/
        /*sc_voxel.DLightBuffer[] _SC_modL_r_foot_BUFFER = new sc_voxel.DLightBuffer[1];
        sc_voxel.DLightBuffer[] _SC_modL_l_foot_BUFFER = new sc_voxel.DLightBuffer[1];*/
        //sc_voxel.DLightBuffer[] _SC_modL_lft_hnd_BUFFER = new sc_voxel.DLightBuffer[1];



        //sc_voxel.DLightBuffer[] _SC_modL_lft_shldr_BUFFER = new sc_voxel.DLightBuffer[1];


        //sc_voxel.DLightBuffer[] _SC_modL_rght_pelvisjoint_BUFFER = new sc_voxel.DLightBuffer[1];
        //sc_voxel.DLightBuffer[] _SC_modL_lft_pelvisjoint_BUFFER = new sc_voxel.DLightBuffer[1];






        //sc_voxel.DLightBuffer[] _SC_modL_lft_elbow_target_BUFFER = new sc_voxel.DLightBuffer[1];
        //sc_voxel.DLightBuffer[] _SC_modL_lft_lower_arm_BUFFER = new sc_voxel.DLightBuffer[1];

        //sc_voxel.DLightBuffer[] _SC_modL_rght_elbow_target_knee_BUFFER = new sc_voxel.DLightBuffer[1];
        //sc_voxel.DLightBuffer[] _SC_modL_lft_elbow_target_knee_BUFFER = new sc_voxel.DLightBuffer[1];
        //sc_voxel.DLightBuffer[] _SC_modL_rght_elbow_target_two_knee_BUFFER = new sc_voxel.DLightBuffer[1];
        //sc_voxel.DLightBuffer[] _SC_modL_lft_elbow_target_two_knee_BUFFER = new sc_voxel.DLightBuffer[1];




        //Matrix[][][] worldMatrix_instances_l_hand_grab;
        //Matrix[][][] worldMatrix_instances_player_ik;



        //Matrix[][][] worldMatrix_instances_l_elbow_target;

        //Matrix[][][] worldMatrix_instances_l_elbow_target_two;
        //Matrix[][][] worldMatrix_instances_r_target_knee;
        //Matrix[][][] worldMatrix_instances_l_target_knee;
        //Matrix[][][] worldMatrix_instances_r_target_two_knee;
        //Matrix[][][] worldMatrix_instances_l_target_two_knee;
        //Matrix[][][] worldMatrix_instances_r_upper_leg;
        //Matrix[][][] worldMatrix_instances_l_upper_leg;
        //Matrix[][][] worldMatrix_instances_r_lower_leg;
        //Matrix[][][] worldMatrix_instances_l_lower_leg;


        //Matrix[][][] worldMatrix_instances_r_foot;
        //Matrix[][][] worldMatrix_instances_l_foot;


        //Matrix[][][] worldMatrix_instances_l_hand;

        //Matrix[][][] worldMatrix_instances_l_shoulder;

        //Matrix[][][] worldMatrix_instances_r_pelvisjoint;
        //Matrix[][][] worldMatrix_instances_l_pelvisjoint;



        //Matrix[][][] worldMatrix_instances_l_upperarm;

        Matrix[][][] worldMatrix_instances_l_lowerarm;
        Matrix[][][] worldMatrix_instances_containment_grid_LH;

        //sc_voxel.DLightBuffer[] _SC_modL_lft_elbow_target_two_BUFFER = new sc_voxel.DLightBuffer[1];
        //sc_voxel.DLightBuffer[] _SC_modL_lft_upper_arm_BUFFER = new sc_voxel.DLightBuffer[1];








        Vector3[][][] point3DCollection;
        Matrix[][][] _screenDirMatrix_correct_pos;

        Matrix[][][] worldMatrix_instances_voxel_cube;
        Matrix[][][] worldMatrix_instances_spectrum;
        Matrix[][][] worldMatrix_instances_DZgrid;
        Matrix[][][] worldMatrix_instances_floor;
        Matrix[][][] worldMatrix_instances_terrain_tiles;
        Matrix[][][] worldMatrix_instances_terrain;
        Matrix[][][] worldMatrix_instances_screen_assets;
        Matrix[][][] _screenDirMatrix;
        Matrix[][][] worldMatrix_instances_screens;
        Matrix[][][] world_last_Matrix_instances_screens;
        Matrix[][][] worldMatrix_instances_cubes;





        Matrix[][][] worldMatrix_instances_grid;
        Matrix[][][] worldMatrix_instances_containment_grid_RH;

        Matrix[][][] worldMatrix_instances_containment_grid_screen;
        Matrix[][][] worldMatrix_instances_cone;
        Matrix[][][] worldMatrix_instances_cylinder;
        Matrix[][][] worldMatrix_instances_capsule;
        Matrix[][][] worldMatrix_instances_sphere;






        sc_containment_grid[][] _world_containment_grid_screen;
        //sc_containment_grid[][] _world_containment_grid_list_RH;





        SC_grid[][] _world_grid_list;
        SC_cube[][] _world_screen_list;
        SC_cube[][] _world_cube_list;
        SC_cube[][] _world_cone_list;
        SC_cube[][] _world_cylinder_list;
        SC_cube[][] _world_capsule_list;
        SC_cube[][] _world_sphere_list;
        sc_spectrum[][] _world_spectrum_list;
        sc_voxel[][] _world_voxel_cube_lists;
        SC_cube[][] _world_terrain_tile_list;
        SC_cube[][] _world_screen_assets_list;
        SC_cube[][] _terrain;
        SC_cube[][] _floor;

        Vector4[][] _array_of_colors;
        Vector3[][][] _array_of_last_frame_voxel_pos;
        Vector3[][][] _array_of_last_frame_cube_pos;
        Vector3[][][] _array_of_last_frame_cone_pos;
        Vector3[][][] _array_of_last_frame_cylinder_pos;
        Vector3[][][] _array_of_last_frame_capsule_pos;
        Vector3[][][] _array_of_last_frame_sphere_pos;
        Matrix[] worldMatrix_base;






        /*
        sc_voxel voxel_cuber_r_hand_grab;
        sc_voxel voxel_cuber_r_hnd;
        sc_voxel voxel_cuber_r_up_arm;
        sc_voxel voxel_cuber_r_low_arm;
        sc_voxel voxel_cuber_r_shld;
        sc_voxel voxel_cuber_r_targ;
        sc_voxel voxel_cuber_r_targ_two;
        Matrix[] voxel_sometester_r_hand_grab;
        Matrix[] voxel_sometester_r_hnd;
        Matrix[] voxel_sometester_r_up_arm;
        Matrix[] voxel_sometester_r_low_arm;
        Matrix[] voxel_sometester_r_shld;
        Matrix[] voxel_sometester_r_targ;
        Matrix[] voxel_sometester_r_targ_two;


        sc_voxel.DLightBuffer[] _SC_modL_r_hand_grab_BUFFER = new sc_voxel.DLightBuffer[1];

        sc_voxel.DLightBuffer[] _SC_modL_rght_hnd_BUFFER = new sc_voxel.DLightBuffer[1];


        sc_voxel.DLightBuffer[] _SC_modL_rght_shldr_BUFFER = new sc_voxel.DLightBuffer[1];

        sc_voxel.DLightBuffer[] _SC_modL_rght_elbow_target_BUFFER = new sc_voxel.DLightBuffer[1];
        sc_voxel.DLightBuffer[] _SC_modL_rght_lower_arm_BUFFER = new sc_voxel.DLightBuffer[1];


        sc_voxel.DLightBuffer[] _SC_modL_rght_upper_arm_BUFFER = new sc_voxel.DLightBuffer[1];
        sc_voxel.DLightBuffer[] _SC_modL_rght_elbow_target_two_BUFFER = new sc_voxel.DLightBuffer[1];


        Matrix[][][] worldMatrix_instances_r_hand_grab;
        Matrix[][][] worldMatrix_instances_r_elbow_target;
        Matrix[][][] worldMatrix_instances_r_elbow_target_two;
        Matrix[][][] worldMatrix_instances_r_hand;
        Matrix[][][] worldMatrix_instances_r_shoulder;

        Matrix[][][] worldMatrix_instances_r_upperarm;
        Matrix[][][] worldMatrix_instances_r_lowerarm;
        sc_voxel[][] _player_r_hand_grab;

        sc_voxel[][] _player_rght_hnd;

        sc_voxel[][] _player_rght_shldr;
        sc_voxel[][] _player_rght_elbow_target;
        sc_voxel[][] _player_rght_lower_arm;
        sc_voxel[][] _player_rght_upper_arm;
        sc_voxel[][] _player_rght_elbow_target_two;*/







        //sc_voxel[][] _player_l_hand_grab;
        //sc_voxel[][] _player_r_upper_leg;
        //sc_voxel[][] _player_l_upper_leg;
        //sc_voxel[][] _player_r_lower_leg;
        //sc_voxel[][] _player_l_lower_leg;
        //sc_voxel[][] _player_r_foot;
        //sc_voxel[][] _player_l_foot;







        //sc_voxel[][] _player_lft_hnd;

        //sc_voxel[][] _player_lft_shldr;


        //sc_voxel[][] _player_rght_pelvisjoint;
        //sc_voxel[][] _player_lft_pelvisjoint;






        //sc_voxel[][] _player_lft_elbow_target;
        //sc_voxel[][] _player_lft_lower_arm;

        //sc_voxel[][] _player_lft_upper_arm;

        //sc_voxel[][] _player_lft_elbow_target_two;
        //sc_voxel[][] _player_rght_target_knee;
        //sc_voxel[][] _player_lft_target_knee;
        //sc_voxel[][] _player_rght_target_two_knee;
        //sc_voxel[][] _player_lft_target_two_knee;

        sc_containment_grid[][] _world_containment_grid_list_LH;


        int[][][] _some_frame_counter_grab_right_hand_swtch;
        int[][][] _some_frame_counter_grab_right_hand;
        int[][][] _some_frame_counter_raycast_00;
        int[][][] _some_frame_counter_raycast_01;

        float a = 0.0f;
        float r = 0.0f;
        float g = 0.0f;
        float b = 0.0f;
        float offsetPosX = 0.0f;
        float offsetPosY = 0.0f;
        float offsetPosZ = 0.0f;

        public static Jitter.Forces.Buoyancy _buo;
        Jitter.Forces.Buoyancy[] _buoyancy_area;
        int has_water_buo_effect = -1;
        bool containsCoord;
        JVector rh_attract_force = JVector.Zero;
        JVector lh_attract_force = JVector.Zero;

        //SC_console_directx D3D;
        //IntPtr HWND;

        Matrix translationMatrix = Matrix.Identity;
        JQuaternion quatterer = new JQuaternion(0, 0, 0, 1);
        Quaternion tester = Quaternion.Identity;
        Matrix rigidbody_matrix = Matrix.Identity;
        IEnumerator enumerator;
        RigidBody body;

        //SC_DRGrid _grid;
        //main terrain.
        //SC_VR_IcoSphere _icoSphere;
        int _icoVertexCount = 0;

        DContainmentGrid _dContainer;
        DContainmentGrid _dTouchRightContainer;
        DContainmentGrid _dTouchLeftContainer;

        SC_VR_Cube _arrayOfCubes;

        const int ChunkWidth_L = 3;
        const int ChunkWidth_R = 2;
        const int ChunkHeight_L = 3;
        const int ChunkHeight_R = 2;
        const int ChunkDepth_L = 3;
        const int ChunkDepth_R = 2;

        /*public int PlanetChunkWidth_L = 96;
        public int PlanetChunkWidth_R = 95;
        public int PlanetChunkHeight_L = 96;
        public int PlanetChunkHeight_R = 95;
        public int PlanetChunkDepth_L = 96;
        public int PlanetChunkDepth_R = 95;
        public int realplanetwidth = 4;*/

        /*public int PlanetChunkWidth_L = 80;
        public int PlanetChunkWidth_R = 79;
        public int PlanetChunkHeight_L = 80;
        public int PlanetChunkHeight_R = 79;
        public int PlanetChunkDepth_L = 80;
        public int PlanetChunkDepth_R = 79;
        public int realplanetwidth = 4;*/

        /*public int PlanetChunkWidth_L = 70;
        public int PlanetChunkWidth_R = 69;
        public int PlanetChunkHeight_L = 70;
        public int PlanetChunkHeight_R = 69;
        public int PlanetChunkDepth_L = 70;
        public int PlanetChunkDepth_R = 69;
        public int realplanetwidth = 8;*/

        /*public int PlanetChunkWidth_L = 60;
        public int PlanetChunkWidth_R = 59;
        public int PlanetChunkHeight_L = 60;
        public int PlanetChunkHeight_R = 59;
        public int PlanetChunkDepth_L = 60;
        public int PlanetChunkDepth_R = 59;
        public int realplanetwidth = 4;*/


        /*public int PlanetChunkWidth_L = 48;
         public int PlanetChunkWidth_R = 47;
         public int PlanetChunkHeight_L = 48;
         public int PlanetChunkHeight_R = 47;
         public int PlanetChunkDepth_L = 48;
         public int PlanetChunkDepth_R = 47;
         public int realplanetwidth = 4;*/


        public int PlanetChunkWidth_L = 12;
        public int PlanetChunkWidth_R = 11;
        public int PlanetChunkHeight_L = 12;
        public int PlanetChunkHeight_R = 11;
        public int PlanetChunkDepth_L = 12;
        public int PlanetChunkDepth_R = 11;
        public int realplanetwidth = 4;

        float[] arrayX = new float[(ChunkWidth_L + ChunkWidth_R + 1) * (ChunkHeight_L + ChunkHeight_R + 1) * (ChunkDepth_L + ChunkDepth_R + 1)];
        float[] arrayY = new float[(ChunkWidth_L + ChunkWidth_R + 1) * (ChunkHeight_L + ChunkHeight_R + 1) * (ChunkDepth_L + ChunkDepth_R + 1)];
        float[] arrayZ = new float[(ChunkWidth_L + ChunkWidth_R + 1) * (ChunkHeight_L + ChunkHeight_R + 1) * (ChunkDepth_L + ChunkDepth_R + 1)];
        int[] draw_dcontainmentgrid = new int[(ChunkWidth_L + ChunkWidth_R + 1) * (ChunkHeight_L + ChunkHeight_R + 1) * (ChunkDepth_L + ChunkDepth_R + 1)];
        public static int _vertexCount = 8;
        DTerrain _grid_X;
        DTerrain _grid_Y;
        DTerrain _grid_Z;
        DTerrain_Screen _screen_grid_X;
        DTerrain_Screen _screen_grid_Y;
        DTerrain_Screen _screen_grid_Z;
        DTerrain_Screen_Metric _screen_metric_grid_X;
        DTerrain_Screen_Metric _screen_metric_grid_Y;
        DTerrain_Screen_Metric _screen_metric_grid_Z;
        DTerrain_Screen_Metric _WORLD_GRID_X;

        SCCoreSystems.SC_Graphics.SC_cube.DLightBuffer[] _DLightBuffer_cube = new SC_cube.DLightBuffer[1];
        SCCoreSystems.SC_Graphics.SC_grid.DLightBuffer[] _DLightBuffer_grid = new SC_grid.DLightBuffer[1];
        SCCoreSystems.SC_Graphics.sc_containment_grid.DLightBuffer[] _DLightBuffer_containment_grid = new sc_containment_grid.DLightBuffer[1];

        SCCoreSystems.SC_Graphics.sc_voxel.DLightBuffer[] _DLightBuffer_voxel_cube = new sc_voxel.DLightBuffer[1];

        SCCoreSystems.SC_Graphics.sc_spectrum.DLightBuffer[] _DLightBuffer_spectrum = new sc_spectrum.DLightBuffer[1];

        SCCoreSystems.SC_Graphics.sc_voxel_pchunk.DLightBuffer[] _DLightBuffer_voxel_pchunk_cube = new sc_voxel_pchunk.DLightBuffer[1];

        _sc_texture_loader _pink_texture;
        _sc_texture_loader _basicTexture;
        int _start_background_worker_00 = 0;
        int _start_background_worker_01 = 0;

        public static DTerrainHeightMap terrainheightmap;
        Vector3[] directionvectoroffsets;


        public sc_graphics_sec() //SC_console_directx _SC_console_directx, IntPtr _HWND
        {
            directionvectoroffsets = new Vector3[4];

            for (int i = 0; i < directionvectoroffsets.Length; i++)
            {
                directionvectoroffsets[i] = Vector3.Zero;
            }


            //arrayOfPixData = new int[SC_Update._desktopFrame._texture2DFinal.Description.Width * SC_Update._desktopFrame._texture2DFinal.Description.Height * 3];

            keyboardclickstopwatch.Restart();

            //D3D = _SC_console_directx;
            //HWND = _HWND;

            _screenDirMatrix = new Matrix[MainWindow._physics_engine_instance_x * MainWindow._physics_engine_instance_y * MainWindow._physics_engine_instance_z][][];
            _screenDirMatrix_correct_pos = new Matrix[MainWindow._physics_engine_instance_x * MainWindow._physics_engine_instance_y * MainWindow._physics_engine_instance_z][][];
            point3DCollection = new Vector3[MainWindow._physics_engine_instance_x * MainWindow._physics_engine_instance_y * MainWindow._physics_engine_instance_z][][];
            _world_screen_list = new SC_cube[MainWindow._physics_engine_instance_x * MainWindow._physics_engine_instance_y * MainWindow._physics_engine_instance_z][];
            _world_screen_assets_list = new SC_cube[MainWindow._physics_engine_instance_x * MainWindow._physics_engine_instance_y * MainWindow._physics_engine_instance_z][];
            worldMatrix_instances_screens = new Matrix[MainWindow._physics_engine_instance_x * MainWindow._physics_engine_instance_y * MainWindow._physics_engine_instance_z][][];
            world_last_Matrix_instances_screens = new Matrix[MainWindow._physics_engine_instance_x * MainWindow._physics_engine_instance_y * MainWindow._physics_engine_instance_z][][];
            worldMatrix_instances_screen_assets = new Matrix[MainWindow._physics_engine_instance_x * MainWindow._physics_engine_instance_y * MainWindow._physics_engine_instance_z][][];

            _world_cube_list = new SC_cube[MainWindow._physics_engine_instance_x * MainWindow._physics_engine_instance_y * MainWindow._physics_engine_instance_z][];
            _world_voxel_cube_lists = new sc_voxel[MainWindow._physics_engine_instance_x * MainWindow._physics_engine_instance_y * MainWindow._physics_engine_instance_z][];
            _world_cone_list = new SC_cube[MainWindow._physics_engine_instance_x * MainWindow._physics_engine_instance_y * MainWindow._physics_engine_instance_z][];
            _world_cylinder_list = new SC_cube[MainWindow._physics_engine_instance_x * MainWindow._physics_engine_instance_y * MainWindow._physics_engine_instance_z][];
            _world_capsule_list = new SC_cube[MainWindow._physics_engine_instance_x * MainWindow._physics_engine_instance_y * MainWindow._physics_engine_instance_z][];
            _world_sphere_list = new SC_cube[MainWindow._physics_engine_instance_x * MainWindow._physics_engine_instance_y * MainWindow._physics_engine_instance_z][];

            _world_terrain_tile_list = new SC_cube[MainWindow._physics_engine_instance_x * MainWindow._physics_engine_instance_y * MainWindow._physics_engine_instance_z][];

            worldMatrix_instances_voxel_pchunk = new Matrix[MainWindow._physics_engine_instance_x * MainWindow._physics_engine_instance_y * MainWindow._physics_engine_instance_z][][][];
            worldMatrix_instances_cubes = new Matrix[MainWindow._physics_engine_instance_x * MainWindow._physics_engine_instance_y * MainWindow._physics_engine_instance_z][][];
            worldMatrix_instances_voxel_cube = new Matrix[MainWindow._physics_engine_instance_x * MainWindow._physics_engine_instance_y * MainWindow._physics_engine_instance_z][][];
            worldMatrix_instances_cone = new Matrix[MainWindow._physics_engine_instance_x * MainWindow._physics_engine_instance_y * MainWindow._physics_engine_instance_z][][];
            worldMatrix_instances_cylinder = new Matrix[MainWindow._physics_engine_instance_x * MainWindow._physics_engine_instance_y * MainWindow._physics_engine_instance_z][][];
            worldMatrix_instances_capsule = new Matrix[MainWindow._physics_engine_instance_x * MainWindow._physics_engine_instance_y * MainWindow._physics_engine_instance_z][][];
            worldMatrix_instances_sphere = new Matrix[MainWindow._physics_engine_instance_x * MainWindow._physics_engine_instance_y * MainWindow._physics_engine_instance_z][][];

            worldMatrix_instances_terrain_tiles = new Matrix[MainWindow._physics_engine_instance_x * MainWindow._physics_engine_instance_y * MainWindow._physics_engine_instance_z][][];
            _array_of_colors = new Vector4[MainWindow._physics_engine_instance_x * MainWindow._physics_engine_instance_y * MainWindow._physics_engine_instance_z][];
            _array_of_last_frame_cube_pos = new Vector3[MainWindow._physics_engine_instance_x * MainWindow._physics_engine_instance_y * MainWindow._physics_engine_instance_z][][];
            _array_of_last_frame_voxel_pos = new Vector3[MainWindow._physics_engine_instance_x * MainWindow._physics_engine_instance_y * MainWindow._physics_engine_instance_z][][];
            _array_of_last_frame_cone_pos = new Vector3[MainWindow._physics_engine_instance_x * MainWindow._physics_engine_instance_y * MainWindow._physics_engine_instance_z][][];
            _array_of_last_frame_cylinder_pos = new Vector3[MainWindow._physics_engine_instance_x * MainWindow._physics_engine_instance_y * MainWindow._physics_engine_instance_z][][];
            _array_of_last_frame_capsule_pos = new Vector3[MainWindow._physics_engine_instance_x * MainWindow._physics_engine_instance_y * MainWindow._physics_engine_instance_z][][];
            _array_of_last_frame_sphere_pos = new Vector3[MainWindow._physics_engine_instance_x * MainWindow._physics_engine_instance_y * MainWindow._physics_engine_instance_z][][];


            //worldMatrix_instances_voxel_pchunk = new Matrix[1];

            //SINGLE OBJECTS
            //SINGLE OBJECTS
            //SINGLE OBJECTS
            //_world_containment_grid_list_RH = new sc_containment_grid[1][];



            _world_containment_grid_screen = new sc_containment_grid[1][];

            _world_grid_list = new SC_grid[1][];
            _terrain = new SC_cube[1][];
            _floor = new SC_cube[1][];

            worldMatrix_instances_terrain = new Matrix[1][][];

            _world_spectrum_list = new sc_spectrum[1][];
            worldMatrix_instances_spectrum = new Matrix[1][][];

            worldMatrix_instances_DZgrid = new Matrix[1][][];
            worldMatrix_instances_grid = new Matrix[1][][];
            worldMatrix_instances_containment_grid_RH = new Matrix[1][][];
            worldMatrix_instances_containment_grid_screen = new Matrix[1][][];
            //SINGLE OBJECTS
            //SINGLE OBJECTS
            //SINGLE OBJECTS





            //HUMAN RIG STUFF









            //worldMatrix_instances_l_hand_grab = new Matrix[tempMultiInstancePhysicsTotal][][];






            worldMatrix_instances_floor = new Matrix[MainWindow._physics_engine_instance_x * MainWindow._physics_engine_instance_y * MainWindow._physics_engine_instance_z][][];



            _some_frame_counter_grab_right_hand_swtch = new int[MainWindow._physics_engine_instance_x * MainWindow._physics_engine_instance_y * MainWindow._physics_engine_instance_z][][];
            _some_frame_counter_grab_right_hand = new int[MainWindow._physics_engine_instance_x * MainWindow._physics_engine_instance_y * MainWindow._physics_engine_instance_z][][];
            _some_frame_counter_raycast_00 = new int[MainWindow._physics_engine_instance_x * MainWindow._physics_engine_instance_y * MainWindow._physics_engine_instance_z][][];
            _some_frame_counter_raycast_01 = new int[MainWindow._physics_engine_instance_x * MainWindow._physics_engine_instance_y * MainWindow._physics_engine_instance_z][][];


            _some_frame_counter_grab_right_hand_swtch[0] = new int[MainWindow.world_width * MainWindow.world_height * MainWindow.world_depth][];
            _some_frame_counter_grab_right_hand[0] = new int[MainWindow.world_width * MainWindow.world_height * MainWindow.world_depth][];
            _some_frame_counter_raycast_00[0] = new int[MainWindow.world_width * MainWindow.world_height * MainWindow.world_depth][];
            _some_frame_counter_raycast_01[0] = new int[MainWindow.world_width * MainWindow.world_height * MainWindow.world_depth][];


            _some_frame_counter_grab_right_hand_swtch[0][0] = new int[_human_inst_rig_x * _human_inst_rig_y * _human_inst_rig_z];
            _some_frame_counter_grab_right_hand[0][0] = new int[_human_inst_rig_x * _human_inst_rig_y * _human_inst_rig_z];
            //_some_frame_counter_raycast_00[0] = new int[MainWindow.world_width * MainWindow.world_height * MainWindow.world_depth][];
            //_some_frame_counter_raycast_01[0] = new int[MainWindow.world_width * MainWindow.world_height * MainWindow.world_depth][];



            swtch_for_last_pos = new int[MainWindow._physics_engine_instance_x * MainWindow._physics_engine_instance_y * MainWindow._physics_engine_instance_z][][];
            swtch_for_last_pos[0] = new int[MainWindow.world_width * MainWindow.world_height * MainWindow.world_depth][];
            swtch_for_last_pos[0][0] = new int[_human_inst_rig_x * _human_inst_rig_y * _human_inst_rig_z];
            swtch_for_last_pos[0][0][0] = 0;

            for (int i = 0; i < _some_frame_counter_grab_right_hand[0][0].Length; i++)
            {
                _some_frame_counter_grab_right_hand[0][0][i] = 0;
                _some_frame_counter_grab_right_hand_swtch[0][0][i] = 0;
            }


            worldMatrix_base = new Matrix[1];
            worldMatrix_base[0] = Matrix.Identity;

            DoWork(0);
        }



        public scmessageobjectjitter[][] _sc_create_world_objects(scmessageobjectjitter[][] _sc_jitter_tasks)
        {
            try
            {

                if (MainWindow.usejitterphysics == 1 && MainWindow.usejitterphysicsbuo == 1)
                {
                    _buoyancy_area = new Jitter.Forces.Buoyancy[1];
                }





                //draw_dcontainmentgrid = new int[6 * 6 * 6];

                for (int i = 0; i < draw_dcontainmentgrid.Length; i++)
                {
                    draw_dcontainmentgrid[i] = 0;
                }








                if (MainWindow.usejitterphysics == 1)
                {
                    //SETTING UP SINGLE WORLD OBJECTS
                    //END OF LOOP FOR PHYSICS ENGINE INSTANCES
                    _some_data_0 = (object)_sc_jitter_tasks[0][0]._world_data[0];
                    //World[] _jitter_worlds0 = (World[])_some_data_0;
                    _thejitter_world = (World)_some_data_0;



                }

























                for (int xx = 0; xx < MainWindow._physics_engine_instance_x; xx++)
                {
                    for (int yy = 0; yy < MainWindow._physics_engine_instance_y; yy++)
                    {
                        for (int zz = 0; zz < MainWindow._physics_engine_instance_z; zz++)
                        {
                            var indexer00 = xx + MainWindow._physics_engine_instance_x * (yy + MainWindow._physics_engine_instance_y * zz);
                            Vector3 physics_engine_offset_pos = new Vector3(xx * 2, yy * 2, zz * 2);

                            worldMatrix_instances_voxel_pchunk[indexer00] = new Matrix[MainWindow.world_width * MainWindow.world_height * MainWindow.world_depth][][];


                            //World[] _jitter_worlds = (World[])_sc_jitter_tasks[indexer00]._world_data;
                            _array_of_last_frame_voxel_pos[indexer00] = new Vector3[MainWindow.world_width * MainWindow.world_height * MainWindow.world_depth][];
                            _array_of_last_frame_cube_pos[indexer00] = new Vector3[MainWindow.world_width * MainWindow.world_height * MainWindow.world_depth][];
                            _array_of_last_frame_cone_pos[indexer00] = new Vector3[MainWindow.world_width * MainWindow.world_height * MainWindow.world_depth][];
                            _array_of_last_frame_cylinder_pos[indexer00] = new Vector3[MainWindow.world_width * MainWindow.world_height * MainWindow.world_depth][];
                            _array_of_last_frame_capsule_pos[indexer00] = new Vector3[MainWindow.world_width * MainWindow.world_height * MainWindow.world_depth][];
                            _array_of_last_frame_sphere_pos[indexer00] = new Vector3[MainWindow.world_width * MainWindow.world_height * MainWindow.world_depth][];

                            _world_cube_list[indexer00] = new SC_cube[MainWindow.world_width * MainWindow.world_height * MainWindow.world_depth];
                            _world_voxel_cube_lists[indexer00] = new sc_voxel[MainWindow.world_width * MainWindow.world_height * MainWindow.world_depth];
                            _world_cone_list[indexer00] = new SC_cube[MainWindow.world_width * MainWindow.world_height * MainWindow.world_depth];
                            _world_cylinder_list[indexer00] = new SC_cube[MainWindow.world_width * MainWindow.world_height * MainWindow.world_depth];
                            _world_capsule_list[indexer00] = new SC_cube[MainWindow.world_width * MainWindow.world_height * MainWindow.world_depth];
                            _world_sphere_list[indexer00] = new SC_cube[MainWindow.world_width * MainWindow.world_height * MainWindow.world_depth];

                            worldMatrix_instances_cubes[indexer00] = new Matrix[MainWindow.world_width * MainWindow.world_height * MainWindow.world_depth][];
                            worldMatrix_instances_cone[indexer00] = new Matrix[MainWindow.world_width * MainWindow.world_height * MainWindow.world_depth][];
                            worldMatrix_instances_cylinder[indexer00] = new Matrix[MainWindow.world_width * MainWindow.world_height * MainWindow.world_depth][];
                            worldMatrix_instances_capsule[indexer00] = new Matrix[MainWindow.world_width * MainWindow.world_height * MainWindow.world_depth][];
                            worldMatrix_instances_sphere[indexer00] = new Matrix[MainWindow.world_width * MainWindow.world_height * MainWindow.world_depth][];

                            worldMatrix_instances_voxel_cube[indexer00] = new Matrix[MainWindow.world_width * MainWindow.world_height * MainWindow.world_depth][];

                            float offsetCubeY = 0;
                            float offsetVoxelY = 0;
                            float offsetCapsuleY = 0;
                            float offsetConeY = 0;
                            float offsetCylinderY = 0;
                            float offsetSphereY = 0;

                            try
                            {
                                for (int x = 0; x < MainWindow.world_width; x++)
                                {
                                    for (int y = 0; y < MainWindow.world_height; y++)
                                    {
                                        for (int z = 0; z < MainWindow.world_depth; z++)
                                        {
                                            var indexer01 = x + MainWindow.world_width * (y + MainWindow.world_height * z);

                                            Vector3 world_pos_offset = new Vector3(x * 2, y * 2, z * 2);
                                            if (MainWindow.usejitterphysics == 1)
                                            {

                                                _some_data_00 = (object)_sc_jitter_tasks[indexer00][indexer01]._world_data[0];
                                                //World _jitter_worlds = (World)_some_data_00;
                                                _jitter_world = (World)_some_data_00;//= _jitter_worlds[0];

                                            }



                                            //PHYSICS CUBES
                                            offsetCubeY = 0;
                                            r = 0.75f;
                                            g = 0.15f;
                                            b = 0;
                                            a = 1;
                                            _object_worldmatrix = Matrix.Identity;
                                            offsetPosX = _cube_size_x * 1.15f; //x between each world instance
                                            offsetPosY = _cube_size_y * 1.15f; //y between each world instance
                                            offsetPosZ = _cube_size_z * 1.15f; //z between each world instance
                                            _object_worldmatrix = WorldMatrix;
                                            _object_worldmatrix.M41 = 0.5f + x + physics_engine_offset_pos.X + world_pos_offset.X;
                                            _object_worldmatrix.M42 = 0.5f + y + physics_engine_offset_pos.Y + world_pos_offset.Y + offsetCubeY;
                                            _object_worldmatrix.M43 = 0 + z + physics_engine_offset_pos.Z + world_pos_offset.Z;
                                            _object_worldmatrix.M44 = 1;

                                            var _size_screen = 0.00045f;
                                            var _cuber = new SC_cube();
                                            var _hasinit3 = _cuber.Initialize(SC_console_directx.D3D, SC_console_directx.D3D.SurfaceWidth, SC_console_directx.D3D.SurfaceHeight, 0.1f, 1, 1, _cube_size_x, _cube_size_y, _cube_size_z, new Vector4(r, g, b, a), _inst_cube_x, _inst_cube_y, _inst_cube_z, SC_Update.HWND, _object_worldmatrix, 2, offsetPosX, offsetPosY, offsetPosZ, _jitter_world, SCCoreSystems.sc_console.SC_console_directx.BodyTag.physicsInstancedCube, false, 0, 100, 0, 0, 0); //, "terrainGrassDirt.bmp" //0.00035f
                                            _world_cube_list[indexer00][indexer01] = _cuber;
                                            _array_of_last_frame_cube_pos[indexer00][indexer01] = new Vector3[_inst_cube_x * _inst_cube_y * _inst_cube_z];
                                            worldMatrix_instances_cubes[indexer00][indexer01] = new Matrix[_inst_cube_x * _inst_cube_y * _inst_cube_z];
                                            for (int i = 0; i < worldMatrix_instances_cubes[indexer00][indexer01].Length; i++)
                                            {
                                                Vector3 poser = new Vector3(_world_cube_list[indexer00][indexer01]._arrayOfInstances[i].current_pos.M41,
                                                                            _world_cube_list[indexer00][indexer01]._arrayOfInstances[i].current_pos.M42,
                                                                            _world_cube_list[indexer00][indexer01]._arrayOfInstances[i].current_pos.M43);

                                                _array_of_last_frame_cube_pos[indexer00][indexer01][i] = poser;
                                                worldMatrix_instances_cubes[indexer00][indexer01][i] = _world_cube_list[indexer00][indexer01]._arrayOfInstances[i].current_pos;
                                            }



                                            offsetConeY = 10;
                                            //PHYSICS CONES
                                            r = 0.75f;
                                            g = 0.15f;
                                            b = 0;
                                            a = 1;
                                            _object_worldmatrix = Matrix.Identity;
                                            offsetPosX = _cube_size_x * 1.15f; //x between each world instance
                                            offsetPosY = _cube_size_y * 1.15f; //y between each world instance
                                            offsetPosZ = _cube_size_z * 1.15f; //z between each world instance
                                            _object_worldmatrix = WorldMatrix;
                                            _object_worldmatrix.M41 = 1.5f + x + physics_engine_offset_pos.X + world_pos_offset.X;
                                            _object_worldmatrix.M42 = 3 + y + physics_engine_offset_pos.Y + world_pos_offset.Y + offsetConeY;
                                            _object_worldmatrix.M43 = -0.5f + z + physics_engine_offset_pos.Z + world_pos_offset.Z;
                                            _object_worldmatrix.M44 = 1;
                                            _size_screen = 0.00045f;
                                            _cuber = new SC_cube();
                                            _hasinit3 = _cuber.Initialize(SC_console_directx.D3D, SC_console_directx.D3D.SurfaceWidth, SC_console_directx.D3D.SurfaceHeight, 0.1f, 1, 1, _cube_size_x, _cube_size_y, _cube_size_z, new Vector4(r, g, b, a), _inst_other_x, _inst_other_y, _inst_other_z, SC_Update.HWND, _object_worldmatrix, 6, offsetPosX, offsetPosY, offsetPosZ, _jitter_world, SCCoreSystems.sc_console.SC_console_directx.BodyTag.physicsInstancedCone, false, 0, 100, 0, 0, 0); //, "terrainGrassDirt.bmp" //0.00035f
                                            _world_cone_list[indexer00][indexer01] = _cuber;

                                            _array_of_last_frame_cone_pos[indexer00][indexer01] = new Vector3[_inst_other_x * _inst_other_y * _inst_other_z];

                                            worldMatrix_instances_cone[indexer00][indexer01] = new Matrix[_inst_other_x * _inst_other_y * _inst_other_z];
                                            for (int i = 0; i < worldMatrix_instances_cone[indexer00][indexer01].Length; i++)
                                            {
                                                Vector3 poser = new Vector3(_world_cone_list[indexer00][indexer01]._arrayOfInstances[i].current_pos.M41,
                                                                            _world_cone_list[indexer00][indexer01]._arrayOfInstances[i].current_pos.M42,
                                                                            _world_cone_list[indexer00][indexer01]._arrayOfInstances[i].current_pos.M43);

                                                _array_of_last_frame_cone_pos[indexer00][indexer01][i] = poser;
                                                worldMatrix_instances_cone[indexer00][indexer01][i] = _world_cone_list[indexer00][indexer01]._arrayOfInstances[i].current_pos;
                                            }


                                            offsetCylinderY = 20;
                                            //PHYSICS CYLINDERS
                                            r = 0.75f;
                                            g = 0.15f;
                                            b = 0;
                                            a = 1;
                                            _object_worldmatrix = Matrix.Identity;
                                            offsetPosX = _cube_size_x * 1.15f; //x between each world instance
                                            offsetPosY = _cube_size_y * 1.15f; //y between each world instance
                                            offsetPosZ = _cube_size_z * 1.15f; //z between each world instance
                                            _object_worldmatrix = WorldMatrix;
                                            _object_worldmatrix.M41 = 1.5f + x + physics_engine_offset_pos.X + world_pos_offset.X;
                                            _object_worldmatrix.M42 = 3 + y + physics_engine_offset_pos.Y + world_pos_offset.Y + offsetCylinderY;
                                            _object_worldmatrix.M43 = -0.5f + z + physics_engine_offset_pos.Z + world_pos_offset.Z;
                                            _object_worldmatrix.M44 = 1;
                                            _size_screen = 0.00045f;
                                            _cuber = new SC_cube();
                                            _hasinit3 = _cuber.Initialize(SC_console_directx.D3D, SC_console_directx.D3D.SurfaceWidth, SC_console_directx.D3D.SurfaceHeight, 0.1f, 1, 1, _cube_size_x, _cube_size_y, _cube_size_z, new Vector4(r, g, b, a), _inst_other_x, _inst_other_y, _inst_other_z, SC_Update.HWND, _object_worldmatrix, 7, offsetPosX, offsetPosY, offsetPosZ, _jitter_world, SCCoreSystems.sc_console.SC_console_directx.BodyTag.physicsInstancedCylinder, false, 0, 100, 0, 0, 0); //, "terrainGrassDirt.bmp" //0.00035f
                                            _world_cylinder_list[indexer00][indexer01] = _cuber;

                                            _array_of_last_frame_cylinder_pos[indexer00][indexer01] = new Vector3[_inst_other_x * _inst_other_y * _inst_other_z];

                                            worldMatrix_instances_cylinder[indexer00][indexer01] = new Matrix[_inst_other_x * _inst_other_y * _inst_other_z];
                                            for (int i = 0; i < worldMatrix_instances_cylinder[indexer00][indexer01].Length; i++)
                                            {
                                                Vector3 poser = new Vector3(_world_cylinder_list[indexer00][indexer01]._arrayOfInstances[i].current_pos.M41,
                                                                            _world_cylinder_list[indexer00][indexer01]._arrayOfInstances[i].current_pos.M42,
                                                                            _world_cylinder_list[indexer00][indexer01]._arrayOfInstances[i].current_pos.M43);

                                                _array_of_last_frame_cylinder_pos[indexer00][indexer01][i] = poser;
                                                worldMatrix_instances_cylinder[indexer00][indexer01][i] = _world_cylinder_list[indexer00][indexer01]._arrayOfInstances[i].current_pos;
                                            }


                                            offsetCapsuleY = 30;
                                            //PHYSICS CAPSULES
                                            r = 0.75f;
                                            g = 0.15f;
                                            b = 0;
                                            a = 1;
                                            _object_worldmatrix = Matrix.Identity;
                                            offsetPosX = _cube_size_x * 1.15f; //x between each world instance
                                            offsetPosY = _cube_size_y * 1.15f; //y between each world instance
                                            offsetPosZ = _cube_size_z * 1.15f; //z between each world instance
                                            _object_worldmatrix = WorldMatrix;
                                            _object_worldmatrix.M41 = 1.5f + x + physics_engine_offset_pos.X + world_pos_offset.X;
                                            _object_worldmatrix.M42 = 3 + y + physics_engine_offset_pos.Y + world_pos_offset.Y + offsetCapsuleY;
                                            _object_worldmatrix.M43 = -0.5f + z + physics_engine_offset_pos.Z + world_pos_offset.Z;
                                            _object_worldmatrix.M44 = 1;
                                            _size_screen = 0.00045f;
                                            _cuber = new SC_cube();
                                            _hasinit3 = _cuber.Initialize(SC_console_directx.D3D, SC_console_directx.D3D.SurfaceWidth, SC_console_directx.D3D.SurfaceHeight, 0.1f, 1, 1, _cube_size_x, _cube_size_y, _cube_size_z, new Vector4(r, g, b, a), _inst_other_x, _inst_other_y, _inst_other_z, SC_Update.HWND, _object_worldmatrix, 8, offsetPosX, offsetPosY, offsetPosZ, _jitter_world, SCCoreSystems.sc_console.SC_console_directx.BodyTag.physicsInstancedCapsule, false, 0, 100, 0, 0, 0); //, "terrainGrassDirt.bmp" //0.00035f
                                            _world_capsule_list[indexer00][indexer01] = _cuber;

                                            _array_of_last_frame_capsule_pos[indexer00][indexer01] = new Vector3[_inst_other_x * _inst_other_y * _inst_other_z];

                                            worldMatrix_instances_capsule[indexer00][indexer01] = new Matrix[_inst_other_x * _inst_other_y * _inst_other_z];
                                            for (int i = 0; i < worldMatrix_instances_capsule[indexer00][indexer01].Length; i++)
                                            {
                                                Vector3 poser = new Vector3(_world_capsule_list[indexer00][indexer01]._arrayOfInstances[i].current_pos.M41,
                                                                            _world_capsule_list[indexer00][indexer01]._arrayOfInstances[i].current_pos.M42,
                                                                            _world_capsule_list[indexer00][indexer01]._arrayOfInstances[i].current_pos.M43);

                                                _array_of_last_frame_capsule_pos[indexer00][indexer01][i] = poser;
                                                worldMatrix_instances_capsule[indexer00][indexer01][i] = _world_capsule_list[indexer00][indexer01]._arrayOfInstances[i].current_pos;
                                            }



                                            offsetSphereY = 40;


                                            //PHYSICS SPHERES
                                            r = 0.75f;
                                            g = 0.15f;
                                            b = 0;
                                            a = 1;
                                            _object_worldmatrix = Matrix.Identity;
                                            offsetPosX = _cube_size_x * 1.15f; //x between each world instance
                                            offsetPosY = _cube_size_y * 1.15f; //y between each world instance
                                            offsetPosZ = _cube_size_z * 1.15f; //z between each world instance
                                            _object_worldmatrix = WorldMatrix;
                                            _object_worldmatrix.M41 = 1.5f + x + physics_engine_offset_pos.X + world_pos_offset.X;
                                            _object_worldmatrix.M42 = 3 + y + physics_engine_offset_pos.Y + world_pos_offset.Y + offsetSphereY;
                                            _object_worldmatrix.M43 = -0.5f + z + physics_engine_offset_pos.Z + world_pos_offset.Z;
                                            _object_worldmatrix.M44 = 1;
                                            _size_screen = 0.00045f;
                                            _cuber = new SC_cube();
                                            _hasinit3 = _cuber.Initialize(SC_console_directx.D3D, SC_console_directx.D3D.SurfaceWidth, SC_console_directx.D3D.SurfaceHeight, 0.1f, 1, 1, _cube_size_x, _cube_size_y, _cube_size_z, new Vector4(r, g, b, a), _inst_other_x, _inst_other_y, _inst_other_z, SC_Update.HWND, _object_worldmatrix, 1, offsetPosX, offsetPosY, offsetPosZ, _jitter_world, SCCoreSystems.sc_console.SC_console_directx.BodyTag.physicsInstancedSphere, false, 0, 100, 0, 0, 0); //, "terrainGrassDirt.bmp" //0.00035f
                                            _world_sphere_list[indexer00][indexer01] = _cuber;

                                            _array_of_last_frame_sphere_pos[indexer00][indexer01] = new Vector3[_inst_other_x * _inst_other_y * _inst_other_z];

                                            worldMatrix_instances_sphere[indexer00][indexer01] = new Matrix[_inst_other_x * _inst_other_y * _inst_other_z];
                                            for (int i = 0; i < worldMatrix_instances_sphere[indexer00][indexer01].Length; i++)
                                            {
                                                Vector3 poser = new Vector3(_world_sphere_list[indexer00][indexer01]._arrayOfInstances[i].current_pos.M41,
                                                                            _world_sphere_list[indexer00][indexer01]._arrayOfInstances[i].current_pos.M42,
                                                                            _world_sphere_list[indexer00][indexer01]._arrayOfInstances[i].current_pos.M43);

                                                _array_of_last_frame_sphere_pos[indexer00][indexer01][i] = poser;
                                                worldMatrix_instances_sphere[indexer00][indexer01][i] = _world_sphere_list[indexer00][indexer01]._arrayOfInstances[i].current_pos;
                                            }















                                            offsetVoxelY = 40;

                                            //VOXELS
                                            r = 0.95f; //0.75f
                                            g = 0.95f; //0.75f
                                            b = 0.95f; //0.75f
                                            a = 1;

                                            _object_worldmatrix = Matrix.Identity;

                                            /*offsetPosX = _voxel_cube_size_x * (1.15f); //x between each world instance
                                            offsetPosY = _voxel_cube_size_y * (1.15f); //y between each world instance
                                            offsetPosZ = _voxel_cube_size_z * (1.15f); //z between each world instance

                                            //_offsetPos = new Vector3(0, 0, 0);

                                            _object_worldmatrix = Matrix.Identity;
                                            _object_worldmatrix.M41 = 0 + x + physics_engine_offset_pos.X + world_pos_offset.X;
                                            _object_worldmatrix.M42 = 3 + y + physics_engine_offset_pos.Y + world_pos_offset.Y + offsetVoxelY;
                                            _object_worldmatrix.M43 = 0 + z + physics_engine_offset_pos.Z + world_pos_offset.Z;
                                            _object_worldmatrix.M44 = 1;*/




                                            world_pos_offset.X = 0;
                                            world_pos_offset.Y = 10;
                                            world_pos_offset.Z = 0;















                                            //////////////TO READD
                                            //////////////TO READD
                                            //////////////TO READD
                                            /*var _sccsproceduralplanetbuilder = new sccsproceduralplanetbuilder();
                                            arrayOfPlanetChunk = _sccsproceduralplanetbuilder.buildplanetchunk(WorldMatrix, physics_engine_offset_pos, world_pos_offset, _jitter_world, SC_Update.HWND);

                                            //worldMatrix_instances_voxel_pchunk[1] = Matrix.Identity;

                                            //voxel_general_size = 0.00075f; //0.0015f
                                            //voxel_type = 1;
                                            //is_static = false;
                                            //_voxel_mass = 100;
                                            //var _hasinit00 = sc_voxel_spheroid.Initialize(SC_console_directx.D3D, SC_console_directx.D3D.SurfaceWidth, SC_console_directx.D3D.SurfaceHeight, 0, 1, 1, 1,
                                            ///    _voxel_cube_size_x, _voxel_cube_size_y, _voxel_cube_size_z, new Vector4(r, g, b, a), _inst_voxel_cube_x, _inst_voxel_cube_y, _inst_voxel_cube_z, SC_Update.HWND,
                                            //    _object_worldmatrix, 2, offsetPosX, offsetPosY, offsetPosZ, _jitter_world, _voxel_mass, is_static, SCCoreSystems.sc_console.SC_console_directx.BodyTag.sc_perko_voxel,
                                            //    9, 9, 9, 9, 9, 9, 9, 9, 9, 35, 34, 40, 59, 23, 22,
                                            //    voxel_general_size, Vector3.Zero, 17, 0, 0, 0, 2, voxel_type);


                                            worldMatrix_instances_voxel_pchunk[indexer00][indexer01] = new Matrix[arrayOfPlanetChunk.Length][];



                                            //for (int pc = 0; pc < arrayOfPlanetChunk.Length; pc++)
                                            //{
                                            //    if (arrayOfPlanetChunk[pc] != null)
                                            //    {
                                            //        if (arrayOfPlanetChunk[pc].Vertices != null)
                                            //        {
                                            //            if (arrayOfPlanetChunk[pc].Vertices.Length > 0)
                                            //            {
                                            //                worldMatrix_instances_voxel_pchunk[indexer00][indexer01][pc] = new Matrix[1];
                                            //                worldMatrix_instances_voxel_pchunk[indexer00][indexer01][pc][0] = arrayOfPlanetChunk[pc].current_pos;
                                            //            }
                                            //        }
                                            //    }
                                            //}

                                            
                                            for (int yc = -PlanetChunkHeight_L; yc <= PlanetChunkHeight_R; yc += realplanetwidth)
                                            {
                                                for (int xc = -PlanetChunkWidth_L; xc <= PlanetChunkWidth_R; xc += realplanetwidth)
                                                {
                                                    for (int zc = -PlanetChunkDepth_L; zc <= PlanetChunkDepth_R; zc += realplanetwidth)
                                                    {
                                                        var xxc = xc;
                                                        var yyc = yc;
                                                        var zzc = zc;

                                                        if (xxc < 0)
                                                        {
                                                            xxc *= -1;
                                                            xxc = (PlanetChunkWidth_R) + xxc;
                                                        }
                                                        if (yyc < 0)
                                                        {
                                                            yyc *= -1;
                                                            yyc = (PlanetChunkHeight_R) + yyc;
                                                        }
                                                        if (zzc < 0)
                                                        {
                                                            zzc *= -1;
                                                            zzc = (PlanetChunkDepth_R) + zzc;
                                                        }

                                                        int _index = xxc + (PlanetChunkWidth_L + PlanetChunkWidth_R + 1) * (yyc + (PlanetChunkHeight_L + PlanetChunkHeight_R + 1) * zzc);

                                                        worldMatrix_instances_voxel_pchunk[indexer00][indexer01][_index] = new Matrix[1];
                                                        worldMatrix_instances_voxel_pchunk[indexer00][indexer01][_index][0] = arrayOfPlanetChunk[_index].current_pos;
                                                    }
                                                }
                                            }*/
                                            //////////////TO READD
                                            //////////////TO READD
                                            //////////////TO READD






















































                                            /*
                                            //VR VOXEL PLAYER SPATIAL LOCATION VISUALIZER CONTAINMENT GRID
                                            //VR VOXEL PLAYER SPATIAL LOCATION VISUALIZER CONTAINMENT GRID
                                            //VR VOXEL PLAYER SPATIAL LOCATION VISUALIZER CONTAINMENT GRID
                                            someglobalsplayerspatiallocation = new SC_GlobalsVoxelInstancing();

                                            someglobalsplayerspatiallocation.planeSize = 1 * 4; // * 10
                                            someglobalsplayerspatiallocation.tinyChunkWidth = 4;
                                            someglobalsplayerspatiallocation.tinyChunkHeight = 4;
                                            someglobalsplayerspatiallocation.tinyChunkDepth = 4;
                                            someglobalsplayerspatiallocation.numberOfInstancesPerObjectInWidth = 4;
                                            someglobalsplayerspatiallocation.numberOfInstancesPerObjectInHeight = 4;
                                            someglobalsplayerspatiallocation.numberOfInstancesPerObjectInDepth = 4;
                                            someglobalsplayerspatiallocation.numberOfObjectInWidth = 1;
                                            someglobalsplayerspatiallocation.numberOfObjectInHeight = 1;
                                            someglobalsplayerspatiallocation.numberOfObjectInDepth = 1;

                                            somechunkplayerspatiallocationscene = new SC_instancedChunkPrim[somechunkplayerspatiallocationscenesw * somechunkplayerspatiallocationscenesh * somechunkplayerspatiallocationscenesd];

                                            //Vector3 originkeyboardposition = new Vector3(0, 0.5f, 15);
                                            //Vector3 originsomechunksceneposition = new Vector3(0, 0, 0);

                                            float pitch = (float)(Math.PI * (0) / 180.0f);
                                            float yaw = (float)(Math.PI * (0) / 180.0f);
                                            float roll = (float)(Math.PI * (0) / 180.0f);

                                            Matrix somematrixrot = SharpDX.Matrix.RotationYawPitchRoll(yaw, pitch, roll);
                                            //somematrixrot = Matrix.Identity;

                                            //Vector3 originkeyboardposition = new Vector3(0, 0.5f, 15);
                                            //Vector3 originkeyboardposition = new Vector3(0, 0, 0);
                                            //Vector3 originkeyboardposition = new Vector3(-0.4f, 0.4f, 0.4f);
                                            Vector3 originchunkplayerspatiallocationscene = new Vector3(0, 0, 0);

                                            for (int xxx = 0; xxx < somechunkplayerspatiallocationscenesw; xxx++)
                                            {
                                                for (int yyy = 0; yyy < somechunkplayerspatiallocationscenesh; yyy++)
                                                {
                                                    for (int zzz = 0; zzz < somechunkplayerspatiallocationscenesd; zzz++)
                                                    {
                                                        int somechunkplayerspatiallocationindex = xxx + somechunkplayerspatiallocationscenesw * (yyy + somechunkplayerspatiallocationscenesh * zzz);

                                                        //Vector3 somechunkpriminstancepos = new Vector3(xxx, yyy, zzz) * SC_Globals.numberOfInstancesPerObjectInWidth * SC_Globals.numberOfObjectInWidth * SC_Globals.tinyChunkWidth * SC_Globals.planeSize*4;
                                                        Vector3 somespatialplayeralloc = new Vector3(xxx, yyy, zzz);

                                                        somespatialplayeralloc.X *= someglobalsplayerspatiallocation.numberOfInstancesPerObjectInWidth * someglobalsplayerspatiallocation.numberOfObjectInWidth * someglobalsplayerspatiallocation.tinyChunkWidth * someglobalsplayerspatiallocation.planeSize;
                                                        somespatialplayeralloc.Y *= someglobalsplayerspatiallocation.numberOfInstancesPerObjectInHeight * someglobalsplayerspatiallocation.numberOfObjectInHeight * someglobalsplayerspatiallocation.tinyChunkHeight * someglobalsplayerspatiallocation.planeSize;
                                                        somespatialplayeralloc.Z *= someglobalsplayerspatiallocation.numberOfInstancesPerObjectInDepth * someglobalsplayerspatiallocation.numberOfObjectInDepth * someglobalsplayerspatiallocation.tinyChunkDepth * someglobalsplayerspatiallocation.planeSize;

                                                        somespatialplayeralloc += originchunkplayerspatiallocationscene;

                                                        float tempwidth = 0.1f;
                                                        float tempheight = 0.1f;

                                                        //benchmarking and instancing chunked virtual desktops.
                                                        //benchmarking and instancing chunked virtual desktops.
                                                        //benchmarking and instancing chunked virtual desktops.
                                                        somechunkplayerspatiallocationscene[somechunkplayerspatiallocationindex] = new SC_instancedChunkPrim();
                                                        somechunkplayerspatiallocationscene[somechunkplayerspatiallocationindex].createChunk(SC_console_directx.D3D, tempwidth, tempheight, new Vector3(0, 10, 0), new Vector3(0, -1, 0), somespatialplayeralloc, somechunkplayerspatiallocationindex, 0, 100, _jitter_world, false, SC_console_directx.BodyTag.physicsinstancedvertexbindingchunk, somevoxelroomgridw, somevoxelroomgridh, somevoxelroomgridd, someglobalsplayerspatiallocation.numberOfObjectInWidth, someglobalsplayerspatiallocation.numberOfObjectInHeight, someglobalsplayerspatiallocation.numberOfObjectInDepth, someglobalsplayerspatiallocation.numberOfInstancesPerObjectInWidth, someglobalsplayerspatiallocation.numberOfInstancesPerObjectInHeight, someglobalsplayerspatiallocation.numberOfInstancesPerObjectInDepth, someglobalsplayerspatiallocation.tinyChunkWidth, someglobalsplayerspatiallocation.tinyChunkHeight, someglobalsplayerspatiallocation.tinyChunkDepth, someglobalsplayerspatiallocation.planeSize, 0, 1.0f, 1, 0, somechunkplayerspatiallocationindex, 1, somematrixrot, 1, xxx, yyy, zzz);
                                                        //benchmarking and instancing chunked virtual desktops.
                                                        //benchmarking and instancing chunked virtual desktops.
                                                        //benchmarking and instancing chunked virtual desktops.

                                                        somechunkplayerspatiallocationscene[somechunkplayerspatiallocationindex].lightBufferInstChunk[0] = new SC_instancedChunkPrim.DLightBufferEr()
                                                        {
                                                            ambientColor = ambientColor,
                                                            diffuseColor = diffuseColour,
                                                            lightDirection = dirLight,
                                                            padding0 = 0,
                                                            lightPosition = lightpos,
                                                            padding1 = 100
                                                        };

                                                        somechunkplayerspatiallocationscene[somechunkplayerspatiallocationindex].arrayOfMatrixBuff[0] = new SC_instancedChunkPrim.DMatrixBuffer()
                                                        {
                                                            world = Matrix.Identity,
                                                            view = Matrix.Identity,
                                                            proj = Matrix.Identity,
                                                        };
                                                    }
                                                }
                                            }
                                            //VR VOXEL PLAYER SPATIAL LOCATION VISUALIZER CONTAINMENT GRID
                                            //VR VOXEL PLAYER SPATIAL LOCATION VISUALIZER CONTAINMENT GRID
                                            //VR VOXEL PLAYER SPATIAL LOCATION VISUALIZER CONTAINMENT GRID
                                            */












                                            /*
                                            //INSTANCED DESTROYABLE CHUNK 
                                            //INSTANCED DESTROYABLE CHUNK
                                            //INSTANCED DESTROYABLE CHUNK 
                                            someglobalschunkmesh = new SC_GlobalsVoxelInstancing();

                                            someglobalschunkmesh.planeSize = 0.05f;

                                            someglobalschunkmesh.tinyChunkWidth = 4;
                                            someglobalschunkmesh.tinyChunkHeight = 4;
                                            someglobalschunkmesh.tinyChunkDepth = 4;

                                            someglobalschunkmesh.numberOfInstancesPerObjectInWidth = 1;
                                            someglobalschunkmesh.numberOfInstancesPerObjectInHeight = 1;
                                            someglobalschunkmesh.numberOfInstancesPerObjectInDepth = 1;

                                            someglobalschunkmesh.numberOfObjectInWidth = 1;
                                            someglobalschunkmesh.numberOfObjectInHeight = 1;
                                            someglobalschunkmesh.numberOfObjectInDepth = 1;


                                            somechunkmesh = new SC_instancedChunkPrim[somechunkmeshswidth * somechunkmeshsheight * somechunkmeshsdepth];

                                            //float yaw = sc_maths.DegreeToRadian(45);
                                            //float pitch = sc_maths.DegreeToRadian(45);
                                            //float roll = sc_maths.DegreeToRadian(45);

                                            pitch = (float)(Math.PI * (0) / 180.0f);
                                            yaw = (float)(Math.PI * (0) / 180.0f);
                                            roll = (float)(Math.PI * (0) / 180.0f);

                                            somematrixrot = SharpDX.Matrix.RotationYawPitchRoll(yaw, pitch, roll);

                                            //Vector3 originkeyboardposition = new Vector3(0, 0.5f, 15);
                                            //Vector3 originkeyboardposition = new Vector3(0, 0, 0);
                                            //Vector3 originkeyboardposition = new Vector3(-0.4f, 0.4f, 0.4f);
                                            //Vector3 originkeyboardposition = new Vector3(-2, 0, 2);
                                            Vector3 originkeyboardposition = new Vector3(-2, 0, 0);


                                            for (int xxx = 0; xxx < somechunkmeshswidth; xxx++)
                                            {
                                                for (int yyy = 0; yyy < somechunkmeshsheight; yyy++)
                                                {
                                                    for (int zzz = 0; zzz < somechunkmeshsdepth; zzz++)
                                                    {
                                                        int somechunkmeshindex = xxx + somechunkmeshswidth * (yyy + somechunkmeshsheight * zzz);

                                                        //Vector3 somechunkpriminstancepos = new Vector3(xxx, yyy, zzz) * SC_Globals.numberOfInstancesPerObjectInWidth * SC_Globals.numberOfObjectInWidth * SC_Globals.tinyChunkWidth * SC_Globals.planeSize*4;
                                                        Vector3 somechunkmeshpos = new Vector3(xxx, yyy, zzz);

                                                        somechunkmeshpos.X *= someglobalschunkmesh.numberOfInstancesPerObjectInWidth * someglobalschunkmesh.numberOfObjectInWidth * someglobalschunkmesh.tinyChunkWidth * someglobalschunkmesh.planeSize;
                                                        somechunkmeshpos.Y *= someglobalschunkmesh.numberOfInstancesPerObjectInHeight * someglobalschunkmesh.numberOfObjectInHeight * someglobalschunkmesh.tinyChunkHeight * someglobalschunkmesh.planeSize;
                                                        somechunkmeshpos.Z *= someglobalschunkmesh.numberOfInstancesPerObjectInDepth * someglobalschunkmesh.numberOfObjectInDepth * someglobalschunkmesh.tinyChunkDepth * someglobalschunkmesh.planeSize;

                                                        somechunkmeshpos += originkeyboardposition;

                                                        float tempwidth = 0.1f;
                                                        float tempheight = 0.1f;

                                                        somematrixrot.M41 = somechunkmeshpos.X;
                                                        somematrixrot.M42 = somechunkmeshpos.Y;
                                                        somematrixrot.M43 = somechunkmeshpos.Z;

                                                        //benchmarking and instancing chunked virtual desktops.
                                                        //benchmarking and instancing chunked virtual desktops.
                                                        //benchmarking and instancing chunked virtual desktops.
                                                        somechunkmesh[somechunkmeshindex] = new SC_instancedChunkPrim();
                                                        somechunkmesh[somechunkmeshindex].createChunk(SC_console_directx.D3D, tempwidth, tempheight, new Vector3(0, 10, 0), new Vector3(0, -1, 0), somechunkmeshpos, somechunkmeshindex, 0, 100, _jitter_world, false, SC_console_directx.BodyTag.physicsinstancedvertexbindingchunk, somevoxelroomgridw, somevoxelroomgridh, somevoxelroomgridd, someglobalschunkmesh.numberOfObjectInWidth, someglobalschunkmesh.numberOfObjectInHeight, someglobalschunkmesh.numberOfObjectInDepth, someglobalschunkmesh.numberOfInstancesPerObjectInWidth, someglobalschunkmesh.numberOfInstancesPerObjectInHeight, someglobalschunkmesh.numberOfInstancesPerObjectInDepth, someglobalschunkmesh.tinyChunkWidth, someglobalschunkmesh.tinyChunkHeight, someglobalschunkmesh.tinyChunkDepth, someglobalschunkmesh.planeSize, 0, 1.0f, 1, 0, somechunkmeshindex, 0, somematrixrot, 0, xxx, yyy, zzz);
                                                        //benchmarking and instancing chunked virtual desktops.
                                                        //benchmarking and instancing chunked virtual desktops.
                                                        //benchmarking and instancing chunked virtual desktops.

                                                        Matrix someinitmat = somechunkmesh[somechunkmeshindex].worldmatofobj;
                                                        Quaternion somedirquat;
                                                        Quaternion.RotationMatrix(ref someinitmat, out somedirquat);

                                                        var dirInstanceRight = sc_maths._newgetdirleft(somedirquat);
                                                        var dirInstanceUp = sc_maths._newgetdirup(somedirquat);
                                                        var dirInstanceForward = sc_maths._newgetdirforward(somedirquat);

                                                        //position = position - (new Vector4(dirInstanceRight.X, dirInstanceRight.Y, dirInstanceRight.Z, 1.0f) * (tinyChunkWidth * planeSize * 0.5f));
                                                        //position = position - (new Vector4(dirInstanceUp.X, dirInstanceUp.Y, dirInstanceUp.Z, 1.0f) * (tinyChunkWidth * planeSize * 0.5f));
                                                        //position = position + (new Vector4(dirInstanceForward.X, dirInstanceForward.Y, dirInstanceForward.Z, 1.0f) * (tinyChunkWidth * planeSize * 0.5f));

                                                        Vector4 somevecx = new Vector4(dirInstanceRight.X, dirInstanceRight.Y, dirInstanceRight.Z, 1.0f);
                                                        Vector4 somevecy = new Vector4(dirInstanceUp.X, dirInstanceUp.Y, dirInstanceUp.Z, 1.0f);
                                                        Vector4 somevecz = new Vector4(dirInstanceForward.X, dirInstanceForward.Y, dirInstanceForward.Z, 1.0f);

                                                        Vector4 somemainpos = new Vector4(someinitmat.M41, someinitmat.M42, someinitmat.M43, 1.0f);
                                                        Vector4 someinstancepostest = somemainpos;// Vector4.Zero;

                                                        //WARNING - USING THE SAME LOOP AS THE CHUNK CREATION IS DANGEROUS SINCE THIS MAIN LOOP X/Y/Z IS FOR THE ENTIRE POSITION SETUP AND NOT THE TINYCHUNKWIDTH/BYTECHUNKWIDTH SO IF ADDING ANYTHING OTHER THAN +1 ON THIS LOOP ITERATOR, IT WILL BREAK PROBABLY. SO JUST DON'T CHANGE THE MAIN LOOP AND IT SHOULD BE FINE, INSTEAD IF YOU WANT TO CHANGE THE POSITION, DO IT SO FROM THE VECTOR somechunkmeshpos. STEVE CHASSÉ AKA NINEKORN AKA NINE AKA 9 - 2021-AUGUST-18 NOTES
                                                        //WARNING - USING THE SAME LOOP AS THE CHUNK CREATION IS DANGEROUS SINCE THIS MAIN LOOP X/Y/Z IS FOR THE ENTIRE POSITION SETUP AND NOT THE TINYCHUNKWIDTH/BYTECHUNKWIDTH SO IF ADDING ANYTHING OTHER THAN +1 ON THIS LOOP ITERATOR, IT WILL BREAK PROBABLY. SO JUST DON'T CHANGE THE MAIN LOOP AND IT SHOULD BE FINE, INSTEAD IF YOU WANT TO CHANGE THE POSITION, DO IT SO FROM THE VECTOR somechunkmeshpos. STEVE CHASSÉ AKA NINEKORN AKA NINE AKA 9 - 2021-AUGUST-18 NOTES
                                                        //WARNING - USING THE SAME LOOP AS THE CHUNK CREATION IS DANGEROUS SINCE THIS MAIN LOOP X/Y/Z IS FOR THE ENTIRE POSITION SETUP AND NOT THE TINYCHUNKWIDTH/BYTECHUNKWIDTH SO IF ADDING ANYTHING OTHER THAN +1 ON THIS LOOP ITERATOR, IT WILL BREAK PROBABLY. SO JUST DON'T CHANGE THE MAIN LOOP AND IT SHOULD BE FINE, INSTEAD IF YOU WANT TO CHANGE THE POSITION, DO IT SO FROM THE VECTOR somechunkmeshpos. STEVE CHASSÉ AKA NINEKORN AKA NINE AKA 9 - 2021-AUGUST-18 NOTES
                                                        someinstancepostest = someinstancepostest + (somevecx * (x * someglobalschunkmesh.tinyChunkWidth * someglobalschunkmesh.planeSize));
                                                        someinstancepostest = someinstancepostest + (somevecy * (y * someglobalschunkmesh.tinyChunkWidth * someglobalschunkmesh.planeSize));
                                                        someinstancepostest = someinstancepostest + (somevecz * (z * someglobalschunkmesh.tinyChunkWidth * someglobalschunkmesh.planeSize));
                                                        //WARNING - USING THE SAME LOOP AS THE CHUNK CREATION IS DANGEROUS SINCE THIS MAIN LOOP X/Y/Z IS FOR THE ENTIRE POSITION SETUP AND NOT THE TINYCHUNKWIDTH/BYTECHUNKWIDTH SO IF ADDING ANYTHING OTHER THAN +1 ON THIS LOOP ITERATOR, IT WILL BREAK PROBABLY. SO JUST DON'T CHANGE THE MAIN LOOP AND IT SHOULD BE FINE, INSTEAD IF YOU WANT TO CHANGE THE POSITION, DO IT SO FROM THE VECTOR somechunkmeshpos. STEVE CHASSÉ AKA NINEKORN AKA NINE AKA 9 - 2021-AUGUST-18 NOTES
                                                        //WARNING - USING THE SAME LOOP AS THE CHUNK CREATION IS DANGEROUS SINCE THIS MAIN LOOP X/Y/Z IS FOR THE ENTIRE POSITION SETUP AND NOT THE TINYCHUNKWIDTH/BYTECHUNKWIDTH SO IF ADDING ANYTHING OTHER THAN +1 ON THIS LOOP ITERATOR, IT WILL BREAK PROBABLY. SO JUST DON'T CHANGE THE MAIN LOOP AND IT SHOULD BE FINE, INSTEAD IF YOU WANT TO CHANGE THE POSITION, DO IT SO FROM THE VECTOR somechunkmeshpos. STEVE CHASSÉ AKA NINEKORN AKA NINE AKA 9 - 2021-AUGUST-18 NOTES
                                                        //WARNING - USING THE SAME LOOP AS THE CHUNK CREATION IS DANGEROUS SINCE THIS MAIN LOOP X/Y/Z IS FOR THE ENTIRE POSITION SETUP AND NOT THE TINYCHUNKWIDTH/BYTECHUNKWIDTH SO IF ADDING ANYTHING OTHER THAN +1 ON THIS LOOP ITERATOR, IT WILL BREAK PROBABLY. SO JUST DON'T CHANGE THE MAIN LOOP AND IT SHOULD BE FINE, INSTEAD IF YOU WANT TO CHANGE THE POSITION, DO IT SO FROM THE VECTOR somechunkmeshpos. STEVE CHASSÉ AKA NINEKORN AKA NINE AKA 9 - 2021-AUGUST-18 NOTES

                                                        someinitmat.M41 = someinstancepostest.X;
                                                        someinitmat.M42 = someinstancepostest.Y;
                                                        someinitmat.M43 = someinstancepostest.Z;

                                                        somechunkmesh[somechunkmeshindex].worldmatofobj = someinitmat;

                                                        somechunkmesh[somechunkmeshindex].lightBufferInstChunk[0] = new SC_instancedChunkPrim.DLightBufferEr()
                                                        {
                                                            ambientColor = ambientColor,
                                                            diffuseColor = diffuseColour,
                                                            lightDirection = dirLight,
                                                            padding0 = 0,
                                                            lightPosition = lightpos,
                                                            padding1 = 100
                                                        };

                                                        somechunkmesh[somechunkmeshindex].arrayOfMatrixBuff[0] = new SC_instancedChunkPrim.DMatrixBuffer()
                                                        {
                                                            world = Matrix.Identity,//Matrix.Identity,
                                                            view = Matrix.Identity,
                                                            proj = Matrix.Identity,
                                                        };
                                                    }
                                                }
                                            }*/
                                            //INSTANCED DESTROYABLE CHUNK 
                                            //INSTANCED DESTROYABLE CHUNK
                                            //INSTANCED DESTROYABLE CHUNK 

























                                            /*
                                            //CHUNK VOXEL GRID
                                            //CHUNK VOXEL GRID
                                            //CHUNK VOXEL GRID
                                            someglobalschunkmeshgrid = new SC_GlobalsVoxelInstancing();

                                            someglobalschunkmeshgrid.planeSize = someglobalschunkmesh.planeSize * 1.00001f; // * 10
                                            someglobalschunkmeshgrid.tinyChunkWidth = 4;
                                            someglobalschunkmeshgrid.tinyChunkHeight = 4;
                                            someglobalschunkmeshgrid.tinyChunkDepth = 4;
                                            someglobalschunkmeshgrid.numberOfInstancesPerObjectInWidth = 1;
                                            someglobalschunkmeshgrid.numberOfInstancesPerObjectInHeight = 1;
                                            someglobalschunkmeshgrid.numberOfInstancesPerObjectInDepth = 1;
                                            someglobalschunkmeshgrid.numberOfObjectInWidth = 1;
                                            someglobalschunkmeshgrid.numberOfObjectInHeight = 1;
                                            someglobalschunkmeshgrid.numberOfObjectInDepth = 1;

                                            somechunkmeshgrid = new SC_instancedChunkPrim[somechunkplayerspatiallocationscenesw * somechunkplayerspatiallocationscenesh * somechunkplayerspatiallocationscenesd];

                                            //Vector3 originkeyboardposition = new Vector3(0, 0.5f, 15);
                                            //Vector3 originsomechunksceneposition = new Vector3(0, 0, 0);

                                            pitch = (float)(Math.PI * (0) / 180.0f);
                                            yaw = (float)(Math.PI * (0) / 180.0f);
                                            roll = (float)(Math.PI * (0) / 180.0f);

                                            somematrixrot = SharpDX.Matrix.RotationYawPitchRoll(yaw, pitch, roll);
                                            //somematrixrot = Matrix.Identity;

                                            //Vector3 originkeyboardposition = new Vector3(0, 0.5f, 15);
                                            //Vector3 originkeyboardposition = new Vector3(0, 0, 0);
                                            //Vector3 originkeyboardposition = new Vector3(-0.4f, 0.4f, 0.4f);
                                            Vector3 originsomechunkspatialalocpos = originkeyboardposition;// new Vector3(-2, 0, 2);

                                            for (int xxx = 0; xxx < somechunkplayerspatiallocationscenesw; xxx++)
                                            {
                                                for (int yyy = 0; yyy < somechunkplayerspatiallocationscenesh; yyy++)
                                                {
                                                    for (int zzz = 0; zzz < somechunkplayerspatiallocationscenesd; zzz++)
                                                    {
                                                        int somechunkgridindex = xxx + somechunkplayerspatiallocationscenesw * (yyy + somechunkplayerspatiallocationscenesh * zzz);

                                                        //Vector3 somechunkpriminstancepos = new Vector3(xxx, yyy, zzz) * SC_Globals.numberOfInstancesPerObjectInWidth * SC_Globals.numberOfObjectInWidth * SC_Globals.tinyChunkWidth * SC_Globals.planeSize*4;
                                                        Vector3 somescenegridpos = new Vector3(xxx, yyy, zzz);

                                                        somescenegridpos.X *= -someglobalschunkmeshgrid.numberOfInstancesPerObjectInWidth * someglobalschunkmeshgrid.numberOfObjectInWidth * someglobalschunkmeshgrid.tinyChunkWidth * someglobalschunkmeshgrid.planeSize;
                                                        somescenegridpos.Y *= someglobalschunkmeshgrid.numberOfInstancesPerObjectInHeight * someglobalschunkmeshgrid.numberOfObjectInHeight * someglobalschunkmeshgrid.tinyChunkHeight * someglobalschunkmeshgrid.planeSize;
                                                        somescenegridpos.Z *= someglobalschunkmeshgrid.numberOfInstancesPerObjectInDepth * someglobalschunkmeshgrid.numberOfObjectInDepth * someglobalschunkmeshgrid.tinyChunkDepth * someglobalschunkmeshgrid.planeSize;

                                                        somescenegridpos += originsomechunkspatialalocpos;

                                                        float tempwidth = 0.1f;
                                                        float tempheight = 0.1f;

                                                        somematrixrot.M41 = somescenegridpos.X;
                                                        somematrixrot.M42 = somescenegridpos.Y;
                                                        somematrixrot.M43 = somescenegridpos.Z;

                                                        //benchmarking and instancing chunked virtual desktops.
                                                        //benchmarking and instancing chunked virtual desktops.
                                                        //benchmarking and instancing chunked virtual desktops.
                                                        somechunkmeshgrid[somechunkgridindex] = new SC_instancedChunkPrim();
                                                        somechunkmeshgrid[somechunkgridindex].createChunk(SC_console_directx.D3D, tempwidth, tempheight, new Vector3(0, 10, 0), new Vector3(0, -1, 0), somescenegridpos, somechunkgridindex, 0, 100, _jitter_world, false, SC_console_directx.BodyTag.physicsinstancedvertexbindingchunk, somevoxelroomgridw, somevoxelroomgridh, somevoxelroomgridd, someglobalschunkmeshgrid.numberOfObjectInWidth, someglobalschunkmeshgrid.numberOfObjectInHeight, someglobalschunkmeshgrid.numberOfObjectInDepth, someglobalschunkmeshgrid.numberOfInstancesPerObjectInWidth, someglobalschunkmeshgrid.numberOfInstancesPerObjectInHeight, someglobalschunkmeshgrid.numberOfInstancesPerObjectInDepth, someglobalschunkmeshgrid.tinyChunkWidth, someglobalschunkmeshgrid.tinyChunkHeight, someglobalschunkmeshgrid.tinyChunkDepth, someglobalschunkmeshgrid.planeSize, 0, 1.0f, 1, 0, somechunkgridindex, 1, somematrixrot, 0, xxx, yyy, zzz);
                                                        //benchmarking and instancing chunked virtual desktops.
                                                        //benchmarking and instancing chunked virtual desktops.
                                                        //benchmarking and instancing chunked virtual desktops.

                                                        Matrix someinitmat = somechunkmeshgrid[somechunkgridindex].worldmatofobj;
                                                        Quaternion somedirquat;
                                                        Quaternion.RotationMatrix(ref someinitmat, out somedirquat);

                                                        var dirInstanceRight = -sc_maths._newgetdirleft(somedirquat);
                                                        var dirInstanceUp = sc_maths._newgetdirup(somedirquat);
                                                        var dirInstanceForward = sc_maths._newgetdirforward(somedirquat);

                                                        //position = position - (new Vector4(dirInstanceRight.X, dirInstanceRight.Y, dirInstanceRight.Z, 1.0f) * (tinyChunkWidth * planeSize * 0.5f));
                                                        //position = position - (new Vector4(dirInstanceUp.X, dirInstanceUp.Y, dirInstanceUp.Z, 1.0f) * (tinyChunkWidth * planeSize * 0.5f));
                                                        //position = position + (new Vector4(dirInstanceForward.X, dirInstanceForward.Y, dirInstanceForward.Z, 1.0f) * (tinyChunkWidth * planeSize * 0.5f));

                                                        Vector4 somevecx = new Vector4(dirInstanceRight.X, dirInstanceRight.Y, dirInstanceRight.Z, 1.0f);
                                                        Vector4 somevecy = new Vector4(dirInstanceUp.X, dirInstanceUp.Y, dirInstanceUp.Z, 1.0f);
                                                        Vector4 somevecz = new Vector4(dirInstanceForward.X, dirInstanceForward.Y, dirInstanceForward.Z, 1.0f);

                                                        Vector4 somemainpos = new Vector4(someinitmat.M41, someinitmat.M42, someinitmat.M43, 1.0f);
                                                        Vector4 someinstancepostest = somemainpos;// Vector4.Zero;

                                                        //WARNING - USING THE SAME LOOP AS THE CHUNK CREATION IS DANGEROUS SINCE THIS MAIN LOOP X/Y/Z IS FOR THE ENTIRE POSITION SETUP AND NOT THE TINYCHUNKWIDTH/BYTECHUNKWIDTH SO IF ADDING ANYTHING OTHER THAN +1 ON THIS LOOP ITERATOR, IT WILL BREAK PROBABLY. SO JUST DON'T CHANGE THE MAIN LOOP AND IT SHOULD BE FINE, INSTEAD IF YOU WANT TO CHANGE THE POSITION, DO IT SO FROM THE VECTOR somechunkmeshpos. STEVE CHASSÉ AKA NINEKORN AKA NINE AKA 9 - 2021-AUGUST-18 NOTES
                                                        //WARNING - USING THE SAME LOOP AS THE CHUNK CREATION IS DANGEROUS SINCE THIS MAIN LOOP X/Y/Z IS FOR THE ENTIRE POSITION SETUP AND NOT THE TINYCHUNKWIDTH/BYTECHUNKWIDTH SO IF ADDING ANYTHING OTHER THAN +1 ON THIS LOOP ITERATOR, IT WILL BREAK PROBABLY. SO JUST DON'T CHANGE THE MAIN LOOP AND IT SHOULD BE FINE, INSTEAD IF YOU WANT TO CHANGE THE POSITION, DO IT SO FROM THE VECTOR somechunkmeshpos. STEVE CHASSÉ AKA NINEKORN AKA NINE AKA 9 - 2021-AUGUST-18 NOTES
                                                        //WARNING - USING THE SAME LOOP AS THE CHUNK CREATION IS DANGEROUS SINCE THIS MAIN LOOP X/Y/Z IS FOR THE ENTIRE POSITION SETUP AND NOT THE TINYCHUNKWIDTH/BYTECHUNKWIDTH SO IF ADDING ANYTHING OTHER THAN +1 ON THIS LOOP ITERATOR, IT WILL BREAK PROBABLY. SO JUST DON'T CHANGE THE MAIN LOOP AND IT SHOULD BE FINE, INSTEAD IF YOU WANT TO CHANGE THE POSITION, DO IT SO FROM THE VECTOR somechunkmeshpos. STEVE CHASSÉ AKA NINEKORN AKA NINE AKA 9 - 2021-AUGUST-18 NOTES
                                                        someinstancepostest = someinstancepostest + (somevecx * (x * someglobalschunkmeshgrid.tinyChunkWidth * someglobalschunkmeshgrid.planeSize));
                                                        someinstancepostest = someinstancepostest + (somevecy * (y * someglobalschunkmeshgrid.tinyChunkWidth * someglobalschunkmeshgrid.planeSize));
                                                        someinstancepostest = someinstancepostest + (somevecz * (z * someglobalschunkmeshgrid.tinyChunkWidth * someglobalschunkmeshgrid.planeSize));
                                                        //WARNING - USING THE SAME LOOP AS THE CHUNK CREATION IS DANGEROUS SINCE THIS MAIN LOOP X/Y/Z IS FOR THE ENTIRE POSITION SETUP AND NOT THE TINYCHUNKWIDTH/BYTECHUNKWIDTH SO IF ADDING ANYTHING OTHER THAN +1 ON THIS LOOP ITERATOR, IT WILL BREAK PROBABLY. SO JUST DON'T CHANGE THE MAIN LOOP AND IT SHOULD BE FINE, INSTEAD IF YOU WANT TO CHANGE THE POSITION, DO IT SO FROM THE VECTOR somechunkmeshpos. STEVE CHASSÉ AKA NINEKORN AKA NINE AKA 9 - 2021-AUGUST-18 NOTES
                                                        //WARNING - USING THE SAME LOOP AS THE CHUNK CREATION IS DANGEROUS SINCE THIS MAIN LOOP X/Y/Z IS FOR THE ENTIRE POSITION SETUP AND NOT THE TINYCHUNKWIDTH/BYTECHUNKWIDTH SO IF ADDING ANYTHING OTHER THAN +1 ON THIS LOOP ITERATOR, IT WILL BREAK PROBABLY. SO JUST DON'T CHANGE THE MAIN LOOP AND IT SHOULD BE FINE, INSTEAD IF YOU WANT TO CHANGE THE POSITION, DO IT SO FROM THE VECTOR somechunkmeshpos. STEVE CHASSÉ AKA NINEKORN AKA NINE AKA 9 - 2021-AUGUST-18 NOTES
                                                        //WARNING - USING THE SAME LOOP AS THE CHUNK CREATION IS DANGEROUS SINCE THIS MAIN LOOP X/Y/Z IS FOR THE ENTIRE POSITION SETUP AND NOT THE TINYCHUNKWIDTH/BYTECHUNKWIDTH SO IF ADDING ANYTHING OTHER THAN +1 ON THIS LOOP ITERATOR, IT WILL BREAK PROBABLY. SO JUST DON'T CHANGE THE MAIN LOOP AND IT SHOULD BE FINE, INSTEAD IF YOU WANT TO CHANGE THE POSITION, DO IT SO FROM THE VECTOR somechunkmeshpos. STEVE CHASSÉ AKA NINEKORN AKA NINE AKA 9 - 2021-AUGUST-18 NOTES

                                                        someinitmat.M41 = someinstancepostest.X;
                                                        someinitmat.M42 = someinstancepostest.Y;
                                                        someinitmat.M43 = someinstancepostest.Z;

                                                        somechunkmeshgrid[somechunkgridindex].worldmatofobj = someinitmat;

                                                        somechunkmeshgrid[somechunkgridindex].lightBufferInstChunk[0] = new SC_instancedChunkPrim.DLightBufferEr()
                                                        {
                                                            ambientColor = ambientColor,
                                                            diffuseColor = diffuseColour,
                                                            lightDirection = dirLight,
                                                            padding0 = 0,
                                                            lightPosition = lightpos,
                                                            padding1 = 100
                                                        };

                                                        somechunkmeshgrid[somechunkgridindex].arrayOfMatrixBuff[0] = new SC_instancedChunkPrim.DMatrixBuffer()
                                                        {
                                                            world = Matrix.Identity,
                                                            view = Matrix.Identity,
                                                            proj = Matrix.Identity,
                                                        };
                                                    }
                                                }
                                            }*/
                                            //CHUNK VOXEL GRID
                                            //CHUNK VOXEL GRID
                                            //CHUNK VOXEL GRID









                                            //VOXEL VIRTUAL DESKTOP
                                            //VOXEL VIRTUAL DESKTOP
                                            //VOXEL VIRTUAL DESKTOP
                                            somevoxelvirtualdesktopglobals = new SC_GlobalsVoxelInstancing();

                                            somevoxelvirtualdesktopglobals.planeSize = 0.01f; // * 10
                                            somevoxelvirtualdesktopglobals.tinyChunkWidth = 6;
                                            somevoxelvirtualdesktopglobals.tinyChunkHeight = 6;
                                            somevoxelvirtualdesktopglobals.tinyChunkDepth = 6;
                                            somevoxelvirtualdesktopglobals.numberOfInstancesPerObjectInWidth = 1;
                                            somevoxelvirtualdesktopglobals.numberOfInstancesPerObjectInHeight = 1;
                                            somevoxelvirtualdesktopglobals.numberOfInstancesPerObjectInDepth = 1;
                                            somevoxelvirtualdesktopglobals.numberOfObjectInWidth = 1;
                                            somevoxelvirtualdesktopglobals.numberOfObjectInHeight = 1;
                                            somevoxelvirtualdesktopglobals.numberOfObjectInDepth = 1;


                                            somevoxelvirtualdesktop = new SC_instancedChunkPrim[somevoxelvirtualdesktopw * somevoxelvirtualdesktoph * somevoxelvirtualdesktopd];

                                            //Vector3 originvirtualdesktoppos = new Vector3(0, 0.5f, 15);
                                            //Vector3 originsomechunksceneposition = new Vector3(0, 0, 0);

                                            var pitch = (float)(Math.PI * (0) / 180.0f);
                                            var yaw = (float)(Math.PI * (0) / 180.0f);
                                            var roll = (float)(Math.PI * (0) / 180.0f);

                                            var somematrixrot = SharpDX.Matrix.RotationYawPitchRoll(yaw, pitch, roll);
                                            //somematrixrot = Matrix.Identity;

                                            //Vector3 originvirtualdesktoppos = new Vector3(0, 0.5f, 15);
                                            Vector3 originvirtualdesktoppos = new Vector3(1, 1, 1);
                                            //Vector3 originvirtualdesktoppos = new Vector3(-0.4f, 0.4f, 0.4f);
                                            //Vector3 originvirtualdesktoppos = new Vector3(1.333333f * somevoxelvirtualdesktopglobals.numberOfInstancesPerObjectInWidth * somevoxelvirtualdesktopglobals.numberOfObjectInWidth * somevoxelvirtualdesktopglobals.tinyChunkWidth * somevoxelvirtualdesktopglobals.planeSize, 0, 5); // somevoxelvirtualdesktopglobals.numberOfInstancesPerObjectInDepth * somevoxelvirtualdesktopglobals.numberOfObjectInDepth * somevoxelvirtualdesktopglobals.tinyChunkDepth * somevoxelvirtualdesktopglobals.planeSize * 10
                                            //Vector3 originvirtualdesktoppos = new Vector3(-1 * 1.25f * somevoxelvirtualdesktopglobals.numberOfInstancesPerObjectInWidth * somevoxelvirtualdesktopglobals.numberOfObjectInWidth * somevoxelvirtualdesktopglobals.tinyChunkWidth * somevoxelvirtualdesktopglobals.planeSize, 1, somevoxelvirtualdesktopglobals.numberOfInstancesPerObjectInDepth * somevoxelvirtualdesktopglobals.numberOfObjectInDepth * somevoxelvirtualdesktopglobals.tinyChunkDepth * somevoxelvirtualdesktopglobals.planeSize * 10f);

                                            for (int xxx = 0; xxx < somevoxelvirtualdesktopw; xxx++)
                                            {
                                                for (int yyy = 0; yyy < somevoxelvirtualdesktoph; yyy++)
                                                {
                                                    for (int zzz = 0; zzz < somevoxelvirtualdesktopd; zzz++)
                                                    {
                                                        int somevoxelindex = xxx + somevoxelvirtualdesktopw * (yyy + somevoxelvirtualdesktoph * zzz);

                                                        //Vector3 somechunkpriminstancepos = new Vector3(xxx, yyy, zzz) * SC_Globals.numberOfInstancesPerObjectInWidth * SC_Globals.numberOfObjectInWidth * SC_Globals.tinyChunkWidth * SC_Globals.planeSize*4;
                                                        Vector3 somevoxelposition = new Vector3(xxx, yyy, zzz);

                                                        somevoxelposition.X *= somevoxelvirtualdesktopglobals.numberOfInstancesPerObjectInWidth * somevoxelvirtualdesktopglobals.numberOfObjectInWidth * somevoxelvirtualdesktopglobals.tinyChunkWidth * somevoxelvirtualdesktopglobals.planeSize;
                                                        somevoxelposition.Y *= somevoxelvirtualdesktopglobals.numberOfInstancesPerObjectInHeight * somevoxelvirtualdesktopglobals.numberOfObjectInHeight * somevoxelvirtualdesktopglobals.tinyChunkHeight * somevoxelvirtualdesktopglobals.planeSize;
                                                        somevoxelposition.Z *= somevoxelvirtualdesktopglobals.numberOfInstancesPerObjectInDepth * somevoxelvirtualdesktopglobals.numberOfObjectInDepth * somevoxelvirtualdesktopglobals.tinyChunkDepth * somevoxelvirtualdesktopglobals.planeSize;

                                                        somevoxelposition += originvirtualdesktoppos;

                                                        float tempwidth = 0.1f;
                                                        float tempheight = 0.1f;

                                                        somematrixrot.M41 = somevoxelposition.X;
                                                        somematrixrot.M42 = somevoxelposition.Y;
                                                        somematrixrot.M43 = somevoxelposition.Z;

                                                        //benchmarking and instancing chunked virtual desktops.
                                                        //benchmarking and instancing chunked virtual desktops.
                                                        //benchmarking and instancing chunked virtual desktops.
                                                        somevoxelvirtualdesktop[somevoxelindex] = new SC_instancedChunkPrim();
                                                        somevoxelvirtualdesktop[somevoxelindex].createChunk(SC_console_directx.D3D, tempwidth, tempheight, new Vector3(0, 10, 0), new Vector3(0, -1, 0), somevoxelposition, somevoxelindex, 0, 100, _jitter_world, false, SC_console_directx.BodyTag.physicsinstancedvertexbindingchunk, somevoxelroomgridw, somevoxelroomgridh, somevoxelroomgridd, somevoxelvirtualdesktopglobals.numberOfObjectInWidth, somevoxelvirtualdesktopglobals.numberOfObjectInHeight, somevoxelvirtualdesktopglobals.numberOfObjectInDepth, somevoxelvirtualdesktopglobals.numberOfInstancesPerObjectInWidth, somevoxelvirtualdesktopglobals.numberOfInstancesPerObjectInHeight, somevoxelvirtualdesktopglobals.numberOfInstancesPerObjectInDepth, somevoxelvirtualdesktopglobals.tinyChunkWidth, somevoxelvirtualdesktopglobals.tinyChunkHeight, somevoxelvirtualdesktopglobals.tinyChunkDepth, somevoxelvirtualdesktopglobals.planeSize, 0, 1.0f, 1, 0, somevoxelindex, 0, somematrixrot, 1, xxx, yyy, zzz);
                                                        //benchmarking and instancing chunked virtual desktops.
                                                        //benchmarking and instancing chunked virtual desktops.
                                                        //benchmarking and instancing chunked virtual desktops.

                                                        Matrix someinitmat = somevoxelvirtualdesktop[somevoxelindex].worldmatofobj;
                                                        Quaternion somedirquat;
                                                        Quaternion.RotationMatrix(ref someinitmat, out somedirquat);

                                                        var dirInstanceRight = sc_maths._newgetdirleft(somedirquat);
                                                        var dirInstanceUp = sc_maths._newgetdirup(somedirquat);
                                                        var dirInstanceForward = sc_maths._newgetdirforward(somedirquat);

                                                        //position = position - (new Vector4(dirInstanceRight.X, dirInstanceRight.Y, dirInstanceRight.Z, 1.0f) * (tinyChunkWidth * planeSize * 0.5f));
                                                        //position = position - (new Vector4(dirInstanceUp.X, dirInstanceUp.Y, dirInstanceUp.Z, 1.0f) * (tinyChunkWidth * planeSize * 0.5f));
                                                        //position = position + (new Vector4(dirInstanceForward.X, dirInstanceForward.Y, dirInstanceForward.Z, 1.0f) * (tinyChunkWidth * planeSize * 0.5f));

                                                        Vector4 somevecx = new Vector4(dirInstanceRight.X, dirInstanceRight.Y, dirInstanceRight.Z, 1.0f);
                                                        Vector4 somevecy = new Vector4(dirInstanceUp.X, dirInstanceUp.Y, dirInstanceUp.Z, 1.0f);
                                                        Vector4 somevecz = new Vector4(dirInstanceForward.X, dirInstanceForward.Y, dirInstanceForward.Z, 1.0f);

                                                        Vector4 somemainpos = new Vector4(someinitmat.M41, someinitmat.M42, someinitmat.M43, 1.0f);
                                                        Vector4 someinstancepostest = somemainpos;// Vector4.Zero;

                                                        //WARNING - USING THE SAME LOOP AS THE CHUNK CREATION IS DANGEROUS SINCE THIS MAIN LOOP X/Y/Z IS FOR THE ENTIRE POSITION SETUP AND NOT THE TINYCHUNKWIDTH/BYTECHUNKWIDTH SO IF ADDING ANYTHING OTHER THAN +1 ON THIS LOOP ITERATOR, IT WILL BREAK PROBABLY. SO JUST DON'T CHANGE THE MAIN LOOP AND IT SHOULD BE FINE, INSTEAD IF YOU WANT TO CHANGE THE POSITION, DO IT SO FROM THE VECTOR somechunkmeshpos. STEVE CHASSÉ AKA NINEKORN AKA NINE AKA 9 - 2021-AUGUST-18 NOTES
                                                        //WARNING - USING THE SAME LOOP AS THE CHUNK CREATION IS DANGEROUS SINCE THIS MAIN LOOP X/Y/Z IS FOR THE ENTIRE POSITION SETUP AND NOT THE TINYCHUNKWIDTH/BYTECHUNKWIDTH SO IF ADDING ANYTHING OTHER THAN +1 ON THIS LOOP ITERATOR, IT WILL BREAK PROBABLY. SO JUST DON'T CHANGE THE MAIN LOOP AND IT SHOULD BE FINE, INSTEAD IF YOU WANT TO CHANGE THE POSITION, DO IT SO FROM THE VECTOR somechunkmeshpos. STEVE CHASSÉ AKA NINEKORN AKA NINE AKA 9 - 2021-AUGUST-18 NOTES
                                                        //WARNING - USING THE SAME LOOP AS THE CHUNK CREATION IS DANGEROUS SINCE THIS MAIN LOOP X/Y/Z IS FOR THE ENTIRE POSITION SETUP AND NOT THE TINYCHUNKWIDTH/BYTECHUNKWIDTH SO IF ADDING ANYTHING OTHER THAN +1 ON THIS LOOP ITERATOR, IT WILL BREAK PROBABLY. SO JUST DON'T CHANGE THE MAIN LOOP AND IT SHOULD BE FINE, INSTEAD IF YOU WANT TO CHANGE THE POSITION, DO IT SO FROM THE VECTOR somechunkmeshpos. STEVE CHASSÉ AKA NINEKORN AKA NINE AKA 9 - 2021-AUGUST-18 NOTES
                                                        someinstancepostest = someinstancepostest + (somevecx * (x * somevoxelvirtualdesktopglobals.tinyChunkWidth * somevoxelvirtualdesktopglobals.planeSize));
                                                        someinstancepostest = someinstancepostest + (somevecy * (y * somevoxelvirtualdesktopglobals.tinyChunkWidth * somevoxelvirtualdesktopglobals.planeSize));
                                                        someinstancepostest = someinstancepostest + (somevecz * (z * somevoxelvirtualdesktopglobals.tinyChunkWidth * somevoxelvirtualdesktopglobals.planeSize));
                                                        //WARNING - USING THE SAME LOOP AS THE CHUNK CREATION IS DANGEROUS SINCE THIS MAIN LOOP X/Y/Z IS FOR THE ENTIRE POSITION SETUP AND NOT THE TINYCHUNKWIDTH/BYTECHUNKWIDTH SO IF ADDING ANYTHING OTHER THAN +1 ON THIS LOOP ITERATOR, IT WILL BREAK PROBABLY. SO JUST DON'T CHANGE THE MAIN LOOP AND IT SHOULD BE FINE, INSTEAD IF YOU WANT TO CHANGE THE POSITION, DO IT SO FROM THE VECTOR somechunkmeshpos. STEVE CHASSÉ AKA NINEKORN AKA NINE AKA 9 - 2021-AUGUST-18 NOTES
                                                        //WARNING - USING THE SAME LOOP AS THE CHUNK CREATION IS DANGEROUS SINCE THIS MAIN LOOP X/Y/Z IS FOR THE ENTIRE POSITION SETUP AND NOT THE TINYCHUNKWIDTH/BYTECHUNKWIDTH SO IF ADDING ANYTHING OTHER THAN +1 ON THIS LOOP ITERATOR, IT WILL BREAK PROBABLY. SO JUST DON'T CHANGE THE MAIN LOOP AND IT SHOULD BE FINE, INSTEAD IF YOU WANT TO CHANGE THE POSITION, DO IT SO FROM THE VECTOR somechunkmeshpos. STEVE CHASSÉ AKA NINEKORN AKA NINE AKA 9 - 2021-AUGUST-18 NOTES
                                                        //WARNING - USING THE SAME LOOP AS THE CHUNK CREATION IS DANGEROUS SINCE THIS MAIN LOOP X/Y/Z IS FOR THE ENTIRE POSITION SETUP AND NOT THE TINYCHUNKWIDTH/BYTECHUNKWIDTH SO IF ADDING ANYTHING OTHER THAN +1 ON THIS LOOP ITERATOR, IT WILL BREAK PROBABLY. SO JUST DON'T CHANGE THE MAIN LOOP AND IT SHOULD BE FINE, INSTEAD IF YOU WANT TO CHANGE THE POSITION, DO IT SO FROM THE VECTOR somechunkmeshpos. STEVE CHASSÉ AKA NINEKORN AKA NINE AKA 9 - 2021-AUGUST-18 NOTES

                                                        someinitmat.M41 = someinstancepostest.X;
                                                        someinitmat.M42 = someinstancepostest.Y;
                                                        someinitmat.M43 = someinstancepostest.Z;

                                                        somevoxelvirtualdesktop[somevoxelindex].worldmatofobj = someinitmat;

                                                        somevoxelvirtualdesktop[somevoxelindex].lightBufferInstChunk[0] = new SC_instancedChunkPrim.DLightBufferEr()
                                                        {
                                                            ambientColor = ambientColor,
                                                            diffuseColor = diffuseColour,
                                                            lightDirection = dirLight,
                                                            padding0 = 0,
                                                            lightPosition = lightpos,
                                                            padding1 = 100
                                                        };

                                                        somevoxelvirtualdesktop[somevoxelindex].arrayOfMatrixBuff[0] = new SC_instancedChunkPrim.DMatrixBuffer()
                                                        {
                                                            world = Matrix.Identity,
                                                            view = Matrix.Identity,
                                                            proj = Matrix.Identity,
                                                        };


                                                        somevoxelvirtualdesktop[somevoxelindex].somechunk = null;
                                                        somevoxelvirtualdesktop[somevoxelindex].sccstrigvertbuilder = null;

                                                    }
                                                }
                                            }
                                            //VOXEL VIRTUAL DESKTOP
                                            //VOXEL VIRTUAL DESKTOP
                                            //VOXEL VIRTUAL DESKTOP







                                            /*
                                            //VOXEL VIRTUAL DESKTOP GRID
                                            //VOXEL VIRTUAL DESKTOP GRID
                                            //VOXEL VIRTUAL DESKTOP GRID
                                            somevoxelvirtualdesktopglobalsgrid = new SC_GlobalsVoxelInstancing();

                                            somevoxelvirtualdesktopglobalsgrid.planeSize = somevoxelvirtualdesktopglobals.planeSize * 1.0001f; // * 10
                                            somevoxelvirtualdesktopglobalsgrid.tinyChunkWidth = somevoxelvirtualdesktopglobals.tinyChunkWidth;
                                            somevoxelvirtualdesktopglobalsgrid.tinyChunkHeight = somevoxelvirtualdesktopglobals.tinyChunkHeight;
                                            somevoxelvirtualdesktopglobalsgrid.tinyChunkDepth = somevoxelvirtualdesktopglobals.tinyChunkDepth;
                                            somevoxelvirtualdesktopglobalsgrid.numberOfInstancesPerObjectInWidth = somevoxelvirtualdesktopglobals.numberOfInstancesPerObjectInWidth;
                                            somevoxelvirtualdesktopglobalsgrid.numberOfInstancesPerObjectInHeight = somevoxelvirtualdesktopglobals.numberOfInstancesPerObjectInHeight;
                                            somevoxelvirtualdesktopglobalsgrid.numberOfInstancesPerObjectInDepth = somevoxelvirtualdesktopglobals.numberOfInstancesPerObjectInDepth;
                                            somevoxelvirtualdesktopglobalsgrid.numberOfObjectInWidth = somevoxelvirtualdesktopglobals.numberOfObjectInWidth;
                                            somevoxelvirtualdesktopglobalsgrid.numberOfObjectInHeight = somevoxelvirtualdesktopglobals.numberOfObjectInHeight;
                                            somevoxelvirtualdesktopglobalsgrid.numberOfObjectInDepth = somevoxelvirtualdesktopglobals.numberOfObjectInDepth;

                                            /*
                                            somevoxelvirtualdesktopglobalsgrid.planeSize = somevoxelvirtualdesktopglobals.planeSize * 1.0001f; // * 10
                                            somevoxelvirtualdesktopglobalsgrid.tinyChunkWidth = somevoxelvirtualdesktopglobals.tinyChunkWidth;
                                            somevoxelvirtualdesktopglobalsgrid.tinyChunkHeight = somevoxelvirtualdesktopglobals.tinyChunkHeight;
                                            somevoxelvirtualdesktopglobalsgrid.tinyChunkDepth = somevoxelvirtualdesktopglobals.tinyChunkDepth;
                                            somevoxelvirtualdesktopglobalsgrid.numberOfInstancesPerObjectInWidth = 1;
                                            somevoxelvirtualdesktopglobalsgrid.numberOfInstancesPerObjectInHeight = 1;
                                            somevoxelvirtualdesktopglobalsgrid.numberOfInstancesPerObjectInDepth = 1;
                                            somevoxelvirtualdesktopglobalsgrid.numberOfObjectInWidth = 1;
                                            somevoxelvirtualdesktopglobalsgrid.numberOfObjectInHeight = 1;
                                            somevoxelvirtualdesktopglobalsgrid.numberOfObjectInDepth = 1;


                                            somevoxelvirtualdesktopgrid = new SC_instancedChunkPrim[somevoxelvirtualdesktopgridw * somevoxelvirtualdesktopgridh * somevoxelvirtualdesktopgridd];

                                            //Vector3 originkeyboardposition = new Vector3(0, 0.5f, 15);
                                            //Vector3 originsomechunksceneposition = new Vector3(0, 0, 0);

                                            pitch = (float)(Math.PI * (0) / 180.0f);
                                            yaw = (float)(Math.PI * (0) / 180.0f);
                                            roll = (float)(Math.PI * (0) / 180.0f);

                                            somematrixrot = somematrixrot;// SharpDX.Matrix.RotationYawPitchRoll(yaw, pitch, roll);
                                            //somematrixrot = Matrix.Identity;

                                            //Vector3 originkeyboardposition = new Vector3(0, 0.5f, 15);
                                            //Vector3 originkeyboardposition = new Vector3(0, 0, 0);
                                            //Vector3 originkeyboardposition = new Vector3(-0.4f, 0.4f, 0.4f);
                                            Vector3 originvirtualdesktopgridpos = originvirtualdesktoppos;// new Vector3(-1, 1, -1);

                                            for (int xxx = 0; xxx < somevoxelvirtualdesktopgridw; xxx++)
                                            {
                                                for (int yyy = 0; yyy < somevoxelvirtualdesktopgridh; yyy++)
                                                {
                                                    for (int zzz = 0; zzz < somevoxelvirtualdesktopgridd; zzz++)
                                                    {
                                                        int somevoxelindex = xxx + somevoxelvirtualdesktopgridw * (yyy + somevoxelvirtualdesktopgridh * zzz);

                                                        //Vector3 somechunkpriminstancepos = new Vector3(xxx, yyy, zzz) * SC_Globals.numberOfInstancesPerObjectInWidth * SC_Globals.numberOfObjectInWidth * SC_Globals.tinyChunkWidth * SC_Globals.planeSize*4;
                                                        Vector3 somevoxelposition = new Vector3(xxx, yyy, zzz);

                                                        somevoxelposition.X *= somevoxelvirtualdesktopglobalsgrid.numberOfInstancesPerObjectInWidth * somevoxelvirtualdesktopglobalsgrid.numberOfObjectInWidth * somevoxelvirtualdesktopglobalsgrid.tinyChunkWidth * somevoxelvirtualdesktopglobalsgrid.planeSize;
                                                        somevoxelposition.Y *= somevoxelvirtualdesktopglobalsgrid.numberOfInstancesPerObjectInHeight * somevoxelvirtualdesktopglobalsgrid.numberOfObjectInHeight * somevoxelvirtualdesktopglobalsgrid.tinyChunkHeight * somevoxelvirtualdesktopglobalsgrid.planeSize;
                                                        somevoxelposition.Z *= somevoxelvirtualdesktopglobalsgrid.numberOfInstancesPerObjectInDepth * somevoxelvirtualdesktopglobalsgrid.numberOfObjectInDepth * somevoxelvirtualdesktopglobalsgrid.tinyChunkDepth * somevoxelvirtualdesktopglobalsgrid.planeSize;

                                                        somevoxelposition += originvirtualdesktopgridpos;

                                                        //somevoxelposition.X += somevoxelvirtualdesktop[somevoxelindex].worldmatofobj.M41;
                                                        //somevoxelposition.Y += somevoxelvirtualdesktop[somevoxelindex].worldmatofobj.M42;
                                                        //somevoxelposition.Z += somevoxelvirtualdesktop[somevoxelindex].worldmatofobj.M43;

                                                        float tempwidth = 0.1f;
                                                        float tempheight = 0.1f;
                                                        somematrixrot.M41 = somevoxelposition.X;
                                                        somematrixrot.M42 = somevoxelposition.Y;
                                                        somematrixrot.M43 = somevoxelposition.Z;
                                                        //benchmarking and instancing chunked virtual desktops.
                                                        //benchmarking and instancing chunked virtual desktops.
                                                        //benchmarking and instancing chunked virtual desktops.
                                                        somevoxelvirtualdesktopgrid[somevoxelindex] = new SC_instancedChunkPrim();
                                                        somevoxelvirtualdesktopgrid[somevoxelindex].createChunk(SC_console_directx.D3D, tempwidth, tempheight, new Vector3(0, 10, 0), new Vector3(0, -1, 0), somevoxelposition, somevoxelindex, 0, 100, _jitter_world, false, SC_console_directx.BodyTag.physicsinstancedvertexbindingchunk, somevoxelroomgridw, somevoxelroomgridh, somevoxelroomgridd, somevoxelvirtualdesktopglobalsgrid.numberOfObjectInWidth, somevoxelvirtualdesktopglobalsgrid.numberOfObjectInHeight, somevoxelvirtualdesktopglobalsgrid.numberOfObjectInDepth, somevoxelvirtualdesktopglobalsgrid.numberOfInstancesPerObjectInWidth, somevoxelvirtualdesktopglobalsgrid.numberOfInstancesPerObjectInHeight, somevoxelvirtualdesktopglobalsgrid.numberOfInstancesPerObjectInDepth, somevoxelvirtualdesktopglobalsgrid.tinyChunkWidth, somevoxelvirtualdesktopglobalsgrid.tinyChunkHeight, somevoxelvirtualdesktopglobalsgrid.tinyChunkDepth, somevoxelvirtualdesktopglobalsgrid.planeSize, 0, 1.0f, 1, 0, somevoxelindex, 1, somematrixrot, 1, xxx, yyy, zzz);
                                                        //benchmarking and instancing chunked virtual desktops.
                                                        //benchmarking and instancing chunked virtual desktops.
                                                        //benchmarking and instancing chunked virtual desktops.

                                                        Matrix someinitmat = somevoxelvirtualdesktopgrid[somevoxelindex].worldmatofobj;
                                                        Quaternion somedirquat;
                                                        Quaternion.RotationMatrix(ref someinitmat, out somedirquat);

                                                        var dirInstanceRight = sc_maths._newgetdirleft(somedirquat);
                                                        var dirInstanceUp = sc_maths._newgetdirup(somedirquat);
                                                        var dirInstanceForward = sc_maths._newgetdirforward(somedirquat);

                                                        //position = position - (new Vector4(dirInstanceRight.X, dirInstanceRight.Y, dirInstanceRight.Z, 1.0f) * (tinyChunkWidth * planeSize * 0.5f));
                                                        //position = position - (new Vector4(dirInstanceUp.X, dirInstanceUp.Y, dirInstanceUp.Z, 1.0f) * (tinyChunkWidth * planeSize * 0.5f));
                                                        //position = position + (new Vector4(dirInstanceForward.X, dirInstanceForward.Y, dirInstanceForward.Z, 1.0f) * (tinyChunkWidth * planeSize * 0.5f));

                                                        Vector4 somevecx = new Vector4(dirInstanceRight.X, dirInstanceRight.Y, dirInstanceRight.Z, 1.0f);
                                                        Vector4 somevecy = new Vector4(dirInstanceUp.X, dirInstanceUp.Y, dirInstanceUp.Z, 1.0f);
                                                        Vector4 somevecz = new Vector4(dirInstanceForward.X, dirInstanceForward.Y, dirInstanceForward.Z, 1.0f);

                                                        Vector4 somemainpos = new Vector4(someinitmat.M41, someinitmat.M42, someinitmat.M43, 1.0f);
                                                        Vector4 someinstancepostest = somemainpos;// Vector4.Zero;

                                                        //WARNING - USING THE SAME LOOP AS THE CHUNK CREATION IS DANGEROUS SINCE THIS MAIN LOOP X/Y/Z IS FOR THE ENTIRE POSITION SETUP AND NOT THE TINYCHUNKWIDTH/BYTECHUNKWIDTH SO IF ADDING ANYTHING OTHER THAN +1 ON THIS LOOP ITERATOR, IT WILL BREAK PROBABLY. SO JUST DON'T CHANGE THE MAIN LOOP AND IT SHOULD BE FINE, INSTEAD IF YOU WANT TO CHANGE THE POSITION, DO IT SO FROM THE VECTOR somechunkmeshpos. STEVE CHASSÉ AKA NINEKORN AKA NINE AKA 9 - 2021-AUGUST-18 NOTES
                                                        //WARNING - USING THE SAME LOOP AS THE CHUNK CREATION IS DANGEROUS SINCE THIS MAIN LOOP X/Y/Z IS FOR THE ENTIRE POSITION SETUP AND NOT THE TINYCHUNKWIDTH/BYTECHUNKWIDTH SO IF ADDING ANYTHING OTHER THAN +1 ON THIS LOOP ITERATOR, IT WILL BREAK PROBABLY. SO JUST DON'T CHANGE THE MAIN LOOP AND IT SHOULD BE FINE, INSTEAD IF YOU WANT TO CHANGE THE POSITION, DO IT SO FROM THE VECTOR somechunkmeshpos. STEVE CHASSÉ AKA NINEKORN AKA NINE AKA 9 - 2021-AUGUST-18 NOTES
                                                        //WARNING - USING THE SAME LOOP AS THE CHUNK CREATION IS DANGEROUS SINCE THIS MAIN LOOP X/Y/Z IS FOR THE ENTIRE POSITION SETUP AND NOT THE TINYCHUNKWIDTH/BYTECHUNKWIDTH SO IF ADDING ANYTHING OTHER THAN +1 ON THIS LOOP ITERATOR, IT WILL BREAK PROBABLY. SO JUST DON'T CHANGE THE MAIN LOOP AND IT SHOULD BE FINE, INSTEAD IF YOU WANT TO CHANGE THE POSITION, DO IT SO FROM THE VECTOR somechunkmeshpos. STEVE CHASSÉ AKA NINEKORN AKA NINE AKA 9 - 2021-AUGUST-18 NOTES
                                                        someinstancepostest = someinstancepostest + (somevecx * (x * somevoxelvirtualdesktopglobalsgrid.tinyChunkWidth * somevoxelvirtualdesktopglobalsgrid.planeSize));
                                                        someinstancepostest = someinstancepostest + (somevecy * (y * somevoxelvirtualdesktopglobalsgrid.tinyChunkWidth * somevoxelvirtualdesktopglobalsgrid.planeSize));
                                                        someinstancepostest = someinstancepostest + (somevecz * (z * somevoxelvirtualdesktopglobalsgrid.tinyChunkWidth * somevoxelvirtualdesktopglobalsgrid.planeSize));
                                                        //WARNING - USING THE SAME LOOP AS THE CHUNK CREATION IS DANGEROUS SINCE THIS MAIN LOOP X/Y/Z IS FOR THE ENTIRE POSITION SETUP AND NOT THE TINYCHUNKWIDTH/BYTECHUNKWIDTH SO IF ADDING ANYTHING OTHER THAN +1 ON THIS LOOP ITERATOR, IT WILL BREAK PROBABLY. SO JUST DON'T CHANGE THE MAIN LOOP AND IT SHOULD BE FINE, INSTEAD IF YOU WANT TO CHANGE THE POSITION, DO IT SO FROM THE VECTOR somechunkmeshpos. STEVE CHASSÉ AKA NINEKORN AKA NINE AKA 9 - 2021-AUGUST-18 NOTES
                                                        //WARNING - USING THE SAME LOOP AS THE CHUNK CREATION IS DANGEROUS SINCE THIS MAIN LOOP X/Y/Z IS FOR THE ENTIRE POSITION SETUP AND NOT THE TINYCHUNKWIDTH/BYTECHUNKWIDTH SO IF ADDING ANYTHING OTHER THAN +1 ON THIS LOOP ITERATOR, IT WILL BREAK PROBABLY. SO JUST DON'T CHANGE THE MAIN LOOP AND IT SHOULD BE FINE, INSTEAD IF YOU WANT TO CHANGE THE POSITION, DO IT SO FROM THE VECTOR somechunkmeshpos. STEVE CHASSÉ AKA NINEKORN AKA NINE AKA 9 - 2021-AUGUST-18 NOTES
                                                        //WARNING - USING THE SAME LOOP AS THE CHUNK CREATION IS DANGEROUS SINCE THIS MAIN LOOP X/Y/Z IS FOR THE ENTIRE POSITION SETUP AND NOT THE TINYCHUNKWIDTH/BYTECHUNKWIDTH SO IF ADDING ANYTHING OTHER THAN +1 ON THIS LOOP ITERATOR, IT WILL BREAK PROBABLY. SO JUST DON'T CHANGE THE MAIN LOOP AND IT SHOULD BE FINE, INSTEAD IF YOU WANT TO CHANGE THE POSITION, DO IT SO FROM THE VECTOR somechunkmeshpos. STEVE CHASSÉ AKA NINEKORN AKA NINE AKA 9 - 2021-AUGUST-18 NOTES

                                                        someinitmat.M41 = someinstancepostest.X;
                                                        someinitmat.M42 = someinstancepostest.Y;
                                                        someinitmat.M43 = someinstancepostest.Z;

                                                        somevoxelvirtualdesktopgrid[somevoxelindex].worldmatofobj = someinitmat;

                                                        somevoxelvirtualdesktopgrid[somevoxelindex].lightBufferInstChunk[0] = new SC_instancedChunkPrim.DLightBufferEr()
                                                        {
                                                            ambientColor = ambientColor,
                                                            diffuseColor = diffuseColour,
                                                            lightDirection = dirLight,
                                                            padding0 = 0,
                                                            lightPosition = lightpos,
                                                            padding1 = 100
                                                        };

                                                        somevoxelvirtualdesktopgrid[somevoxelindex].arrayOfMatrixBuff[0] = new SC_instancedChunkPrim.DMatrixBuffer()
                                                        {
                                                            world = Matrix.Identity,
                                                            view = Matrix.Identity,
                                                            proj = Matrix.Identity,
                                                        };
                                                    }
                                                }
                                            }*/
                                            //VOXEL VIRTUAL DESKTOP GRID
                                            //VOXEL VIRTUAL DESKTOP GRID
                                            //VOXEL VIRTUAL DESKTOP GRID











                                            //VOXEL CHUNK KEYBOARD
                                            //VOXEL CHUNK KEYBOARD
                                            //VOXEL CHUNK KEYBOARD
                                            somechunkkeyboardglobals = new SC_GlobalsVoxelInstancing();

                                            /*somechunkkeyboardglobals.planeSize = 0.005f; // * 10
                                            somechunkkeyboardglobals.tinyChunkWidth = somevoxelvirtualdesktopglobals.tinyChunkWidth;
                                            somechunkkeyboardglobals.tinyChunkHeight = somevoxelvirtualdesktopglobals.tinyChunkHeight;
                                            somechunkkeyboardglobals.tinyChunkDepth = somevoxelvirtualdesktopglobals.tinyChunkDepth;
                                            somechunkkeyboardglobals.numberOfInstancesPerObjectInWidth = somevoxelvirtualdesktopglobals.numberOfInstancesPerObjectInWidth;
                                            somechunkkeyboardglobals.numberOfInstancesPerObjectInHeight = somevoxelvirtualdesktopglobals.numberOfInstancesPerObjectInHeight;
                                            somechunkkeyboardglobals.numberOfInstancesPerObjectInDepth = somevoxelvirtualdesktopglobals.numberOfInstancesPerObjectInDepth;
                                            somechunkkeyboardglobals.numberOfObjectInWidth = somevoxelvirtualdesktopglobals.numberOfObjectInWidth;
                                            somechunkkeyboardglobals.numberOfObjectInHeight = somevoxelvirtualdesktopglobals.numberOfObjectInHeight;
                                            somechunkkeyboardglobals.numberOfObjectInDepth = somevoxelvirtualdesktopglobals.numberOfObjectInDepth;
                                            */
                                            somechunkkeyboardglobals.planeSize = 0.005f; // * 10
                                            somechunkkeyboardglobals.tinyChunkWidth = 4;
                                            somechunkkeyboardglobals.tinyChunkHeight = 4;
                                            somechunkkeyboardglobals.tinyChunkDepth = 4;
                                            somechunkkeyboardglobals.numberOfInstancesPerObjectInWidth = 21;
                                            somechunkkeyboardglobals.numberOfInstancesPerObjectInHeight = 6;
                                            somechunkkeyboardglobals.numberOfInstancesPerObjectInDepth = 1;
                                            somechunkkeyboardglobals.numberOfObjectInWidth = 1;
                                            somechunkkeyboardglobals.numberOfObjectInHeight = 1;
                                            somechunkkeyboardglobals.numberOfObjectInDepth = 1;


                                            somechunkkeyboard = new SC_instancedChunkPrim[somechunkkeyboardw * somechunkkeyboardh * somechunkkeyboardd];

                                            //Vector3 originkeyboardposition = new Vector3(0, 0.5f, 15);
                                            //Vector3 originsomechunksceneposition = new Vector3(0, 0, 0);


                                            float somewidthOfObjectx = somevoxelvirtualdesktopglobals.numberOfInstancesPerObjectInWidth * somevoxelvirtualdesktopglobals.numberOfObjectInWidth * somevoxelvirtualdesktopglobals.tinyChunkWidth * somevoxelvirtualdesktopglobals.planeSize * 0.5f;
                                            float somewidthOfObjecty = somevoxelvirtualdesktopglobals.numberOfInstancesPerObjectInHeight * somevoxelvirtualdesktopglobals.numberOfObjectInHeight * somevoxelvirtualdesktopglobals.tinyChunkHeight * somevoxelvirtualdesktopglobals.planeSize * 0.5f;
                                            float somewidthOfObjectz = somevoxelvirtualdesktopglobals.numberOfInstancesPerObjectInDepth * somevoxelvirtualdesktopglobals.numberOfObjectInHeight * somevoxelvirtualdesktopglobals.tinyChunkDepth * somevoxelvirtualdesktopglobals.planeSize * 0.5f;
                                            Vector3 somecenter = new Vector3(somewidthOfObjectx, somewidthOfObjecty, somewidthOfObjectz);

                                            //finalHMDMatrix = hmd_matrix_current * finalRotationMatrix;
                                            //Quaternion.RotationMatrix(ref finalHMDMatrix, out otherQuat);
                                            //direction_head_forward = sc_maths._getDirection(Vector3.ForwardRH, otherQuat);
                                            //direction_head_right = sc_maths._getDirection(Vector3.Right, otherQuat);
                                            //direction_head_up = sc_maths._getDirection(Vector3.Up, otherQuat);
                                            //var theheadrotmatrix = Matrix.LookAtRH(pivotOfHead, pivotOfHead + direction_head_right, direction_head_up);
                                            //theheadrotmatrix.Invert();
                                            //matrixerer = theheadrotmatrix;


                                            //sc_maths.makeRotationDir();
                                            /*Vector3 somerightvec = Vector3.ForwardRH;
                                            Vector3 someupvec = Vector3.Up;
                                            somematrixrot = Matrix.LookAtRH(somecenter, somecenter + somerightvec, someupvec);*/
                                            /*Matrix3x3 somematrix = Matrix3x3.Identity;
                                            Quaternion otherQuat = Quaternion.Identity;

                                            Quaternion.RotationMatrix(ref somematrix, out otherQuat);                         
                                            var direction_head_forward = sc_maths._getDirection(Vector3.ForwardRH, otherQuat);
                                            var direction_head_right = sc_maths._getDirection(Vector3.Right, otherQuat);
                                            var direction_head_up = sc_maths._getDirection(Vector3.Up, otherQuat);*/



                                            /*
                                            Vector3 sometranslationvector = Vector3.Zero;
                                            Quaternion otherQuat1;
                                            Quaternion.RotationLookAtRH(ref direction_head_forward,ref direction_head_up,out otherQuat1);
                                            sc_maths.AffineTransformation(1.0f,ref somecenter, ref otherQuat1,ref sometranslationvector, out somematrixrot,1, xxx,yyy,zzz);
                                            */

                                            //Vector3 somerotaxis = Vector3.Up;
                                            //SharpDX.Matrix.RotationAxis(ref somerotaxis, 180, out somematrixrot,1, xxx,yyy,zzz);
                                            pitch = sc_maths.DegreeToRadian(0);// (float)(Math.PI * (0) / 180.0f);
                                            yaw = sc_maths.DegreeToRadian(180);//(float)(Math.PI * (180) / 180.0f);
                                            roll = sc_maths.DegreeToRadian(0);// (float)(Math.PI * (0) / 180.0f);

                                            somematrixrot = SharpDX.Matrix.RotationYawPitchRoll(yaw, pitch, roll);
                                            //somematrixrot = Matrix.Identity;

                                            Vector3 originchunkpplayerkeyboard = new Vector3(1, 0, 0);// originvirtualdesktoppos; //new Vector3(0, 0, 4) + 
                                            //Vector3 originchunkpplayerkeyboard = new Vector3(0, 0, 0);
                                            //Vector3 originchunkpplayerkeyboard = new Vector3(-0.4f, 0.4f, 0.4f);
                                            //Vector3 originchunkpplayerkeyboard = new Vector3(somevoxelvirtualdesktopglobalsgrid.numberOfInstancesPerObjectInWidth * somevoxelvirtualdesktopglobalsgrid.numberOfObjectInWidth * somevoxelvirtualdesktopglobalsgrid.tinyChunkWidth * somevoxelvirtualdesktopglobalsgrid.planeSize * 0.5f, 0.25f, somevoxelvirtualdesktopglobalsgrid.numberOfInstancesPerObjectInDepth * somevoxelvirtualdesktopglobalsgrid.numberOfObjectInDepth * somevoxelvirtualdesktopglobalsgrid.tinyChunkDepth * somevoxelvirtualdesktopglobalsgrid.planeSize * 9f) + originvirtualdesktoppos;

                                            for (int xxx = 0; xxx < somechunkkeyboardw; xxx++)
                                            {
                                                for (int yyy = 0; yyy < somechunkkeyboardh; yyy++)
                                                {
                                                    for (int zzz = 0; zzz < somechunkkeyboardd; zzz++)
                                                    {
                                                        int somevoxelindex = xxx + somechunkkeyboardw * (yyy + somechunkkeyboardh * zzz);

                                                        //Vector3 somechunkpriminstancepos = new Vector3(xxx, yyy, zzz) * SC_Globals.numberOfInstancesPerObjectInWidth * SC_Globals.numberOfObjectInWidth * SC_Globals.tinyChunkWidth * SC_Globals.planeSize*4;
                                                        Vector3 somevoxelposition = new Vector3(xxx, yyy, zzz);

                                                        somevoxelposition.X *= somechunkkeyboardglobals.numberOfInstancesPerObjectInWidth * somechunkkeyboardglobals.numberOfObjectInWidth * somechunkkeyboardglobals.tinyChunkWidth * somechunkkeyboardglobals.planeSize;
                                                        somevoxelposition.Y *= somechunkkeyboardglobals.numberOfInstancesPerObjectInHeight * somechunkkeyboardglobals.numberOfObjectInHeight * somechunkkeyboardglobals.tinyChunkHeight * somechunkkeyboardglobals.planeSize;
                                                        somevoxelposition.Z *= somechunkkeyboardglobals.numberOfInstancesPerObjectInDepth * somechunkkeyboardglobals.numberOfObjectInDepth * somechunkkeyboardglobals.tinyChunkDepth * somechunkkeyboardglobals.planeSize;

                                                        somevoxelposition += originchunkpplayerkeyboard;

                                                        somevoxelposition.X += somechunkkeyboardglobals.numberOfInstancesPerObjectInWidth * somechunkkeyboardglobals.numberOfObjectInWidth * somechunkkeyboardglobals.tinyChunkWidth * somechunkkeyboardglobals.planeSize * 0.5f;
                                                        somevoxelposition.Y += somechunkkeyboardglobals.numberOfInstancesPerObjectInHeight * somechunkkeyboardglobals.numberOfObjectInHeight * somechunkkeyboardglobals.tinyChunkHeight * somechunkkeyboardglobals.planeSize * 0.5f;
                                                        //somevoxelposition.Z -= somechunkkeyboardglobals.numberOfInstancesPerObjectInDepth * somechunkkeyboardglobals.numberOfObjectInDepth * somechunkkeyboardglobals.tinyChunkDepth * somechunkkeyboardglobals.planeSize;
                                                        //somevoxelposition.Z += somechunkkeyboardglobals.numberOfInstancesPerObjectInDepth * somechunkkeyboardglobals.numberOfObjectInDepth * somechunkkeyboardglobals.tinyChunkDepth * somechunkkeyboardglobals.planeSize * 0.5f;
                                                        somevoxelposition.Z += somechunkkeyboardglobals.numberOfInstancesPerObjectInWidth * somechunkkeyboardglobals.numberOfObjectInDepth * somechunkkeyboardglobals.tinyChunkDepth * somechunkkeyboardglobals.planeSize * 0.5f;
                                                        somevoxelposition.Z -= somechunkkeyboardglobals.tinyChunkDepth * somechunkkeyboardglobals.planeSize * 0.5f;


                                                        /*somevoxelposition.X *= 0.5f;
                                                        somevoxelposition.Y *= 0.5f;
                                                        somevoxelposition.Z *= 0.5f;*/

                                                        //somevoxelposition.X += somevoxelvirtualdesktop[somevoxelindex].worldmatofobj.M41;
                                                        //somevoxelposition.Y += somevoxelvirtualdesktop[somevoxelindex].worldmatofobj.M42;
                                                        //somevoxelposition.Z += somevoxelvirtualdesktop[somevoxelindex].worldmatofobj.M43;

                                                        float tempwidth = 0.1f;
                                                        float tempheight = 0.1f;
                                                        somematrixrot.M41 = somevoxelposition.X;
                                                        somematrixrot.M42 = somevoxelposition.Y;
                                                        somematrixrot.M43 = somevoxelposition.Z;
                                                        //benchmarking and instancing chunked virtual desktops.
                                                        //benchmarking and instancing chunked virtual desktops.
                                                        //benchmarking and instancing chunked virtual desktops.
                                                        somechunkkeyboard[somevoxelindex] = new SC_instancedChunkPrim();
                                                        somechunkkeyboard[somevoxelindex].createChunk(SC_console_directx.D3D, tempwidth, tempheight, new Vector3(0, 10, 0), new Vector3(0, -1, 0), somevoxelposition, somevoxelindex, 0, 100, _jitter_world, false, SC_console_directx.BodyTag.physicsinstancedvertexbindingchunk, somevoxelroomgridw, somevoxelroomgridh, somevoxelroomgridd, somechunkkeyboardglobals.numberOfObjectInWidth, somechunkkeyboardglobals.numberOfObjectInHeight, somechunkkeyboardglobals.numberOfObjectInDepth, somechunkkeyboardglobals.numberOfInstancesPerObjectInWidth, somechunkkeyboardglobals.numberOfInstancesPerObjectInHeight, somechunkkeyboardglobals.numberOfInstancesPerObjectInDepth, somechunkkeyboardglobals.tinyChunkWidth, somechunkkeyboardglobals.tinyChunkHeight, somechunkkeyboardglobals.tinyChunkDepth, somechunkkeyboardglobals.planeSize, 0, 1.0f, 1, 0, somevoxelindex, 0, somematrixrot, 1, xxx, yyy, zzz);
                                                        //somevoxelvirtualdesktop[somevoxelindex].createChunk(SC_console_directx.D3D, tempwidth, tempheight, new Vector3(0, 10, 0), new Vector3(0, -1, 0), somevoxelposition, somevoxelindex, 0, 100, _jitter_world, false, SC_console_directx.BodyTag.physicsinstancedvertexbindingchunk, somevoxelroomgridw,somevoxelroomgridh,somevoxelroomgridd,somevoxelvirtualdesktopglobals.numberOfObjectInWidth, somevoxelvirtualdesktopglobals.numberOfObjectInHeight, somevoxelvirtualdesktopglobals.numberOfObjectInDepth, somevoxelvirtualdesktopglobals.numberOfInstancesPerObjectInWidth, somevoxelvirtualdesktopglobals.numberOfInstancesPerObjectInHeight, somevoxelvirtualdesktopglobals.numberOfInstancesPerObjectInDepth, somevoxelvirtualdesktopglobals.tinyChunkWidth, somevoxelvirtualdesktopglobals.tinyChunkHeight, somevoxelvirtualdesktopglobals.tinyChunkDepth, somevoxelvirtualdesktopglobals.planeSize, 0, 1.0f, 1, 0, somevoxelindex, 0, somematrixrot,1, xxx,yyy,zzz);

                                                        //benchmarking and instancing chunked virtual desktops.
                                                        //benchmarking and instancing chunked virtual desktops.
                                                        //benchmarking and instancing chunked virtual desktops.

                                                        Matrix someinitmat = somechunkkeyboard[somevoxelindex].worldmatofobj;
                                                        Quaternion somedirquat;
                                                        Quaternion.RotationMatrix(ref someinitmat, out somedirquat);

                                                        var dirInstanceRight = sc_maths._newgetdirleft(somedirquat);
                                                        var dirInstanceUp = sc_maths._newgetdirup(somedirquat);
                                                        var dirInstanceForward = sc_maths._newgetdirforward(somedirquat);

                                                        //position = position - (new Vector4(dirInstanceRight.X, dirInstanceRight.Y, dirInstanceRight.Z, 1.0f) * (tinyChunkWidth * planeSize * 0.5f));
                                                        //position = position - (new Vector4(dirInstanceUp.X, dirInstanceUp.Y, dirInstanceUp.Z, 1.0f) * (tinyChunkWidth * planeSize * 0.5f));
                                                        //position = position + (new Vector4(dirInstanceForward.X, dirInstanceForward.Y, dirInstanceForward.Z, 1.0f) * (tinyChunkWidth * planeSize * 0.5f));

                                                        Vector4 somevecx = new Vector4(dirInstanceRight.X, dirInstanceRight.Y, dirInstanceRight.Z, 1.0f);
                                                        Vector4 somevecy = new Vector4(dirInstanceUp.X, dirInstanceUp.Y, dirInstanceUp.Z, 1.0f);
                                                        Vector4 somevecz = new Vector4(dirInstanceForward.X, dirInstanceForward.Y, dirInstanceForward.Z, 1.0f);

                                                        Vector4 somemainpos = new Vector4(someinitmat.M41, someinitmat.M42, someinitmat.M43, 1.0f);
                                                        Vector4 someinstancepostest = somemainpos;// Vector4.Zero;

                                                        //WARNING - USING THE SAME LOOP AS THE CHUNK CREATION IS DANGEROUS SINCE THIS MAIN LOOP X/Y/Z IS FOR THE ENTIRE POSITION SETUP AND NOT THE TINYCHUNKWIDTH/BYTECHUNKWIDTH SO IF ADDING ANYTHING OTHER THAN +1 ON THIS LOOP ITERATOR, IT WILL BREAK PROBABLY. SO JUST DON'T CHANGE THE MAIN LOOP AND IT SHOULD BE FINE, INSTEAD IF YOU WANT TO CHANGE THE POSITION, DO IT SO FROM THE VECTOR somechunkmeshpos. STEVE CHASSÉ AKA NINEKORN AKA NINE AKA 9 - 2021-AUGUST-18 NOTES
                                                        //WARNING - USING THE SAME LOOP AS THE CHUNK CREATION IS DANGEROUS SINCE THIS MAIN LOOP X/Y/Z IS FOR THE ENTIRE POSITION SETUP AND NOT THE TINYCHUNKWIDTH/BYTECHUNKWIDTH SO IF ADDING ANYTHING OTHER THAN +1 ON THIS LOOP ITERATOR, IT WILL BREAK PROBABLY. SO JUST DON'T CHANGE THE MAIN LOOP AND IT SHOULD BE FINE, INSTEAD IF YOU WANT TO CHANGE THE POSITION, DO IT SO FROM THE VECTOR somechunkmeshpos. STEVE CHASSÉ AKA NINEKORN AKA NINE AKA 9 - 2021-AUGUST-18 NOTES
                                                        //WARNING - USING THE SAME LOOP AS THE CHUNK CREATION IS DANGEROUS SINCE THIS MAIN LOOP X/Y/Z IS FOR THE ENTIRE POSITION SETUP AND NOT THE TINYCHUNKWIDTH/BYTECHUNKWIDTH SO IF ADDING ANYTHING OTHER THAN +1 ON THIS LOOP ITERATOR, IT WILL BREAK PROBABLY. SO JUST DON'T CHANGE THE MAIN LOOP AND IT SHOULD BE FINE, INSTEAD IF YOU WANT TO CHANGE THE POSITION, DO IT SO FROM THE VECTOR somechunkmeshpos. STEVE CHASSÉ AKA NINEKORN AKA NINE AKA 9 - 2021-AUGUST-18 NOTES
                                                        someinstancepostest = someinstancepostest + (somevecx * (x * somechunkkeyboardglobals.tinyChunkWidth * somechunkkeyboardglobals.planeSize));
                                                        someinstancepostest = someinstancepostest + (somevecy * (y * somechunkkeyboardglobals.tinyChunkWidth * somechunkkeyboardglobals.planeSize));
                                                        someinstancepostest = someinstancepostest + (somevecz * (z * somechunkkeyboardglobals.tinyChunkWidth * somechunkkeyboardglobals.planeSize));
                                                        //WARNING - USING THE SAME LOOP AS THE CHUNK CREATION IS DANGEROUS SINCE THIS MAIN LOOP X/Y/Z IS FOR THE ENTIRE POSITION SETUP AND NOT THE TINYCHUNKWIDTH/BYTECHUNKWIDTH SO IF ADDING ANYTHING OTHER THAN +1 ON THIS LOOP ITERATOR, IT WILL BREAK PROBABLY. SO JUST DON'T CHANGE THE MAIN LOOP AND IT SHOULD BE FINE, INSTEAD IF YOU WANT TO CHANGE THE POSITION, DO IT SO FROM THE VECTOR somechunkmeshpos. STEVE CHASSÉ AKA NINEKORN AKA NINE AKA 9 - 2021-AUGUST-18 NOTES
                                                        //WARNING - USING THE SAME LOOP AS THE CHUNK CREATION IS DANGEROUS SINCE THIS MAIN LOOP X/Y/Z IS FOR THE ENTIRE POSITION SETUP AND NOT THE TINYCHUNKWIDTH/BYTECHUNKWIDTH SO IF ADDING ANYTHING OTHER THAN +1 ON THIS LOOP ITERATOR, IT WILL BREAK PROBABLY. SO JUST DON'T CHANGE THE MAIN LOOP AND IT SHOULD BE FINE, INSTEAD IF YOU WANT TO CHANGE THE POSITION, DO IT SO FROM THE VECTOR somechunkmeshpos. STEVE CHASSÉ AKA NINEKORN AKA NINE AKA 9 - 2021-AUGUST-18 NOTES
                                                        //WARNING - USING THE SAME LOOP AS THE CHUNK CREATION IS DANGEROUS SINCE THIS MAIN LOOP X/Y/Z IS FOR THE ENTIRE POSITION SETUP AND NOT THE TINYCHUNKWIDTH/BYTECHUNKWIDTH SO IF ADDING ANYTHING OTHER THAN +1 ON THIS LOOP ITERATOR, IT WILL BREAK PROBABLY. SO JUST DON'T CHANGE THE MAIN LOOP AND IT SHOULD BE FINE, INSTEAD IF YOU WANT TO CHANGE THE POSITION, DO IT SO FROM THE VECTOR somechunkmeshpos. STEVE CHASSÉ AKA NINEKORN AKA NINE AKA 9 - 2021-AUGUST-18 NOTES

                                                        someinitmat.M41 = someinstancepostest.X;
                                                        someinitmat.M42 = someinstancepostest.Y;
                                                        someinitmat.M43 = someinstancepostest.Z;

                                                        somechunkkeyboard[somevoxelindex].worldmatofobj = someinitmat;

                                                        somechunkkeyboard[somevoxelindex].lightBufferInstChunk[0] = new SC_instancedChunkPrim.DLightBufferEr()
                                                        {
                                                            ambientColor = ambientColor,
                                                            diffuseColor = diffuseColour,
                                                            lightDirection = dirLight,
                                                            padding0 = 0,
                                                            lightPosition = lightpos,
                                                            padding1 = 100
                                                        };

                                                        somechunkkeyboard[somevoxelindex].arrayOfMatrixBuff[0] = new SC_instancedChunkPrim.DMatrixBuffer()
                                                        {
                                                            world = Matrix.Identity,
                                                            view = Matrix.Identity,
                                                            proj = Matrix.Identity,
                                                        };
                                                    }
                                                }
                                            }
                                            //VOXEL CHUNK KEYBOARD
                                            //VOXEL CHUNK KEYBOARD
                                            //VOXEL CHUNK KEYBOARD







                                            /*
                                            //VOXEL CHUNK KEYBOARD GRID
                                            //VOXEL CHUNK KEYBOARD GRID
                                            //VOXEL CHUNK KEYBOARD GRID
                                            somechunkkeyboardglobalsgrid = new SC_GlobalsVoxelInstancing();

                                            /*somechunkkeyboardglobalsgrid.planeSize = somechunkkeyboardglobals.planeSize * 1.00001f; // * 10
                                            somechunkkeyboardglobalsgrid.tinyChunkWidth = somechunkkeyboardglobals.tinyChunkWidth;
                                            somechunkkeyboardglobalsgrid.tinyChunkHeight = somechunkkeyboardglobals.tinyChunkHeight;
                                            somechunkkeyboardglobalsgrid.tinyChunkDepth = somechunkkeyboardglobals.tinyChunkDepth;
                                            somechunkkeyboardglobalsgrid.numberOfInstancesPerObjectInWidth = somechunkkeyboardglobals.numberOfInstancesPerObjectInWidth;
                                            somechunkkeyboardglobalsgrid.numberOfInstancesPerObjectInHeight = somechunkkeyboardglobals.numberOfInstancesPerObjectInHeight;
                                            somechunkkeyboardglobalsgrid.numberOfInstancesPerObjectInDepth = somechunkkeyboardglobals.numberOfInstancesPerObjectInDepth;
                                            somechunkkeyboardglobalsgrid.numberOfObjectInWidth = somechunkkeyboardglobals.numberOfObjectInWidth;
                                            somechunkkeyboardglobalsgrid.numberOfObjectInHeight = somechunkkeyboardglobals.numberOfObjectInHeight;
                                            somechunkkeyboardglobalsgrid.numberOfObjectInDepth = somechunkkeyboardglobals.numberOfObjectInDepth;
                                            
                                            somechunkkeyboardglobalsgrid.planeSize = 0.005f; // * 10
                                            somechunkkeyboardglobalsgrid.tinyChunkWidth = 4;
                                            somechunkkeyboardglobalsgrid.tinyChunkHeight = 4;
                                            somechunkkeyboardglobalsgrid.tinyChunkDepth = 4;
                                            somechunkkeyboardglobalsgrid.numberOfInstancesPerObjectInWidth = 21;
                                            somechunkkeyboardglobalsgrid.numberOfInstancesPerObjectInHeight = 6;
                                            somechunkkeyboardglobalsgrid.numberOfInstancesPerObjectInDepth = 1;
                                            somechunkkeyboardglobalsgrid.numberOfObjectInWidth = 1;
                                            somechunkkeyboardglobalsgrid.numberOfObjectInHeight = 1;
                                            somechunkkeyboardglobalsgrid.numberOfObjectInDepth = 1;

                                            somechunkkeyboardgrid = new SC_instancedChunkPrim[somechunkkeyboardsgridw * somechunkkeyboardsgridh * somechunkkeyboardsgridd];

                                            //Vector3 originkeyboardposition = new Vector3(0, 0.5f, 15);
                                            //Vector3 originsomechunksceneposition = new Vector3(0, 0, 0);

                                            pitch = (float)(Math.PI * (0) / 180.0f);
                                            yaw = (float)(Math.PI * (180) / 180.0f);
                                            roll = (float)(Math.PI * (0) / 180.0f);

                                            somematrixrot = SharpDX.Matrix.RotationYawPitchRoll(yaw, pitch, roll);
                                            //somematrixrot = Matrix.Identity;
                                            /*somerightvec = Vector3.ForwardRH;
                                            someupvec = Vector3.Up;
                                            somematrixrot = Matrix.LookAtRH(somecenter, somecenter + somerightvec, someupvec);
                                            

                                            //Vector3 originkeyboardposition = new Vector3(0, 0.5f, 15);
                                            //Vector3 originkeyboardposition = new Vector3(0, 0, 0);
                                            //Vector3 originkeyboardposition = new Vector3(-0.4f, 0.4f, 0.4f);
                                            Vector3 originchunkkeyboardgridpos = originchunkpplayerkeyboard;

                                            for (int xxx = 0; xxx < somechunkkeyboardsgridw; xxx++)
                                            {
                                                for (int yyy = 0; yyy < somechunkkeyboardsgridh; yyy++)
                                                {
                                                    for (int zzz = 0; zzz < somechunkkeyboardsgridd; zzz++)
                                                    {
                                                        int somevoxelindex = xxx + somechunkkeyboardsgridw * (yyy + somechunkkeyboardsgridh * zzz);

                                                        //Vector3 somechunkpriminstancepos = new Vector3(xxx, yyy, zzz) * SC_Globals.numberOfInstancesPerObjectInWidth * SC_Globals.numberOfObjectInWidth * SC_Globals.tinyChunkWidth * SC_Globals.planeSize*4;
                                                        Vector3 somevoxelposition = new Vector3(xxx, yyy, zzz);

                                                        somevoxelposition.X *= somechunkkeyboardglobalsgrid.numberOfInstancesPerObjectInWidth * somechunkkeyboardglobalsgrid.numberOfObjectInWidth * somechunkkeyboardglobalsgrid.tinyChunkWidth * somechunkkeyboardglobalsgrid.planeSize;
                                                        somevoxelposition.Y *= somechunkkeyboardglobalsgrid.numberOfInstancesPerObjectInHeight * somechunkkeyboardglobalsgrid.numberOfObjectInHeight * somechunkkeyboardglobalsgrid.tinyChunkHeight * somechunkkeyboardglobalsgrid.planeSize;
                                                        somevoxelposition.Z *= somechunkkeyboardglobalsgrid.numberOfInstancesPerObjectInDepth * somechunkkeyboardglobalsgrid.numberOfObjectInDepth * somechunkkeyboardglobalsgrid.tinyChunkDepth * somechunkkeyboardglobalsgrid.planeSize;

                                                        /*
                                                        if (somevoxelvirtualdesktop.Length > 0)
                                                        {
                                                            somevoxelposition.X += somevoxelvirtualdesktop[somevoxelindex].worldmatofobj.M41;
                                                            somevoxelposition.Y += somevoxelvirtualdesktop[somevoxelindex].worldmatofobj.M42;
                                                            somevoxelposition.Z += somevoxelvirtualdesktop[somevoxelindex].worldmatofobj.M43;
                                                        }

                                                        somevoxelposition += originchunkpplayerkeyboard;

                                                        somevoxelposition.X += somechunkkeyboardglobals.numberOfInstancesPerObjectInWidth * somechunkkeyboardglobals.numberOfObjectInWidth * somechunkkeyboardglobals.tinyChunkWidth * somechunkkeyboardglobals.planeSize * 0.5f;
                                                        somevoxelposition.Y += somechunkkeyboardglobals.numberOfInstancesPerObjectInHeight * somechunkkeyboardglobals.numberOfObjectInHeight * somechunkkeyboardglobals.tinyChunkHeight * somechunkkeyboardglobals.planeSize * 0.5f;
                                                        //somevoxelposition.Z -= somechunkkeyboardglobals.numberOfInstancesPerObjectInDepth * somechunkkeyboardglobals.numberOfObjectInDepth * somechunkkeyboardglobals.tinyChunkDepth * somechunkkeyboardglobals.planeSize;
                                                        //somevoxelposition.Z += somechunkkeyboardglobals.numberOfInstancesPerObjectInDepth * somechunkkeyboardglobals.numberOfObjectInDepth * somechunkkeyboardglobals.tinyChunkDepth * somechunkkeyboardglobals.planeSize * 0.5f;
                                                        somevoxelposition.Z += somechunkkeyboardglobals.numberOfInstancesPerObjectInWidth * somechunkkeyboardglobals.numberOfObjectInDepth * somechunkkeyboardglobals.tinyChunkDepth * somechunkkeyboardglobals.planeSize * 0.5f;
                                                        somevoxelposition.Z -= somechunkkeyboardglobals.tinyChunkDepth * somechunkkeyboardglobals.planeSize * 0.5f;





                                                        float tempwidth = 0.1f;
                                                        float tempheight = 0.1f;
                                                        somematrixrot.M41 = somevoxelposition.X;
                                                        somematrixrot.M42 = somevoxelposition.Y;
                                                        somematrixrot.M43 = somevoxelposition.Z;
                                                        //benchmarking and instancing chunked virtual desktops.
                                                        //benchmarking and instancing chunked virtual desktops.
                                                        //benchmarking and instancing chunked virtual desktops.
                                                        somechunkkeyboardgrid[somevoxelindex] = new SC_instancedChunkPrim();
                                                        somechunkkeyboardgrid[somevoxelindex].createChunk(SC_console_directx.D3D, tempwidth, tempheight, new Vector3(0, 10, 0), new Vector3(0, -1, 0), somevoxelposition, somevoxelindex, 0, 100, _jitter_world, false, SC_console_directx.BodyTag.physicsinstancedvertexbindingchunk, somevoxelroomgridw, somevoxelroomgridh, somevoxelroomgridd, somechunkkeyboardglobalsgrid.numberOfObjectInWidth, somechunkkeyboardglobalsgrid.numberOfObjectInHeight, somechunkkeyboardglobalsgrid.numberOfObjectInDepth, somechunkkeyboardglobalsgrid.numberOfInstancesPerObjectInWidth, somechunkkeyboardglobalsgrid.numberOfInstancesPerObjectInHeight, somechunkkeyboardglobalsgrid.numberOfInstancesPerObjectInDepth, somechunkkeyboardglobalsgrid.tinyChunkWidth, somechunkkeyboardglobalsgrid.tinyChunkHeight, somechunkkeyboardglobalsgrid.tinyChunkDepth, somechunkkeyboardglobalsgrid.planeSize, 0, 1.0f, 1, 0, somevoxelindex, 1, somematrixrot, 1, xxx, yyy, zzz);
                                                        //benchmarking and instancing chunked virtual desktops.
                                                        //benchmarking and instancing chunked virtual desktops.
                                                        //benchmarking and instancing chunked virtual desktops.



                                                        Matrix someinitmat = somechunkkeyboardgrid[somevoxelindex].worldmatofobj;
                                                        Quaternion somedirquat;
                                                        Quaternion.RotationMatrix(ref someinitmat, out somedirquat);

                                                        var dirInstanceRight = sc_maths._newgetdirleft(somedirquat);
                                                        var dirInstanceUp = sc_maths._newgetdirup(somedirquat);
                                                        var dirInstanceForward = sc_maths._newgetdirforward(somedirquat);

                                                        //position = position - (new Vector4(dirInstanceRight.X, dirInstanceRight.Y, dirInstanceRight.Z, 1.0f) * (tinyChunkWidth * planeSize * 0.5f));
                                                        //position = position - (new Vector4(dirInstanceUp.X, dirInstanceUp.Y, dirInstanceUp.Z, 1.0f) * (tinyChunkWidth * planeSize * 0.5f));
                                                        //position = position + (new Vector4(dirInstanceForward.X, dirInstanceForward.Y, dirInstanceForward.Z, 1.0f) * (tinyChunkWidth * planeSize * 0.5f));

                                                        Vector4 somevecx = new Vector4(dirInstanceRight.X, dirInstanceRight.Y, dirInstanceRight.Z, 1.0f);
                                                        Vector4 somevecy = new Vector4(dirInstanceUp.X, dirInstanceUp.Y, dirInstanceUp.Z, 1.0f);
                                                        Vector4 somevecz = new Vector4(dirInstanceForward.X, dirInstanceForward.Y, dirInstanceForward.Z, 1.0f);

                                                        Vector4 somemainpos = new Vector4(someinitmat.M41, someinitmat.M42, someinitmat.M43, 1.0f);
                                                        Vector4 someinstancepostest = somemainpos;// Vector4.Zero;

                                                        //WARNING - USING THE SAME LOOP AS THE CHUNK CREATION IS DANGEROUS SINCE THIS MAIN LOOP X/Y/Z IS FOR THE ENTIRE POSITION SETUP AND NOT THE TINYCHUNKWIDTH/BYTECHUNKWIDTH SO IF ADDING ANYTHING OTHER THAN +1 ON THIS LOOP ITERATOR, IT WILL BREAK PROBABLY. SO JUST DON'T CHANGE THE MAIN LOOP AND IT SHOULD BE FINE, INSTEAD IF YOU WANT TO CHANGE THE POSITION, DO IT SO FROM THE VECTOR somechunkmeshpos. STEVE CHASSÉ AKA NINEKORN AKA NINE AKA 9 - 2021-AUGUST-18 NOTES
                                                        //WARNING - USING THE SAME LOOP AS THE CHUNK CREATION IS DANGEROUS SINCE THIS MAIN LOOP X/Y/Z IS FOR THE ENTIRE POSITION SETUP AND NOT THE TINYCHUNKWIDTH/BYTECHUNKWIDTH SO IF ADDING ANYTHING OTHER THAN +1 ON THIS LOOP ITERATOR, IT WILL BREAK PROBABLY. SO JUST DON'T CHANGE THE MAIN LOOP AND IT SHOULD BE FINE, INSTEAD IF YOU WANT TO CHANGE THE POSITION, DO IT SO FROM THE VECTOR somechunkmeshpos. STEVE CHASSÉ AKA NINEKORN AKA NINE AKA 9 - 2021-AUGUST-18 NOTES
                                                        //WARNING - USING THE SAME LOOP AS THE CHUNK CREATION IS DANGEROUS SINCE THIS MAIN LOOP X/Y/Z IS FOR THE ENTIRE POSITION SETUP AND NOT THE TINYCHUNKWIDTH/BYTECHUNKWIDTH SO IF ADDING ANYTHING OTHER THAN +1 ON THIS LOOP ITERATOR, IT WILL BREAK PROBABLY. SO JUST DON'T CHANGE THE MAIN LOOP AND IT SHOULD BE FINE, INSTEAD IF YOU WANT TO CHANGE THE POSITION, DO IT SO FROM THE VECTOR somechunkmeshpos. STEVE CHASSÉ AKA NINEKORN AKA NINE AKA 9 - 2021-AUGUST-18 NOTES
                                                        someinstancepostest = someinstancepostest + (somevecx * (x * somechunkkeyboardglobalsgrid.tinyChunkWidth * somechunkkeyboardglobalsgrid.planeSize));
                                                        someinstancepostest = someinstancepostest + (somevecy * (y * somechunkkeyboardglobalsgrid.tinyChunkWidth * somechunkkeyboardglobalsgrid.planeSize));
                                                        someinstancepostest = someinstancepostest + (somevecz * (z * somechunkkeyboardglobalsgrid.tinyChunkWidth * somechunkkeyboardglobalsgrid.planeSize));
                                                        //WARNING - USING THE SAME LOOP AS THE CHUNK CREATION IS DANGEROUS SINCE THIS MAIN LOOP X/Y/Z IS FOR THE ENTIRE POSITION SETUP AND NOT THE TINYCHUNKWIDTH/BYTECHUNKWIDTH SO IF ADDING ANYTHING OTHER THAN +1 ON THIS LOOP ITERATOR, IT WILL BREAK PROBABLY. SO JUST DON'T CHANGE THE MAIN LOOP AND IT SHOULD BE FINE, INSTEAD IF YOU WANT TO CHANGE THE POSITION, DO IT SO FROM THE VECTOR somechunkmeshpos. STEVE CHASSÉ AKA NINEKORN AKA NINE AKA 9 - 2021-AUGUST-18 NOTES
                                                        //WARNING - USING THE SAME LOOP AS THE CHUNK CREATION IS DANGEROUS SINCE THIS MAIN LOOP X/Y/Z IS FOR THE ENTIRE POSITION SETUP AND NOT THE TINYCHUNKWIDTH/BYTECHUNKWIDTH SO IF ADDING ANYTHING OTHER THAN +1 ON THIS LOOP ITERATOR, IT WILL BREAK PROBABLY. SO JUST DON'T CHANGE THE MAIN LOOP AND IT SHOULD BE FINE, INSTEAD IF YOU WANT TO CHANGE THE POSITION, DO IT SO FROM THE VECTOR somechunkmeshpos. STEVE CHASSÉ AKA NINEKORN AKA NINE AKA 9 - 2021-AUGUST-18 NOTES
                                                        //WARNING - USING THE SAME LOOP AS THE CHUNK CREATION IS DANGEROUS SINCE THIS MAIN LOOP X/Y/Z IS FOR THE ENTIRE POSITION SETUP AND NOT THE TINYCHUNKWIDTH/BYTECHUNKWIDTH SO IF ADDING ANYTHING OTHER THAN +1 ON THIS LOOP ITERATOR, IT WILL BREAK PROBABLY. SO JUST DON'T CHANGE THE MAIN LOOP AND IT SHOULD BE FINE, INSTEAD IF YOU WANT TO CHANGE THE POSITION, DO IT SO FROM THE VECTOR somechunkmeshpos. STEVE CHASSÉ AKA NINEKORN AKA NINE AKA 9 - 2021-AUGUST-18 NOTES

                                                        someinitmat.M41 = someinstancepostest.X;
                                                        someinitmat.M42 = someinstancepostest.Y;
                                                        someinitmat.M43 = someinstancepostest.Z;

                                                        somechunkkeyboardgrid[somevoxelindex].worldmatofobj = someinitmat;


                                                        somechunkkeyboardgrid[somevoxelindex].lightBufferInstChunk[0] = new SC_instancedChunkPrim.DLightBufferEr()
                                                        {
                                                            ambientColor = ambientColor,
                                                            diffuseColor = diffuseColour,
                                                            lightDirection = dirLight,
                                                            padding0 = 0,
                                                            lightPosition = lightpos,
                                                            padding1 = 100
                                                        };

                                                        somechunkkeyboardgrid[somevoxelindex].arrayOfMatrixBuff[0] = new SC_instancedChunkPrim.DMatrixBuffer()
                                                        {
                                                            world = Matrix.Identity,
                                                            view = Matrix.Identity,
                                                            proj = Matrix.Identity,
                                                        };
                                                    }
                                                }
                                            }*/
                                            //VOXEL CHUNK KEYBOARD GRID
                                            //VOXEL CHUNK KEYBOARD GRID
                                            //VOXEL CHUNK KEYBOARD GRID









































                                            /*

                                            someglobalschunkmesh = new SC_GlobalsVoxelInstancing();
                                            someglobalschunkmeshgrid = new SC_GlobalsVoxelInstancing();
                                            someglobalsplayerspatiallocation = new SC_GlobalsVoxelInstancing();
                                            somechunkkeyboardglobals = new SC_GlobalsVoxelInstancing();
                                            somechunkkeyboardglobalsgrid = new SC_GlobalsVoxelInstancing();

                                            */





                                            /*
                                            int somechunkkeyboardw = 1;
                                            int somechunkkeyboardh = 1;
                                            int somechunkkeyboardd = 1;
                                            SC_instancedChunkPrim[] somechunkkeyboard;

                                            int somechunkkeyboardsgridw = 1;
                                            int somechunkkeyboardsgridh = 1;
                                            int somechunkkeyboardsgridd = 1;
                                            SC_instancedChunkPrim[] somechunkkeyboardgrid;

                                            int somechunkplayerspatiallocationscenesw = 1;
                                            int somechunkplayerspatiallocationscenesh = 1;
                                            int somechunkplayerspatiallocationscenesd = 1;
                                            SC_instancedChunkPrim[] somechunkplayerspatiallocationscene;

                                            SC_GlobalsVoxelInstancing someglobalschunkmesh;
                                            SC_GlobalsVoxelInstancing someglobalschunkmeshgrid;
                                            SC_GlobalsVoxelInstancing someglobalsplayerspatiallocation;
                                            SC_GlobalsVoxelInstancing somechunkkeyboardglobals;
                                            SC_GlobalsVoxelInstancing somechunkkeyboardglobalsgrid;
                                            */
































                                            /*
                                            //VOXEL ROOM
                                            //VOXEL ROOM
                                            //VOXEL ROOM
                                            somevoxelroomglobals = new SC_GlobalsVoxelInstancing();

                                            somevoxelroomglobals.planeSize = 0.05f; // * 10
                                            somevoxelroomglobals.tinyChunkWidth = 4;
                                            somevoxelroomglobals.tinyChunkHeight = 4;
                                            somevoxelroomglobals.tinyChunkDepth = 4;
                                            somevoxelroomglobals.numberOfInstancesPerObjectInWidth = 4;
                                            somevoxelroomglobals.numberOfInstancesPerObjectInHeight = 4;
                                            somevoxelroomglobals.numberOfInstancesPerObjectInDepth = 4;
                                            somevoxelroomglobals.numberOfObjectInWidth = 1;
                                            somevoxelroomglobals.numberOfObjectInHeight = 1;
                                            somevoxelroomglobals.numberOfObjectInDepth = 1;

                                            somevoxelroom = new SC_instancedChunkPrim[somevoxelroomw * somevoxelroomh * somevoxelroomd];

                                            //Vector3 originvirtualdesktoppos = new Vector3(0, 0.5f, 15);
                                            //Vector3 originsomechunksceneposition = new Vector3(0, 0, 0);

                                             pitch = (float)(Math.PI * (0) / 180.0f);
                                             yaw = (float)(Math.PI * (0) / 180.0f);
                                             roll = (float)(Math.PI * (0) / 180.0f);

                                             somematrixrot = SharpDX.Matrix.RotationYawPitchRoll(yaw, pitch, roll);
                                            //somematrixrot = Matrix.Identity;

                                            //Vector3 originvirtualdesktoppos = new Vector3(0, 0.5f, 15);
                                            Vector3 originvoxelroomposition = new Vector3(5, 0, 0);
                                            //Vector3 originvirtualdesktoppos = new Vector3(-0.4f, 0.4f, 0.4f);
                                            //Vector3 originvirtualdesktoppos = new Vector3(1.333333f * somevoxelroomglobals.numberOfInstancesPerObjectInWidth * somevoxelroomglobals.numberOfObjectInWidth * somevoxelroomglobals.tinyChunkWidth * somevoxelroomglobals.planeSize, 0, 5); // somevoxelroomglobals.numberOfInstancesPerObjectInDepth * somevoxelroomglobals.numberOfObjectInDepth * somevoxelroomglobals.tinyChunkDepth * somevoxelroomglobals.planeSize * 10
                                            //Vector3 originvirtualdesktoppos = new Vector3(-1 * 1.25f * somevoxelroomglobals.numberOfInstancesPerObjectInWidth * somevoxelroomglobals.numberOfObjectInWidth * somevoxelroomglobals.tinyChunkWidth * somevoxelroomglobals.planeSize, 1, somevoxelroomglobals.numberOfInstancesPerObjectInDepth * somevoxelroomglobals.numberOfObjectInDepth * somevoxelroomglobals.tinyChunkDepth * somevoxelroomglobals.planeSize * 10f);

                                            for (int xxx = 0; xxx < somevoxelroomw; xxx++)
                                            {
                                                for (int yyy = 0; yyy < somevoxelroomh; yyy++)
                                                {
                                                    for (int zzz = 0; zzz < somevoxelroomd; zzz++)
                                                    {
                                                        int somevoxelindex = xxx + somevoxelroomw * (yyy + somevoxelroomh * zzz);

                                                        //Vector3 somechunkpriminstancepos = new Vector3(xxx, yyy, zzz) * SC_Globals.numberOfInstancesPerObjectInWidth * SC_Globals.numberOfObjectInWidth * SC_Globals.tinyChunkWidth * SC_Globals.planeSize*4;
                                                        Vector3 somevoxelposition = new Vector3(xxx, yyy, zzz);

                                                        somevoxelposition.X *= somevoxelroomglobals.numberOfInstancesPerObjectInWidth * somevoxelroomglobals.numberOfObjectInWidth * somevoxelroomglobals.tinyChunkWidth * somevoxelroomglobals.planeSize;
                                                        somevoxelposition.Y *= somevoxelroomglobals.numberOfInstancesPerObjectInHeight * somevoxelroomglobals.numberOfObjectInHeight * somevoxelroomglobals.tinyChunkHeight * somevoxelroomglobals.planeSize;
                                                        somevoxelposition.Z *= somevoxelroomglobals.numberOfInstancesPerObjectInDepth * somevoxelroomglobals.numberOfObjectInDepth * somevoxelroomglobals.tinyChunkDepth * somevoxelroomglobals.planeSize;

                                                        somevoxelposition += originvoxelroomposition;

                                                        float tempwidth = 0.1f;
                                                        float tempheight = 0.1f;

                                                        somematrixrot.M41 = somevoxelposition.X;
                                                        somematrixrot.M42 = somevoxelposition.Y;
                                                        somematrixrot.M43 = somevoxelposition.Z;

                                                        //benchmarking and instancing chunked virtual desktops.
                                                        //benchmarking and instancing chunked virtual desktops.
                                                        //benchmarking and instancing chunked virtual desktops.
                                                        somevoxelroom[somevoxelindex] = new SC_instancedChunkPrim();
                                                        somevoxelroom[somevoxelindex].createChunk(SC_console_directx.D3D, tempwidth, tempheight, new Vector3(0, 10, 0), new Vector3(0, -1, 0), somevoxelposition, somevoxelindex, 0, 100, _jitter_world, false, SC_console_directx.BodyTag.physicsinstancedvertexbindingchunk, somevoxelroomgridw, somevoxelroomgridh, somevoxelroomgridd, somevoxelroomglobals.numberOfObjectInWidth, somevoxelroomglobals.numberOfObjectInHeight, somevoxelroomglobals.numberOfObjectInDepth, somevoxelroomglobals.numberOfInstancesPerObjectInWidth, somevoxelroomglobals.numberOfInstancesPerObjectInHeight, somevoxelroomglobals.numberOfInstancesPerObjectInDepth, somevoxelroomglobals.tinyChunkWidth, somevoxelroomglobals.tinyChunkHeight, somevoxelroomglobals.tinyChunkDepth, somevoxelroomglobals.planeSize, 0, 1.0f, 1, 0, somevoxelindex, 0, somematrixrot, 2, xxx, yyy, zzz);
                                                        //benchmarking and instancing chunked virtual desktops.
                                                        //benchmarking and instancing chunked virtual desktops.
                                                        //benchmarking and instancing chunked virtual desktops.

                                                        Matrix someinitmat = somevoxelroom[somevoxelindex].worldmatofobj;
                                                        Quaternion somedirquat;
                                                        Quaternion.RotationMatrix(ref someinitmat, out somedirquat);

                                                        var dirInstanceRight = sc_maths._newgetdirleft(somedirquat);
                                                        var dirInstanceUp = sc_maths._newgetdirup(somedirquat);
                                                        var dirInstanceForward = sc_maths._newgetdirforward(somedirquat);

                                                        //position = position - (new Vector4(dirInstanceRight.X, dirInstanceRight.Y, dirInstanceRight.Z, 1.0f) * (tinyChunkWidth * planeSize * 0.5f));
                                                        //position = position - (new Vector4(dirInstanceUp.X, dirInstanceUp.Y, dirInstanceUp.Z, 1.0f) * (tinyChunkWidth * planeSize * 0.5f));
                                                        //position = position + (new Vector4(dirInstanceForward.X, dirInstanceForward.Y, dirInstanceForward.Z, 1.0f) * (tinyChunkWidth * planeSize * 0.5f));

                                                        Vector4 somevecx = new Vector4(dirInstanceRight.X, dirInstanceRight.Y, dirInstanceRight.Z, 1.0f);
                                                        Vector4 somevecy = new Vector4(dirInstanceUp.X, dirInstanceUp.Y, dirInstanceUp.Z, 1.0f);
                                                        Vector4 somevecz = new Vector4(dirInstanceForward.X, dirInstanceForward.Y, dirInstanceForward.Z, 1.0f);

                                                        Vector4 somemainpos = new Vector4(someinitmat.M41, someinitmat.M42, someinitmat.M43, 1.0f);
                                                        Vector4 someinstancepostest = somemainpos;// Vector4.Zero;

                                                        //WARNING - USING THE SAME LOOP AS THE CHUNK CREATION IS DANGEROUS SINCE THIS MAIN LOOP X/Y/Z IS FOR THE ENTIRE POSITION SETUP AND NOT THE TINYCHUNKWIDTH/BYTECHUNKWIDTH SO IF ADDING ANYTHING OTHER THAN +1 ON THIS LOOP ITERATOR, IT WILL BREAK PROBABLY. SO JUST DON'T CHANGE THE MAIN LOOP AND IT SHOULD BE FINE, INSTEAD IF YOU WANT TO CHANGE THE POSITION, DO IT SO FROM THE VECTOR somechunkmeshpos. STEVE CHASSÉ AKA NINEKORN AKA NINE AKA 9 - 2021-AUGUST-18 NOTES
                                                        //WARNING - USING THE SAME LOOP AS THE CHUNK CREATION IS DANGEROUS SINCE THIS MAIN LOOP X/Y/Z IS FOR THE ENTIRE POSITION SETUP AND NOT THE TINYCHUNKWIDTH/BYTECHUNKWIDTH SO IF ADDING ANYTHING OTHER THAN +1 ON THIS LOOP ITERATOR, IT WILL BREAK PROBABLY. SO JUST DON'T CHANGE THE MAIN LOOP AND IT SHOULD BE FINE, INSTEAD IF YOU WANT TO CHANGE THE POSITION, DO IT SO FROM THE VECTOR somechunkmeshpos. STEVE CHASSÉ AKA NINEKORN AKA NINE AKA 9 - 2021-AUGUST-18 NOTES
                                                        //WARNING - USING THE SAME LOOP AS THE CHUNK CREATION IS DANGEROUS SINCE THIS MAIN LOOP X/Y/Z IS FOR THE ENTIRE POSITION SETUP AND NOT THE TINYCHUNKWIDTH/BYTECHUNKWIDTH SO IF ADDING ANYTHING OTHER THAN +1 ON THIS LOOP ITERATOR, IT WILL BREAK PROBABLY. SO JUST DON'T CHANGE THE MAIN LOOP AND IT SHOULD BE FINE, INSTEAD IF YOU WANT TO CHANGE THE POSITION, DO IT SO FROM THE VECTOR somechunkmeshpos. STEVE CHASSÉ AKA NINEKORN AKA NINE AKA 9 - 2021-AUGUST-18 NOTES
                                                        someinstancepostest = someinstancepostest + (somevecx * (x * somevoxelroomglobals.tinyChunkWidth * somevoxelroomglobals.planeSize));
                                                        someinstancepostest = someinstancepostest + (somevecy * (y * somevoxelroomglobals.tinyChunkWidth * somevoxelroomglobals.planeSize));
                                                        someinstancepostest = someinstancepostest + (somevecz * (z * somevoxelroomglobals.tinyChunkWidth * somevoxelroomglobals.planeSize));
                                                        //WARNING - USING THE SAME LOOP AS THE CHUNK CREATION IS DANGEROUS SINCE THIS MAIN LOOP X/Y/Z IS FOR THE ENTIRE POSITION SETUP AND NOT THE TINYCHUNKWIDTH/BYTECHUNKWIDTH SO IF ADDING ANYTHING OTHER THAN +1 ON THIS LOOP ITERATOR, IT WILL BREAK PROBABLY. SO JUST DON'T CHANGE THE MAIN LOOP AND IT SHOULD BE FINE, INSTEAD IF YOU WANT TO CHANGE THE POSITION, DO IT SO FROM THE VECTOR somechunkmeshpos. STEVE CHASSÉ AKA NINEKORN AKA NINE AKA 9 - 2021-AUGUST-18 NOTES
                                                        //WARNING - USING THE SAME LOOP AS THE CHUNK CREATION IS DANGEROUS SINCE THIS MAIN LOOP X/Y/Z IS FOR THE ENTIRE POSITION SETUP AND NOT THE TINYCHUNKWIDTH/BYTECHUNKWIDTH SO IF ADDING ANYTHING OTHER THAN +1 ON THIS LOOP ITERATOR, IT WILL BREAK PROBABLY. SO JUST DON'T CHANGE THE MAIN LOOP AND IT SHOULD BE FINE, INSTEAD IF YOU WANT TO CHANGE THE POSITION, DO IT SO FROM THE VECTOR somechunkmeshpos. STEVE CHASSÉ AKA NINEKORN AKA NINE AKA 9 - 2021-AUGUST-18 NOTES
                                                        //WARNING - USING THE SAME LOOP AS THE CHUNK CREATION IS DANGEROUS SINCE THIS MAIN LOOP X/Y/Z IS FOR THE ENTIRE POSITION SETUP AND NOT THE TINYCHUNKWIDTH/BYTECHUNKWIDTH SO IF ADDING ANYTHING OTHER THAN +1 ON THIS LOOP ITERATOR, IT WILL BREAK PROBABLY. SO JUST DON'T CHANGE THE MAIN LOOP AND IT SHOULD BE FINE, INSTEAD IF YOU WANT TO CHANGE THE POSITION, DO IT SO FROM THE VECTOR somechunkmeshpos. STEVE CHASSÉ AKA NINEKORN AKA NINE AKA 9 - 2021-AUGUST-18 NOTES

                                                        someinitmat.M41 = someinstancepostest.X;
                                                        someinitmat.M42 = someinstancepostest.Y;
                                                        someinitmat.M43 = someinstancepostest.Z;

                                                        somevoxelroom[somevoxelindex].worldmatofobj = someinitmat;

                                                        somevoxelroom[somevoxelindex].lightBufferInstChunk[0] = new SC_instancedChunkPrim.DLightBufferEr()
                                                        {
                                                            ambientColor = ambientColor,
                                                            diffuseColor = diffuseColour,
                                                            lightDirection = dirLight,
                                                            padding0 = 0,
                                                            lightPosition = lightpos,
                                                            padding1 = 100
                                                        };

                                                        somevoxelroom[somevoxelindex].arrayOfMatrixBuff[0] = new SC_instancedChunkPrim.DMatrixBuffer()
                                                        {
                                                            world = Matrix.Identity,
                                                            view = Matrix.Identity,
                                                            proj = Matrix.Identity,
                                                        };
                                                    }
                                                }
                                            }
                                            */
                                            //VOXEL ROOM
                                            //VOXEL ROOM
                                            //VOXEL ROOM







                                            /*
                                            //VOXEL ROOM GRID
                                            //VOXEL ROOM GRID
                                            //VOXEL ROOM GRID
                                            somevoxelroomgridglobals = new SC_GlobalsVoxelInstancing();

                                            /*somevoxelroomgridglobals.planeSize = 0.05f; // * 10
                                            somevoxelroomgridglobals.tinyChunkWidth = 4;
                                            somevoxelroomgridglobals.tinyChunkHeight = 4;
                                            somevoxelroomgridglobals.tinyChunkDepth = 4;
                                            somevoxelroomgridglobals.numberOfInstancesPerObjectInWidth = 20;
                                            somevoxelroomgridglobals.numberOfInstancesPerObjectInHeight = 10;
                                            somevoxelroomgridglobals.numberOfInstancesPerObjectInDepth = 1;
                                            somevoxelroomgridglobals.numberOfObjectInWidth = 1;
                                            somevoxelroomgridglobals.numberOfObjectInHeight = 1;
                                            somevoxelroomgridglobals.numberOfObjectInDepth = 1;

                                            somechunkkeyboardglobalsgrid.planeSize = 0.05f; // * 10
                                            somechunkkeyboardglobalsgrid.tinyChunkWidth = somechunkkeyboardglobals.tinyChunkWidth;
                                            somechunkkeyboardglobalsgrid.tinyChunkHeight = somechunkkeyboardglobals.tinyChunkHeight;
                                            somechunkkeyboardglobalsgrid.tinyChunkDepth = somechunkkeyboardglobals.tinyChunkDepth;
                                            somechunkkeyboardglobalsgrid.numberOfInstancesPerObjectInWidth = somechunkkeyboardglobals.numberOfInstancesPerObjectInWidth;
                                            somechunkkeyboardglobalsgrid.numberOfInstancesPerObjectInHeight = somechunkkeyboardglobals.numberOfInstancesPerObjectInHeight;
                                            somechunkkeyboardglobalsgrid.numberOfInstancesPerObjectInDepth = somechunkkeyboardglobals.numberOfInstancesPerObjectInDepth;
                                            somechunkkeyboardglobalsgrid.numberOfObjectInWidth = somechunkkeyboardglobals.numberOfObjectInWidth;
                                            somechunkkeyboardglobalsgrid.numberOfObjectInHeight = somechunkkeyboardglobals.numberOfObjectInHeight;
                                            somechunkkeyboardglobalsgrid.numberOfObjectInDepth = somechunkkeyboardglobals.numberOfObjectInDepth;


                                            somevoxelroomgrid = new SC_instancedChunkPrim[somevoxelroomgridw * somevoxelroomgridh * somevoxelroomgridd];

                                            //Vector3 originvirtualdesktoppos = new Vector3(0, 0.5f, 15);
                                            //Vector3 originsomechunksceneposition = new Vector3(0, 0, 0);

                                            pitch = (float)(Math.PI * (0) / 180.0f);
                                            yaw = (float)(Math.PI * (0) / 180.0f);
                                            roll = (float)(Math.PI * (0) / 180.0f);

                                            somematrixrot = SharpDX.Matrix.RotationYawPitchRoll(yaw, pitch, roll);
                                            //somematrixrot = Matrix.Identity;

                                            //Vector3 originvirtualdesktoppos = new Vector3(0, 0.5f, 15);
                                            Vector3 originvoxelroompositiongrid = originvoxelroomposition;// new Vector3(1, 1, 1);
                                            //Vector3 originvirtualdesktoppos = new Vector3(-0.4f, 0.4f, 0.4f);
                                            //Vector3 originvirtualdesktoppos = new Vector3(1.333333f * somevoxelroomgridglobals.numberOfInstancesPerObjectInWidth * somevoxelroomgridglobals.numberOfObjectInWidth * somevoxelroomgridglobals.tinyChunkWidth * somevoxelroomgridglobals.planeSize, 0, 5); // somevoxelroomgridglobals.numberOfInstancesPerObjectInDepth * somevoxelroomgridglobals.numberOfObjectInDepth * somevoxelroomgridglobals.tinyChunkDepth * somevoxelroomgridglobals.planeSize * 10
                                            //Vector3 originvirtualdesktoppos = new Vector3(-1 * 1.25f * somevoxelroomgridglobals.numberOfInstancesPerObjectInWidth * somevoxelroomgridglobals.numberOfObjectInWidth * somevoxelroomgridglobals.tinyChunkWidth * somevoxelroomgridglobals.planeSize, 1, somevoxelroomgridglobals.numberOfInstancesPerObjectInDepth * somevoxelroomgridglobals.numberOfObjectInDepth * somevoxelroomgridglobals.tinyChunkDepth * somevoxelroomgridglobals.planeSize * 10f);

                                            for (int xxx = 0; xxx < somevoxelroomgridw; xxx++)
                                            {
                                                for (int yyy = 0; yyy < somevoxelroomgridh; yyy++)
                                                {
                                                    for (int zzz = 0; zzz < somevoxelroomgridd; zzz++)
                                                    {
                                                        int somevoxelindex = xxx + somevoxelroomgridw * (yyy + somevoxelroomgridh * zzz);

                                                        //Vector3 somechunkpriminstancepos = new Vector3(xxx, yyy, zzz) * SC_Globals.numberOfInstancesPerObjectInWidth * SC_Globals.numberOfObjectInWidth * SC_Globals.tinyChunkWidth * SC_Globals.planeSize*4;
                                                        Vector3 somevoxelposition = new Vector3(xxx, yyy, zzz);

                                                        somevoxelposition.X *= somevoxelroomgridglobals.numberOfInstancesPerObjectInWidth * somevoxelroomgridglobals.numberOfObjectInWidth * somevoxelroomgridglobals.tinyChunkWidth * somevoxelroomgridglobals.planeSize;
                                                        somevoxelposition.Y *= somevoxelroomgridglobals.numberOfInstancesPerObjectInHeight * somevoxelroomgridglobals.numberOfObjectInHeight * somevoxelroomgridglobals.tinyChunkHeight * somevoxelroomgridglobals.planeSize;
                                                        somevoxelposition.Z *= somevoxelroomgridglobals.numberOfInstancesPerObjectInDepth * somevoxelroomgridglobals.numberOfObjectInDepth * somevoxelroomgridglobals.tinyChunkDepth * somevoxelroomgridglobals.planeSize;

                                                        somevoxelposition += originvoxelroompositiongrid;

                                                        float tempwidth = 0.1f;
                                                        float tempheight = 0.1f;

                                                        somematrixrot.M41 = somevoxelposition.X;
                                                        somematrixrot.M42 = somevoxelposition.Y;
                                                        somematrixrot.M43 = somevoxelposition.Z;

                                                        //benchmarking and instancing chunked virtual desktops.
                                                        //benchmarking and instancing chunked virtual desktops.
                                                        //benchmarking and instancing chunked virtual desktops.
                                                        somevoxelroomgrid[somevoxelindex] = new SC_instancedChunkPrim();
                                                        somevoxelroomgrid[somevoxelindex].createChunk(SC_console_directx.D3D, tempwidth, tempheight, new Vector3(0, 10, 0), new Vector3(0, -1, 0), somevoxelposition, somevoxelindex, 0, 100, _jitter_world, false, SC_console_directx.BodyTag.physicsinstancedvertexbindingchunk, somevoxelroomgridw, somevoxelroomgridh, somevoxelroomgridd, somevoxelroomgridglobals.numberOfObjectInWidth, somevoxelroomgridglobals.numberOfObjectInHeight, somevoxelroomgridglobals.numberOfObjectInDepth, somevoxelroomgridglobals.numberOfInstancesPerObjectInWidth, somevoxelroomgridglobals.numberOfInstancesPerObjectInHeight, somevoxelroomgridglobals.numberOfInstancesPerObjectInDepth, somevoxelroomgridglobals.tinyChunkWidth, somevoxelroomgridglobals.tinyChunkHeight, somevoxelroomgridglobals.tinyChunkDepth, somevoxelroomgridglobals.planeSize, 0, 1.0f, 1, 0, somevoxelindex, 2, somematrixrot, 1, xxx, yyy, zzz);
                                                        //benchmarking and instancing chunked virtual desktops.
                                                        //benchmarking and instancing chunked virtual desktops.
                                                        //benchmarking and instancing chunked virtual desktops.

                                                        Matrix someinitmat = somevoxelroomgrid[somevoxelindex].worldmatofobj;
                                                        Quaternion somedirquat;
                                                        Quaternion.RotationMatrix(ref someinitmat, out somedirquat);

                                                        var dirInstanceRight = sc_maths._newgetdirleft(somedirquat);
                                                        var dirInstanceUp = sc_maths._newgetdirup(somedirquat);
                                                        var dirInstanceForward = sc_maths._newgetdirforward(somedirquat);

                                                        //position = position - (new Vector4(dirInstanceRight.X, dirInstanceRight.Y, dirInstanceRight.Z, 1.0f) * (tinyChunkWidth * planeSize * 0.5f));
                                                        //position = position - (new Vector4(dirInstanceUp.X, dirInstanceUp.Y, dirInstanceUp.Z, 1.0f) * (tinyChunkWidth * planeSize * 0.5f));
                                                        //position = position + (new Vector4(dirInstanceForward.X, dirInstanceForward.Y, dirInstanceForward.Z, 1.0f) * (tinyChunkWidth * planeSize * 0.5f));

                                                        Vector4 somevecx = new Vector4(dirInstanceRight.X, dirInstanceRight.Y, dirInstanceRight.Z, 1.0f);
                                                        Vector4 somevecy = new Vector4(dirInstanceUp.X, dirInstanceUp.Y, dirInstanceUp.Z, 1.0f);
                                                        Vector4 somevecz = new Vector4(dirInstanceForward.X, dirInstanceForward.Y, dirInstanceForward.Z, 1.0f);

                                                        Vector4 somemainpos = new Vector4(someinitmat.M41, someinitmat.M42, someinitmat.M43, 1.0f);
                                                        Vector4 someinstancepostest = somemainpos;// Vector4.Zero;

                                                        //WARNING - USING THE SAME LOOP AS THE CHUNK CREATION IS DANGEROUS SINCE THIS MAIN LOOP X/Y/Z IS FOR THE ENTIRE POSITION SETUP AND NOT THE TINYCHUNKWIDTH/BYTECHUNKWIDTH SO IF ADDING ANYTHING OTHER THAN +1 ON THIS LOOP ITERATOR, IT WILL BREAK PROBABLY. SO JUST DON'T CHANGE THE MAIN LOOP AND IT SHOULD BE FINE, INSTEAD IF YOU WANT TO CHANGE THE POSITION, DO IT SO FROM THE VECTOR somechunkmeshpos. STEVE CHASSÉ AKA NINEKORN AKA NINE AKA 9 - 2021-AUGUST-18 NOTES
                                                        //WARNING - USING THE SAME LOOP AS THE CHUNK CREATION IS DANGEROUS SINCE THIS MAIN LOOP X/Y/Z IS FOR THE ENTIRE POSITION SETUP AND NOT THE TINYCHUNKWIDTH/BYTECHUNKWIDTH SO IF ADDING ANYTHING OTHER THAN +1 ON THIS LOOP ITERATOR, IT WILL BREAK PROBABLY. SO JUST DON'T CHANGE THE MAIN LOOP AND IT SHOULD BE FINE, INSTEAD IF YOU WANT TO CHANGE THE POSITION, DO IT SO FROM THE VECTOR somechunkmeshpos. STEVE CHASSÉ AKA NINEKORN AKA NINE AKA 9 - 2021-AUGUST-18 NOTES
                                                        //WARNING - USING THE SAME LOOP AS THE CHUNK CREATION IS DANGEROUS SINCE THIS MAIN LOOP X/Y/Z IS FOR THE ENTIRE POSITION SETUP AND NOT THE TINYCHUNKWIDTH/BYTECHUNKWIDTH SO IF ADDING ANYTHING OTHER THAN +1 ON THIS LOOP ITERATOR, IT WILL BREAK PROBABLY. SO JUST DON'T CHANGE THE MAIN LOOP AND IT SHOULD BE FINE, INSTEAD IF YOU WANT TO CHANGE THE POSITION, DO IT SO FROM THE VECTOR somechunkmeshpos. STEVE CHASSÉ AKA NINEKORN AKA NINE AKA 9 - 2021-AUGUST-18 NOTES
                                                        someinstancepostest = someinstancepostest + (somevecx * (x * somevoxelroomgridglobals.tinyChunkWidth * somevoxelroomgridglobals.planeSize));
                                                        someinstancepostest = someinstancepostest + (somevecy * (y * somevoxelroomgridglobals.tinyChunkWidth * somevoxelroomgridglobals.planeSize));
                                                        someinstancepostest = someinstancepostest + (somevecz * (z * somevoxelroomgridglobals.tinyChunkWidth * somevoxelroomgridglobals.planeSize));
                                                        //WARNING - USING THE SAME LOOP AS THE CHUNK CREATION IS DANGEROUS SINCE THIS MAIN LOOP X/Y/Z IS FOR THE ENTIRE POSITION SETUP AND NOT THE TINYCHUNKWIDTH/BYTECHUNKWIDTH SO IF ADDING ANYTHING OTHER THAN +1 ON THIS LOOP ITERATOR, IT WILL BREAK PROBABLY. SO JUST DON'T CHANGE THE MAIN LOOP AND IT SHOULD BE FINE, INSTEAD IF YOU WANT TO CHANGE THE POSITION, DO IT SO FROM THE VECTOR somechunkmeshpos. STEVE CHASSÉ AKA NINEKORN AKA NINE AKA 9 - 2021-AUGUST-18 NOTES
                                                        //WARNING - USING THE SAME LOOP AS THE CHUNK CREATION IS DANGEROUS SINCE THIS MAIN LOOP X/Y/Z IS FOR THE ENTIRE POSITION SETUP AND NOT THE TINYCHUNKWIDTH/BYTECHUNKWIDTH SO IF ADDING ANYTHING OTHER THAN +1 ON THIS LOOP ITERATOR, IT WILL BREAK PROBABLY. SO JUST DON'T CHANGE THE MAIN LOOP AND IT SHOULD BE FINE, INSTEAD IF YOU WANT TO CHANGE THE POSITION, DO IT SO FROM THE VECTOR somechunkmeshpos. STEVE CHASSÉ AKA NINEKORN AKA NINE AKA 9 - 2021-AUGUST-18 NOTES
                                                        //WARNING - USING THE SAME LOOP AS THE CHUNK CREATION IS DANGEROUS SINCE THIS MAIN LOOP X/Y/Z IS FOR THE ENTIRE POSITION SETUP AND NOT THE TINYCHUNKWIDTH/BYTECHUNKWIDTH SO IF ADDING ANYTHING OTHER THAN +1 ON THIS LOOP ITERATOR, IT WILL BREAK PROBABLY. SO JUST DON'T CHANGE THE MAIN LOOP AND IT SHOULD BE FINE, INSTEAD IF YOU WANT TO CHANGE THE POSITION, DO IT SO FROM THE VECTOR somechunkmeshpos. STEVE CHASSÉ AKA NINEKORN AKA NINE AKA 9 - 2021-AUGUST-18 NOTES

                                                        someinitmat.M41 = someinstancepostest.X;
                                                        someinitmat.M42 = someinstancepostest.Y;
                                                        someinitmat.M43 = someinstancepostest.Z;

                                                        somevoxelroomgrid[somevoxelindex].worldmatofobj = someinitmat;

                                                        somevoxelroomgrid[somevoxelindex].lightBufferInstChunk[0] = new SC_instancedChunkPrim.DLightBufferEr()
                                                        {
                                                            ambientColor = ambientColor,
                                                            diffuseColor = diffuseColour,
                                                            lightDirection = dirLight,
                                                            padding0 = 0,
                                                            lightPosition = lightpos,
                                                            padding1 = 100
                                                        };

                                                        somevoxelroomgrid[somevoxelindex].arrayOfMatrixBuff[0] = new SC_instancedChunkPrim.DMatrixBuffer()
                                                        {
                                                            world = Matrix.Identity,
                                                            view = Matrix.Identity,
                                                            proj = Matrix.Identity,
                                                        };
                                                    }
                                                }
                                            }
                                            */
                                            //VOXEL ROOM GRID
                                            //VOXEL ROOM GRID
                                            //VOXEL ROOM GRID




















                                            /*
                                            _human_inst_rig_x = 10;
                                            _human_inst_rig_y = 1;
                                            _human_inst_rig_z = 10;*/

                                            ikvoxelbody = new sccsikvoxellimbs[(somechunkpriminstancesikvoxelbodywidthR)];

                                            Vector3 originpositionikvoxelbody = new Vector3(0, 0, 0); //around 0.165f to 0.17f



                                            Matrix worldmatofobj = Matrix.Identity;
                                            //worldmatofobj.M41 = originpositionikvoxelbody.X;
                                            //worldmatofobj.M42 = originpositionikvoxelbody.Y;
                                            //worldmatofobj.M43 = originpositionikvoxelbody.Z;

                                            //float pelvisvaluey = -0.625f;
                                            //int realtorsowidth = 4;
                                            float ikvoxelrigbodysize = 0.1f;

                                            Vector3 somechunkpriminstanceikvoxelbodypos = Vector3.Zero;

                                            for (int xxx = 0; xxx < somechunkpriminstancesikvoxelbodywidthR; xxx++)
                                            {

                                                float posX = (xxx);
                                                float posY = (0);
                                                float posZ = (0);

                                                var xxi = xxx;
                                                var yyi = 0;
                                                var zzi = 0;

                                                if (xxi < 0)
                                                {
                                                    xxi *= -1;
                                                    xxi = (somechunkpriminstancesikvoxelbodywidthR) + xxi;
                                                }
                                                if (yyi < 0)
                                                {
                                                    yyi *= -1;
                                                    yyi = (somechunkpriminstancesikvoxelbodyheightR) + yyi;
                                                }
                                                if (zzi < 0)
                                                {
                                                    zzi *= -1;
                                                    zzi = (somechunkpriminstancesikvoxelbodydepthR) + zzi;
                                                }

                                                int somechunkpriminstanceikvoxelbodyindex = xxi;

                                                /*if (somechunkpriminstanceikvoxelbodyindex == 0)
                                                {
                                                    somechunkpriminstanceikvoxelbodypos = ((new Vector3(posX, posY, posZ)) + originpositionikvoxelbody);

                                                    somechunkpriminstanceikvoxelbodypos.X *= somechunkpriminstancesikvoxelbodywidthL * 0.25f;
                                                    somechunkpriminstanceikvoxelbodypos.Y *= somechunkpriminstancesikvoxelbodyheightL * 1;

                                                    somechunkpriminstanceikvoxelbodypos.X += (somechunkpriminstancesikvoxelbodywidthL * 0.125f);
                                                    somechunkpriminstanceikvoxelbodypos.X -= (somechunkpriminstancesikvoxelbodywidthL * 0.015625f);

                                                    //somechunkpriminstanceikvoxelbodypos.Y -= (somechunkpriminstancesikvoxelbodyheightL * 0.0625f);
                                                    //somechunkpriminstanceikvoxelbodypos.X *= 0.5f;

                                                    somechunkpriminstanceikvoxelbodypos.Y += somechunkpriminstancesikvoxelbodyheightL * 1.15f;

                                                }
                                                else if (somechunkpriminstanceikvoxelbodyindex == 1)
                                                {

                                                    somechunkpriminstanceikvoxelbodypos = ((new Vector3(posX, posY, posZ)) + originpositionikvoxelbody);

                                                    somechunkpriminstanceikvoxelbodypos.X *= somechunkpriminstancesikvoxelbodywidthL * 0.25f;
                                                    somechunkpriminstanceikvoxelbodypos.Y *= somechunkpriminstancesikvoxelbodyheightL * 1;

                                                    somechunkpriminstanceikvoxelbodypos.X += (somechunkpriminstancesikvoxelbodywidthL * 0.125f);
                                                    somechunkpriminstanceikvoxelbodypos.X -= (somechunkpriminstancesikvoxelbodywidthL * 0.015625f);

                                                    //somechunkpriminstanceikvoxelbodypos.Y -= (somechunkpriminstancesikvoxelbodyheightL * 0.0625f);
                                                    //somechunkpriminstanceikvoxelbodypos.X *= 0.5f;

                                                    somechunkpriminstanceikvoxelbodypos.Y += somechunkpriminstancesikvoxelbodyheightL * 1.15f;

                                                }
                                                else if (somechunkpriminstanceikvoxelbodyindex == 2)
                                                {

                                                    somechunkpriminstanceikvoxelbodypos = ((new Vector3(posX, posY, posZ)) + originpositionikvoxelbody);

                                                    somechunkpriminstanceikvoxelbodypos.X *= somechunkpriminstancesikvoxelbodywidthL * 0.25f;
                                                    somechunkpriminstanceikvoxelbodypos.Y *= somechunkpriminstancesikvoxelbodyheightL * 0.75f;

                                                    somechunkpriminstanceikvoxelbodypos.X += (somechunkpriminstancesikvoxelbodywidthL * 0.125f);
                                                    somechunkpriminstanceikvoxelbodypos.X -= (somechunkpriminstancesikvoxelbodywidthL * 0.015625f);

                                                    somechunkpriminstanceikvoxelbodypos.Y -= somechunkpriminstancesikvoxelbodyheightL * 0.15f;

                                                    somechunkpriminstanceikvoxelbodypos.X -= somechunkpriminstancesikvoxelbodywidthL * 0.05f;
                                                }
                                                else if (somechunkpriminstanceikvoxelbodyindex == 3)
                                                {

                                                    somechunkpriminstanceikvoxelbodypos = ((new Vector3(posX, posY, posZ)) + originpositionikvoxelbody);

                                                    somechunkpriminstanceikvoxelbodypos.X *= somechunkpriminstancesikvoxelbodywidthL * 0.25f;
                                                    somechunkpriminstanceikvoxelbodypos.Y *= somechunkpriminstancesikvoxelbodyheightL * 0.75f;

                                                    somechunkpriminstanceikvoxelbodypos.X += (somechunkpriminstancesikvoxelbodywidthL * 0.125f);
                                                    somechunkpriminstanceikvoxelbodypos.X -= (somechunkpriminstancesikvoxelbodywidthL * 0.015625f);

                                                    somechunkpriminstanceikvoxelbodypos.Y -= somechunkpriminstancesikvoxelbodyheightL * 0.15f;

                                                    somechunkpriminstanceikvoxelbodypos.X += somechunkpriminstancesikvoxelbodywidthL * 0.05f;
                                                }*/


                                                somechunkpriminstanceikvoxelbodypos = ((new Vector3(posX, posY, posZ)) + originpositionikvoxelbody);

                                                ikvoxelbody[somechunkpriminstanceikvoxelbodyindex] = new sccsikvoxellimbs();
                                                _sc_jitter_tasks = ikvoxelbody[somechunkpriminstanceikvoxelbodyindex].createikbody(_sc_jitter_tasks, tempMultiInstancePhysicsTotal, somechunkpriminstanceikvoxelbodypos, null, worldmatofobj, _human_inst_rig_x, _human_inst_rig_y, _human_inst_rig_z);







                                                /*for (int yyy = -somechunkpriminstancesikvoxelbodyheightL; yyy <= somechunkpriminstancesikvoxelbodyheightR; yyy++)
                                                {
                                                    for (int zzz = -somechunkpriminstancesikvoxelbodydepthL; zzz <= somechunkpriminstancesikvoxelbodydepthR; zzz++)
                                                    {
                                                        }
                                                }*/
                                            }








                                            //_total_torso_width = (((ChunkWidth_L + ChunkWidth_R + 1) * _sizeX * planesize * 4));// + (offsetPosX * _sizeX) * 2); //2.25f








                                            ikarmvoxel = new sccsikvoxellimbs[(somechunkpriminstancesikarmvoxelwidthR) + (somechunkpriminstancesikarmvoxelheightR)];

                                            Vector3 originpositionikarmvoxel = new Vector3(0, 0, 0);

                                            //float pelvisvaluey = -0.625f;
                                            //int realtorsowidth = 4;
                                            //float ikvoxelrigsize = 0.1f;

                                            Vector3 somechunkpriminstanceikarmvoxelpos = Vector3.Zero;

                                            for (int xxx = 0; xxx < somechunkpriminstancesikarmvoxelwidthR; xxx++)
                                            {
                                                for (int yyy = 0; yyy < somechunkpriminstancesikarmvoxelheightR; yyy++)
                                                {


                                                    float posX = (xxx);
                                                    float posY = (yyy);
                                                    float posZ = (0);

                                                    var xxi = xxx;
                                                    var yyi = yyy;
                                                    var zzi = 0;

                                                    if (xxi < 0)
                                                    {
                                                        xxi *= -1;
                                                        xxi = (somechunkpriminstancesikarmvoxelwidthR) + xxi;
                                                    }
                                                    if (yyi < 0)
                                                    {
                                                        yyi *= -1;
                                                        yyi = (somechunkpriminstancesikarmvoxelheightR) + yyi;
                                                    }
                                                    if (zzi < 0)
                                                    {
                                                        zzi *= -1;
                                                        zzi = (somechunkpriminstancesikarmvoxeldepthR) + zzi;
                                                    }

                                                    int somechunkpriminstanceikarmvoxelindex = xxi + (yyi * (somechunkpriminstancesikarmvoxelheightR));

                                                    somechunkpriminstanceikarmvoxelpos = ((new Vector3(posX, posY, posZ)) + originpositionikarmvoxel);


                                                    if (somechunkpriminstanceikarmvoxelindex == 0) // bottom left
                                                    {

                                                        somechunkpriminstanceikarmvoxelpos.X = 0;
                                                        somechunkpriminstanceikarmvoxelpos.Y = 0;
                                                        //somechunkpriminstanceikarmvoxelpos.X = xxx;
                                                        //somechunkpriminstanceikarmvoxelpos.Y = -1;


                                                        //somechunkpriminstanceikarmvoxelpos.X = //
                                                        //somechunkpriminstanceikarmvoxelpos.Y =-0.1f;
                                                        //somechunkpriminstanceikarmvoxelpos.Y *= somechunkpriminstancesikarmvoxelheightL * 2;

                                                        //somechunkpriminstanceikarmvoxelpos.X += (somechunkpriminstancesikarmvoxelwidthL * 0.125f);
                                                        //somechunkpriminstanceikarmvoxelpos.X -= (somechunkpriminstancesikarmvoxelwidthL * 0.015625f);

                                                        //somechunkpriminstanceikarmvoxelpos.Y -= (somechunkpriminstancesikarmvoxelheightL * 0.0625f);
                                                        //somechunkpriminstanceikarmvoxelpos.X *= 0.5f;

                                                        //somechunkpriminstanceikarmvoxelpos.Y += somechunkpriminstancesikarmvoxelheightL * 0.15f;

                                                    }
                                                    else if (somechunkpriminstanceikarmvoxelindex == 1) // top right
                                                    {

                                                        somechunkpriminstanceikarmvoxelpos.X = 0;
                                                        somechunkpriminstanceikarmvoxelpos.Y = 0;



                                                        //somechunkpriminstanceikarmvoxelpos.X = 0;
                                                        //somechunkpriminstanceikarmvoxelpos.Y = -0.1f;
                                                        //somechunkpriminstanceikarmvoxelpos.X *= somechunkpriminstancesikarmvoxelwidthL * 1;
                                                        //somechunkpriminstanceikarmvoxelpos.Y *= somechunkpriminstancesikarmvoxelheightL * 1;

                                                        //somechunkpriminstanceikarmvoxelpos.X += (somechunkpriminstancesikarmvoxelwidthL * 0.125f);
                                                        //somechunkpriminstanceikarmvoxelpos.X -= (somechunkpriminstancesikarmvoxelwidthL * 0.015625f);

                                                        //somechunkpriminstanceikarmvoxelpos.Y -= (somechunkpriminstancesikarmvoxelheightL * 0.0625f);
                                                        //somechunkpriminstanceikarmvoxelpos.X *= 0.5f;

                                                        //somechunkpriminstanceikarmvoxelpos.Y += somechunkpriminstancesikarmvoxelheightL * 0.15f;

                                                    }
                                                    else if (somechunkpriminstanceikarmvoxelindex == 2)
                                                    {
                                                        somechunkpriminstanceikarmvoxelpos.X = 0;
                                                        somechunkpriminstanceikarmvoxelpos.Y = 0;

                                                        //somechunkpriminstanceikarmvoxelpos = ((new Vector3(posX, posY, posZ)) + originpositionikarmvoxel);

                                                        //somechunkpriminstanceikarmvoxelpos.X = xxx;
                                                        //somechunkpriminstanceikarmvoxelpos.Y = -1;

                                                        //somechunkpriminstanceikarmvoxelpos.X -= (somechunkpriminstancesikarmvoxelwidthL * 1f);
                                                        //somechunkpriminstanceikarmvoxelpos.X -= (somechunkpriminstancesikarmvoxelwidthL * 0.015625f);

                                                        //somechunkpriminstanceikarmvoxelpos.Y -= somechunkpriminstancesikarmvoxelheightL * 0.15f;

                                                        //somechunkpriminstanceikarmvoxelpos.X -= somechunkpriminstancesikarmvoxelwidthL * 0.05f;
                                                    }
                                                    else if (somechunkpriminstanceikarmvoxelindex == 3)
                                                    {
                                                        somechunkpriminstanceikarmvoxelpos.X = 0;
                                                        somechunkpriminstanceikarmvoxelpos.Y = 0;
                                                        //somechunkpriminstanceikarmvoxelpos = ((new Vector3(posX, posY, posZ)) + originpositionikarmvoxel);

                                                        //somechunkpriminstanceikarmvoxelpos.X = xxx;

                                                        //somechunkpriminstanceikarmvoxelpos.X += (somechunkpriminstancesikarmvoxelwidthL * 1f);
                                                        //somechunkpriminstanceikarmvoxelpos.X -= (somechunkpriminstancesikarmvoxelwidthL * 0.015625f);

                                                        //somechunkpriminstanceikarmvoxelpos.Y -= somechunkpriminstancesikarmvoxelheightL * 0.15f;

                                                        //somechunkpriminstanceikarmvoxelpos.X += somechunkpriminstancesikarmvoxelwidthL * 0.05f;
                                                    }

                                                    //somechunkpriminstanceikarmvoxelpos = ((new Vector3(posX, posY, posZ)) + originpositionikarmvoxel);

                                                    ikarmvoxel[somechunkpriminstanceikarmvoxelindex] = new sccsikvoxellimbs();
                                                    _sc_jitter_tasks = ikarmvoxel[somechunkpriminstanceikarmvoxelindex].createikarm(_sc_jitter_tasks, tempMultiInstancePhysicsTotal, somechunkpriminstanceikarmvoxelpos, ikvoxelbody[0], somechunkpriminstanceikarmvoxelindex, _human_inst_rig_x, _human_inst_rig_y, _human_inst_rig_z);













                                                    for (int zzz = -somechunkpriminstancesikarmvoxeldepthL; zzz <= somechunkpriminstancesikarmvoxeldepthR; zzz++)
                                                    {
                                                    }
                                                }
                                            }








                                            _inst_voxel_cube_x = 10;
                                            _inst_voxel_cube_y = 1;
                                            _inst_voxel_cube_z = 1;

                                            offsetVoxelY = 40;
                                            //VOXELS
                                            r = 0.95f; //0.75f
                                            g = 0.35f; //0.75f
                                            b = 0.35f; //0.75f
                                            a = 1;
                                            _object_worldmatrix = Matrix.Identity;
                                            offsetPosX = _voxel_cube_size_x * (1.15f); //x between each world instance
                                            offsetPosY = _voxel_cube_size_y * (1.15f); //y between each world instance
                                            offsetPosZ = _voxel_cube_size_z * (1.15f); //z between each world instance
                                            //_offsetPos = new Vector3(0, 0, 0);
                                            _object_worldmatrix = WorldMatrix;
                                            _object_worldmatrix.M41 = 0 + x + physics_engine_offset_pos.X + world_pos_offset.X;
                                            _object_worldmatrix.M42 = 3 + y + physics_engine_offset_pos.Y + world_pos_offset.Y + offsetVoxelY;
                                            _object_worldmatrix.M43 = 0 + z + physics_engine_offset_pos.Z + world_pos_offset.Z;
                                            _object_worldmatrix.M44 = 1;
                                            var sc_voxel_spheroid = new sc_voxel();
                                            voxel_general_size = somevoxelvirtualdesktopglobals.planeSize * 0.005f; //0.0015f //0.00075f
                                            voxel_type = 1;
                                            is_static = false;
                                            _voxel_mass = 100;

                                            var _hasinit00 = sc_voxel_spheroid.Initialize(SC_console_directx.D3D, SC_console_directx.D3D.SurfaceWidth, SC_console_directx.D3D.SurfaceHeight, 0, 1, 1, 1,
                                                _voxel_cube_size_x, _voxel_cube_size_y, _voxel_cube_size_z, new Vector4(r, g, b, a), _inst_voxel_cube_x, _inst_voxel_cube_y, _inst_voxel_cube_z, SC_Update.HWND,
                                                _object_worldmatrix, 2, offsetPosX, offsetPosY, offsetPosZ, _jitter_world, _voxel_mass, is_static, SCCoreSystems.sc_console.SC_console_directx.BodyTag.sc_perko_voxel,
                                                9, 9, 9, 9, 9, 9, 9, 9, 9, 60, 60, 60, 60, 60, 60,
                                                //9, 9, 9, 9, 9, 9, 9, 9, 9, 35, 34, 40, 59, 23, 22,
                                                voxel_general_size, Vector3.Zero, 7, 0, 0, 0, 2, voxel_type); //, "terrainGrassDirt.bmp" //0.00035f
                                                                                                              //9, 9, 9, 9, 9, 9, 20, 19, 20, 19, 20, 19
                                                                                                              //9, 9, 9, 9, 9, 9, 35, 34, 40, 59, 20, 19, 
                                                                                                              //FOR CUBES AND SET TO voxel_type = 1                  
                                                                                                              //var _hasinit00 = sc_voxel_spheroid.Initialize(SC_console_directx.D3D, SC_console_directx.D3D.SurfaceWidth, SC_console_directx.D3D.SurfaceHeight, 1, 1, 1, _voxel_cube_size_x, _voxel_cube_size_y, _voxel_cube_size_z, new Vector4(r, g, b, a), _inst_voxel_cube_x, _inst_voxel_cube_y, _inst_voxel_cube_z, Hwnd, _object_worldmatrix, 2, offsetPosX, offsetPosY, offsetPosZ, World, _voxel_mass, is_static, SCCoreSystems.sc_console.SC_console_directx.BodyTag._voxel_spheroid, 2, 2, 2, 2, 2, 2, 20, 19, 20, 19, 20, 19, voxel_general_size, Vector3.Zero, 250, 0, 0, 0, 2, voxel_type); //, "terrainGrassDirt.bmp" //0.00035f                                  
                                                                                                              //FOR CUBES AND SET TO voxel_type = 1

                                            _array_of_last_frame_voxel_pos[indexer00][indexer01] = new Vector3[_inst_voxel_cube_x * _inst_voxel_cube_y * _inst_voxel_cube_z];

                                            _world_voxel_cube_lists[indexer00][indexer01] = sc_voxel_spheroid;
                                            worldMatrix_instances_voxel_cube[indexer00][indexer01] = new Matrix[_inst_voxel_cube_x * _inst_voxel_cube_y * _inst_voxel_cube_z];
                                            for (int i = 0; i < worldMatrix_instances_voxel_cube[indexer00][indexer01].Length; i++)
                                            {
                                                _array_of_last_frame_voxel_pos[indexer00][indexer01][i] = Vector3.Zero;
                                                worldMatrix_instances_voxel_cube[indexer00][indexer01][i] = Matrix.Identity;
                                            }











                                        }
                                    }
                                }
                                //END OF LOOP FOR WORLDS
                            }
                            catch
                            {

                            }
                        }
                    }
                }


                if (MainWindow.usejitterphysics == 1)
                {
                    //SETTING UP SINGLE WORLD OBJECTS
                    //END OF LOOP FOR PHYSICS ENGINE INSTANCES
                    _some_data_0 = (object)_sc_jitter_tasks[0][0]._world_data[0];
                    //World[] _jitter_worlds0 = (World[])_some_data_0;
                    _thejitter_world = (World)_some_data_0;



                }





                r = 0.10f;
                g = 0.10f;
                b = 0.10f;
                a = 1.0f;


                //////////BOTTOM FLOOR//////
                ////////////////////////////
                _inst_terrain_tile_x = 1;
                _inst_terrain_tile_y = 1;
                _inst_terrain_tile_z = 1;
                r = 0.10f;
                g = 0.10f;
                b = 0.10f;
                a = 1.0f;
                _object_worldmatrix = Matrix.Identity;
                _object_worldmatrix = WorldMatrix;
                _object_worldmatrix.M41 = 0;
                _object_worldmatrix.M42 = (-_floor_size_y) - _platform_size_y - 3;
                _object_worldmatrix.M43 = 0;
                _object_worldmatrix.M44 = 1;
                offsetPosX = 0;
                offsetPosY = 0;
                offsetPosZ = 0;
                _floor[0] = new SC_cube[1];
                _floor[0][0] = new SC_cube();
                _floor[0][0].Initialize(SC_console_directx.D3D, SC_console_directx.D3D.SurfaceWidth, SC_console_directx.D3D.SurfaceHeight, 0.05f, 1, 1, _floor_size_x, (_floor_size_y), _floor_size_z, new Vector4(r, g, b, a), _inst_terrain_tile_x, _inst_terrain_tile_y, _inst_terrain_tile_z, SC_Update.HWND, _object_worldmatrix, 0, offsetPosX, offsetPosY, offsetPosZ, _thejitter_world, SCCoreSystems.sc_console.SC_console_directx.BodyTag._floor, true, 0, 10, 0, 0, 0); //, "terrainGrassDirt.bmp" //0.00035f
                worldMatrix_instances_floor[0] = new Matrix[1][]; //MainWindow.world_width * MainWindow.world_height * MainWindow.world_depth
                worldMatrix_instances_floor[0][0] = new Matrix[1]; //_inst_terrain_tile_x * _inst_terrain_tile_y * _inst_terrain_tile_z
                for (int i = 0; i < worldMatrix_instances_floor[0][0].Length; i++)
                {
                    worldMatrix_instances_floor[0][0][i] = _floor[0][0]._arrayOfInstances[0]._POSITION;
                }
                ////////////////////////////
                //////////BOTTOM FLOOR//////
                ////////////////////////////








                //////////SPECTRUM//////////
                ////////////////////////////
                r = 0.10f;
                g = 0.10f;
                b = 0.10f;
                a = 1.0f;
                /*
                _object_worldmatrix = Matrix.Identity;

                _object_worldmatrix = WorldMatrix;

                _object_worldmatrix.M41 = 0;
                _object_worldmatrix.M42 = 0;
                _object_worldmatrix.M43 = 0;
                _object_worldmatrix.M44 = 1;

                offsetPosX = 0;
                offsetPosY = 0;
                offsetPosZ = 0;*/
                _object_worldmatrix = Matrix.Identity;
                offsetPosX = _spectrum_size_x * 1.15f; //x between each world instance
                offsetPosY = _spectrum_size_y * 1.15f; //y between each world instance
                offsetPosZ = _spectrum_size_z * 1.15f; //z between each world instance
                _object_worldmatrix = WorldMatrix;
                _object_worldmatrix.M41 = 0;// + 0 + physics_engine_offset_pos.X + world_pos_offset.X;
                _object_worldmatrix.M42 = 0.5f;// + 0 + physics_engine_offset_pos.Y + world_pos_offset.Y + offsetCubeY;
                _object_worldmatrix.M43 = 0;// + 0 + physics_engine_offset_pos.Z + world_pos_offset.Z;
                _object_worldmatrix.M44 = 1;


                _world_spectrum_list[0] = new sc_spectrum[1];
                _world_spectrum_list[0][0] = new sc_spectrum();
                _world_spectrum_list[0][0].Initialize(SC_console_directx.D3D, SC_console_directx.D3D.SurfaceWidth, SC_console_directx.D3D.SurfaceHeight, 0.05f, 1, 1, _spectrum_size_x, _spectrum_size_y, _spectrum_size_z, new Vector4(r, g, b, a), _inst_spectrum_x, _inst_spectrum_y, _inst_spectrum_z, SC_Update.HWND, _object_worldmatrix, 2, offsetPosX, offsetPosY, offsetPosZ, _thejitter_world, SCCoreSystems.sc_console.SC_console_directx.BodyTag._spectrum, true, 0, 10, 0, 0, 0); //, "terrainGrassDirt.bmp" //0.00035f

                worldMatrix_instances_spectrum[0] = new Matrix[1][]; //MainWindow.world_width * MainWindow.world_height * MainWindow.world_depth
                worldMatrix_instances_spectrum[0][0] = new Matrix[_inst_spectrum_x * _inst_spectrum_y * _inst_spectrum_z]; //_inst_terrain_tile_x * _inst_terrain_tile_y * _inst_terrain_tile_z

                for (int i = 0; i < worldMatrix_instances_spectrum[0][0].Length; i++)
                {
                    worldMatrix_instances_spectrum[0][0][i] = _world_spectrum_list[0][0]._arrayOfInstances[i]._POSITION;
                }
                _world_spectrum_list[0][0]._WORLDMATRIXINSTANCES = worldMatrix_instances_spectrum[0][0];

                ////////////////////////////
                //////////SPECTRUM//////////
                ////////////////////////////












                ////////////////////////////
                //////////PLATFORM//////////
                ////////////////////////////
                _inst_terrain_tile_x = 1;
                _inst_terrain_tile_y = 1;
                _inst_terrain_tile_z = 1;
                r = 0.10f;
                g = 0.10f;
                b = 0.10f;
                a = 1.0f;
                _object_worldmatrix = Matrix.Identity;
                _object_worldmatrix = WorldMatrix;
                _object_worldmatrix.M41 = 0;
                _object_worldmatrix.M42 = -_platform_size_y;
                _object_worldmatrix.M43 = 0;
                _object_worldmatrix.M44 = 1;
                offsetPosX = 0;
                offsetPosY = 0;
                offsetPosZ = 0;

                _terrain[0] = new SC_cube[1];
                _terrain[0][0] = new SC_cube();
                _terrain[0][0].Initialize(SC_console_directx.D3D, SC_console_directx.D3D.SurfaceWidth, SC_console_directx.D3D.SurfaceHeight, 0.1f, 1, 1, _platform_size_x, _platform_size_y, _platform_size_z, new Vector4(r, g, b, a), _inst_terrain_tile_x, _inst_terrain_tile_y, _inst_terrain_tile_z, SC_Update.HWND, _object_worldmatrix, 0, offsetPosX, offsetPosY, offsetPosZ, _thejitter_world, SCCoreSystems.sc_console.SC_console_directx.BodyTag.Terrain, true, 0, 10, 0, 0, 0); //, "terrainGrassDirt.bmp" //0.00035f

                worldMatrix_instances_terrain[0] = new Matrix[1][];
                worldMatrix_instances_terrain[0][0] = new Matrix[1];
                for (int i = 0; i < worldMatrix_instances_terrain[0][0].Length; i++)
                {
                    worldMatrix_instances_terrain[0][0][i] = _terrain[0][0]._arrayOfInstances[0]._POSITION;
                }
                ////////////////////////////
                //////////PLATFORM//////////
                ////////////////////////////




                ////////////////////////////
                //////////GRIDS//////////
                ////////////////////////////
                r = 0.85f;
                g = 0.85f;
                b = 0.85f;
                a = 1;
                _object_worldmatrix = Matrix.Identity;
                //offsetPosX = _grid_size_x * 1.15f; //x between each world instance
                //offsetPosY = _grid_size_y * 1.15f; //y between each world instance
                //offsetPosZ = _grid_size_z * 1.15f; //z between each world instance
                _object_worldmatrix = WorldMatrix;
                _object_worldmatrix.M41 = 0;
                _size_screen = 0.30f;
                _object_worldmatrix.M42 = _terrain[0][0]._arrayOfInstances[0]._POSITION.M42 + (_terrain[0][0]._total_torso_height) + (1 * 0.001f); //_terrain_size_y + (_terrain_size_y * 0.501f)-5 //_terrain[0][0]._arrayOfInstances[0]._POSITION.M42
                _object_worldmatrix.M43 = 0;
                _object_worldmatrix.M44 = 1;


                _world_grid_list[0] = new SC_grid[1];
                _world_grid_list[0][0] = new SC_grid();
                _world_grid_list[0][0].Initialize(SC_console_directx.D3D, 10, 10, _size_screen, 10, 10, _grid_size_x, _grid_size_y, _grid_size_z, new Vector4(r, g, b, a), _inst_terrain_tile_x, _inst_terrain_tile_y, _inst_terrain_tile_z, SC_Update.HWND, _object_worldmatrix, 0, offsetPosX, offsetPosY, offsetPosZ, _thejitter_world, SCCoreSystems.sc_console.SC_console_directx.BodyTag.sc_grid, true, 0, 10, 0, 0, 0); //, "terrainGrassDirt.bmp" //0.00035f

                worldMatrix_instances_grid[0] = new Matrix[1][];
                worldMatrix_instances_grid[0][0] = new Matrix[1];
                for (int i = 0; i < worldMatrix_instances_grid[0][0].Length; i++)
                {
                    worldMatrix_instances_grid[0][0][i] = _world_grid_list[0][0]._arrayOfInstances[i].current_pos;
                }
                ////////////////////////////
                //////////PLATFORM//////////
                ////////////////////////////



















                if (MainWindow.usejitterphysics == 1 && MainWindow.usejitterphysicsbuo == 1)
                {

                    ////////////////////////////
                    //////////BUOYANCY//////////
                    ////////////////////////////
                    _buo = new Jitter.Forces.Buoyancy(_thejitter_world);
                    float _size__neg_x = 1.175494351F - 38;
                    float _size__pos_x = 3.402823466F + 38;

                    float _size__neg_y = 1.175494351F - 38;
                    float _size__pos_y = -0.5f;

                    float _size__neg_z = 1.175494351F - 38;
                    float _size__pos_z = 3.402823466F + 38;

                    JVector _min = new JVector(_size__neg_x, _size__neg_y, _size__neg_z);
                    JVector _max = new JVector(_size__pos_x, _size__pos_y, _size__pos_z);

                    JBBox _box = new JBBox(_min, _max);
                    //_box.Min = new JVector(_size__neg_x, _size__neg_y, _size__neg_z);

                    _box.AddPoint(new JVector(_size__neg_x, _size__neg_y, _size__neg_z));
                    _box.AddPoint(new JVector(_size__pos_x, _size__neg_y, _size__neg_z));
                    _box.AddPoint(new JVector(_size__neg_x, _size__neg_y, _size__pos_z));
                    _box.AddPoint(new JVector(_size__pos_x, _size__neg_y, _size__pos_z));

                    _box.AddPoint(new JVector(_size__neg_x, _size__pos_y, _size__neg_z));
                    _box.AddPoint(new JVector(_size__pos_x, _size__pos_y, _size__neg_z));
                    _box.AddPoint(new JVector(_size__neg_x, _size__pos_y, _size__pos_z));
                    _box.AddPoint(new JVector(_size__pos_x, _size__pos_y, _size__pos_z));

                    _buo.FluidBox = _box;

                    //_buo.UseOwnFluidArea
                    //Action _action = new Action();
                    //JVector _new_vec = new JVector(0,0,0);
                    //var refreshDXEngineAction = new Action(() =>
                    //{
                    //    _set_fluid_point(ref _new_vec);
                    //});

                    Jitter.Forces.Buoyancy.DefineFluidArea test = new Jitter.Forces.Buoyancy.DefineFluidArea(ref _set_fluid_point);
                    _buo.UseOwnFluidArea(test);
                    _buoyancy_area[0] = _buo;


                    //_buo.FluidBox = JBBox.LargeBox;
                    _buo.Density = 2.0f;
                    _buo.Damping = 0.75f;
                    ////////////////////////////
                    //////////BUOYANCY//////////
                    ////////////////////////////

                    for (int phys = 0; phys < MainWindow._physics_engine_instance_x * MainWindow._physics_engine_instance_y * MainWindow._physics_engine_instance_z; phys++)
                    {
                        for (int i = 0; i < MainWindow.world_width * MainWindow.world_height * MainWindow.world_depth; i++)
                        {
                            object _some_dator = (object)_sc_jitter_tasks[phys][i]._world_data[0];
                            World _the_current_world = (World)_some_dator;

                            _the_current_world.AddBody(_terrain[0][0]._arrayOfInstances[0].transform.Component.rigidbody);
                            _the_current_world.AddBody(_floor[0][0]._arrayOfInstances[0].transform.Component.rigidbody);

                            for (int cu = 0; cu < _world_cube_list[phys][i]._arrayOfInstances.Length; cu++)
                            {
                                _buo.Add(_world_cube_list[phys][i]._arrayOfInstances[cu].transform.Component.rigidbody, 3);
                            }

                            for (int cu = 0; cu < _world_cone_list[phys][i]._arrayOfInstances.Length; cu++)
                            {
                                _buo.Add(_world_cone_list[phys][i]._arrayOfInstances[cu].transform.Component.rigidbody, 3);
                            }

                            for (int cu = 0; cu < _world_cylinder_list[phys][i]._arrayOfInstances.Length; cu++)
                            {
                                _buo.Add(_world_cylinder_list[phys][i]._arrayOfInstances[cu].transform.Component.rigidbody, 3);
                            }

                            for (int cu = 0; cu < _world_capsule_list[phys][i]._arrayOfInstances.Length; cu++)
                            {
                                _buo.Add(_world_capsule_list[phys][i]._arrayOfInstances[cu].transform.Component.rigidbody, 3);
                            }

                            for (int cu = 0; cu < _world_sphere_list[phys][i]._arrayOfInstances.Length; cu++)
                            {
                                _buo.Add(_world_sphere_list[phys][i]._arrayOfInstances[cu].transform.Component.rigidbody, 3);
                            }

                            for (int cu = 0; cu < _world_voxel_cube_lists[phys][i]._arrayOfInstances.Length; cu++)
                            {
                                _buo.Add(_world_voxel_cube_lists[phys][i]._arrayOfInstances[cu].transform.Component.rigidbody, 3);
                            }
                        }
                    }
                }
                //OBJECTS CREATION
                //OBJECTS CREATION
                //OBJECTS CREATION
                //OBJECTS CREATION

                //HUMAN PHYSICS RIG



























                /*
                //LEFT UPPER LEG
                vertoffsetx = 0;
                vertoffsety = 0;
                vertoffsetz = 0;
                r = 0.19f;
                g = 0.19f;
                b = 0.19f;
                a = 1;
                _tempMatroxer = Matrix.Identity;
                _tempMatroxer = WorldMatrix;
                _tempMatroxer.M41 = -0.09f;
                _tempMatroxer.M42 = -((((13 + 12 + 1) + (1 * 0.00123f)) * 0.10550f * 0.30f));
                _tempMatroxer.M43 = 0;
                _tempMatroxer.M44 = 1;
                offsetPosX = _dist_between * 2;
                offsetPosY = _dist_between * 2;
                offsetPosZ = _dist_between * 2;
                //_player_r_upper_leg[0] = new sc_voxel();
                //_hasinit0 = _player_r_upper_leg.Initialize(_SC_console_directx.D3D, _SC_console_directx.D3D.SurfaceWidth, _SC_console_directx.D3D.SurfaceHeight, _size_screen, 1, 1, 0.035f, 0.10550f, 0.035f, new Vector4(r, g, b, a), instX, instY, instZ, Hwnd, _tempMatroxer, 0, offsetPosX, offsetPosY, offsetPosZ, vertOffsetX, vertOffsetY, vertOffsetZ); //, "terrainGrassDirt.bmp" //0.00035f
                //_hasinit0 = _player_r_upper_leg[0].Initialize(SC_console_directx.D3D, SC_console_directx.D3D.SurfaceWidth, SC_console_directx.D3D.SurfaceHeight, 1, 1, 1, 0.035f, 0.10550f, 0.035f, new Vector4(r, g, b, a), _inst_p_r_hand_x, _inst_p_r_hand_y, _inst_p_r_hand_z, Hwnd, _tempMatroxer, 2, offsetPosX, offsetPosY, offsetPosZ, World, SCCoreSystems.sc_console.SC_console_directx.BodyTag.PlayerUpperArmLeft, _static, 1, _mass, 0, 0, 0); //, "terrainGrassDirt.bmp" //0.00035f
                voxel_general_size = 0.0025f;
                //voxel_type = 0;
                _type_of_cube = 2;

                _player_l_upper_leg[0][0] = new sc_voxel();
                //_player_lft_upper_arm[0].Initialize(SC_console_directx.D3D, SC_console_directx.D3D.SurfaceWidth, SC_console_directx.D3D.SurfaceHeight, 1, 1, 1, 0.05f, 0.05f, 0.05f, new Vector4(r, g, b, a), _inst_p_r_hand_x, _inst_p_r_hand_y, _inst_p_r_hand_z, Hwnd, _tempMatroxer, _type_of_cube, offsetPosX, offsetPosY, offsetPosZ, World, _mass, false, SCCoreSystems.sc_console.SC_console_directx.BodyTag.PlayerUpperArmLeft, 10, 10, 10, 10, 10, 10, 4, 3, 20, 19, 20, 19, 0.0025f, Vector3.Zero, 300); //, "terrainGrassDirt.bmp" //0.00035f
                _player_l_upper_leg[0][0].Initialize(SC_console_directx.D3D, SC_console_directx.D3D.SurfaceWidth, SC_console_directx.D3D.SurfaceHeight, 0, 1, 1, 1, 0.035f, 0.10550f, 0.035f, new Vector4(r, g, b, a),
                    _inst_p_upper_l_leg_x, _inst_p_upper_l_leg_y, _inst_p_upper_l_leg_z, MainWindow.consoleHandle, _tempMatroxer, _type_of_cube, offsetPosX, offsetPosY, offsetPosZ, _thejitter_world, _mass, is_static,
                    SCCoreSystems.sc_console.SC_console_directx.BodyTag.PlayerUpperLegLeft,
                    9, 9, 9, 17, 17, 17, 17, 17, 17, 13, 12, 40, 39, 13, 12,
                    voxel_general_size, new Vector3(0, 0, 0), 50, vertoffsetx, vertoffsety, vertoffsetz, _addToWorld, voxel_type); //, "terrainGrassDirt.bmp" //0.00035f

                worldMatrix_instances_l_upper_leg[0][0] = new Matrix[_inst_p_upper_l_leg_x * _inst_p_upper_l_leg_y * _inst_p_upper_l_leg_z];
                for (int i = 0; i < worldMatrix_instances_l_upper_leg[0][0].Length; i++)
                {
                    worldMatrix_instances_l_upper_leg[0][0][i] = Matrix.Identity;
                }


                //LEFT LOWER LEG
                vertoffsetx = 0;
                vertoffsety = 0;
                vertoffsetz = 0;
                r = 0.19f;
                g = 0.19f;
                b = 0.19f;
                a = 1;
                _tempMatroxer = Matrix.Identity;
                _tempMatroxer = WorldMatrix;
                _tempMatroxer.M41 = 0.09f;
                _tempMatroxer.M42 = -((((13 + 12 + 1) + (1 * 0.00123f)) * 0.10550f * 0.30f));
                _tempMatroxer.M43 = 0;
                _tempMatroxer.M44 = 1;
                offsetPosX = _dist_between * 2;
                offsetPosY = _dist_between * 2;
                offsetPosZ = _dist_between * 2;
                //_player_r_upper_leg[0] = new sc_voxel();
                //_hasinit0 = _player_r_upper_leg.Initialize(_SC_console_directx.D3D, _SC_console_directx.D3D.SurfaceWidth, _SC_console_directx.D3D.SurfaceHeight, _size_screen, 1, 1, 0.035f, 0.10550f, 0.035f, new Vector4(r, g, b, a), instX, instY, instZ, Hwnd, _tempMatroxer, 0, offsetPosX, offsetPosY, offsetPosZ, vertOffsetX, vertOffsetY, vertOffsetZ); //, "terrainGrassDirt.bmp" //0.00035f
                //_hasinit0 = _player_r_upper_leg[0].Initialize(SC_console_directx.D3D, SC_console_directx.D3D.SurfaceWidth, SC_console_directx.D3D.SurfaceHeight, 1, 1, 1, 0.035f, 0.10550f, 0.035f, new Vector4(r, g, b, a), _inst_p_r_hand_x, _inst_p_r_hand_y, _inst_p_r_hand_z, Hwnd, _tempMatroxer, 2, offsetPosX, offsetPosY, offsetPosZ, World, SCCoreSystems.sc_console.SC_console_directx.BodyTag.PlayerUpperArmLeft, _static, 1, _mass, 0, 0, 0); //, "terrainGrassDirt.bmp" //0.00035f
                voxel_general_size = 0.0025f;
                //voxel_type = 0;
                _type_of_cube = 2;

                _player_l_lower_leg[0][0] = new sc_voxel();
                //_player_lft_upper_arm[0].Initialize(SC_console_directx.D3D, SC_console_directx.D3D.SurfaceWidth, SC_console_directx.D3D.SurfaceHeight, 1, 1, 1, 0.05f, 0.05f, 0.05f, new Vector4(r, g, b, a), _inst_p_r_hand_x, _inst_p_r_hand_y, _inst_p_r_hand_z, Hwnd, _tempMatroxer, _type_of_cube, offsetPosX, offsetPosY, offsetPosZ, World, _mass, false, SCCoreSystems.sc_console.SC_console_directx.BodyTag.PlayerUpperArmLeft, 10, 10, 10, 10, 10, 10, 4, 3, 20, 19, 20, 19, 0.0025f, Vector3.Zero, 300); //, "terrainGrassDirt.bmp" //0.00035f
                _player_l_lower_leg[0][0].Initialize(SC_console_directx.D3D, SC_console_directx.D3D.SurfaceWidth, SC_console_directx.D3D.SurfaceHeight, 0, 1, 1, 1, 0.035f, 0.10550f, 0.035f, new Vector4(r, g, b, a),
                    _inst_p_lower_l_leg_x, _inst_p_lower_l_leg_y, _inst_p_lower_l_leg_z, MainWindow.consoleHandle, _tempMatroxer, _type_of_cube, offsetPosX, offsetPosY, offsetPosZ, _thejitter_world, _mass, is_static,
                    SCCoreSystems.sc_console.SC_console_directx.BodyTag.PlayerLowerLegLeft,
                    9, 9, 9, 17, 17, 17, 17, 17, 17, 13, 12, 40, 39, 13, 12,
                    voxel_general_size, new Vector3(0, 0, 0), 50, vertoffsetx, vertoffsety, vertoffsetz, _addToWorld, voxel_type); //, "terrainGrassDirt.bmp" //0.00035f

                worldMatrix_instances_l_lower_leg[0][0] = new Matrix[_inst_p_lower_l_leg_x * _inst_p_lower_l_leg_y * _inst_p_lower_l_leg_z];
                for (int i = 0; i < worldMatrix_instances_l_lower_leg[0][0].Length; i++)
                {
                    worldMatrix_instances_l_lower_leg[0][0][i] = Matrix.Identity;
                }







                //LEFT KNEE TARGET
                vertoffsetx = 0;
                vertoffsety = 0;
                vertoffsetz = 0;
                r = 0.19f;
                g = 0.19f;
                b = 0.19f;
                a = 1;
                //_tempMatroxer.M41 = -0.25f; /
                //_tempMatroxer.M42 = -0.2f;
                _tempMatroxer = Matrix.Identity;
                _tempMatroxer = WorldMatrix;
                _tempMatroxer.M41 = -0.09f;
                _tempMatroxer.M42 = -((((13 + 12 + 1) + (1 * 0.00123f)) * 0.10550f * 0.30f));// - 0.25f; //(_player_r_upper_leg[0][0]._POSITION.M42 + (_player_r_upper_leg[0][0]._total_torso_height * 0.5f) + 0.45f)
                _tempMatroxer.M43 = 0;
                _tempMatroxer.M44 = 1;
                offsetPosX = _dist_between * 2;
                offsetPosY = _dist_between * 2;
                offsetPosZ = _dist_between * 2;
                //_player_rght_elbow_target[0] = new sc_voxel();
                //_hasinit0 = _player_rght_elbow_target.Initialize(_SC_console_directx.D3D, _SC_console_directx.D3D.SurfaceWidth, _SC_console_directx.D3D.SurfaceHeight, _size_screen, 1, 1, 0.075f, 0.075f, 0.075f, new Vector4(r, g, b, a), instX, instY, instZ, Hwnd, _tempMatroxer, 0, offsetPosX, offsetPosY, offsetPosZ, vertOffsetX, vertOffsetY, vertOffsetZ); //, "terrainGrassDirt.bmp" //0.00035f
                //_hasinit0 = _player_rght_elbow_target[0].Initialize(SC_console_directx.D3D, SC_console_directx.D3D.SurfaceWidth, SC_console_directx.D3D.SurfaceHeight, 1, 1, 1, 0.075f, 0.075f, 0.075f, new Vector4(r, g, b, a), _inst_p_r_hand_x, _inst_p_r_hand_y, _inst_p_r_hand_z, Hwnd, _tempMatroxer, 2, offsetPosX, offsetPosY, offsetPosZ, World, SCCoreSystems.sc_console.SC_console_directx.BodyTag.PlayerRightElbowTarget, _static, 1, _mass, 0, 0, 0); //, "terrainGrassDirt.bmp" //0.00035f
                voxel_general_size = 0.0025f;

                //voxel_type = 0;

                _type_of_cube = 2;
                _player_lft_target_knee[0][0] = new sc_voxel();
                _player_lft_target_knee[0][0].Initialize(SC_console_directx.D3D, SC_console_directx.D3D.SurfaceWidth, SC_console_directx.D3D.SurfaceHeight, 0, 1, 1, 1, 0.05f, 0.05f, 0.05f, new Vector4(r, g, b, a), _inst_p_r_hand_x, _inst_p_r_hand_y, _inst_p_r_hand_z, MainWindow.consoleHandle, _tempMatroxer, _type_of_cube, offsetPosX, offsetPosY, offsetPosZ, _thejitter_world, _mass, is_static, SCCoreSystems.sc_console.SC_console_directx.BodyTag.PlayerLeftTargetKnee, 2, 2, 2, 2, 2, 2, 9, 9, 9, 10, 9, 10, 9, 10, 9, voxel_general_size, Vector3.Zero, 25, vertoffsetx, vertoffsety, vertoffsetz, 0, voxel_type); //, "terrainGrassDirt.bmp" //0.00035f
                worldMatrix_instances_l_target_knee[0][0] = new Matrix[_inst_p_upper_l_leg_x * _inst_p_upper_l_leg_y * _inst_p_upper_l_leg_z];
                for (int i = 0; i < worldMatrix_instances_l_target_knee[0][0].Length; i++)
                {
                    worldMatrix_instances_l_target_knee[0][0][i] = Matrix.Identity;
                }





                //LEFT KNEE TARGET TWO
                vertoffsetx = 0;
                vertoffsety = 0;
                vertoffsetz = 0;
                r = 0.19f;
                g = 0.19f;
                b = 0.19f;
                a = 1;
                //_tempMatroxer.M41 = -0.25f; /
                //_tempMatroxer.M42 = -0.2f;
                _tempMatroxer = Matrix.Identity;
                _tempMatroxer = WorldMatrix;
                _tempMatroxer.M41 = -0.25f;
                _tempMatroxer.M42 = (_player_l_upper_leg[0][0]._POSITION.M42 + (_player_l_upper_leg[0][0]._total_torso_height * 0.5f) + 0.45f);// - 0.25f;
                _tempMatroxer.M43 = -0.25f;
                _tempMatroxer.M44 = 1;
                offsetPosX = _dist_between * 2;
                offsetPosY = _dist_between * 2;
                offsetPosZ = _dist_between * 2;
                //_player_rght_elbow_target[0] = new sc_voxel();
                //_hasinit0 = _player_rght_elbow_target.Initialize(_SC_console_directx.D3D, _SC_console_directx.D3D.SurfaceWidth, _SC_console_directx.D3D.SurfaceHeight, _size_screen, 1, 1, 0.075f, 0.075f, 0.075f, new Vector4(r, g, b, a), instX, instY, instZ, Hwnd, _tempMatroxer, 0, offsetPosX, offsetPosY, offsetPosZ, vertOffsetX, vertOffsetY, vertOffsetZ); //, "terrainGrassDirt.bmp" //0.00035f
                //_hasinit0 = _player_rght_elbow_target[0].Initialize(SC_console_directx.D3D, SC_console_directx.D3D.SurfaceWidth, SC_console_directx.D3D.SurfaceHeight, 1, 1, 1, 0.075f, 0.075f, 0.075f, new Vector4(r, g, b, a), _inst_p_r_hand_x, _inst_p_r_hand_y, _inst_p_r_hand_z, Hwnd, _tempMatroxer, 2, offsetPosX, offsetPosY, offsetPosZ, World, SCCoreSystems.sc_console.SC_console_directx.BodyTag.PlayerRightElbowTarget, _static, 1, _mass, 0, 0, 0); //, "terrainGrassDirt.bmp" //0.00035f
                voxel_general_size = 0.0025f;
                //voxel_type = 0;
                _type_of_cube = 2;
                _player_lft_target_two_knee[0][0] = new sc_voxel();
                _player_lft_target_two_knee[0][0].Initialize(SC_console_directx.D3D, SC_console_directx.D3D.SurfaceWidth, SC_console_directx.D3D.SurfaceHeight, 0, 1, 1, 1, 0.05f, 0.05f, 0.05f, new Vector4(r, g, b, a), _inst_p_r_hand_x, _inst_p_r_hand_y, _inst_p_r_hand_z, MainWindow.consoleHandle, _tempMatroxer, _type_of_cube, offsetPosX, offsetPosY, offsetPosZ, _thejitter_world, _mass, is_static, SCCoreSystems.sc_console.SC_console_directx.BodyTag.PlayerLeftTargettwoKnee, 2, 2, 2, 2, 2, 2, 9, 9, 9, 10, 9, 10, 9, 10, 9, voxel_general_size, Vector3.Zero, 25, vertoffsetx, vertoffsety, vertoffsetz, 0, voxel_type); //, "terrainGrassDirt.bmp" //0.00035f
                worldMatrix_instances_l_target_two_knee[0][0] = new Matrix[_inst_p_upper_l_leg_x * _inst_p_upper_l_leg_y * _inst_p_upper_l_leg_z];
                for (int i = 0; i < worldMatrix_instances_l_target_two_knee[0][0].Length; i++)
                {
                    worldMatrix_instances_l_target_two_knee[0][0][i] = Matrix.Identity;
                }


                //LEFT FOOT
                vertoffsetx = 0;
                vertoffsety = 0;
                vertoffsetz = 0;
                r = 0.19f;
                g = 0.19f;
                b = 0.19f;
                a = 1;
                _tempMatroxer = Matrix.Identity;
                _tempMatroxer = WorldMatrix;
                _tempMatroxer.M41 = 0.09f;
                _tempMatroxer.M42 = -((((13 + 12 + 1 + 13 + 12 + 1 + 13 + 12 + 1) + (1 * 0.00123f)) * 0.10550f * 0.30f));
                _tempMatroxer.M43 = 0;
                _tempMatroxer.M44 = 1;
                offsetPosX = _dist_between * 2;
                offsetPosY = _dist_between * 2;
                offsetPosZ = _dist_between * 2;
                //_player_r_upper_leg[0] = new sc_voxel();
                //_hasinit0 = _player_r_upper_leg.Initialize(_SC_console_directx.D3D, _SC_console_directx.D3D.SurfaceWidth, _SC_console_directx.D3D.SurfaceHeight, _size_screen, 1, 1, 0.035f, 0.10550f, 0.035f, new Vector4(r, g, b, a), instX, instY, instZ, Hwnd, _tempMatroxer, 0, offsetPosX, offsetPosY, offsetPosZ, vertOffsetX, vertOffsetY, vertOffsetZ); //, "terrainGrassDirt.bmp" //0.00035f
                //_hasinit0 = _player_r_upper_leg[0].Initialize(SC_console_directx.D3D, SC_console_directx.D3D.SurfaceWidth, SC_console_directx.D3D.SurfaceHeight, 1, 1, 1, 0.035f, 0.10550f, 0.035f, new Vector4(r, g, b, a), _inst_p_r_hand_x, _inst_p_r_hand_y, _inst_p_r_hand_z, Hwnd, _tempMatroxer, 2, offsetPosX, offsetPosY, offsetPosZ, World, SCCoreSystems.sc_console.SC_console_directx.BodyTag.PlayerUpperArmLeft, _static, 1, _mass, 0, 0, 0); //, "terrainGrassDirt.bmp" //0.00035f
                voxel_general_size = 0.0025f;
                //voxel_type = 0;
                _type_of_cube = 2;

                _player_l_foot[0][0] = new sc_voxel();
                //_player_lft_upper_arm[0].Initialize(SC_console_directx.D3D, SC_console_directx.D3D.SurfaceWidth, SC_console_directx.D3D.SurfaceHeight, 1, 1, 1, 0.05f, 0.05f, 0.05f, new Vector4(r, g, b, a), _inst_p_r_hand_x, _inst_p_r_hand_y, _inst_p_r_hand_z, Hwnd, _tempMatroxer, _type_of_cube, offsetPosX, offsetPosY, offsetPosZ, World, _mass, false, SCCoreSystems.sc_console.SC_console_directx.BodyTag.PlayerUpperArmLeft, 10, 10, 10, 10, 10, 10, 4, 3, 20, 19, 20, 19, 0.0025f, Vector3.Zero, 300); //, "terrainGrassDirt.bmp" //0.00035f
                _player_l_foot[0][0].Initialize(SC_console_directx.D3D, SC_console_directx.D3D.SurfaceWidth, SC_console_directx.D3D.SurfaceHeight, 0, 1, 1, 1, 0.035f, 0.10550f, 0.035f, new Vector4(r, g, b, a),
                    _inst_p_l_foot_x, _inst_p_l_foot_y, _inst_p_l_foot_z, MainWindow.consoleHandle, _tempMatroxer, _type_of_cube, offsetPosX, offsetPosY, offsetPosZ, _thejitter_world, _mass, is_static,
                    SCCoreSystems.sc_console.SC_console_directx.BodyTag.PlayerFootLeft,
                    9, 9, 9, 17, 17, 17, 17, 17, 17, 9, 8, 9, 8, 20, 19,
                    voxel_general_size, new Vector3(0, 0, 0), 50, vertoffsetx, vertoffsety, vertoffsetz, _addToWorld, voxel_type); //, "terrainGrassDirt.bmp" //0.00035f

                worldMatrix_instances_l_foot[0][0] = new Matrix[_inst_p_l_foot_x * _inst_p_l_foot_y * _inst_p_l_foot_z];
                for (int i = 0; i < worldMatrix_instances_l_foot[0][0].Length; i++)
                {
                    worldMatrix_instances_l_foot[0][0][i] = Matrix.Identity;
                }*/
















































                //PHYSICS SCREENS
                _grab_rigid_data = new _rigid_data();
                _grab_rigid_data._body = null;
                _grab_rigid_data.position = Matrix.Identity;
                _grab_rigid_data._index = -1;
                _grab_rigid_data._physics_engine_index = -1;
                //SET TO 0 AND YOU HAVE USE A SHADERRESOURCE INSTEAD for the texture instead of using the color. cheap way for the moment as my switch wasnt working.
                r = 0;
                g = 0;
                b = 0;
                a = 0;
                _object_worldmatrix = Matrix.Identity;
                var _offsetPos = new Vector3(0.15f, 0.15f, 0.15f);
                _object_worldmatrix = WorldMatrix;
                _object_worldmatrix.M41 = -10; //-1.5f
                _object_worldmatrix.M42 = 1 + 0;
                _object_worldmatrix.M43 = 9; //-1.5f
                _object_worldmatrix.M44 = 1;
                _object_worldmatrix.M41 += _offsetPos.X;
                _object_worldmatrix.M42 += _offsetPos.Y;
                _object_worldmatrix.M43 += _offsetPos.Z;
                _size_screen = 0.0005f;
                var sizeWidth01 = (float)(((float)SC_console_directx.D3D.SurfaceWidth * mulScreen) * _size_screen) * _screen_size_x;
                var sizeheight01 = (float)((float)(SC_console_directx.D3D.SurfaceHeight * mulScreen) * _size_screen) * _screen_size_y;
                var sizedepth01 = 1 * _screen_size_z;
                float sizeWidther01 = (float)(sizeWidth01 * 0.5f);
                float sizeHeighter01 = (float)(sizeheight01 * 0.5f);
                float sizeDepther01 = (float)(sizedepth01 * 0.5f);
                offsetPosX = sizeWidth01 * 2;
                offsetPosY = sizeheight01 * 2;
                offsetPosZ = sizedepth01 * 2;
                _world_screen_list[0] = new SC_cube[1];
                _world_screen_list[0][0] = new SC_cube();
                worldMatrix_instances_screens[0] = new Matrix[1][];
                _world_screen_list[0][0].Initialize(SC_console_directx.D3D, SC_console_directx.D3D.SurfaceWidth, SC_console_directx.D3D.SurfaceHeight, 1, 1, 1, sizeWidther01, sizeHeighter01, sizeDepther01, new Vector4(r, g, b, a), _inst_screen_x, _inst_screen_y, _inst_screen_z, MainWindow.consoleHandle, _object_worldmatrix, 3, offsetPosX, offsetPosY, offsetPosZ, _thejitter_world, SCCoreSystems.sc_console.SC_console_directx.BodyTag.physicsInstancedScreen, true, 0, 100, 0, 0, 0); //, "terrainGrassDirt.bmp" //0.00035f
                if (MainWindow.usejitterphysics == 1 && MainWindow.usejitterphysicsbuo == 1)
                {
                    _buo.Add(_world_screen_list[0][0]._arrayOfInstances[0].transform.Component.rigidbody, 3);
                    _world_screen_list[0][0]._arrayOfInstances[0].transform.Component.rigidbody.AllowDeactivation = false;
                }
                worldMatrix_instances_screens[0][0] = new Matrix[1];
                worldMatrix_instances_screens[0][0][0] = _world_screen_list[0][0]._arrayOfInstances[0].current_pos; //





                /*int sizeX = (int)1;
                int sizeY = (int)(((SC_console_directx.D3D.SurfaceHeight * 0.0125f)) * _screen_size_y);
                int sizeZ = (int)(((SC_console_directx.D3D.SurfaceWidth * 0.0125f)) * _screen_size_x);
                int _dvX = 10;
                int _dvY = 10;
                a = 1;
                r = 0.65f;
                g = 0.15f;
                b = 0.15f;
                float offsetDepth = 3.0f;
                float depthScreen = _screen_size_z*2;
                _size_screen = 0.0006f;// * ((1 - mulScreen) + 1);
                _screen_grid_Y = new DTerrain_Screen();
                _screen_grid_Y.Initialize(SC_console_directx.D3D, SC_console_directx.D3D.SurfaceWidth, SC_console_directx.D3D.SurfaceHeight, _size_screen, 10, 10, a, r, g, b, depthScreen, offsetDepth);




                _dvX = (int)(SC_console_directx.D3D.SurfaceWidth * 0.5f * _screen_size_x * 0.01f * 0.55f);
                _dvY = (int)(SC_console_directx.D3D.SurfaceHeight * 0.5f * _screen_size_y * 0.01f); ;
                a = 1;
                r = 0.15f;
                g = 0.65f;
                b = 0.15f;
                offsetDepth = 3.0f;
                depthScreen = _screen_size_z*2;
                _size_screen = 0.0006f;// * ((1 - mulScreen) + 1);
                _screen_metric_grid_Y = new DTerrain_Screen_Metric();
                _screen_metric_grid_Y.Initialize(SC_console_directx.D3D, SC_console_directx.D3D.SurfaceWidth, SC_console_directx.D3D.SurfaceHeight, _size_screen, _dvX, _dvY, a, r, g, b, depthScreen, offsetDepth);
                */


                int _dvX = (int)(SC_console_directx.D3D.SurfaceWidth * 0.5f * _screen_size_x * 0.01f);
                int _dvY = (int)(SC_console_directx.D3D.SurfaceHeight * 0.5f * _screen_size_y * 0.01f);
                a = 1;
                r = 0.65f;
                g = 0.15f;
                b = 0.15f;
                _size_screen = 0.0005f;
                float maxwidthMul = 1.0f * 1.85f;
                float maxheightMul = 1.0f * 1.85f;
                _screen_grid_Y = new DTerrain_Screen();
                _screen_grid_Y.Initialize(SC_console_directx.D3D, SC_console_directx.D3D.SurfaceWidth, SC_console_directx.D3D.SurfaceHeight, _size_screen, 10, 10, a, r, g, b, 1, 1, maxwidthMul, maxheightMul);




                _dvX = (int)(SC_console_directx.D3D.SurfaceWidth * 0.5f * _screen_size_x * 0.01f);
                _dvY = (int)(SC_console_directx.D3D.SurfaceWidth * 0.5f * _screen_size_x * 0.01f);

                a = 1;
                r = 0.15f;
                g = 0.65f;
                b = 0.15f;
                _size_screen = 0.0005f;
                maxwidthMul = 0.95f;
                maxheightMul = 0.55f;
                _screen_metric_grid_Y = new DTerrain_Screen_Metric();
                _screen_metric_grid_Y.Initialize(SC_console_directx.D3D, SC_console_directx.D3D.SurfaceWidth, SC_console_directx.D3D.SurfaceWidth, _size_screen, _dvX, _dvY, a, r, g, b, 1, 1, maxwidthMul, maxheightMul);







                ////////////////////////////////////////////////
                //////////CONTAINMENT GRIDS SCREEN//////////////
                ////////////////////////////////////////////////
                int sizeX = (int)1;
                int sizeY = (int)(((SC_console_directx.D3D.SurfaceHeight * 0.0125f)) * _screen_size_y);
                int sizeZ = (int)(((SC_console_directx.D3D.SurfaceWidth * 0.0125f)) * _screen_size_x);
                r = 0.85f;
                g = 0.85f;
                b = 0.85f;
                a = 1;
                _object_worldmatrix = Matrix.Identity;
                _object_worldmatrix = WorldMatrix;
                _object_worldmatrix.M41 = 0;
                _object_worldmatrix.M42 = 0;
                _object_worldmatrix.M43 = 0;
                _object_worldmatrix.M44 = 1;
                _size_screen = 0.0006f * 10 * 2;
                _world_containment_grid_screen[0] = new sc_containment_grid[1];
                _world_containment_grid_screen[0][0] = new sc_containment_grid();
                _world_containment_grid_screen[0][0].Initialize(SC_console_directx.D3D, (int)(sizeX * 1), (int)(sizeY * 1), _size_screen, 10, 10, sizeWidther01, sizeHeighter01, sizeDepther01, new Vector4(r, g, b, a), _inst_screen_x, _inst_screen_y, _inst_screen_z, SC_Update.HWND, _object_worldmatrix, 0, offsetPosX, offsetPosY, offsetPosZ, _thejitter_world, SCCoreSystems.sc_console.SC_console_directx.BodyTag.sc_containment_grid, true, 0, 10, 0, 0, 0, 0, 0, 0, false, true, false, false, false, false);
                worldMatrix_instances_containment_grid_screen[0] = new Matrix[1][];
                worldMatrix_instances_containment_grid_screen[0][0] = new Matrix[1];
                for (int i = 0; i < worldMatrix_instances_containment_grid_screen[0][0].Length; i++)
                {
                    worldMatrix_instances_containment_grid_screen[0][0][i] = Matrix.Identity;
                }
                ////////////////////////////////////////////////
                //////////CONTAINMENT GRIDS SCREEN//////////////
                ////////////////////////////////////////////////



















                //_arrayOfCubes = new SC_VR_Cube();//[6 * 6 * 6];
                //_arrayOfCubes.Initialize(SC_console_directx.D3D.device, 0.05f, 0.05f, 0.05f, new Vector4(0.1f, 0.1f, 1f, 1), ChunkWidth_L, ChunkWidth_R, ChunkHeight_L, ChunkHeight_R, ChunkDepth_L, ChunkDepth_R);
                /*_tempMatroxer = WorldMatrix;
                _tempMatroxer.M42 = 1;
                sc_jitter_cloth = new PseudoCloth(_thejitter_world, SC_console_directx.D3D, MainWindow.consoleHandle, 10, 10, 0.1f, _tempMatroxer);
                worldMatrix_Cloth_instances = new Matrix[10 * 10];
                */










                oriRotationScreenX = 0;
                oriRotationScreenY = 0;
                oriRotationScreenZ = 0;

                RotationScreenX = oriRotationScreenX;
                RotationScreenY = oriRotationScreenY;
                RotationScreenZ = oriRotationScreenZ;

                //pitcher = oriRotationScreenX * 0.0174532925f;
                //yawer = oriRotationScreenY * 0.0174532925f;
                //roller = oriRotationScreenZ * 0.0174532925f;

                var pitcher = (float)(Math.PI * (oriRotationScreenX) / 180.0f);
                var yawer = (float)(Math.PI * (oriRotationScreenY) / 180.0f);
                var roller = (float)(Math.PI * (oriRotationScreenZ) / 180.0f);


                originRotScreen = SharpDX.Matrix.RotationYawPitchRoll(yawer, pitcher, roller);
                rotatingMatrixScreen = SharpDX.Matrix.RotationYawPitchRoll(yawer, pitcher, roller);


                float oriRotationScreenX0 = 0;
                float oriRotationScreenY0 = 180;
                float oriRotationScreenZ0 = 0;

                //pitcher = oriRotationScreenX0 * 0.0174532925f;
                //yawer = oriRotationScreenY0 * 0.0174532925f;
                //roller = oriRotationScreenZ0 * 0.0174532925f;
                pitcher = (float)(Math.PI * (oriRotationScreenX0) / 180.0f);
                yawer = (float)(Math.PI * (oriRotationScreenY0) / 180.0f);
                roller = (float)(Math.PI * (oriRotationScreenZ0) / 180.0f);

                _direction_offsetter = SharpDX.Matrix.RotationYawPitchRoll(yawer, pitcher, roller);

                _screen_direction_offsetter_two = SharpDX.Matrix.RotationYawPitchRoll(0, 0, 0);

                _size_screen = 0.0005f;
                sizeWidtherer = (float)(((float)SC_console_directx.D3D.SurfaceWidth * mulScreen) * _size_screen);
                sizeheighterer = (float)((float)(SC_console_directx.D3D.SurfaceHeight * mulScreen) * _size_screen);

                //float sizeWidther = (float)(sizeWidth * 0.5f);
                //float sizeHeighter = (float)(sizeheight * 0.5f);
                //float sizeDepther = (float)(sizedepth * 0.5f);







                //_screenCorners = new DModelClass4_cube[4];
                rotatingMatrixScreen.M41 = SC_Update.originPosScreen.X;
                rotatingMatrixScreen.M42 = SC_Update.originPosScreen.Y;
                rotatingMatrixScreen.M43 = SC_Update.originPosScreen.Z;
                _screenDirMatrix[0] = new Matrix[1][];
                point3DCollection[0] = new Vector3[1][];
                _screenDirMatrix_correct_pos[0] = new Matrix[1][];
                _screenDirMatrix[0][0] = new Matrix[4];
                point3DCollection[0][0] = new Vector3[4];
                _screenDirMatrix_correct_pos[0][0] = new Matrix[4];
                for (int i = 0; i < _screenDirMatrix[0][0].Length; i++)
                {
                    _screenDirMatrix[0][0][i] = new Matrix();
                    _screenDirMatrix[0][0][i] = rotatingMatrixScreen;
                }
                _screenDirMatrix[0][0][0].M41 = _world_screen_list[0][0].Vertices[16].position.X;// + originPosScreen.X;
                _screenDirMatrix[0][0][0].M42 = _world_screen_list[0][0].Vertices[16].position.Y;// + originPosScreen.Y;
                _screenDirMatrix[0][0][0].M43 = _world_screen_list[0][0].Vertices[16].position.Z;// + originPosScreen.Z;
                _screenDirMatrix[0][0][1].M41 = _world_screen_list[0][0].Vertices[13].position.X;// + originPosScreen.X;
                _screenDirMatrix[0][0][1].M42 = _world_screen_list[0][0].Vertices[13].position.Y;// + originPosScreen.Y;
                _screenDirMatrix[0][0][1].M43 = _world_screen_list[0][0].Vertices[13].position.Z;// + originPosScreen.Z;
                _screenDirMatrix[0][0][2].M41 = _world_screen_list[0][0].Vertices[15].position.X;// + originPosScreen.X;
                _screenDirMatrix[0][0][2].M42 = _world_screen_list[0][0].Vertices[15].position.Y;// + originPosScreen.Y;
                _screenDirMatrix[0][0][2].M43 = _world_screen_list[0][0].Vertices[15].position.Z;// + originPosScreen.Z;
                _screenDirMatrix[0][0][3].M41 = _world_screen_list[0][0].Vertices[17].position.X;// + originPosScreen.X;
                _screenDirMatrix[0][0][3].M42 = _world_screen_list[0][0].Vertices[17].position.Y;// + originPosScreen.Y;
                _screenDirMatrix[0][0][3].M43 = _world_screen_list[0][0].Vertices[17].position.Z;// + originPosScreen.Z;
                //16//13//15//17 
                //8//9//10//11
                for (int i = 0; i < _screenDirMatrix[0][0].Length; i++)
                {
                    point3DCollection[0][0][i] = new Vector3(_screenDirMatrix[0][0][i].M41, _screenDirMatrix[0][0][i].M42, _screenDirMatrix[0][0][i].M43);
                }




                //PHYSICS SCREEN ASSETS
                //SET TO 0 AND YOU HAVE USE A SHADERRESOURCE INSTEAD for the texture instead of using the color. cheap way for the moment as my switch wasnt working.
                //_array_of_colors[0] = new Vector4[_inst_screen_assets_x * _inst_screen_assets_y * _inst_screen_assets_z];
                //r = 0.05f;
                //g = 0.05f;
                //b = 0.05f;
                //a = 1;
                //SCREEN CORNERS
                //for (int i = 0; i < _array_of_colors.Length; i++)
                //{
                //    _array_of_colors[0][i] = new Vector4(r, g, b, a);
                //}
                //r = 0.05f;
                //g = 0.05f;
                //b = 0.05f;
                //a = 1;
                //_array_of_colors[0][4] = new Vector4(r, g, b, a);

                vertoffsetx = 0;
                vertoffsety = 0;
                vertoffsetz = 0;
                r = 0.05f;
                g = 0.05f;
                b = 0.05f;
                a = 1;
                _object_worldmatrix = Matrix.Identity;
                _object_worldmatrix.M41 = 0;
                _object_worldmatrix.M42 = 0;
                _object_worldmatrix.M43 = 0;
                _object_worldmatrix.M44 = 1;
                offsetPosX = sizeWidth01 * 2;
                offsetPosY = sizeheight01 * 2;
                offsetPosZ = sizedepth01 * 2;
                _world_screen_assets_list[0] = new SC_cube[1];
                _world_screen_assets_list[0][0] = new SC_cube();
                worldMatrix_instances_screen_assets[0] = new Matrix[1][];
                _world_screen_assets_list[0][0].Initialize(SC_console_directx.D3D, SC_console_directx.D3D.SurfaceWidth, SC_console_directx.D3D.SurfaceHeight, 1, 1, 1, _screen_assets_size_x, _screen_assets_size_y, _screen_assets_size_z, new Vector4(r, g, b, a), _inst_screen_assets_x, _inst_screen_assets_y, _inst_screen_assets_z, MainWindow.consoleHandle, _object_worldmatrix, 3, offsetPosX, offsetPosY, offsetPosZ, _thejitter_world, SCCoreSystems.sc_console.SC_console_directx.BodyTag._screen_assets, true, 0, 10, vertoffsetx, vertoffsety, vertoffsetz); //, "terrainGrassDirt.bmp" //0.00035f
                worldMatrix_instances_screen_assets[0][0] = new Matrix[_inst_screen_assets_x * _inst_screen_assets_y * _inst_screen_assets_z];
                for (int i = 0; i < worldMatrix_instances_screen_assets[0][0].Length; i++)
                {
                    worldMatrix_instances_screen_assets[0][0][i] = Matrix.Identity;
                }













                //lightpos = new Vector3(0, 100, 0);
                ambientColor = new Vector4(0.45f, 0.45f, 0.45f, 1.0f);
                diffuseColour = new Vector4(1, 1, 1, 1);
                lightDirection = new Vector3(0, -1, -1);


                _DLightBuffer_cube[0] = new SCCoreSystems.SC_Graphics.SC_cube.DLightBuffer()
                {
                    ambientColor = ambientColor,
                    diffuseColor = diffuseColour,
                    lightDirection = dirLight,
                    padding0 = 0,
                    lightPosition = lightpos,
                    padding1 = 100
                };

                _DLightBuffer_grid[0] = new SCCoreSystems.SC_Graphics.SC_grid.DLightBuffer()
                {
                    ambientColor = ambientColor,
                    diffuseColor = diffuseColour,
                    lightDirection = dirLight,
                    padding0 = 0,
                    lightPosition = lightpos,
                    padding1 = 100
                };

                _DLightBuffer_containment_grid[0] = new SCCoreSystems.SC_Graphics.sc_containment_grid.DLightBuffer()
                {
                    ambientColor = ambientColor,
                    diffuseColor = diffuseColour,
                    lightDirection = dirLight,
                    padding0 = 0,
                    lightPosition = lightpos,
                    padding1 = 100
                };

                _DLightBuffer_voxel_cube[0] = new SCCoreSystems.SC_Graphics.sc_voxel.DLightBuffer()
                {
                    ambientColor = ambientColor,
                    diffuseColor = diffuseColour,
                    lightDirection = dirLight,
                    padding0 = 0,
                    lightPosition = lightpos,
                    padding1 = 100
                };

                _DLightBuffer_spectrum[0] = new SCCoreSystems.SC_Graphics.sc_spectrum.DLightBuffer()
                {
                    ambientColor = ambientColor,
                    diffuseColor = diffuseColour,
                    lightDirection = dirLight,
                    padding0 = 0,
                    lightPosition = lightpos,
                    padding1 = 100
                };

                _DLightBuffer_voxel_pchunk_cube[0] = new SCCoreSystems.SC_Graphics.sc_voxel_pchunk.DLightBuffer()
                {
                    ambientColor = ambientColor,
                    diffuseColor = diffuseColour,
                    lightDirection = dirLight,
                    padding0 = 0,
                    lightPosition = lightpos,
                    padding1 = 100
                };






                /*_SC_modL_lft_hnd_BUFFER[0] = new SCCoreSystems.SC_Graphics.sc_voxel.DLightBuffer()
                {
                    ambientColor = ambientColor,
                    diffuseColor = diffuseColour,
                    lightDirection = dirLight,
                    padding0 = 0,
                    lightPosition = lightpos,
                    padding1 = 100
                };

                _SC_modL_lft_hnd_BUFFER[0] = new SCCoreSystems.SC_Graphics.sc_voxel.DLightBuffer()
                {
                    ambientColor = ambientColor,
                    diffuseColor = diffuseColour,
                    lightDirection = dirLight,
                    padding0 = 0,
                    lightPosition = lightpos,
                    padding1 = 100
                };*/

                /*
                _SC_modL_lft_shldr_BUFFER[0] = new SCCoreSystems.SC_Graphics.sc_voxel.DLightBuffer()
                {
                    ambientColor = ambientColor,
                    diffuseColor = diffuseColour,
                    lightDirection = dirLight,
                    padding0 = 0,
                    lightPosition = lightpos,
                    padding1 = 100
                };*/
                /*
                _SC_modL_lft_elbow_target_BUFFER[0] = new SCCoreSystems.SC_Graphics.sc_voxel.DLightBuffer()
                {
                    ambientColor = ambientColor,
                    diffuseColor = diffuseColour,
                    lightDirection = dirLight,
                    padding0 = 0,
                    lightPosition = lightpos,
                    padding1 = 100
                };
                _SC_modL_lft_elbow_target_two_BUFFER[0] = new SCCoreSystems.SC_Graphics.sc_voxel.DLightBuffer()
                {
                    ambientColor = ambientColor,
                    diffuseColor = diffuseColour,
                    lightDirection = dirLight,
                    padding0 = 0,
                    lightPosition = lightpos,
                    padding1 = 100
                };
                _SC_modL_lft_upper_arm_BUFFER[0] = new SCCoreSystems.SC_Graphics.sc_voxel.DLightBuffer()
                {
                    ambientColor = ambientColor,
                    diffuseColor = diffuseColour,
                    lightDirection = dirLight,
                    padding0 = 0,
                    lightPosition = lightpos,
                    padding1 = 100
                };
                _SC_modL_lft_lower_arm_BUFFER[0] = new SCCoreSystems.SC_Graphics.sc_voxel.DLightBuffer()
                {
                    ambientColor = ambientColor,
                    diffuseColor = diffuseColour,
                    lightDirection = dirLight,
                    padding0 = 0,
                    lightPosition = lightpos,
                    padding1 = 100
                };*/


                //_basicTexture = new _sc_texture_loader();
                //var terrainGrassDirtfilename = SCCoreSystems.Properties.Resources.terrainGrassDirt;

                //terrainGrassDirtfilename.GetHbitmap

                //var someterrainGrassDirt = ShaderBytecode.Compile(terrainGrassDirtfilename, "TextureVertexShader", "vs_4_0", ShaderFlags.None, SharpDX.D3DCompiler.EffectFlags.None);
                //if (!_basicTexture.Initialize(SC_console_directx.D3D.device, ))
                //    MainWindow.MessageBox((IntPtr)0, "fail load terrainGrassDirt.bmp", "sccs message", 0);


                _basicTexture = new _sc_texture_loader();
                var pathto_basicTexture = @"C:\Users\steve\Documents\GitHub\sccs\releases\sccsr13rm\sccsr13wpf472\terrainGrassDirt.bmp";
                if (!_basicTexture.Initialize(SC_console_directx.D3D.device, pathto_basicTexture))
                    MainWindow.MessageBox((IntPtr)0, "fail load terrainGrassDirt.bmp", "sccs message", 0);


                _pink_texture = new _sc_texture_loader();
                var pathto_pink_texture = @"C:\Users\steve\Documents\GitHub\sccs\releases\sccsr13rm\sccsr13wpf472\1x1_pink_color.png";
                if (!_pink_texture.Initialize(SC_console_directx.D3D.device, pathto_pink_texture))
                    MainWindow.MessageBox((IntPtr)0, "fail load 1x1_pink_color.png", "sccs message", 0);


                terrainheightmap = new DTerrainHeightMap();
                var pathto_heightmap = @"C:\Users\steve\Documents\GitHub\sccs\releases\sccsr13rm\sccsr13wpf472\heightmap01.bmp";
                if (!terrainheightmap.Initialize(SC_console_directx.D3D.device, pathto_heightmap))
                    MainWindow.MessageBox((IntPtr)0, "fail load heightmap01.bmp", "sccs message", 0);


                /*_pink_texture = new _sc_texture_loader();
                //_hasinit1 = _pink_texture.Initialize(SC_console_directx.D3D.device, "../../../1x1_pink_color.png");
                if (!_pink_texture.Initialize(SC_console_directx.D3D.device, "../../../1x1_pink_color.png"))
                    MainWindow.MessageBox((IntPtr)0, "fail load 1x1_pink_color.png", "sccs message", 0);

                // Create the model object.
                terrainheightmap = new DTerrainHeightMap();
                // Initialize the terrain object.
                if (!terrainheightmap.Initialize(SC_console_directx.D3D.Device, "../../../heightmap01.bmp"))
                    MainWindow.MessageBox((IntPtr)0, "fail load heightmap01.bmp", "sccs message", 0);*/


                /*terrainheightmap = new DTerrainHeightMap();
                // Initialize the terrain object.
                if (!terrainheightmap.Initialize(SC_console_directx.D3D.Device, "../../../heightmap01.bmp"))
                    MainWindow.MessageBox((IntPtr)0, "fail load heightmap01.bmp", "sccs message", 0);*/



            }
            catch (Exception ex)
            {
                MainWindow.MessageBox((IntPtr)0, "TESt" + ex.ToString(), "sc core systems message", 0);
            }


            _sc_jitter_tasks[0][0].hasinit = 1;

            return _sc_jitter_tasks;
        }

        bool _set_fluid_point(ref JVector test)
        {
            //test = new JVector(5, 5, 5);
            test = new JVector(0, 0, 0);
            return _buoyancy_area[0].FluidBox.Contains(ref test) != JBBox.ContainmentType.Disjoint;
        }
























        RigidBody grabBody;
        JVector hitNormal;

        Matrix finalRotationMatrix = Matrix.Identity;

        PointPointDistance _distanceConstraintRight;
        PointPointDistance _distanceConstraintLeft;
        RigidBody _lastRigidGrab;
        float _lastFraction = 0;
        JVector _lastHitPoint;
        //bool _hasGrabbed = false;

        private bool RaycastCallback(RigidBody body, JVector normal, float fraction)
        {
            if (body.IsStatic) return false;
            else return true;
        }

        Matrix hmdmatrixRot_;
        Matrix OriginRot = Matrix.Identity;
        Matrix RotatingMatrix = Matrix.Identity;
        Matrix RotatingMatrixForPelvis = Matrix.Identity;
        Matrix viewMatrix_ = Matrix.Identity;

















        public unsafe void oculuscontrolsNRecordSoundNMousePointer()
        {


            if (_updateFunctionBoolRight)
            {
                _updateFunctionStopwatchRight.Stop();
                _updateFunctionStopwatchRight.Reset();
                _updateFunctionStopwatchRight.Start();
                _updateFunctionBoolRight = false;
            }
            if (_updateFunctionBoolRightThumbStickGoLeft)
            {
                _updateFunctionStopwatchRightThumbstickGoLeft.Stop();
                _updateFunctionStopwatchRightThumbstickGoLeft.Reset();
                _updateFunctionStopwatchRightThumbstickGoLeft.Start();
                _updateFunctionBoolRightThumbStickGoLeft = false;
            }

            if (_updateFunctionBoolRightThumbStickGoRight)
            {
                _updateFunctionStopwatchRightThumbstickGoRight.Stop();
                _updateFunctionStopwatchRightThumbstickGoRight.Reset();
                _updateFunctionStopwatchRightThumbstickGoRight.Start();
                _updateFunctionBoolRightThumbStickGoRight = false;
            }

            if (_updateFunctionBoolLeftThumbStick)
            {
                _updateFunctionStopwatchLeftThumbstick.Stop();
                _updateFunctionStopwatchLeftThumbstick.Reset();
                _updateFunctionStopwatchLeftThumbstick.Start();
                _updateFunctionBoolLeftThumbStick = false;
            }






            //FOR WHEN THERE IS MY PHYSICS DESKTOP SCREEN

            Quaternion _quat_screen00;

            Matrix mater = worldMatrix_instances_screens[0][0][0];
            Quaternion.RotationMatrix(ref mater, out _quat_screen00);
            var screenNormal = sc_maths._getDirection(Vector3.ForwardRH, _quat_screen00);
            screenNormal.Normalize();

            var planer = new Plane(new Vector3(mater.M41, mater.M42, mater.M43), screenNormal);
            var screen_mat = worldMatrix_instances_screens[0][0][0];
            var somematroxer2 = screen_mat;
            Quaternion _quat_screen;
            Quaternion.RotationMatrix(ref screen_mat, out _quat_screen);
            screenNormal = sc_maths._getDirection(Vector3.ForwardRH, _quat_screen);
            screenNormal.Normalize();
            planer = new Plane(new Vector3(screen_mat.M41, screen_mat.M42, screen_mat.M43), screenNormal);

            //FOR SCREEN COLLISION DETECTION
            var centerPosRight = new Vector3(final_hand_pos_right_locked.M41, final_hand_pos_right_locked.M42, final_hand_pos_right_locked.M43);
            Quaternion.RotationMatrix(ref final_hand_pos_right_locked, out _rightTouchQuat);
            var rayDirRighter = sc_maths._getDirection(Vector3.ForwardRH, _rightTouchQuat);
            var someRay = new Ray(centerPosRight, rayDirRighter);
            var intersecter = someRay.Intersects(ref planer, out intersectPointRight);
            var _ray_dir_right = centerPosRight - intersectPointRight;
            var _length_of_ray_right = (_ray_dir_right).Length();

            var centerPosLeft = new Vector3(final_hand_pos_left_locked.M41, final_hand_pos_left_locked.M42, final_hand_pos_left_locked.M43);
            Quaternion.RotationMatrix(ref final_hand_pos_left_locked, out _leftTouchQuat);
            var rayDirLeft = sc_maths._getDirection(Vector3.ForwardRH, _leftTouchQuat);
            var someRayLeft = new Ray(centerPosLeft, rayDirLeft);
            var intersecterLeft = someRayLeft.Intersects(ref planer, out intersectPointLeft);
            var _ray_dir_left = centerPosLeft - intersectPointLeft;
            var _length_of_ray_left = (_ray_dir_left).Length();

            //SPECTRUM AND SOUND RECORDING

            if (has_spoken_sec == 1)
            {

                //MainWindow.MessageBox((IntPtr)0, "" + "0", "sccoresystems", 0);
                //_sound_byte_array.OrderBy(x => String.Join(String.Empty, x));
                //_sound_byte_array.OrderBy(x > x).FirstOrDefault();
                //_sound_byte_array = _sound_byte_array.ToList().OrderBy(x => x).ToArray(); // new List<byte>();
                //_sound_byte_array = list.OrderBy(x => x).ToArray();
                //var test = _sound_byte_array.OrderBy(x => x, new ByteListComparer());

                int count_spec = 0;

                var widthL = (int)(_inst_spectrum_x / 2);
                var widthR = (int)((_inst_spectrum_x / 2) - 1);

                var heightL = _inst_spectrum_y;
                var heightR = _inst_spectrum_y;

                var depthL = (int)(_inst_spectrum_z / 2);
                var depthR = (int)((_inst_spectrum_z / 2) - 1);

                //var depthL = _inst_spectrum_z;// (int)(_inst_spectrum_z / 2);
                //var depthR = _inst_spectrum_z;// (int)((_inst_spectrum_z / 2) - 1);

                // wL5 and <=wR4  = -5 to 5 ... 210/2 = 105 and 105 so 105-1 = 104 for wL105 and <=wR104   

                for (int x = -widthL; x <= widthR; x++)
                {
                    for (int y = -heightL; y <= heightR; y++)
                    {
                        for (int z = -depthL; z <= depthR; z++)
                        {
                            //MainWindow.MessageBox((IntPtr)0, "" + "0", "sccoresystems", 0);

                            //the higher the closer to center middle.

                            float posX = (x);
                            float posY = (y);
                            float posZ = (z);

                            var xx = x;
                            var yy = y;
                            var zz = z;

                            if (xx < 0)
                            {
                                xx *= -1;
                                xx = widthR + xx;
                            }
                            if (yy < 0)
                            {
                                yy *= -1;
                                yy = heightR + yy;
                            }
                            if (zz < 0)
                            {
                                zz *= -1;
                                zz = depthR + zz;
                            }

                            var _index = xx + _inst_spectrum_x * (yy + _inst_spectrum_y * zz);

                            Vector3 pos = new Vector3(posX, posY, posZ);

                            if (_index < _sound_byte_array.Length)
                            {
                                //MainWindow.MessageBox((IntPtr)0, "" + _index, "sccoresystems", 0);
                            }
                            else
                            {
                                //MainWindow.MessageBox((IntPtr)0, "" + _index, "sccoresystems", 0);
                            }

                            //var dist = sc_maths.sc_check_distance_node_3d_geometry(Vector3.Zero, pos, 9, 9, 9, 9, 9, 9);

                            try
                            {
                                if (_index < _world_spectrum_list[0][0]._arrayOfInstances.Length && _index < _sound_byte_array.Length) //_inst_spectrum_x * _inst_spectrum_y * _inst_spectrum_z)
                                {
                                    if (_sound_byte_array != null)
                                    {
                                        if (_sound_byte_array.Length > 0)
                                        {
                                            var _left_touch_pos = new Vector3(WorldMatrix.M41, WorldMatrix.M42, WorldMatrix.M43);
                                            /*
                                            if (count_spec < _sound_byte_array.Length && count_spec < _world_spectrum_list[0]._arrayOfInstances.Length) // 
                                            {
                                             
                                                /*if (_has_recorded == 1)
                                                {
                                                    var planeSize = 0.01f;
                                                    var detailscale = 10;
                                                    var heightmul = 20;
                                                    var seed = 3420;
                                                    var fastNoise = new FastNoise(seed);
                                                    float noise = fastNoise.GetPerlin((((spectrum_mat.M41 * planeSize) + seed) / detailscale) * heightmul, (((spectrum_mat.M42 * planeSize) + seed) / detailscale) * heightmul, (((spectrum_mat.M43 * planeSize) + seed) / detailscale) * heightmul);
                                                    _has_recorded = 2;
                                                }
                                                else
                                                {
                                                    //spectrum_mat.M41 = _left_touch_pos.X + _world_spectrum_list[0]._arrayOfInstances[s]._POSITION.M41;
                                                    //spectrum_mat.M42 = _left_touch_pos.Y + _world_spectrum_list[0]._arrayOfInstances[s]._POSITION.M42;
                                                    //spectrum_mat.M43 = _left_touch_pos.Z + _world_spectrum_list[0]._arrayOfInstances[s]._POSITION.M43;
                                                }
                                            }
                                            else
                                            {
                                                spectrum_mat.M41 = _left_touch_pos.X + _world_spectrum_list[0]._arrayOfInstances[_index]._POSITION.M41;
                                                spectrum_mat.M42 = _left_touch_pos.Y + _world_spectrum_list[0]._arrayOfInstances[_index]._POSITION.M42 + spectrum_noise_value; //0.0015f // + (_sound_byte_array[count_spec] * 0.0005f)
                                                spectrum_mat.M43 = _left_touch_pos.Z + _world_spectrum_list[0]._arrayOfInstances[_index]._POSITION.M43;
                                                //count_spec = 0;
                                            }*/
                                            spectrum_mat.M41 = _world_spectrum_list[0][0]._arrayOfInstances[_index]._POSITION.M41;
                                            spectrum_mat.M42 = _world_spectrum_list[0][0]._arrayOfInstances[_index]._POSITION.M42 + spectrum_noise_value + (_sound_byte_array[_index] * 0.005f); //0.0015f
                                            spectrum_mat.M43 = _world_spectrum_list[0][0]._arrayOfInstances[_index]._POSITION.M43;

                                            worldMatrix_instances_spectrum[0][0][_index] = spectrum_mat;
                                            count_spec++;

                                            /*else
                                            {
                                                var _left_touch_pos = new Vector3(WorldMatrix.M41, WorldMatrix.M42, WorldMatrix.M43);

                                                spectrum_mat.M41 = _left_touch_pos.X + _world_spectrum_list[0]._arrayOfInstances[_index]._POSITION.M41;
                                                spectrum_mat.M42 = _left_touch_pos.Y + _world_spectrum_list[0]._arrayOfInstances[_index]._POSITION.M42 + spectrum_noise_value + (_sound_byte_array[0] * 0.0015f);
                                                spectrum_mat.M43 = _left_touch_pos.Z + _world_spectrum_list[0]._arrayOfInstances[_index]._POSITION.M43;

                                                if (_has_recorded == 1)
                                                {
                                                    var planeSize = 0.01f;
                                                    var detailscale = 100;
                                                    var heightmul = 20;
                                                    var seed = 3420;
                                                    var fastNoise = new FastNoise(3420);
                                                    float noise = fastNoise.GetPerlin((((spectrum_mat.M41 * planeSize) + seed) / detailscale) * heightmul, (((spectrum_mat.M42 * planeSize) + seed) / detailscale) * heightmul, (((spectrum_mat.M43 * planeSize) + seed) / detailscale) * heightmul);
                                                    _has_recorded = 2;
                                                }
                                                else
                                                {
                                                    //spectrum_mat.M41 = _left_touch_pos.X + _world_spectrum_list[0]._arrayOfInstances[s]._POSITION.M41;
                                                    //spectrum_mat.M42 = _left_touch_pos.Y + _world_spectrum_list[0]._arrayOfInstances[s]._POSITION.M42;
                                                    //spectrum_mat.M43 = _left_touch_pos.Z + _world_spectrum_list[0]._arrayOfInstances[s]._POSITION.M43;
                                                }
                                                worldMatrix_instances_spectrum[0][_index] = spectrum_mat;
                                            }*/
                                        }
                                    }
                                }
                            }
                            catch (Exception ex)
                            {
                                MainWindow.MessageBox((IntPtr)0, "" + ex.ToString(), "sccoresystems", 0);
                            }
                            //for (int sba = 0; sba < _sound_byte_array.Length; sba++)
                            //{
                            //
                            //}
                        }
                    }
                }

                //_sound_byte_array = list.OrderBy(x => x).ThenBy().ToArray();

                /*for (int s = 0; s < worldMatrix_instances_spectrum[0].Length; s++)
                {

                }*/
                has_spoken_sec = 0;
                has_spoken_main = 0;
            }

            //Console.WriteLine("test0");

            //RECORD SOUND
            if (MainWindow._keyboard_input._KeyboardState.PressedKeys.Contains(SharpDX.DirectInput.Key.R))
            {
                if (sc_start_recording == 0)
                {
                    _records_instant_counter = 0;
                    _time_of_recording_start = DateTime.Now;

                    mciSendString("open new Type waveaudio Alias recsound", null, 0, IntPtr.Zero);
                    mciSendString("record recsound", null, 0, IntPtr.Zero);

                    sc_start_recording = 1;
                    has_spoken_main = 1;
                    //has_spoken_sec = 1;
                }
            }

            if (swtchinstantsound == 1)
            {
                if (has_spoken_tier == 1 && has_spoken_main == 1)
                {
                    instant_short_path = "wave_instant_audio_" + _records_instant_counter;
                    var filename = @"C:\Users\steve\Desktop\#RECINSTANTSOUND\" + "wave_instant_audio_" + _records_instant_counter + ".wav";
                    //var filename = @"D:\#RECINSTANTSOUND\" + "wave_instant_audio_" + _records_instant_counter + ".wav";

                    mciSendString("save recinstantsound " + filename, null, 0, IntPtr.Zero);
                    mciSendString("close recinstantsound", null, 0, IntPtr.Zero);

                    /*Process p = new Process();
                    p.StartInfo = new ProcessStartInfo()
                    {
                        FileName = short_path
                    };
                    p.Start();
                    p.Refresh();
                    p.Close();*/

                    DirectoryInfo dir = new DirectoryInfo(filename);
                    dir.Refresh();
                    if (!File.Exists(filename))
                    {
                        FileInfo filinfo = new FileInfo(filename);
                        filinfo.Refresh();
                    }

                    var nativeFileStream = new NativeFileStream(filename, NativeFileMode.Open, NativeFileAccess.Read, NativeFileShare.Read);
                    SoundStream soundStream = new SoundStream(nativeFileStream);
                    MemoryStream ms = new MemoryStream();

                    soundStream.CopyTo(ms);
                    _sound_byte_array_instant = ms.ToArray();

                    soundStream.Dispose();

                    ms.Dispose();
                    dir.Refresh();

                    if (File.Exists(filename))
                    {
                        File.Delete(filename);
                    }

                    _records_instant_counter++;
                    has_spoken_tier = 2;
                }


                if (has_spoken_main == 1)
                {
                    mciSendString("open new Type waveaudio Alias recinstantsound", null, 0, IntPtr.Zero);
                    mciSendString("record recinstantsound", null, 0, IntPtr.Zero);
                    //has_spoken_main = 1;
                }
            }

            if (sc_start_recording == 2)
            {
                if (sc_start_recording_counter >= 50)
                {
                    sc_save_file = 0;
                    //MessageBox((IntPtr)0, "" + sc_start_recording_counter + "", "Oculus Message", 0);
                    sc_start_recording = 0;
                    sc_start_recording_counter = 0;
                }
                sc_start_recording_counter++;
            }

            if (_frames_to_access_counter >= 0)
            {
                if (_records_counter > 0)
                {

                }
                //if (_frames_to_access == 0)
                //{
                //
                //    _frames_to_access = 1;
                //}

                _frames_to_access_counter = 0;
            }


            //SAVE SOUND
            if (MainWindow._keyboard_input._KeyboardState.PressedKeys.Contains(SharpDX.DirectInput.Key.S))
            {
                if (sc_start_recording == 1)
                {
                    if (sc_save_file == 0)
                    {

                        short_path = "wave_audio_" + _records_counter;
                        var filename = @"C:\Users\steve\Desktop\#RECSOUND\" + "wave_audio_" + _records_counter + ".wav";
                        mciSendString("save recsound " + filename, null, 0, IntPtr.Zero);
                        mciSendString("close recsound", null, 0, IntPtr.Zero);
                        _has_recorded = 1;
                        last_wave_filepath = filename;

                        string audiotype = "wave_audio_";

                        var stringtemp = short_path;
                        //"wave_audio_"
                        stringtemp.Substring(11, 1);
                        var info = new FileInfo(last_wave_filepath);
                        info.Refresh();



                        System.Globalization.CultureInfo customCulture = (System.Globalization.CultureInfo)System.Threading.Thread.CurrentThread.CurrentCulture.Clone();
                        customCulture.NumberFormat.NumberDecimalSeparator = ".";
                        System.Threading.Thread.CurrentThread.CurrentCulture = customCulture;

                        //short_path = "wave_audio_" + _records_counter;
                        //path = "c:\\Users\\steve\\Desktop\\testXML\\" + 0 + ".xml";
                        path = @"C:\Users\steve\Desktop\#RECSOUND\" + "wave_audio_" + _records_counter + ".xml";
                        last_xml_filepath = path;
                        //sc_can_start_rec_counter_before_add_index = sc_can_start_rec_counter;
                        //doc = new XmlDocument();
                        //writer = new XmlTextWriter(Console.Out);
                        writer = new XmlTextWriter(path, System.Text.Encoding.UTF8);
                        //sc_can_start_rec_counter_before_add_index = sc_can_start_rec_counter;

                        //root = doc.DocumentElement;

                        writer.WriteProcessingInstruction("xml", "version=\"1.0\" encoding=\"UTF-8\"");

                        writer.Formatting = Formatting.Indented;
                        writer.Indentation = 2;

                        writer.WriteStartElement("root"); // open 0
                        writer.WriteStartElement("wave"); // open 1
                        writer.WriteStartElement("data"); // open 2



                        writer.WriteStartElement("StartTime"); //open 3
                        writer.WriteString("" + _time_of_recording_start);
                        writer.WriteEndElement(); //close 3

                        _time_of_recording_end = DateTime.Now;
                        writer.WriteStartElement("EndTime"); //open 3
                        writer.WriteString("" + _time_of_recording_end);
                        writer.WriteEndElement(); //close 3

                        writer.WriteStartElement("size"); //open 3
                        long size = new System.IO.FileInfo(last_wave_filepath).Length;
                        writer.WriteString("" + size);
                        writer.WriteEndElement(); //close 3

                        writer.WriteStartElement("length"); //open 4
                        int length = GetSoundLength(last_wave_filepath);
                        writer.WriteString("" + length);
                        writer.WriteEndElement(); //close 4


                        writer.WriteEndElement(); //close 0
                        writer.WriteEndElement(); //close 1
                        writer.WriteEndElement(); //close 2

                        writer.Close();
                        //root.WriteTo(writer);

                        //doc.Save(path);

                        sc_can_start_rec_counter++;
                        _records_counter++;
                        //sc_save_file = 0;

                        var lastAccess = info.LastAccessTime;

                        //_index = sc_can_start_rec_counter_before_add_index + "";
                        _sound_player.AddWave(_records_counter - 1 + "", last_wave_filepath);

                        /*var nativeFileStream = new NativeFileStream(last_wave_filepath, NativeFileMode.Open, NativeFileAccess.Read, NativeFileShare.Read);
                        SoundStream soundStream = new SoundStream(nativeFileStream);
                        MemoryStream ms = new MemoryStream();

                        soundStream.CopyTo(ms);
                        _sound_byte_array = ms.ToArray();*/

                        var nativeFileStream = new NativeFileStream(last_wave_filepath, NativeFileMode.Open, NativeFileAccess.Read, NativeFileShare.Read);
                        SoundStream soundStream = new SoundStream(nativeFileStream);
                        MemoryStream ms = new MemoryStream();

                        soundStream.CopyTo(ms);
                        _sound_byte_array = ms.ToArray();

                        soundStream.Dispose();
                        ms.Dispose();

                        _sound_player.Play((_records_counter - 1) + "");
                        sc_start_recording = 2;
                        sc_save_file = 1;
                        has_spoken_main = 1;
                        has_spoken_sec = 1;
                        //has_spoken_tier = 0;
                        //has_spoken_quart = 0;
                    }
                }
            }

            //PLAY SOUND AT INDEX
            if (MainWindow._keyboard_input._KeyboardState.PressedKeys.Contains(SharpDX.DirectInput.Key.P))
            {
                if (sc_play_file == 0)
                {
                    if (File.Exists(last_wave_filepath))
                    {
                        _sound_player.Play((_records_counter - 1) + "");

                        //sc_can_start_rec_counter_before_add_index++;

                        //MessageBox((IntPtr)0, "" + stringtemp + "", "Oculus Message", 0);

                        //File.Delete(last_wave_filepath);
                        /*Process p = new Process();
                        p.StartInfo = new ProcessStartInfo()
                        {
                            FileName = last_wave_filepath
                        };
                        p.Start();
                        p.Refresh();
                        p.Close();*/

                        //int can_play_index= 0;

                        //Array.Sort(_sound_byte_array);
                        //_sound_byte_array.OrderBy(x > x).FirstOrDefault();
                        //lowestX = point3DCollection.OrderBy(x => x.X).FirstOrDefault();
                        //highestX = point3DCollection.OrderBy(x => x.X).Last();

                        //for (int s = 0; s < _sound_byte_array.Length;s++)
                        //{
                        //    if (_sound_byte_array[s] > 100)
                        //    {
                        //        MessageBox((IntPtr)0, "" + "has sound", "Oculus Message", 0);
                        //    }
                        //    //MessageBox((IntPtr)0, "" + "has recorded", "Oculus Error", 0);
                        //}
                        //_main_received_object[0]._someData[0] = _sound_byte_array;// new object[1];

                        ///MessageBox((IntPtr)0, "" + _sound_byte_array.Length, "_sc_core_systems error", 0);
                        //using (var soundStream = new SoundStream(nativeFileStream))
                        //{
                        //    using (MemoryStream ms = new MemoryStream())
                        //    {
                        //        soundStream.CopyTo(ms);
                        //        _sound_byte_array = ms.ToArray();
                        //        _main_received_messages[0]._someData[0] = _sound_byte_array;// new object[1];
                        //    }
                        //}

                        sc_play_file = 1;
                    }
                    else
                    {
                        //create blank file and start listening instead lol. kidding. nerd joke.
                    }
                }
            }

            if (sc_play_file == 1)
            {
                if (sc_play_file_counter >= 50)
                {
                    sc_play_file = 0;
                    sc_play_file_counter = 0;
                }
                sc_play_file_counter++;
            }

            //HEADSET POSITION
            displayMidpoint = SC_console_directx.D3D.OVR.GetPredictedDisplayTime(SC_console_directx.D3D.sessionPtr, 0);
            trackingState = SC_console_directx.D3D.OVR.GetTrackingState(SC_console_directx.D3D.sessionPtr, displayMidpoint, true);
            latencyMark = false;
            trackState = SC_console_directx.D3D.OVR.GetTrackingState(SC_console_directx.D3D.sessionPtr, 0.0f, latencyMark);
            poseStatefer = trackState.HeadPose;
            hmdPose = poseStatefer.ThePose;
            hmdRot = hmdPose.Orientation;
            _hmdPoser = new Vector3(hmdPose.Position.X, hmdPose.Position.Y, hmdPose.Position.Z);
            _hmdRoter = new Quaternion(hmdPose.Orientation.X, hmdPose.Orientation.Y, hmdPose.Orientation.Z, hmdPose.Orientation.W);
            //SET CAMERA POSITION
            //Camera.SetPosition(hmdPose.Position.X, hmdPose.Position.Y, hmdPose.Position.Z);
            Quaternion quatter = new Quaternion(hmdRot.X, hmdRot.Y, hmdRot.Z, hmdRot.W);
            oculusRiftDir = sc_maths._getDirection(Vector3.ForwardRH, quatter);

            Matrix.RotationQuaternion(ref quatter, out hmd_matrix_current);

            //TOUCH CONTROLLER RIGHT
            resultsRight = SC_console_directx.D3D.OVR.GetInputState(SC_console_directx.D3D.sessionPtr, SC_console_directx.D3D.controllerTypeRTouch, ref SC_console_directx.D3D.inputStateRTouch);
            buttonPressedOculusTouchRight = SC_console_directx.D3D.inputStateRTouch.Buttons;
            thumbStickRight = SC_console_directx.D3D.inputStateRTouch.Thumbstick;
            handTriggerRight = SC_console_directx.D3D.inputStateRTouch.HandTrigger;
            indexTriggerRight = SC_console_directx.D3D.inputStateRTouch.IndexTrigger;
            handPoseRight = trackingState.HandPoses[1].ThePose;

            _rightTouchQuat.X = handPoseRight.Orientation.X;
            _rightTouchQuat.Y = handPoseRight.Orientation.Y;
            _rightTouchQuat.Z = handPoseRight.Orientation.Z;
            _rightTouchQuat.W = handPoseRight.Orientation.W;

            _rightTouchQuat = new SharpDX.Quaternion(handPoseRight.Orientation.X, handPoseRight.Orientation.Y, handPoseRight.Orientation.Z, handPoseRight.Orientation.W);
            SharpDX.Matrix.RotationQuaternion(ref _rightTouchQuat, out _rightTouchMatrix);

            _rightTouchMatrix.M41 = handPoseRight.Position.X + SC_Update.originPos.X + SC_Update.movePos.X;
            _rightTouchMatrix.M42 = handPoseRight.Position.Y + SC_Update.originPos.Y + SC_Update.movePos.Y;
            _rightTouchMatrix.M43 = handPoseRight.Position.Z + SC_Update.originPos.Z + SC_Update.movePos.Z;

            //TOUCH CONTROLLER LEFT
            resultsLeft = SC_console_directx.D3D.OVR.GetInputState(SC_console_directx.D3D.sessionPtr, SC_console_directx.D3D.controllerTypeLTouch, ref SC_console_directx.D3D.inputStateLTouch);
            buttonPressedOculusTouchLeft = SC_console_directx.D3D.inputStateLTouch.Buttons;
            thumbStickLeft = SC_console_directx.D3D.inputStateLTouch.Thumbstick;
            handTriggerLeft = SC_console_directx.D3D.inputStateLTouch.HandTrigger;
            indexTriggerLeft = SC_console_directx.D3D.inputStateLTouch.IndexTrigger;
            handPoseLeft = trackingState.HandPoses[0].ThePose;

            _leftTouchQuat.X = handPoseLeft.Orientation.X;
            _leftTouchQuat.Y = handPoseLeft.Orientation.Y;
            _leftTouchQuat.Z = handPoseLeft.Orientation.Z;
            _leftTouchQuat.W = handPoseLeft.Orientation.W;

            _leftTouchQuat = new SharpDX.Quaternion(handPoseLeft.Orientation.X, handPoseLeft.Orientation.Y, handPoseLeft.Orientation.Z, handPoseLeft.Orientation.W);

            SharpDX.Matrix.RotationQuaternion(ref _leftTouchQuat, out _leftTouchMatrix);
            //_other_left_touch_matrix = _leftTouchMatrix;
            //_other_left_touch_matrix.M41 = handPoseLeft.Position.X;
            //_other_left_touch_matrix.M42 = handPoseLeft.Position.Y;
            //_other_left_touch_matrix.M43 = handPoseLeft.Position.Z;

            _leftTouchMatrix.M41 = handPoseLeft.Position.X + SC_Update.originPos.X + SC_Update.movePos.X;
            _leftTouchMatrix.M42 = handPoseLeft.Position.Y + SC_Update.originPos.Y + SC_Update.movePos.Y;
            _leftTouchMatrix.M43 = handPoseLeft.Position.Z + SC_Update.originPos.Z + SC_Update.movePos.Z;

            //TO READD FOR SOME LOCK SCREEN IN SCENE LOGIC
            //TO READD FOR SOME LOCK SCREEN IN SCENE LOGIC
            //TO READD FOR SOME LOCK SCREEN IN SCENE LOGIC

            if (_has_locked_screen_pos == 0)
            {
                if (had_locked_screen == 0)
                {
                    tempMatrix = ikarmvoxel[0]._player_rght_hnd[0][0]._arrayOfInstances[0].current_pos;

                    Vector3 savingPos = new Vector3(tempMatrix.M41, tempMatrix.M42, tempMatrix.M43);

                    Quaternion _testQuator;
                    Quaternion.RotationMatrix(ref tempMatrix, out _testQuator);

                    float xq = _testQuator.X;
                    float yq = _testQuator.Y;
                    float zq = _testQuator.Z;
                    float wq = _testQuator.W;
                    float roll = (float)(Math.Atan2(2 * yq * wq - 2 * xq * zq, 1 - 2 * yq * yq - 2 * zq * zq) * (180 / Math.PI));
                    float pitch = (float)(Math.Atan2(2 * yq * wq - 2 * xq * zq, 1 - 2 * yq * yq - 2 * zq * zq) * (180 / Math.PI));
                    float yaw = (float)(Math.Atan2(2 * yq * wq - 2 * xq * zq, 1 - 2 * yq * yq - 2 * zq * zq) * (180 / Math.PI));

                    //RotationScreenX = pitch;
                    //RotationScreenY = yaw;
                    //RotationScreenZ = roll;

                    _current_screen_pos = _direction_offsetter * tempMatrix;

                    _current_screen_pos.M41 = savingPos.X;
                    _current_screen_pos.M42 = savingPos.Y;
                    _current_screen_pos.M43 = savingPos.Z;

                    _last_screen_pos = tempMatrix;

                }
                else if (had_locked_screen == 1)
                {
                    _last_screen_pos = _world_screen_list[0][0]._arrayOfInstances[0].current_pos;
                    had_locked_screen = 0;
                }

                _current_screen_pos = _world_screen_list[0][0]._arrayOfInstances[0].current_pos;
                _last_screen_pos = _world_screen_list[0][0]._arrayOfInstances[0].current_pos;// worldMatrix_instances_screens[0][0];

                /*Matrix _temp_mat = finalRotationMatrix;
                Quaternion _testQuator;
                Quaternion.RotationMatrix(ref _temp_mat, out _testQuator);

                xq = _testQuator.X;
                yq = _testQuator.Y;
                zq = _testQuator.Z;
                wq = _testQuator.W;

                //temproll = (float)(Math.Atan2(2 * yq * wq - 2 * xq * zq, 1 - 2 * yq * yq - 2 * zq * zq));// * (180 / Math.PI));
                //pitch = (float)(Math.Atan2(2 * yq * wq - 2 * xq * zq, 1 - 2 * yq * yq - 2 * zq * zq) * (180 / Math.PI));//
                //tempyaw = (float)(Math.Atan2(2 * yq * wq - 2 * xq * zq, 1 - 2 * yq * yq - 2 * zq * zq));// * (180 / Math.PI));
                */
                had_locked_screen = 0;

            }
            else if (_has_locked_screen_pos == 1)
            {
                if (had_locked_screen == 0)
                {
                    Quaternion _testQuator;
                    Quaternion.RotationMatrix(ref _last_screen_pos, out _testQuator);

                    float xq = _testQuator.X;
                    float yq = _testQuator.Y;
                    float zq = _testQuator.Z;
                    float wq = _testQuator.W;

                    float roll = (float)(Math.Atan2(2 * yq * wq - 2 * xq * zq, 1 - 2 * yq * yq - 2 * zq * zq));// * (180 / Math.PI));
                    float pitch = (float)(Math.Atan2(2 * yq * wq - 2 * xq * zq, 1 - 2 * yq * yq - 2 * zq * zq) * (180 / Math.PI));//
                    float yaw = (float)(Math.Atan2(2 * yq * wq - 2 * xq * zq, 1 - 2 * yq * yq - 2 * zq * zq));// * (180 / Math.PI));

                    hmd_matrix_current = hmd_matrix_current * OriginRot * RotatingMatrix * RotatingMatrixForPelvis;
                    Quaternion.RotationMatrix(ref hmd_matrix_current, out _testQuator);

                    xq = _testQuator.X;
                    yq = _testQuator.Y;
                    zq = _testQuator.Z;
                    wq = _testQuator.W;

                    float roller = (float)(Math.Atan2(2 * yq * wq - 2 * xq * zq, 1 - 2 * yq * yq - 2 * zq * zq));// * (180 / Math.PI));
                    float pitcher = (float)(Math.Atan2(2 * yq * wq - 2 * xq * zq, 1 - 2 * yq * yq - 2 * zq * zq) * (180 / Math.PI));//
                    float yawer = (float)(Math.Atan2(2 * yq * wq - 2 * xq * zq, 1 - 2 * yq * yq - 2 * zq * zq));// * (180 / Math.PI));

                    pitch = (float)((Math.PI * pitcher + 45) / 180);
                    roll = (float)(0);

                    tempMatrix = SharpDX.Matrix.RotationYawPitchRoll(pitch, 0, roll);

                    tempMatrix.M41 = _last_screen_pos.M41;
                    tempMatrix.M42 = _last_screen_pos.M42;
                    tempMatrix.M43 = _last_screen_pos.M43;

                    _current_screen_pos = tempMatrix; //_direction_offsetter

                    float somediffx = _current_screen_pos.M41 - SC_Update.OFFSETPOS.X;
                    float somediffy = _current_screen_pos.M42 - SC_Update.OFFSETPOS.Y;
                    float somediffz = _current_screen_pos.M43 - SC_Update.OFFSETPOS.Z;

                    //_current_screen_pos.M41 = _last_screen_pos.M41;
                    //_current_screen_pos.M42 = _last_screen_pos.M42;
                    //_current_screen_pos.M43 = _last_screen_pos.M43;


                    //OFFSETPOS, originRot, rotatingMatrix, hmdmatrixRot, hmd_matrix, rotatingMatrixForPelvis

                    _current_screen_pos = SC_Update.originRot * SC_Update.rotatingMatrix * SC_Update.rotatingMatrixForPelvis * SC_Update.hmdmatrixRot;

                    Quaternion somequat;
                    Quaternion.RotationMatrix(ref _current_screen_pos, out somequat);

                    Vector3 forwardcurrentpos = sc_maths._getDirection(Vector3.ForwardRH, somequat);

                    //_current_screen_pos = SC_Update.ori


                    _current_screen_pos.M41 = SC_Update.OFFSETPOS.X;
                    _current_screen_pos.M42 = SC_Update.OFFSETPOS.Y;
                    _current_screen_pos.M43 = SC_Update.OFFSETPOS.Z;


                    //_current_screen_pos.M41 += somediffx;
                    //_current_screen_pos.M42 += somediffy;
                    //_current_screen_pos.M43 += somediffz;

                    _current_screen_pos.M41 += forwardcurrentpos.X;
                    _current_screen_pos.M42 += forwardcurrentpos.Y;
                    _current_screen_pos.M43 += forwardcurrentpos.Z;


                    had_locked_screen = 1;
                }
            }
            //TO READD FOR SOME LOCK SCREEN IN SCENE LOGIC
            //TO READD FOR SOME LOCK SCREEN IN SCENE LOGIC
            //TO READD FOR SOME LOCK SCREEN IN SCENE LOGIC







            //float somediffx = _current_screen_pos.M41 - SC_Update.OFFSETPOS.X;
            //float somediffy = _current_screen_pos.M42 - SC_Update.OFFSETPOS.Y;
            //float somediffz = _current_screen_pos.M43 - SC_Update.OFFSETPOS.Z;



            //SETTING THE POSITION OF THE SCREEN
            //SETTING THE POSITION OF THE SCREEN
            //SETTING THE POSITION OF THE SCREEN
            //_world_screen_list[0][0]._arrayOfInstances[0]._POSITION= SC_Update._rightTouchMatrix;
            _world_screen_list[0][0]._arrayOfInstances[0].current_pos = _current_screen_pos;//_player_l_hand_grab[0][0]._arrayOfInstances[0].current_pos;// _current_screen_pos;// _player_l_hand_grab[0][0]._arrayOfInstances[0].current_pos;// originRot * rotatingMatrix * rotatingMatrixForPelvis * SC_Update._leftTouchMatrix;
            worldMatrix_instances_screens[0][0][0] = _world_screen_list[0][0]._arrayOfInstances[0].current_pos;
            worldMatrix_instances_containment_grid_screen[0][0][0] = _world_screen_list[0][0]._arrayOfInstances[0].current_pos;
            _world_containment_grid_screen[0][0]._arrayOfInstances[0].current_pos = _world_screen_list[0][0]._arrayOfInstances[0].current_pos;
            //SETTING THE POSITION OF THE SCREEN
            //SETTING THE POSITION OF THE SCREEN
            //SETTING THE POSITION OF THE SCREEN









            /*screen_mat = _world_screen_list[0][0]._arrayOfInstances[0].current_pos;//_player_lft_hnd[0]._arrayOfInstances[0].current_pos; 

            
            //Quaternion _quat_screen;
            Quaternion.RotationMatrix(ref screen_mat, out _quat_screen);
             screenNormal = sc_maths._getDirection(Vector3.ForwardRH, _quat_screen);
            screenNormal.Normalize();
             planer = new Plane(new Vector3(screen_mat.M41, screen_mat.M42, screen_mat.M43), screenNormal);

            Vector3 screenPos = new Vector3(_world_screen_list[0][0]._arrayOfInstances[0].current_pos.M41, _world_screen_list[0][0]._arrayOfInstances[0].current_pos.M42, _world_screen_list[0][0]._arrayOfInstances[0].current_pos.M43);
            float distancer;
            Vector3.Distance(ref screenPos, ref SC_Update.OFFSETPOS, out distancer);
            screen_mat = _world_screen_list[0][0]._arrayOfInstances[0].current_pos;*/

            //SCREEN HMDPOINTER
            /*if (_out_of_bounds_oculus_rift == 1)// || distancer >= 4)
            {
                var tester00 = new Vector3(_screenDirMatrix_correct_pos[0][2].M41, _screenDirMatrix_correct_pos[0][2].M42, _screenDirMatrix_correct_pos[0][2].M43);
                _oculusR_Cursor_matrix = screen_mat;

                _oculusR_Cursor_matrix.M41 = tester00.X;
                _oculusR_Cursor_matrix.M42 = tester00.Y;
                _oculusR_Cursor_matrix.M43 = tester00.Z;
                worldMatrix_instances_screen_assets[0][4] = _oculusR_Cursor_matrix;
            }
            else
            {
                worldMatrix_instances_screen_assets[0][4] = _oculusR_Cursor_matrix;
            }*/
            //END OF 

            //OCULUS TOUCH RIGHT
            /*if (_out_of_bounds_right == 1)// || distancer >= 4)
            {
                Vector3 tester00 = new Vector3(_screenDirMatrix_correct_pos[0][0][2].M41, _screenDirMatrix_correct_pos[0][0][2].M42, _screenDirMatrix_correct_pos[0][0][2].M43);
                _intersectTouchRightMatrix = screen_mat;

                _intersectTouchRightMatrix.M41 = tester00.X;
                _intersectTouchRightMatrix.M42 = tester00.Y;
                _intersectTouchRightMatrix.M43 = tester00.Z;
                worldMatrix_instances_screen_assets[0][0][5] = _intersectTouchRightMatrix;

            }
            else
            {
                Vector3 tester00 = new Vector3(intersectPointRight.X, intersectPointRight.Y, intersectPointRight.Z);
                _intersectTouchRightMatrix = screen_mat;

                _intersectTouchRightMatrix.M41 = tester00.X;
                _intersectTouchRightMatrix.M42 = tester00.Y;
                _intersectTouchRightMatrix.M43 = tester00.Z;
                worldMatrix_instances_screen_assets[0][0][5] = _intersectTouchRightMatrix;
            }*/


            /*Vector3 tester01 = new Vector3(intersectPointRight.X, intersectPointRight.Y, intersectPointRight.Z);
            var newmatrix = screen_mat;
            newmatrix.M41 = tester01.X;
            newmatrix.M42 = tester01.Y;
            newmatrix.M43 = tester01.Z;*/










            //NORMAL SCREEN CALCULATION
            tempMatrix = worldMatrix_instances_screens[0][0][0];
            Quaternion.RotationMatrix(ref tempMatrix, out _testQuater);
            var screenNormalRight = sc_maths._getDirection(Vector3.Right, _testQuater);
            screenNormalRight.Normalize();
            var screenNormalUp = sc_maths._getDirection(Vector3.Up, _testQuater);
            screenNormalUp.Normalize();









            var tempMatRight = _intersectTouchRightMatrix;


            worldMatrix_instances_screen_assets[0][0][5] = _intersectTouchRightMatrix;
            worldMatrix_instances_screen_assets[0][0][6] = _intersectTouchLeftMatrix;
            worldMatrix_instances_screen_assets[0][0][7] = _oculusR_Cursor_matrix;





            centerPosRight = new Vector3(final_hand_pos_right_locked.M41, final_hand_pos_right_locked.M42, final_hand_pos_right_locked.M43);
            Quaternion.RotationMatrix(ref final_hand_pos_right_locked, out _rightTouchQuat);
            rayDirRighter = sc_maths._getDirection(Vector3.ForwardRH, _rightTouchQuat);
            someRay = new Ray(centerPosRight, rayDirRighter);
            intersecter = someRay.Intersects(ref planer, out intersectPointRight);



            centerPosLeft = new Vector3(final_hand_pos_left_locked.M41, final_hand_pos_left_locked.M42, final_hand_pos_left_locked.M43);
            Quaternion.RotationMatrix(ref final_hand_pos_left_locked, out _leftTouchQuat);
            rayDirLeft = sc_maths._getDirection(Vector3.ForwardRH, _leftTouchQuat);
            someRayLeft = new Ray(centerPosLeft, rayDirLeft);
            intersecterLeft = someRayLeft.Intersects(ref planer, out intersectPointLeft);






















            Vector3 currentScreenPos = new Vector3(tempMatrix.M41, tempMatrix.M42, tempMatrix.M43); // new Vector3(xii, yii, zii);// new Vector3(_finalRotMatrixScreen.M41, _finalRotMatrixScreen.M42, _finalRotMatrixScreen.M43);
            Vector3 newDirRight = (screenNormalRight) * sizeWidtherer; // + screenNormalTop
            currentScreenPos -= newDirRight;
            Vector3 newDirUp = (screenNormalUp) * sizeheighterer; // + screenNormalTop
            currentScreenPos -= newDirUp;
            Matrix resulter0 = tempMatrix;
            resulter0.M41 = currentScreenPos.X;
            resulter0.M42 = currentScreenPos.Y;
            resulter0.M43 = currentScreenPos.Z;
            _screenDirMatrix_correct_pos[0][0][0] = resulter0;

            currentScreenPos = new Vector3(tempMatrix.M41, tempMatrix.M42, tempMatrix.M43);
            newDirRight = (screenNormalRight) * sizeWidtherer;
            currentScreenPos -= newDirRight;
            newDirUp = (screenNormalUp) * sizeheighterer;
            currentScreenPos += newDirUp;
            resulter0 = tempMatrix;
            resulter0.M41 = currentScreenPos.X;
            resulter0.M42 = currentScreenPos.Y;
            resulter0.M43 = currentScreenPos.Z;
            _screenDirMatrix_correct_pos[0][0][1] = resulter0;

            currentScreenPos = new Vector3(tempMatrix.M41, tempMatrix.M42, tempMatrix.M43);
            newDirRight = (screenNormalRight) * sizeWidtherer;
            currentScreenPos += newDirRight;
            newDirUp = (screenNormalUp) * sizeheighterer;
            currentScreenPos -= newDirUp;
            resulter0 = tempMatrix;
            resulter0.M41 = currentScreenPos.X;
            resulter0.M42 = currentScreenPos.Y;
            resulter0.M43 = currentScreenPos.Z;
            _screenDirMatrix_correct_pos[0][0][2] = resulter0;

            currentScreenPos = new Vector3(tempMatrix.M41, tempMatrix.M42, tempMatrix.M43);
            newDirRight = (screenNormalRight) * sizeWidtherer;
            currentScreenPos += newDirRight;
            newDirUp = (screenNormalUp) * sizeheighterer;
            currentScreenPos += newDirUp;
            resulter0 = tempMatrix;
            resulter0.M41 = currentScreenPos.X;
            resulter0.M42 = currentScreenPos.Y;
            resulter0.M43 = currentScreenPos.Z;
            _screenDirMatrix_correct_pos[0][0][3] = resulter0;

            /*for (int x = 0; x < _physics_engine_instance_x; x++)
            {
                for (int y = 0; y < _physics_engine_instance_y; y++)
                {
                    for (int z = 0; z < _physics_engine_instance_z; z++)
                    {
                        var _index = x + _physics_engine_instance_x * (y + _physics_engine_instance_y * z);

                        for (int i = 0; i < worldMatrix_instances_screen_assets[0].Length; i++)
                        {
                            Matrix matrixor = _screenDirMatrix_correct_pos[0][i];
                            worldMatrix_instances_screen_assets[0][i] = matrixor;
                        }
                    }
                }
            }*/
            for (int i = 0; i < 4; i++) //worldMatrix_instances_screen_assets[0].Length
            {
                worldMatrix_instances_screen_assets[0][0][i] = _screenDirMatrix_correct_pos[0][0][i];
            }

            //RIGHT CONTROLLER HITPOINT
            if (currentFrameRight < arrayOfStabilizerPosRight.Length)
            {
                arrayOfStabilizerPosXRight[currentFrameRight] = intersectPointRight.X;
                arrayOfStabilizerPosYRight[currentFrameRight] = intersectPointRight.Y;
                arrayOfStabilizerPosZRight[currentFrameRight] = intersectPointRight.Z;

                arrayOfStabilizerPosRight[currentFrameRight] = intersectPointRight;
            }
            else
            {
                differenceX = 0;
                differenceY = 0;
                differenceZ = 0;

                int j = 1;

                for (int i = 0; i < arrayOfStabilizerPosXRight.Length - 1; i++, j++)
                {
                    currentX = arrayOfStabilizerPosXRight[j];
                    currentY = arrayOfStabilizerPosYRight[j];
                    currentZ = arrayOfStabilizerPosZRight[j];

                    lastRightHitPointXFrameOne = arrayOfStabilizerPosXRight[i];
                    lastRightHitPointYFrameOne = arrayOfStabilizerPosYRight[i];
                    lastRightHitPointZFrameOne = arrayOfStabilizerPosZRight[i];

                    if (lastRightHitPointXFrameOne >= currentX)
                    {
                        differenceX = lastRightHitPointXFrameOne - currentX;
                    }
                    else
                    {
                        differenceX = currentX - lastRightHitPointXFrameOne;
                    }
                    arrayOfStabilizerPosDifferenceXRight[i] = differenceX;


                    if (lastRightHitPointYFrameOne >= currentY)
                    {
                        differenceY = lastRightHitPointYFrameOne - currentY;
                    }
                    else
                    {
                        differenceY = currentY - lastRightHitPointYFrameOne;
                    }
                    arrayOfStabilizerPosDifferenceYRight[i] = differenceY;


                    if (lastRightHitPointZFrameOne >= currentZ)
                    {
                        differenceZ = lastRightHitPointZFrameOne - currentZ;
                    }
                    else
                    {
                        differenceZ = currentZ - lastRightHitPointZFrameOne;
                    }
                    arrayOfStabilizerPosDifferenceZRight[i] = differenceZ;
                }

                averageXRight = 0;
                averageYRight = 0;
                averageZRight = 0;

                for (int i = 0; i < arrayOfStabilizerPosDifferenceXRight.Length; i++)
                {
                    averageXRight += arrayOfStabilizerPosDifferenceXRight[i];
                    averageYRight += arrayOfStabilizerPosDifferenceYRight[i];
                    averageZRight += arrayOfStabilizerPosDifferenceZRight[i];
                }

                averageXRight = averageXRight / arrayOfStabilizerPosDifferenceXRight.Length;
                averageYRight = averageYRight / arrayOfStabilizerPosDifferenceYRight.Length;
                averageZRight = averageZRight / arrayOfStabilizerPosDifferenceZRight.Length;
                restartFrameCounterRight = true;
            }

            if (!restartFrameCounterRight)
            {
                currentFrameRight++;
            }
            else
            {
                currentFrameRight = 0;
                restartFrameCounterRight = false;
            }

            positionXRight = 0;
            positionYRight = 0;
            positionZRight = 0;

            for (int i = 0; i < arrayOfStabilizerPosRight.Length; i++)
            {
                positionXRight += arrayOfStabilizerPosRight[i].X;
                positionYRight += arrayOfStabilizerPosRight[i].Y;
                positionZRight += arrayOfStabilizerPosRight[i].Z;
            }

            positionXRight = positionXRight / arrayOfStabilizerPosRight.Length;
            positionYRight = positionYRight / arrayOfStabilizerPosRight.Length;
            positionZRight = positionZRight / arrayOfStabilizerPosRight.Length;

            stabilizedIntersectionPosRight = new Vector3((float)positionXRight, (float)positionYRight, (float)positionZRight);

            _intersectTouchRightMatrix = _world_screen_list[0][0]._arrayOfInstances[0].current_pos;
            _intersectTouchRightMatrix.M41 = stabilizedIntersectionPosRight.X;
            _intersectTouchRightMatrix.M42 = stabilizedIntersectionPosRight.Y;
            _intersectTouchRightMatrix.M43 = stabilizedIntersectionPosRight.Z;

            var vert0 = new Vector3(_screenDirMatrix_correct_pos[0][0][0].M41, _screenDirMatrix_correct_pos[0][0][0].M42, _screenDirMatrix_correct_pos[0][0][0].M43);
            var vert1 = new Vector3(_screenDirMatrix_correct_pos[0][0][1].M41, _screenDirMatrix_correct_pos[0][0][1].M42, _screenDirMatrix_correct_pos[0][0][1].M43);
            var vert2 = new Vector3(_screenDirMatrix_correct_pos[0][0][2].M41, _screenDirMatrix_correct_pos[0][0][2].M42, _screenDirMatrix_correct_pos[0][0][2].M43);
            var vert3 = new Vector3(_screenDirMatrix_correct_pos[0][0][3].M41, _screenDirMatrix_correct_pos[0][0][3].M42, _screenDirMatrix_correct_pos[0][0][3].M43);

            var pointOnScreen = new Vector3(_intersectTouchRightMatrix.M41, _intersectTouchRightMatrix.M42, _intersectTouchRightMatrix.M43);
            //var pointOnScreen = new Vector3(intersectPointRight.X, intersectPointRight.Y, intersectPointRight.Z);

            var d = (vert2 - vert0).Length();
            widthLength = (vert2 - vert0).Length();
            heightLength = (vert1 - vert0).Length();
            r = (pointOnScreen - vert0).Length();
            var R = (pointOnScreen - vert2).Length();
            var xcirccirc = ((d * d) - (r * r) + (R * R)) / (2 * d);
            var d1 = xcirccirc;
            var d2 = d - xcirccirc;

            //r is with d2
            //R is with d1
            //a2 + b2 = c2

            b = (float)Math.Sqrt((r * r) - (d2 * d2));
            currentPosWidth = widthLength - d1; // 
            currentPosHeight = heightLength - b;
            percentXRight = currentPosWidth / widthLength;
            percentYRight = currentPosHeight / heightLength;
            percentXRight *= SC_console_directx.D3D.SurfaceWidth;
            percentYRight *= SC_console_directx.D3D.SurfaceHeight;






            //LEFT CONTROLLER HITPOINT
            //////////////////////////////////////////////////////////////////////////

            if (currentFrameLeft < arrayOfStabilizerPosLeft.Length)
            {
                arrayOfStabilizerPosXLeft[currentFrameLeft] = intersectPointLeft.X;
                arrayOfStabilizerPosYLeft[currentFrameLeft] = intersectPointLeft.Y;
                arrayOfStabilizerPosZLeft[currentFrameLeft] = intersectPointLeft.Z;
                arrayOfStabilizerPosLeft[currentFrameLeft] = intersectPointLeft;
            }
            else
            {
                differenceX = 0;
                differenceY = 0;
                differenceZ = 0;

                int j = 1;
                for (int i = 0; i < arrayOfStabilizerPosXLeft.Length - 1; i++, j++)
                {
                    currentX = arrayOfStabilizerPosXLeft[j];
                    currentY = arrayOfStabilizerPosYLeft[j];
                    currentZ = arrayOfStabilizerPosZLeft[j];

                    lastLeftHitPointXFrameOne = arrayOfStabilizerPosXLeft[i];
                    lastLeftHitPointYFrameOne = arrayOfStabilizerPosYLeft[i];
                    lastLeftHitPointZFrameOne = arrayOfStabilizerPosZLeft[i];

                    if (lastLeftHitPointXFrameOne >= currentX)
                    {
                        differenceX = lastLeftHitPointXFrameOne - currentX;
                    }
                    else
                    {
                        differenceX = currentX - lastLeftHitPointXFrameOne;
                    }
                    arrayOfStabilizerPosDifferenceXLeft[i] = differenceX;

                    if (lastLeftHitPointYFrameOne >= currentY)
                    {
                        differenceY = lastLeftHitPointYFrameOne - currentY;
                    }
                    else
                    {
                        differenceY = currentY - lastLeftHitPointYFrameOne;
                    }
                    arrayOfStabilizerPosDifferenceYLeft[i] = differenceY;


                    if (lastLeftHitPointZFrameOne >= currentZ)
                    {
                        differenceZ = lastLeftHitPointZFrameOne - currentZ;
                    }
                    else
                    {
                        differenceZ = currentZ - lastLeftHitPointZFrameOne;
                    }
                    arrayOfStabilizerPosDifferenceZLeft[i] = differenceZ;
                }

                averageXLeft = 0;
                averageYLeft = 0;
                averageZLeft = 0;


                for (int i = 0; i < arrayOfStabilizerPosDifferenceXLeft.Length; i++)
                {
                    averageXLeft += arrayOfStabilizerPosDifferenceXLeft[i];
                    averageYLeft += arrayOfStabilizerPosDifferenceYLeft[i];
                    averageZLeft += arrayOfStabilizerPosDifferenceZLeft[i];
                }

                averageXLeft = averageXLeft / arrayOfStabilizerPosDifferenceXLeft.Length;
                averageYLeft = averageYLeft / arrayOfStabilizerPosDifferenceYLeft.Length;
                averageZLeft = averageZLeft / arrayOfStabilizerPosDifferenceZLeft.Length;

                restartFrameCounterLeft = true;
            }

            if (!restartFrameCounterLeft)
            {
                currentFrameLeft++;
            }
            else
            {
                currentFrameLeft = 0;
                restartFrameCounterLeft = false;
            }

            positionXLeft = 0;
            positionYLeft = 0;
            positionZLeft = 0;

            for (int i = 0; i < arrayOfStabilizerPosLeft.Length; i++)
            {
                positionXLeft += arrayOfStabilizerPosLeft[i].X;
                positionYLeft += arrayOfStabilizerPosLeft[i].Y;
                positionZLeft += arrayOfStabilizerPosLeft[i].Z;
            }

            positionXLeft = positionXLeft / arrayOfStabilizerPosLeft.Length;
            positionYLeft = positionYLeft / arrayOfStabilizerPosLeft.Length;
            positionZLeft = positionZLeft / arrayOfStabilizerPosLeft.Length;

            stabilizedIntersectionPosLeft = new Vector3((float)positionXLeft, (float)positionYLeft, (float)positionZLeft);

            _intersectTouchLeftMatrix = _world_screen_list[0][0]._arrayOfInstances[0].current_pos;
            _intersectTouchLeftMatrix.M41 = stabilizedIntersectionPosLeft.X;
            _intersectTouchLeftMatrix.M42 = stabilizedIntersectionPosLeft.Y;
            _intersectTouchLeftMatrix.M43 = stabilizedIntersectionPosLeft.Z;

            pointOnScreen = new Vector3(intersectPointLeft.X, intersectPointLeft.Y, intersectPointLeft.Z);

            d = (vert2 - vert0).Length();
            widthLength = (vert2 - vert0).Length();
            heightLength = (vert1 - vert0).Length();
            r = (pointOnScreen - vert0).Length();
            R = (pointOnScreen - vert2).Length();
            xcirccirc = ((d * d) - (r * r) + (R * R)) / (2 * d);
            d1 = xcirccirc;
            d2 = d - xcirccirc;

            //r is with d2
            //R is with d1
            //a2 + b2 = c2

            b = (float)Math.Sqrt((r * r) - (d2 * d2));
            currentPosWidth = widthLength - d1; // 
            currentPosHeight = heightLength - b;
            percentXLeft = currentPosWidth / widthLength;
            percentYLeft = currentPosHeight / heightLength;
            percentXLeft *= SC_console_directx.D3D.SurfaceWidth;
            percentYLeft *= SC_console_directx.D3D.SurfaceHeight;

















            //HMD POINTER
            somematroxer2 = _world_screen_list[0][0]._arrayOfInstances[0].current_pos;
            var screenNormaler = sc_maths._getDirection(Vector3.ForwardRH, _testQuater);
            var planor = new Plane(new Vector3(_world_screen_list[0][0]._arrayOfInstances[0].current_pos.M41, _world_screen_list[0][0]._arrayOfInstances[0].current_pos.M42, _world_screen_list[0][0]._arrayOfInstances[0].current_pos.M43), screenNormaler);
            var centerPosOculusRift = new Vector3(_hmdPoser.X, _hmdPoser.Y, _hmdPoser.Z) + SC_Update.OFFSETPOS;
            Matrix oculusRifter;
            Matrix.RotationQuaternion(ref _hmdRoter, out oculusRifter);
            oculusRifter = oculusRifter * OriginRot * RotatingMatrix * RotatingMatrixForPelvis;
            Quaternion some_oculus_quat;
            Quaternion.RotationMatrix(ref oculusRifter, out some_oculus_quat);
            var rayDirRighterer = sc_maths._getDirection(Vector3.ForwardRH, some_oculus_quat);
            rayDirRighterer.Normalize();
            var someRayer = new Ray(centerPosOculusRift, rayDirRighterer);
            Vector3 intersectPointHMD;
            var intersecterHMD = someRayer.Intersects(ref planor, out intersectPointHMD);
            somematroxer2.M41 = intersectPointHMD.X;
            somematroxer2.M42 = intersectPointHMD.Y;
            somematroxer2.M43 = intersectPointHMD.Z;
            //CIRCLE CIRCLE INTERSECTION //http://mathworld.wolfram.com/Circle-CircleIntersection.html
            pointOnScreen = new Vector3(intersectPointHMD.X, intersectPointHMD.Y, intersectPointHMD.Z);
            d = (vert2 - vert0).Length();
            widthLength = (vert2 - vert0).Length();
            heightLength = (vert1 - vert0).Length();
            r = (pointOnScreen - vert0).Length();
            R = (pointOnScreen - vert2).Length();
            xcirccirc = ((d * d) - (r * r) + (R * R)) / (2 * d);
            d1 = xcirccirc;
            d2 = d - xcirccirc;
            //r is with d2
            //R is with d1
            //a2 + b2 = c2
            b = (float)Math.Sqrt((r * r) - (d2 * d2));
            currentPosWidth = widthLength - d1; // 
            currentPosHeight = heightLength - b;
            var percentXRift = currentPosWidth / widthLength;
            var percentYRift = currentPosHeight / heightLength;
            percentXRift *= SC_console_directx.D3D.SurfaceWidth;
            percentYRift *= SC_console_directx.D3D.SurfaceHeight;
            var realOculusRiftCursorPosX = percentXRift;
            var realOculusRiftCursorPosY = percentYRift;



            if (realOculusRiftCursorPosX >= 0 && realOculusRiftCursorPosX <= SC_console_directx.D3D.SurfaceWidth && realOculusRiftCursorPosY >= 0 && realOculusRiftCursorPosY <= SC_console_directx.D3D.SurfaceHeight)
            {
                _oculusR_Cursor_matrix = somematroxer2;

                worldMatrix_instances_screen_assets[0][0][5] = _intersectTouchRightMatrix;
                worldMatrix_instances_screen_assets[0][0][6] = _intersectTouchLeftMatrix;
                worldMatrix_instances_screen_assets[0][0][7] = _oculusR_Cursor_matrix;


                _out_of_bounds_oculus_rift = 0;
            }
            else
            {
                worldMatrix_instances_screen_assets[0][0][5] = worldMatrix_instances_screen_assets[0][0][0];
                worldMatrix_instances_screen_assets[0][0][6] = worldMatrix_instances_screen_assets[0][0][0];
                worldMatrix_instances_screen_assets[0][0][7] = worldMatrix_instances_screen_assets[0][0][0];

                _out_of_bounds_oculus_rift = 1;
            }

            if (percentXRight >= 0 && percentXRight < SC_console_directx.D3D.SurfaceWidth && percentYRight >= 0 && percentYRight < SC_console_directx.D3D.SurfaceHeight)
            {
                _MicrosoftWindowsMouseRight(percentXRight, percentYRight, thumbStickRight, percentXLeft, percentYLeft, thumbStickLeft, percentXRight, percentYRight);
            }




            _oculus_touch_controls(percentXRight, percentYRight, thumbStickRight, percentXLeft, percentYLeft, thumbStickLeft, percentXRight, percentYRight);


            //DISCARDED TO REINSERT
            //DISCARDED TO REINSERT
            //DISCARDED TO REINSERT
            lastHasUsedHandTriggerLeft = hasUsedHandTriggerLeft;
            lastbuttonPressedOculusTouchRight = buttonPressedOculusTouchRight;
            lastbuttonPressedOculusTouchLeft = buttonPressedOculusTouchLeft;

            final_hand_pos_right_locked = ikarmvoxel[3]._player_rght_hnd[0][0]._arrayOfInstances[0].current_pos;
            final_hand_pos_left_locked = ikarmvoxel[0]._player_rght_hnd[0][0]._arrayOfInstances[0].current_pos;
            _last_final_hand_pos_right = new Vector3(ikarmvoxel[3]._player_rght_hnd[0][0]._arrayOfInstances[0].current_pos.M41, ikarmvoxel[3]._player_rght_hnd[0][0]._arrayOfInstances[0].current_pos.M42, ikarmvoxel[3]._player_rght_hnd[0][0]._arrayOfInstances[0].current_pos.M43);
            _last_frame_handPos = new Vector3(ikarmvoxel[3]._player_rght_hnd[0][0]._arrayOfInstances[0].current_pos.M41, ikarmvoxel[3]._player_rght_hnd[0][0]._arrayOfInstances[0].current_pos.M42, ikarmvoxel[3]._player_rght_hnd[0][0]._arrayOfInstances[0].current_pos.M43);
            ///DISCARDED TO REINSERT
            //DISCARDED TO REINSERT
            //DISCARDED TO REINSERT

        }







        public unsafe scmessageobjectjitter[][] workonshaders(scgraphicssecpackage scgraphicssecpackagemessage)
        {
            // , ,,, ,,, , ,, , , 
            scmessageobjectjitter[][] _sc_jitter_tasks = scgraphicssecpackagemessage.scjittertasks;
            Matrix viewMatrix = scgraphicssecpackagemessage.viewMatrix;
            Matrix projectionMatrix = scgraphicssecpackagemessage.projectionMatrix; //_projectionMatrix;
            Matrix originRot = scgraphicssecpackagemessage.originRot; // originRot;
            Matrix rotatingMatrix = scgraphicssecpackagemessage.rotatingMatrix; //rotatingMatrix;
            Matrix hmdrotMatrix = scgraphicssecpackagemessage.hmdmatrixRot; //hmdmatrixRot;
            Matrix hmd_matrix = scgraphicssecpackagemessage.hmd_matrix; //hmd_matrix;
            Matrix rotatingMatrixForPelvis = scgraphicssecpackagemessage.rotatingMatrixForPelvis; //rotatingMatrixForPelvis;
            Matrix _rightTouchMatrix = scgraphicssecpackagemessage.rightTouchMatrix; //_rightTouchMatrix;
            Matrix _leftTouchMatrix = scgraphicssecpackagemessage.leftTouchMatrix; //_leftTouchMatrix;
            Matrix oriProjectionMatrix = scgraphicssecpackagemessage.oriProjectionMatrix; //oriProjectionMatrix;
            Matrix extramatrix = scgraphicssecpackagemessage.someextrapelvismatrix; //someextrapelvismatrix;
            Vector3 OFFSETPOS = scgraphicssecpackagemessage.offsetpos; // OFFSETPOS;
            Posef handPoseRight = scgraphicssecpackagemessage.handPoseRight; //handPoseRight;
            Posef handPoseLeft = scgraphicssecpackagemessage.handPoseLeft; //handPoseLeft;

            Matrix _worldMatrix = Matrix.Identity;
            Matrix _viewMatrix = viewMatrix;
            Matrix _projectionMatrix = oriProjectionMatrix;
            //_worldMatrix.Transpose();


            if (SC_console_directx._useOculusRift)
            {
                _projectionMatrix = oriProjectionMatrix;
                _viewMatrix.Transpose();
            }
            else
            {
                _viewMatrix.Transpose();
                _projectionMatrix = scgraphicssecpackagemessage.projectionMatrix;
                _projectionMatrix.Transpose();
            }
            











            try
            {
                //////////////TO READD
                //////////////TO READD
                //////////////TO READD
                terrainheightmap.Render(SC_console_directx.D3D.DeviceContext);
                // Render the model using the color shader.
                SC_Update._shaderManager.RenderGrid(SC_console_directx.D3D.DeviceContext, terrainheightmap.IndexCount, heightmapmatrix, viewMatrix, projectionMatrix);
                //////////////TO READD
                //////////////TO READD
                //////////////TO READD

                float timeSinceStart = (float)(DateTime.Now - SC_Update.startTime).TotalSeconds;
                Matrix worldmatlightrot = Matrix.Scaling(1.0f) * Matrix.RotationX(timeSinceStart * disco_sphere_rot_speed) * Matrix.RotationY(timeSinceStart * 2 * disco_sphere_rot_speed) * Matrix.RotationZ(timeSinceStart * 3 * disco_sphere_rot_speed);

                Quaternion worldmatlightquat;
                SharpDX.Quaternion.RotationMatrix(ref worldmatlightrot, out worldmatlightquat);
                Vector3 dirLight = sc_maths._getDirection(Vector3.ForwardRH, worldmatlightquat); //new Vector3(0, -1, 0);// 

                lightpos.X = SC_Update._rightTouchMatrix.M41;
                lightpos.Y = SC_Update._rightTouchMatrix.M42;
                lightpos.Z = SC_Update._rightTouchMatrix.M43;

                //lightpos = new Vector3(0, 20, 0);
                //ambientColor = new Vector4(0.45f, 0.45f, 0.45f, 1.0f);
                ambientColor = new Vector4(0.75f, 0.75f, 0.75f, 1.0f);
                diffuseColour = new Vector4(1, 1, 1, 1);
                lightDirection = new Vector3(0, -1, -1);

                _DLightBuffer_voxel_pchunk_cube[0].lightPosition = lightpos;
                _DLightBuffer_voxel_pchunk_cube[0].lightDirection = dirLight;
                _DLightBuffer_cube[0].lightPosition = lightpos;
                _DLightBuffer_cube[0].lightDirection = dirLight;
                _DLightBuffer_grid[0].lightPosition = lightpos;
                _DLightBuffer_grid[0].lightDirection = dirLight;
                _DLightBuffer_containment_grid[0].lightPosition = lightpos;
                _DLightBuffer_containment_grid[0].lightDirection = dirLight;
                _DLightBuffer_voxel_cube[0].lightPosition = lightpos;
                _DLightBuffer_voxel_cube[0].lightDirection = dirLight;
                _DLightBuffer_spectrum[0].lightPosition = lightpos;
                _DLightBuffer_spectrum[0].lightDirection = dirLight;



                hmdmatrixRot_ = hmdrotMatrix;

                OriginRot = originRot;
                RotatingMatrix = rotatingMatrix;
                RotatingMatrixForPelvis = rotatingMatrixForPelvis;

                //TERRAIN SINGLEOBJECT
                _terrain[0][0].Render(SC_console_directx.D3D.device.ImmediateContext);
                SC_Update._shaderManager.RenderInstancedObject(SC_console_directx.D3D.device.ImmediateContext, _terrain[0][0].IndexCount, _terrain[0][0].InstanceCount, _terrain[0][0]._POSITION, viewMatrix, projectionMatrix, _basicTexture.TextureResource, _DLightBuffer_cube, _terrain[0][0]);
                //END OF

                //SPECTRUM SINGLEOBJECT
                //_world_spectrum_list[0][0].Render(SC_console_directx.D3D.device.ImmediateContext);
                //SC_Update._shaderManager.RenderInstancedObjectSpectrum(SC_console_directx.D3D.device.ImmediateContext, _world_spectrum_list[0][0].IndexCount, _world_spectrum_list[0][0].InstanceCount, _world_spectrum_list[0][0]._POSITION, viewMatrix, projectionMatrix, _basicTexture.TextureResource, _DLightBuffer_spectrum, _world_spectrum_list[0][0]);
                //END OF

                //TERRAIN SINGLEOBJECT
                _floor[0][0].Render(SC_console_directx.D3D.device.ImmediateContext);
                SC_Update._shaderManager.RenderInstancedObject(SC_console_directx.D3D.device.ImmediateContext, _floor[0][0].IndexCount, _floor[0][0].InstanceCount, _floor[0][0]._POSITION, viewMatrix, projectionMatrix, _basicTexture.TextureResource, _DLightBuffer_cube, _floor[0][0]);
                //END OF

                //PHYSICS GRID
                //_world_grid_list[0][0].Render(SC_console_directx.D3D.device.ImmediateContext);
                //SC_Update._shaderManager.RenderInstancedGrid(SC_console_directx.D3D.device.ImmediateContext, _world_grid_list[0][0].IndexCount, _world_grid_list[0][0].InstanceCount, _world_grid_list[0][0]._POSITION, viewMatrix, projectionMatrix, SC_Update._desktopFrame.ShaderResource, _DLightBuffer_grid, _world_grid_list[0][0]); // oculusRiftDir



                if (display_grid_type == 0)
                {

                }
                else if (display_grid_type == 1)
                {
                    Matrix screengridmatrix = _world_screen_list[0][0]._arrayOfInstances[0].current_pos;

                    Vector3 tempVec = new Vector3(screengridmatrix.M41, screengridmatrix.M42, screengridmatrix.M43);
                    tempVec = tempVec + (-oculusRiftDir * ((_world_screen_list[0][0]._total_torso_depth * 0.5f) + (1 * 0.00123f)));
                    screengridmatrix.M41 = tempVec.X;
                    screengridmatrix.M42 = tempVec.Y;
                    screengridmatrix.M43 = tempVec.Z;
                    //screengridmatrix.M43 += _world_screen_list[0][0]._total_torso_depth * 1.25f;
                    _screen_grid_Y.Render(SC_console_directx.D3D.Device.ImmediateContext);
                    SC_Update._shaderManager.RenderGrid(SC_console_directx.D3D.Device.ImmediateContext, _screen_grid_Y.IndexCount, screengridmatrix, viewMatrix, projectionMatrix);
                }
                else if (display_grid_type == 2)
                {
                    Matrix screengrid_metricmatrix = _world_screen_list[0][0]._arrayOfInstances[0].current_pos;
                    Vector3 tempVec = new Vector3(screengrid_metricmatrix.M41, screengrid_metricmatrix.M42, screengrid_metricmatrix.M43);
                    tempVec = tempVec + (-oculusRiftDir * ((_world_screen_list[0][0]._total_torso_depth * 0.5f) + (1 * 0.00123f)));
                    screengrid_metricmatrix.M41 = tempVec.X;
                    screengrid_metricmatrix.M42 = tempVec.Y;
                    screengrid_metricmatrix.M43 = tempVec.Z;

                    //screengrid_metricmatrix.M43 += _world_screen_list[0][0]._total_torso_depth * 1.275f;
                    _screen_metric_grid_Y.Render(SC_console_directx.D3D.Device.ImmediateContext);
                    SC_Update._shaderManager.RenderGrid(SC_console_directx.D3D.Device.ImmediateContext, _screen_metric_grid_Y.IndexCount, screengrid_metricmatrix, viewMatrix, projectionMatrix);
                }
                else if (display_grid_type == 3)
                {

                    //PHYSICS GRID
                    _world_containment_grid_screen[0][0].Render(SC_console_directx.D3D.device.ImmediateContext);
                    SC_Update._shaderManager.RenderInstancedContainmentGrid(SC_console_directx.D3D.device.ImmediateContext, _world_containment_grid_screen[0][0].IndexCount, _world_containment_grid_screen[0][0].InstanceCount, _world_containment_grid_screen[0][0]._POSITION, viewMatrix, projectionMatrix, SC_Update._desktopFrame.ShaderResource, _DLightBuffer_containment_grid, _world_containment_grid_screen[0][0]); // oculusRiftDir


                    //PHYSICS GRID
                    //_world_containment_grid_screen[0][0].Render(SC_console_directx.D3D.device.ImmediateContext);
                    //SC_Update._shaderManager.RenderInstancedContainmentGrid(SC_console_directx.D3D.device.ImmediateContext, _world_containment_grid_screen[0][0].IndexCount, _world_containment_grid_screen[0][0].InstanceCount, _world_containment_grid_screen[0][0]._POSITION, viewMatrix, projectionMatrix, SC_Update._desktopFrame.ShaderResource, _DLightBuffer_containment_grid, _world_containment_grid_screen[0][0]); // oculusRiftDir

                    //_dContainer.Render(SC_console_directx.D3D.device.ImmediateContext);
                    //SC_Update._shaderManager.RenderObjectGrid(SC_console_directx.D3D.device.ImmediateContext, _dContainer.IndexCount, _WorldMatrixContainer, viewMatrix, projectionMatrix);
                }


                if (display_grid_type == 1 || display_grid_type == 2 || display_grid_type == 3)
                {
                    //PHYSICS GRID
                    /*_world_containment_grid_list_RH[0][0].Render(SC_console_directx.D3D.device.ImmediateContext);
                    SC_Update._shaderManager.RenderInstancedContainmentGrid(SC_console_directx.D3D.device.ImmediateContext, _world_containment_grid_list_RH[0][0].IndexCount, _world_containment_grid_list_RH[0][0].InstanceCount, _world_containment_grid_list_RH[0][0]._POSITION, viewMatrix, projectionMatrix, SC_Update._desktopFrame.ShaderResource, _DLightBuffer_containment_grid, _world_containment_grid_list_RH[0][0]); // oculusRiftDir
                    */


                    //TO READD FOR SOME containmentgrid SCENE LOGIC
                    //TO READD FOR SOME containmentgrid SCENE LOGIC
                    //TO READD FOR SOME containmentgrid SCENE LOGIC
                    /*
                    //PHYSICS GRID
                    _world_containment_grid_list_LH[0][0].Render(SC_console_directx.D3D.device.ImmediateContext);
                    SC_Update._shaderManager.RenderInstancedContainmentGrid(SC_console_directx.D3D.device.ImmediateContext, _world_containment_grid_list_LH[0][0].IndexCount, _world_containment_grid_list_LH[0][0].InstanceCount, _world_containment_grid_list_LH[0][0]._POSITION, viewMatrix, projectionMatrix, SC_Update._desktopFrame.ShaderResource, _DLightBuffer_containment_grid, _world_containment_grid_list_LH[0][0]); // oculusRiftDir
                    */

                    //TO READD FOR SOME containmentgrid SCENE LOGIC
                    //TO READD FOR SOME containmentgrid SCENE LOGIC
                    //TO READD FOR SOME containmentgrid SCENE LOGIC


                    //_dTouchRightContainer.Render(SC_console_directx.D3D.device.ImmediateContext);
                    //SC_Update._shaderManager.RenderObjectGrid(SC_console_directx.D3D.device.ImmediateContext, _dTouchRightContainer.IndexCount, matrixRight, viewMatrix, projectionMatrix);
                    //_dTouchLeftContainer.Render(SC_console_directx.D3D.device.ImmediateContext);
                    //SC_Update._shaderManager.RenderObjectGrid(SC_console_directx.D3D.device.ImmediateContext, _dTouchLeftContainer.IndexCount, matrixLeft, viewMatrix, projectionMatrix);
                }

                /*sc_jitter_cloth._cube.Render(SC_console_directx.D3D.device.ImmediateContext);
                //_arrayOfClothCubes[i].RenderInstancedObject(SC_console_directx.D3D.device.ImmediateContext, _arrayOfClothCubes[i].IndexCount, _arrayOfClothCubes[i].InstanceCount, _arrayOfClothCubes[i]._POSITION, viewMatrix, _projectionMatrix, null, worldMatrix_Terrain_instances, _DLightBuffer, oculusRiftDir);
                SC_Update._shaderManager.RenderInstancedObject(SC_console_directx.D3D.device.ImmediateContext, sc_jitter_cloth._cube.IndexCount, sc_jitter_cloth._cube.InstanceCount, sc_jitter_cloth._cube._POSITION, viewMatrix, projectionMatrix, SC_Update._desktopFrame.ShaderResource, _DLightBuffer_cube, sc_jitter_cloth._cube); // oculusRiftDir
                */






                //PHYSICS SCREENS
                _world_screen_list[0][0].Render(SC_console_directx.D3D.device.ImmediateContext);
                SC_Update._shaderManager.RenderInstancedObject(SC_console_directx.D3D.device.ImmediateContext, _world_screen_list[0][0].IndexCount, _world_screen_list[0][0].InstanceCount, _world_screen_list[0][0]._POSITION, viewMatrix, projectionMatrix, SC_Update._desktopFrame.ShaderResource, _DLightBuffer_cube, _world_screen_list[0][0]);
                //END OF 

                //PHYSICS SCREEN ASSETS
                _world_screen_assets_list[0][0].Render(SC_console_directx.D3D.device.ImmediateContext);
                SC_Update._shaderManager.RenderInstancedObject(SC_console_directx.D3D.device.ImmediateContext, _world_screen_assets_list[0][0].IndexCount, _world_screen_assets_list[0][0].InstanceCount, _world_screen_assets_list[0][0]._POSITION, viewMatrix, projectionMatrix, null, _DLightBuffer_cube, _world_screen_assets_list[0][0]);
                //END OF




                for (int xx = 0; xx < MainWindow._physics_engine_instance_x; xx++)
                {
                    for (int yy = 0; yy < MainWindow._physics_engine_instance_y; yy++)
                    {
                        for (int zz = 0; zz < MainWindow._physics_engine_instance_z; zz++)
                        {
                            var indexer00 = xx + MainWindow._physics_engine_instance_x * (yy + MainWindow._physics_engine_instance_y * zz);

                            try
                            {
                                for (int x = 0; x < MainWindow.world_width; x++)
                                {
                                    for (int y = 0; y < MainWindow.world_height; y++)
                                    {
                                        for (int z = 0; z < MainWindow.world_depth; z++)
                                        {
                                            var indexer01 = x + MainWindow.world_width * (y + MainWindow.world_height * z);

                                            //Vector3 playerPos = new Vector3(_player_torso[0][0]._arrayOfInstances[0].current_pos.M41, _player_torso[0][0]._arrayOfInstances[0].current_pos.M42, _player_torso[0][0]._arrayOfInstances[0].current_pos.M43);


                                            /*
                                            //PHYSICS CUBES
                                            _world_cube_list[indexer00][indexer01].Render(SC_console_directx.D3D.device.ImmediateContext);
                                            SC_Update._shaderManager.RenderInstancedObject(SC_console_directx.D3D.device.ImmediateContext, _world_cube_list[indexer00][indexer01].IndexCount, _world_cube_list[indexer00][indexer01].InstanceCount, _world_cube_list[indexer00][indexer01]._POSITION, viewMatrix, projectionMatrix, SC_Update._desktopFrame.ShaderResource, _DLightBuffer_cube, _world_cube_list[indexer00][indexer01]); // oculusRiftDir

                                            //PHYSICS CONES
                                            _world_cone_list[indexer00][indexer01].Render(SC_console_directx.D3D.device.ImmediateContext);
                                            SC_Update._shaderManager.RenderInstancedObject(SC_console_directx.D3D.device.ImmediateContext, _world_cone_list[indexer00][indexer01].IndexCount, _world_cone_list[indexer00][indexer01].InstanceCount, _world_cone_list[indexer00][indexer01]._POSITION, viewMatrix, projectionMatrix, SC_Update._desktopFrame.ShaderResource, _DLightBuffer_cube, _world_cone_list[indexer00][indexer01]); // oculusRiftDir

                                            //PHYSICS CYLINDERS
                                            _world_cylinder_list[indexer00][indexer01].Render(SC_console_directx.D3D.device.ImmediateContext);
                                            SC_Update._shaderManager.RenderInstancedObject(SC_console_directx.D3D.device.ImmediateContext, _world_cylinder_list[indexer00][indexer01].IndexCount, _world_cylinder_list[indexer00][indexer01].InstanceCount, _world_cylinder_list[indexer00][indexer01]._POSITION, viewMatrix, projectionMatrix, SC_Update._desktopFrame.ShaderResource, _DLightBuffer_cube, _world_cylinder_list[indexer00][indexer01]); // oculusRiftDir

                                            //PHYSICS CAPSULES
                                            _world_capsule_list[indexer00][indexer01].Render(SC_console_directx.D3D.device.ImmediateContext);
                                            SC_Update._shaderManager.RenderInstancedObject(SC_console_directx.D3D.device.ImmediateContext, _world_capsule_list[indexer00][indexer01].IndexCount, _world_capsule_list[indexer00][indexer01].InstanceCount, _world_capsule_list[indexer00][indexer01]._POSITION, viewMatrix, projectionMatrix, SC_Update._desktopFrame.ShaderResource, _DLightBuffer_cube, _world_capsule_list[indexer00][indexer01]); // oculusRiftDir

                                            //PHYSICS SPHERES
                                            _world_sphere_list[indexer00][indexer01].Render(SC_console_directx.D3D.device.ImmediateContext);
                                            SC_Update._shaderManager.RenderInstancedObject(SC_console_directx.D3D.device.ImmediateContext, _world_sphere_list[indexer00][indexer01].IndexCount, _world_sphere_list[indexer00][indexer01].InstanceCount, _world_sphere_list[indexer00][indexer01]._POSITION, viewMatrix, projectionMatrix, SC_Update._desktopFrame.ShaderResource, _DLightBuffer_cube, _world_sphere_list[indexer00][indexer01]); // oculusRiftDir
                                            */

                                            //distance = sc_maths.sc_check_distance_node_3d_geometry(currentPosition, new Vector3(posX, posY, posZ), minx, miny, minz, maxx, maxy, maxz);

                                            try
                                            {
                                                //PHYSICS VOXEL CUBES 
                                                //////////////////////about 100 ticks more per loop compared to simple physics cubes? will investigate later as when i do 
                                                //////////////////////simple cubes with the chunk it lags more even though the number of vertices are the same as the physics cube up above
                                                //////////////////////todo: culling of faces by distance from player. etc.

                                                _world_voxel_cube_lists[indexer00][indexer01].Render(SC_console_directx.D3D.device.ImmediateContext);
                                                SC_Update._shaderManager.RenderInstancedObjectsc_perko_voxel(SC_console_directx.D3D.device.ImmediateContext, _world_voxel_cube_lists[indexer00][indexer01].IndexCount, _world_voxel_cube_lists[indexer00][indexer01].InstanceCount, _world_voxel_cube_lists[indexer00][indexer01]._POSITION, viewMatrix, projectionMatrix, SC_Update._desktopFrame.ShaderResource, _DLightBuffer_voxel_cube, _world_voxel_cube_lists[indexer00][indexer01]);
                                                ///Console.WriteLine(_SystemTickPerformance.ElapsedTicks);
                                            }
                                            catch (Exception ex)
                                            {
                                                MainWindow.MessageBox((IntPtr)0, ex.ToString() + "", "Oculus error", 0);
                                            }





















                                            //////////////TO READD
                                            //////////////TO READD
                                            //////////////TO READD
                                            /*for (int yc = -PlanetChunkHeight_L; yc <= PlanetChunkHeight_R; yc += realplanetwidth)
                                            {
                                                for (int xc = -PlanetChunkWidth_L; xc <= PlanetChunkWidth_R; xc += realplanetwidth)
                                                {
                                                    for (int zc = -PlanetChunkDepth_L; zc <= PlanetChunkDepth_R; zc += realplanetwidth)
                                                    {
                                                        var xxc = xc;
                                                        var yyc = yc;
                                                        var zzc = zc;

                                                        if (xxc < 0)
                                                        {
                                                            xxc *= -1;
                                                            xxc = (PlanetChunkWidth_R) + xxc;
                                                        }
                                                        if (yyc < 0)
                                                        {
                                                            yyc *= -1;
                                                            yyc = (PlanetChunkHeight_R) + yyc;
                                                        }
                                                        if (zzc < 0)
                                                        {
                                                            zzc *= -1;
                                                            zzc = (PlanetChunkDepth_R) + zzc;
                                                        }
                                                        int pc = xxc + (PlanetChunkWidth_L + PlanetChunkWidth_R + 1) * (yyc + (PlanetChunkHeight_L + PlanetChunkHeight_R + 1) * zzc);

                                                        Vector3 chunkPos = new Vector3(arrayOfPlanetChunk[pc].current_pos.M41, arrayOfPlanetChunk[pc].current_pos.M42, arrayOfPlanetChunk[pc].current_pos.M43);


                                                        //if (Vector3.Distance(chunkPos, playerPos) < 30)
                                                        var dist = sc_maths.sc_check_distance_node_3d_geometry(chunkPos, playerPos, 350, 350, 350, 350, 350, 350);
                                                        //Console.WriteLine(dist);
                                                        if (dist < 7500)
                                                        {
                                                            if (arrayOfPlanetChunk[pc] != null)
                                                            {
                                                                if (arrayOfPlanetChunk[pc].Vertices != null)
                                                                {
                                                                    if (arrayOfPlanetChunk[pc].Vertices.Length > 0)
                                                                    {
                                                                        arrayOfPlanetChunk[pc].Render(SC_console_directx.D3D.device.ImmediateContext);
                                                                        //SC_Update._shaderManager.RenderInstancedObjectsc_voxel_pchunk(SC_console_directx.D3D.device.ImmediateContext, _world_voxel_cube_lists[indexer00][indexer01].IndexCount, _world_voxel_cube_lists[indexer00][indexer01].InstanceCount, _world_voxel_cube_lists[indexer00][indexer01]._POSITION, viewMatrix, projectionMatrix, SC_Update._desktopFrame.ShaderResource, _DLightBuffer_voxel_pchunk_cube, arrayOfPlanetChunk[pc]);
                                                                        SC_Update._shaderManager.RenderInstancedObjectsc_voxel_pchunk(SC_console_directx.D3D.device.ImmediateContext, arrayOfPlanetChunk[pc].IndexCount, arrayOfPlanetChunk[pc].InstanceCount, arrayOfPlanetChunk[pc]._POSITION, viewMatrix, projectionMatrix, SC_Update._desktopFrame.ShaderResource, _DLightBuffer_voxel_pchunk_cube, arrayOfPlanetChunk[pc]);
                                                                    }
                                                                }
                                                            }
                                                        }   
                                                    }
                                                }
                                            }*/
                                            //////////////TO READD
                                            //////////////TO READD
                                            //////////////TO READD



                                            /*for (int pc = 0; pc < arrayOfPlanetChunk.Length; pc++)
                                            {
                                                if (arrayOfPlanetChunk[pc] != null)
                                                {
                                                    if (arrayOfPlanetChunk[pc].Vertices != null)
                                                    {
                                                        if (arrayOfPlanetChunk[pc].Vertices.Length > 0)
                                                        {
                                                            arrayOfPlanetChunk[pc].Render(SC_console_directx.D3D.device.ImmediateContext);
                                                            //SC_Update._shaderManager.RenderInstancedObjectsc_voxel_pchunk(SC_console_directx.D3D.device.ImmediateContext, _world_voxel_cube_lists[indexer00][indexer01].IndexCount, _world_voxel_cube_lists[indexer00][indexer01].InstanceCount, _world_voxel_cube_lists[indexer00][indexer01]._POSITION, viewMatrix, projectionMatrix, SC_Update._desktopFrame.ShaderResource, _DLightBuffer_voxel_pchunk_cube, arrayOfPlanetChunk[pc]);
                                                            SC_Update._shaderManager.RenderInstancedObjectsc_voxel_pchunk(SC_console_directx.D3D.device.ImmediateContext, arrayOfPlanetChunk[pc].IndexCount, arrayOfPlanetChunk[pc].InstanceCount, arrayOfPlanetChunk[pc]._POSITION, viewMatrix, projectionMatrix, SC_Update._desktopFrame.ShaderResource, _DLightBuffer_voxel_pchunk_cube, arrayOfPlanetChunk[pc]);

                                                        }
                                                    }
                                                }
                                            }*/
                                        }
                                    }
                                }
                            }
                            catch (Exception ex)
                            {
                                Console.WriteLine(ex.ToString());
                            }
                        }
                    }
                }



                finalRotationMatrix = originRot * rotatingMatrix * rotatingMatrixForPelvis * hmdrotMatrix;


                for (int xxx = 0; xxx < somechunkpriminstancesikvoxelbodywidthR; xxx++)
                {


                    float posX = (xxx);
                    float posY = (0);
                    float posZ = (0);

                    var xxi = xxx;
                    var yyi = 0;
                    var zzi = 0;

                    if (xxi < 0)
                    {
                        xxi *= -1;
                        xxi = (somechunkpriminstancesikvoxelbodywidthR) + xxi;
                    }
                    if (yyi < 0)
                    {
                        yyi *= -1;
                        yyi = (somechunkpriminstancesikvoxelbodyheightR) + yyi;
                    }
                    if (zzi < 0)
                    {
                        zzi *= -1;
                        zzi = (somechunkpriminstancesikvoxelbodydepthR) + zzi;
                    }

                    int somechunkpriminstanceikvoxelbodyindex = xxi;// + (somechunkpriminstancesikvoxelbodywidthL ) * (yyi + (somechunkpriminstancesikvoxelbodyheightL) * zzi);

                    _sc_jitter_tasks = ikvoxelbody[somechunkpriminstanceikvoxelbodyindex].setikbodytargetnlimbspositionsNrotations(_sc_jitter_tasks, viewMatrix, projectionMatrix, OFFSETPOS, originRot, rotatingMatrix, hmdrotMatrix, hmd_matrix, ikvoxelbody[somechunkpriminstanceikvoxelbodyindex]._player_pelvis[0][0]._arrayOfInstances[0].current_pos, _rightTouchMatrix, _leftTouchMatrix, handPoseRight, handPoseLeft, oriProjectionMatrix, ikvoxelbody[somechunkpriminstanceikvoxelbodyindex]._player_torso[0][0], lightpos, dirLight, finalRotationMatrix, ikvoxelbody[somechunkpriminstanceikvoxelbodyindex]._player_pelvis[0][0], hmd_matrix_current, extramatrix, hmdmatrixcurrentforpelvis);
                    _sc_jitter_tasks = ikvoxelbody[somechunkpriminstanceikvoxelbodyindex].ikbodyrender(_sc_jitter_tasks, viewMatrix, projectionMatrix, OFFSETPOS, originRot, rotatingMatrix, hmdrotMatrix, hmd_matrix, rotatingMatrixForPelvis, _rightTouchMatrix, _leftTouchMatrix, handPoseRight, handPoseLeft, oriProjectionMatrix);





                    /*
                    for (int yyy = -somechunkpriminstancesikvoxelbodyheightL; yyy <= somechunkpriminstancesikvoxelbodyheightR; yyy++)
                    {
                        for (int zzz = -somechunkpriminstancesikvoxelbodydepthL; zzz <= somechunkpriminstancesikvoxelbodydepthR; zzz++)
                        {
                            
                        }
                    }*/
                }


                for (int xxx = 0; xxx < somechunkpriminstancesikarmvoxelwidthR; xxx++)
                {
                    for (int yyy = 0; yyy < somechunkpriminstancesikarmvoxelheightR; yyy++)
                    {

                        float posX = (xxx);
                        float posY = (yyy);
                        float posZ = (0);

                        var xxi = xxx;
                        var yyi = yyy;
                        var zzi = 0;

                        if (xxi < 0)
                        {
                            xxi *= -1;
                            xxi = (somechunkpriminstancesikarmvoxelwidthR) + xxi;
                        }
                        if (yyi < 0)
                        {
                            yyi *= -1;
                            yyi = (somechunkpriminstancesikarmvoxelheightR) + yyi;
                        }
                        if (zzi < 0)
                        {
                            zzi *= -1;
                            zzi = (somechunkpriminstancesikarmvoxeldepthR) + zzi;
                        }

                        int somechunkpriminstanceikarmvoxelindex = xxi + (yyi * (somechunkpriminstancesikarmvoxelheightR));


                        var sometest = ikarmvoxel[somechunkpriminstanceikarmvoxelindex];


                        _sc_jitter_tasks = ikarmvoxel[somechunkpriminstanceikarmvoxelindex].setiktargetnlimbspositionsNrotations(_sc_jitter_tasks, viewMatrix, projectionMatrix, OFFSETPOS, originRot, rotatingMatrix, hmdrotMatrix, hmd_matrix, ikvoxelbody[0]._player_pelvis[0][0]._arrayOfInstances[0].current_pos, _rightTouchMatrix, _leftTouchMatrix, handPoseRight, handPoseLeft, oriProjectionMatrix, ikvoxelbody[0]._player_torso[0][0], lightpos, dirLight, finalRotationMatrix, ikvoxelbody[0]._player_pelvis[0][0], ikvoxelbody[0], somechunkpriminstanceikarmvoxelindex, rotatingMatrixForPelvis, extramatrix, directionvectoroffsets);
                        _sc_jitter_tasks = ikarmvoxel[somechunkpriminstanceikarmvoxelindex].ikarmrender(_sc_jitter_tasks, viewMatrix, projectionMatrix, OFFSETPOS, originRot, rotatingMatrix, hmdrotMatrix, hmd_matrix, rotatingMatrixForPelvis, _rightTouchMatrix, _leftTouchMatrix, handPoseRight, handPoseLeft, oriProjectionMatrix);



                        /*
                        for (int zzz = -somechunkpriminstancesikarmvoxeldepthL; zzz <= somechunkpriminstancesikarmvoxeldepthR; zzz++)
                        {
                            
                        }*/
                    }
                }






                /*
                //SCENE CONTAINMENT GRID
                //SCENE CONTAINMENT GRID
                //SCENE CONTAINMENT GRID

                for (int xxxx = 0; xxxx < somechunkplayerspatiallocationscenesw; xxxx++)
                {
                    for (int yyyy = 0; yyyy < somechunkplayerspatiallocationscenesh; yyyy++)
                    {
                        for (int zzzz = 0; zzzz < somechunkplayerspatiallocationscenesd; zzzz++)
                        {
                            var someindexcontainementscenegrid = xxxx + somechunkplayerspatiallocationscenesw * (yyyy + somechunkplayerspatiallocationscenesh * zzzz);


                            somechunkplayerspatiallocationscene[someindexcontainementscenegrid].arrayOfMatrixBuff[0].world = _worldMatrix;
                            somechunkplayerspatiallocationscene[someindexcontainementscenegrid].arrayOfMatrixBuff[0].view = _viewMatrix;
                            somechunkplayerspatiallocationscene[someindexcontainementscenegrid].arrayOfMatrixBuff[0].proj = _projectionMatrix;

                            /*somechunkplayerspatiallocationscene[someindexcontainementscenegrid].arrayOfMatrixBuff[0] = new SC_instancedChunkPrim.DMatrixBuffer()
                            {
                                world = _worldMatrix,
                                view = _viewMatrix,
                                proj = _projectionMatrix,
                            };*/


                            /*somechunkplayerspatiallocationscene[someindexcontainementscenegrid].lightBufferInstChunk[0] = new SC_instancedChunkPrim.DLightBufferEr()
                            {
                                ambientColor = ambientColor,
                                diffuseColor = diffuseColour,
                                lightDirection = rayDirFrontInstancesChunks,
                                padding0 = 0,
                                lightPosition = centerPosRighthandposRR,
                                padding1 = 100
                            };

                            lightpos.X = SC_Update._rightTouchMatrix.M41;
                            lightpos.Y = SC_Update._rightTouchMatrix.M42;
                            lightpos.Z = SC_Update._rightTouchMatrix.M43;


                            Quaternion somerighttouchquat;
                            Matrix somemat = SC_Update._rightTouchMatrix;
                            Quaternion.RotationMatrix(ref somemat, out somerighttouchquat);

                            Vector3 forwarddir = sc_maths._getDirection(Vector3.ForwardRH, somerighttouchquat);

                            //ambientColor = new Vector4(0.45f, 0.45f, 0.45f, 1.0f);
                            ambientColor = new Vector4(0.75f, 0.75f, 0.75f, 1.0f);
                            diffuseColour = new Vector4(1, 1, 1, 1);
                            //lightDirection = new Vector3(0, -1, -1);

                            somechunkplayerspatiallocationscene[someindexcontainementscenegrid].lightBufferInstChunk[0].lightDirection = forwarddir;
                            somechunkplayerspatiallocationscene[someindexcontainementscenegrid].lightBufferInstChunk[0].lightPosition = lightpos;

                            somechunkplayerspatiallocationscene[someindexcontainementscenegrid].lightBufferInstChunk[0].ambientColor = ambientColor;
                            somechunkplayerspatiallocationscene[someindexcontainementscenegrid].lightBufferInstChunk[0].diffuseColor = diffuseColour;



                            for (int x = 0; x < someglobalschunkmeshgrid.numberOfObjectInWidth; x++)
                            {
                                for (int y = 0; y < someglobalschunkmeshgrid.numberOfObjectInHeight; y++)
                                {
                                    for (int z = 0; z < someglobalschunkmeshgrid.numberOfObjectInDepth; z++)
                                    {
                                        int c = x + someglobalschunkmeshgrid.numberOfObjectInWidth * (y + someglobalschunkmeshgrid.numberOfObjectInHeight * z);

                                        if (somechunkplayerspatiallocationscene[someindexcontainementscenegrid].arrayOfChunkData[c].switchForRender == 1)
                                        {
                                            var matrixBufferDescriptionVertex00 = new BufferDescription()
                                            {
                                                Usage = ResourceUsage.Dynamic,
                                                SizeInBytes = Marshal.SizeOf(typeof(SC_instancedChunk.DInstanceType)) * somechunkplayerspatiallocationscene[someindexcontainementscenegrid].instances.Length,
                                                BindFlags = BindFlags.VertexBuffer,
                                                CpuAccessFlags = CpuAccessFlags.Write,
                                                OptionFlags = ResourceOptionFlags.None,
                                                StructureByteStride = 0
                                            };

                                            var InstanceBuffer = new SharpDX.Direct3D11.Buffer(SC_console_directx.D3D.device, matrixBufferDescriptionVertex00);

                                            somechunkplayerspatiallocationscene[someindexcontainementscenegrid].arrayOfChunkData[c].SC_instancedChunk_Instances = somechunkplayerspatiallocationscene[someindexcontainementscenegrid].arrayofindexzeromesh[c].instances;
                                            somechunkplayerspatiallocationscene[someindexcontainementscenegrid].arrayOfChunkData[c].worldMatrix = _worldMatrix;
                                            somechunkplayerspatiallocationscene[someindexcontainementscenegrid].arrayOfChunkData[c].viewMatrix = _viewMatrix;
                                            somechunkplayerspatiallocationscene[someindexcontainementscenegrid].arrayOfChunkData[c].projectionMatrix = _projectionMatrix;

                                            //arrayOfChunkData[c].worldMatrix += arrayOfMatrixBuff[0].world;

                                            somechunkplayerspatiallocationscene[someindexcontainementscenegrid].arrayOfChunkData[c].matrixBuffer = somechunkplayerspatiallocationscene[someindexcontainementscenegrid].arrayOfMatrixBuff;

                                            //arrayOfChunkData[c].lightBuffer = lightBufferInstChunk;

                                            somechunkplayerspatiallocationscene[someindexcontainementscenegrid].arrayOfChunkData[c].instanceBuffer = InstanceBuffer;
                                            somechunkplayerspatiallocationscene[someindexcontainementscenegrid].arrayOfChunkData[c].arrayOfSomeMap = somechunkplayerspatiallocationscene[someindexcontainementscenegrid].arrayofindexzeromesh[c].arrayOfSomeMap;

                                            //arrayOfChunkData[c] = shaderOfChunk.Renderer(arrayOfChunkData[c], c);
                                        }
                                        else
                                        {
                                            float staticPlaneSize = someglobalschunkmeshgrid.planeSize;
                                            float planeSize0 = someglobalschunkmeshgrid.planeSize;
                                            float alternateStaticPlaneSize = 0;

                                            if (staticPlaneSize == 1)
                                            {
                                                staticPlaneSize = planeSize0 * 0.1f;
                                                alternateStaticPlaneSize = planeSize0 * 0.1f;
                                            }
                                            else if (staticPlaneSize == 0.1f)
                                            {
                                                staticPlaneSize = planeSize0;
                                                alternateStaticPlaneSize = planeSize0 * 10;
                                            }
                                            else if (staticPlaneSize == 0.01f)
                                            {
                                                staticPlaneSize = planeSize0;
                                                alternateStaticPlaneSize = planeSize0 * 1000;
                                            }


                                            for (int xx = 0; xx < someglobalschunkmeshgrid.numberOfInstancesPerObjectInWidth; xx++)
                                            {
                                                //MainWindow.MessageBox((IntPtr)0, "" + noiseXZ, "sccs", 0);

                                                for (int yy = 0; yy < someglobalschunkmeshgrid.numberOfInstancesPerObjectInHeight; yy++)
                                                {
                                                    for (int zz = 0; zz < someglobalschunkmeshgrid.numberOfInstancesPerObjectInDepth; zz++)
                                                    {

                                                        float seed = (float)sc_maths.getSomeRandNum(3420, 9999999); //3420;

                                                        int cc = xx + someglobalschunkmeshgrid.numberOfInstancesPerObjectInWidth * (yy + someglobalschunkmeshgrid.numberOfInstancesPerObjectInHeight * zz);




                                                        /*if (sc_menu_scroller == 3 && somecounterresetcounter < somechunkplayerspatiallocationsceneswidth * somechunkplayerspatiallocationscenesheight * somechunkplayerspatiallocationscenesdepth * someglobalschunkmeshgrid.numberOfObjectInWidth * someglobalschunkmeshgrid.numberOfObjectInHeight * someglobalschunkmeshgrid.numberOfObjectInDepth * someglobalschunkmeshgrid.numberOfInstancesPerObjectInWidth * someglobalschunkmeshgrid.numberOfInstancesPerObjectInHeight * someglobalschunkmeshgrid.numberOfInstancesPerObjectInDepth && resetvoxelladdercounter == 2)
                                                        {
                                                            //MainWindow.MessageBox((IntPtr)0, "menu option 3" , "sccs", 0);

                                                            int voxelchunkinvertoption = MainWindow.usetypeofvoxel;


                                                            somechunkplayerspatiallocationscene[someindexcontainementscenegrid].arrayofindexzeromesh[c].somechunk[cc].resetmap(out m11, out m12, out m13, out m14, out m21, out m22, out m23, out m24, out m31, out m32, out m33, out m34, out m41, out m42, out m43, out m44, -1, voxelchunkinvertoption);
                                                            //somechunkplayerspatiallocationscene[someindexcontainementscenegrid].arrayofindexzeromesh[c].somechunk[cc].setnewmap(out m11, out m12, out m13, out m14, out m21, out m22, out m23, out m24, out m31, out m32, out m33, out m34, out m41, out m42, out m43, out m44, -1, voxelchunkinvertoption); //


                                                            somechunkplayerspatiallocationscene[someindexcontainementscenegrid].arrayofindexzeromesh[c].instancesmatrix[cc].instancematrix.M11 = (float)m11;
                                                            somechunkplayerspatiallocationscene[someindexcontainementscenegrid].arrayofindexzeromesh[c].instancesmatrix[cc].instancematrix.M12 = (float)m12;
                                                            somechunkplayerspatiallocationscene[someindexcontainementscenegrid].arrayofindexzeromesh[c].instancesmatrix[cc].instancematrix.M13 = (float)m13;
                                                            somechunkplayerspatiallocationscene[someindexcontainementscenegrid].arrayofindexzeromesh[c].instancesmatrix[cc].instancematrix.M14 = (float)m14;

                                                            somechunkplayerspatiallocationscene[someindexcontainementscenegrid].arrayofindexzeromesh[c].instancesmatrix[cc].instancematrix.M21 = (float)m21;
                                                            somechunkplayerspatiallocationscene[someindexcontainementscenegrid].arrayofindexzeromesh[c].instancesmatrix[cc].instancematrix.M22 = (float)m22;
                                                            somechunkplayerspatiallocationscene[someindexcontainementscenegrid].arrayofindexzeromesh[c].instancesmatrix[cc].instancematrix.M23 = (float)m23;
                                                            somechunkplayerspatiallocationscene[someindexcontainementscenegrid].arrayofindexzeromesh[c].instancesmatrix[cc].instancematrix.M24 = (float)m24;

                                                            somechunkplayerspatiallocationscene[someindexcontainementscenegrid].arrayofindexzeromesh[c].instancesmatrix[cc].instancematrix.M31 = (float)m31;
                                                            somechunkplayerspatiallocationscene[someindexcontainementscenegrid].arrayofindexzeromesh[c].instancesmatrix[cc].instancematrix.M32 = (float)m32;
                                                            somechunkplayerspatiallocationscene[someindexcontainementscenegrid].arrayofindexzeromesh[c].instancesmatrix[cc].instancematrix.M33 = (float)m33;
                                                            somechunkplayerspatiallocationscene[someindexcontainementscenegrid].arrayofindexzeromesh[c].instancesmatrix[cc].instancematrix.M34 = (float)m34;

                                                            somechunkplayerspatiallocationscene[someindexcontainementscenegrid].arrayofindexzeromesh[c].instancesmatrix[cc].instancematrix.M41 = (float)m41;
                                                            somechunkplayerspatiallocationscene[someindexcontainementscenegrid].arrayofindexzeromesh[c].instancesmatrix[cc].instancematrix.M42 = (float)m42;
                                                            somechunkplayerspatiallocationscene[someindexcontainementscenegrid].arrayofindexzeromesh[c].instancesmatrix[cc].instancematrix.M43 = (float)m43;
                                                            somechunkplayerspatiallocationscene[someindexcontainementscenegrid].arrayofindexzeromesh[c].instancesmatrix[cc].instancematrix.M44 = (float)m44;

                                                            somechunkplayerspatiallocationscene[someindexcontainementscenegrid].arrayOfChunkData[c].copytobuffer = 1;

                                                            somecounterresetcounter++;
                                                        }*/
                                                        /*if (sc_menu_scroller == 3 && somecounterresetcounter >= somechunkplayerspatiallocationsceneswidth * somechunkplayerspatiallocationscenesheight * somechunkplayerspatiallocationscenesdepth * someglobalschunkmeshgrid.numberOfObjectInWidth * someglobalschunkmeshgrid.numberOfObjectInHeight * someglobalschunkmeshgrid.numberOfObjectInDepth * someglobalschunkmeshgrid.numberOfInstancesPerObjectInWidth * someglobalschunkmeshgrid.numberOfInstancesPerObjectInHeight * someglobalschunkmeshgrid.numberOfInstancesPerObjectInDepth)
                                                        {
                                                            //MainWindow.MessageBox((IntPtr)0, "resetted map", "sccs", 0);

                                                            //sc_menu_scroller = 0;
                                                            //somecounterresetcounter = 0;
                                                        }











                                                        var somecountermax = (float)Math.Abs((somechunkplayerspatiallocationscene[someindexcontainementscenegrid].arrayofindexzeromesh[c].colorsNFaces[cc].colorsNFaces.W - (float)Math.Floor(somechunkplayerspatiallocationscene[someindexcontainementscenegrid].arrayofindexzeromesh[c].colorsNFaces[cc].colorsNFaces.W)) * 1000);

                                                        float noiseXZ = 100;
                                                        float noiseYZ = 100;
                                                        float noiseXY = 100;

                                                        float detailScale1 = 7;
                                                        float heightScale1 = 5;

                                                        //fastNoise = new FastNoise();

                                                        noiseXZ *= (fastNoise.GetNoise((x * planeSize0 + somechunkplayerspatiallocationscene[someindexcontainementscenegrid].arrayofindexzeromesh[c].colorsNFaces[cc].colorsNFaces.X + seed) / detailScale1, (z * planeSize0 + somechunkplayerspatiallocationscene[someindexcontainementscenegrid].arrayofindexzeromesh[c].colorsNFaces[cc].colorsNFaces.Z + seed) / detailScale1) * heightScale1);
                                                        float size0 = (1 / planeSize0) * somechunkplayerspatiallocationscene[someindexcontainementscenegrid].arrayofindexzeromesh[c].colorsNFaces[cc].colorsNFaces.Y;
                                                        noiseXZ -= size0;

                                                        //MainWindow.MessageBox((IntPtr)0, "c:" + somecountermax, "sccs error", 0);
                                                        noiseYZ *= (fastNoise.GetNoise((y * planeSize0 + somechunkplayerspatiallocationscene[someindexcontainementscenegrid].arrayofindexzeromesh[c].colorsNFaces[cc].colorsNFaces.Y + seed) / detailScale1, (z * planeSize0 + somechunkplayerspatiallocationscene[someindexcontainementscenegrid].arrayofindexzeromesh[c].colorsNFaces[cc].colorsNFaces.Z + seed) / detailScale1) * heightScale1);
                                                        float size1 = (1 / planeSize0) * somechunkplayerspatiallocationscene[someindexcontainementscenegrid].arrayofindexzeromesh[c].colorsNFaces[cc].colorsNFaces.X;
                                                        noiseYZ -= size1;


                                                        noiseXY *= (fastNoise.GetNoise((x * planeSize0 + somechunkplayerspatiallocationscene[someindexcontainementscenegrid].arrayofindexzeromesh[c].colorsNFaces[cc].colorsNFaces.X + seed) / detailScale1, (y * planeSize0 + somechunkplayerspatiallocationscene[someindexcontainementscenegrid].arrayofindexzeromesh[c].colorsNFaces[cc].colorsNFaces.Y + seed) / detailScale1) * heightScale1);
                                                        float size2 = (1 / planeSize0) * somechunkplayerspatiallocationscene[someindexcontainementscenegrid].arrayofindexzeromesh[c].colorsNFaces[cc].colorsNFaces.Z;
                                                        noiseXY -= size2;

                                                        //TOREADD FOR NOISE TEST ON COLOR

                                                        //noiseXZ *= fastNoise.GetNoise((((x * staticPlaneSize) + (somechunkplayerspatiallocationscene[someindexcontainementscenegrid].arrayofindexzeromesh[c].colorsNFaces[cc].colorsNFaces.X * alternateStaticPlaneSize) + seed) / _detailScale) * _HeightScale, (((y * staticPlaneSize) + (somechunkplayerspatiallocationscene[someindexcontainementscenegrid].arrayofindexzeromesh[c].colorsNFaces[cc].colorsNFaces.Y * alternateStaticPlaneSize) + seed) / _detailScale) * _HeightScale, (((z * staticPlaneSize) + (somechunkplayerspatiallocationscene[someindexcontainementscenegrid].arrayofindexzeromesh[c].colorsNFaces[cc].colorsNFaces.Z * alternateStaticPlaneSize) + seed) / _detailScale) * _HeightScale);

                                                        float someclampednoisexz = sc_maths.ClampValue(0.55f + (1 * noiseXZ), (xx * 0.05f), 0.75f);
                                                        float someclampednoiseyz = sc_maths.ClampValue(0.55f + (1 * noiseYZ), (yy * 0.05f), 0.75f);
                                                        float someclampednoisexy = sc_maths.ClampValue(0.55f + (1 * noiseXY), (zz * 0.05f), 0.75f);

                                                        //MainWindow.MessageBox((IntPtr)0, "someclampednoisexz:" + someclampednoisexz + "/someclampednoiseyz:" + someclampednoiseyz + "/someclampednoisexy:" + someclampednoisexy, "sccs", 0);
                                                        //MainWindow.MessageBox((IntPtr)0, "noiseXZ:" + noiseXZ + "/noiseYZ:" + noiseYZ + "/noiseXY:" + noiseXY, "sccs", 0);

                                                        //somechunkplayerspatiallocationscene[someindexcontainementscenegrid].arrayofindexzeromesh[c].colorsNFaces[cc].colorsNFaces.X =Math.Abs(0.15f + noiseXZ);// someclampednoisexz;
                                                        //somechunkplayerspatiallocationscene[someindexcontainementscenegrid].arrayofindexzeromesh[c].colorsNFaces[cc].colorsNFaces.Y = Math.Abs(0.25f + noiseYZ);// someclampednoiseyz;
                                                        //somechunkplayerspatiallocationscene[someindexcontainementscenegrid].arrayofindexzeromesh[c].colorsNFaces[cc].colorsNFaces.Z = Math.Abs(0.15f + noiseXY);// someclampednoisexy;

                                                        somechunkplayerspatiallocationscene[someindexcontainementscenegrid].arrayofindexzeromesh[c].colorsNFaces[cc].colorsNFaces.X = (xx * 0.05f) + Math.Abs(someclampednoisexz); //0.35f + Math.Abs(someclampednoisexz);
                                                        somechunkplayerspatiallocationscene[someindexcontainementscenegrid].arrayofindexzeromesh[c].colorsNFaces[cc].colorsNFaces.Y = (yy * 0.05f) + Math.Abs(someclampednoiseyz); //0.35f + Math.Abs(someclampednoisexz);
                                                        somechunkplayerspatiallocationscene[someindexcontainementscenegrid].arrayofindexzeromesh[c].colorsNFaces[cc].colorsNFaces.Z = (zz * 0.05f) + Math.Abs(someclampednoisexy); //0.35f + Math.Abs(someclampednoisexz);

                                                        //somechunkplayerspatiallocationscene[someindexcontainementscenegrid].arrayofindexzeromesh[c].colorsNFaces[cc].colorsNFaces.W = 1.0f;

                                                        //this can be swapped with heightmaps values with some modifications here and there to bring bytes within a range of 0 to 255 rgba values or from within a range of 0.0f to 1.0f values.
                                                        if (Math.Truncate(somechunkplayerspatiallocationscene[someindexcontainementscenegrid].arrayofindexzeromesh[c].colorsNFaces[cc].colorsNFaces.W) >= somecountermax)
                                                        {

                                                            somechunkplayerspatiallocationscene[someindexcontainementscenegrid].arrayofindexzeromesh[c].colorsNFaces[cc].colorsNFaces.W = 0 + somecountermax * 0.001f;
                                                        }
                                                        somechunkplayerspatiallocationscene[someindexcontainementscenegrid].arrayofindexzeromesh[c].colorsNFaces[cc].colorsNFaces.W += 1f;

                                                        //TOREADD FOR NOISE TEST ON COLOR

                                                        //this can be swapped with heightmaps values with some modifications here and there to bring bytes within a range of 0 to 255 rgba values or from within a range of 0.0f to 1.0f values.
                                                    }
                                                }
                                            }
                                        }















                                        Matrix _WorldMatrix = WorldMatrix;
                                        Matrix matrixtouchright = SC_Update._rightTouchMatrix;//_player_rght_hnd[0][0]._arrayOfInstances[0].current_pos;

                                        int xii = 0;
                                        int yii = 0;
                                        int zii = 0;



                                        //ATTRACT FORCE LOGIC
                                        //ATTRACT FORCE LOGIC
                                        //ATTRACT FORCE LOGIC
                                        /*
                                        //arrayOfChunkData[c].worldMatrix += arrayOfMatrixBuff[0].world;
                                        if (SC_Update.handTriggerRight[1] >= 0.001f)
                                        {
                                            //MainWindow.MessageBox((IntPtr)0, "b: ", "", 0);
                                            for (int xxi = 0; xxi < someglobalschunkmeshgrid.numberOfInstancesPerObjectInWidth; xxi++)
                                            {
                                                for (int yyi = 0; yyi < someglobalschunkmeshgrid.numberOfInstancesPerObjectInHeight; yyi++)
                                                {
                                                    for (int zzi = 0; zzi < someglobalschunkmeshgrid.numberOfInstancesPerObjectInDepth; zzi++)
                                                    {
                                                        int cc = xxi + someglobalschunkmeshgrid.numberOfInstancesPerObjectInWidth * (yyi + someglobalschunkmeshgrid.numberOfInstancesPerObjectInHeight * zzi);

                                                        //var dirToRightHand = new Vector3(_player_rght_hnd[0][0]._arrayOfInstances[0].current_pos.M41, _player_rght_hnd[0][0]._arrayOfInstances[0].current_pos.M42, _player_rght_hnd[0][0]._arrayOfInstances[0].current_pos.M43) - new Vector3(arrayOfChunkData[c].SC_instancedChunk_Instances[cc].instancePos.X, arrayOfChunkData[c].SC_instancedChunk_Instances[cc].instancePos.Y, arrayOfChunkData[c].SC_instancedChunk_Instances[cc].instancePos.Z);

                                                        var dirToRightHand = new Vector3(_player_rght_hnd[0][0]._arrayOfInstances[0].current_pos.M41, _player_rght_hnd[0][0]._arrayOfInstances[0].current_pos.M42, _player_rght_hnd[0][0]._arrayOfInstances[0].current_pos.M43) - new Vector3(somechunkplayerspatiallocationscene[someindexcontainementscenegrid].arrayofindexzeromesh[c].arrayOfScriptForInstances[cc].current_pos.M41, somechunkplayerspatiallocationscene[someindexcontainementscenegrid].arrayofindexzeromesh[c].arrayOfScriptForInstances[cc].current_pos.M42, somechunkplayerspatiallocationscene[someindexcontainementscenegrid].arrayofindexzeromesh[c].arrayOfScriptForInstances[cc].current_pos.M43);

                                                        var lengthofdir = dirToRightHand.Length();

                                                        //var moveRightHand = new JVector(_player_lft_hnd[0]._arrayOfInstances[0].current_pos.M41, _player_lft_hnd[0]._arrayOfInstances[0].current_pos.M42, _player_lft_hnd[0]._arrayOfInstances[0].current_pos.M43) - new JVector(_player_lft_hnd[0]._arrayOfInstances[0]._LASTPOSITIONFORPHYSICS.M41, _player_lft_hnd[0]._arrayOfInstances[0]._LASTPOSITIONFORPHYSICS.M42, _player_lft_hnd[0]._arrayOfInstances[0]._LASTPOSITIONFORPHYSICS.M43);

                                                        if (dirToRightHand != null)
                                                        {
                                                            dirToRightHand.Normalize();

                                                            lh_attract_force = new JVector(dirToRightHand.X, dirToRightHand.Y, dirToRightHand.Z) * 1;

                                                            lh_attract_force.Normalize();

                                                            lh_attract_force *= 0.5f; //0.1f

                                                            Vector4 otherVec4AttractForce = new Vector4(lh_attract_force.X, lh_attract_force.Y, lh_attract_force.Z, 1);

                                                            somechunkplayerspatiallocationscene[someindexcontainementscenegrid].arrayOfChunkData[c].SC_instancedChunk_Instances[cc].instancePos += otherVec4AttractForce;// new Vector4(lh_attract_force.X, lh_attract_force.Y, lh_attract_force.Z, 1);

                                                            somechunkplayerspatiallocationscene[someindexcontainementscenegrid].arrayofindexzeromesh[c].arrayOfScriptForInstances[cc].current_pos.M41 = somechunkplayerspatiallocationscene[someindexcontainementscenegrid].arrayOfChunkData[c].SC_instancedChunk_Instances[cc].instancePos.X;// otherVec4AttractForce.X;
                                                            somechunkplayerspatiallocationscene[someindexcontainementscenegrid].arrayofindexzeromesh[c].arrayOfScriptForInstances[cc].current_pos.M42 = somechunkplayerspatiallocationscene[someindexcontainementscenegrid].arrayOfChunkData[c].SC_instancedChunk_Instances[cc].instancePos.Y;//otherVec4AttractForce.Y;
                                                            somechunkplayerspatiallocationscene[someindexcontainementscenegrid].arrayofindexzeromesh[c].arrayOfScriptForInstances[cc].current_pos.M43 = somechunkplayerspatiallocationscene[someindexcontainementscenegrid].arrayOfChunkData[c].SC_instancedChunk_Instances[cc].instancePos.Z;//otherVec4AttractForce.Z;

                                                            somechunkplayerspatiallocationscene[someindexcontainementscenegrid].arrayofindexzeromesh[c].instances[cc].instancePos.X += otherVec4AttractForce.X;
                                                            somechunkplayerspatiallocationscene[someindexcontainementscenegrid].arrayofindexzeromesh[c].instances[cc].instancePos.Y += otherVec4AttractForce.Y;
                                                            somechunkplayerspatiallocationscene[someindexcontainementscenegrid].arrayofindexzeromesh[c].instances[cc].instancePos.Z += otherVec4AttractForce.Z;

                                                            //arrayOfChunkData[c].SC_instancedChunk_Instances[cc].instancePos.X

                                                            if (lh_attract_force != JVector.Zero && lh_attract_force != null && lh_attract_force.Length() > 0 && body != _grab_rigid_data._body)
                                                            {
                                                                //MessageBox((IntPtr)0, "" + "null dir 01", "Oculus Error", 0);
                                                                //MessageBox((IntPtr)0, "" + "not null force", "Oculus Error", 0);
                                                                //lh_attract_force.Normalize();

                                                                //if (has_water_buo_effect == 1)
                                                                //{
                                                                //    lh_attract_force *= force_4_screen * 10;
                                                               /// }
                                                                //else
                                                                //{
                                                                //    lh_attract_force *= force_4_screen * 1;
                                                                //}

                                                                //0.0045f

                                                                //lh_attract_force *= force_4_screen*1000;
                                                                //body.LinearVelocity += lh_attract_force;
                                                                //body.AddForce(lh_attract_force);

                                                                //worldMatrix

                                                                //arrayOfChunkData[c].arrayOfInstance[cc].instancePos += new Vector4(lh_attract_force.X, lh_attract_force.Y, lh_attract_force.Z, 1);

                                                                //body.AddTorque(force);
                                                            }
                                                        }
                                                        else
                                                        {
                                                            //Console.WriteLine("null dir");
                                                           //// MainWindow.MessageBox((IntPtr)0, "" + "null dir 01", "Oculus Error", 0);
                                                        }
                                                    }
                                                }
                                            }
                                        }




                                        //somechunkplayerspatiallocationscene[someindexcontainementscenegrid].arrayOfChunkData[c].viewMatrix = _viewMatrix;
                                        //somechunkplayerspatiallocationscene[someindexcontainementscenegrid].arrayOfChunkData[c].projectionMatrix = _projectionMatrix;

                                        //arrayOfChunkData[c].worldMatrix += arrayOfMatrixBuff[0].world;






                                        somechunkplayerspatiallocationscene[someindexcontainementscenegrid].lightBufferInstChunk = somechunkplayerspatiallocationscene[someindexcontainementscenegrid].arrayOfChunkData[c].lightBuffer;

                                        //SENDING THE SCREENCAPTURE TO THE BUFFER FOR THE SHADER
                                        //somechunkplayerspatiallocationscene[someindexcontainementscenegrid].shaderOfChunk.shaderResourceView2D = SC_Update._desktopFrame.ShaderResource;// SC_Update._desktopFrame.ShaderResourceArray;
                                        //somechunkplayerspatiallocationscene[someindexcontainementscenegrid].arrayOfChunkData[c].chunkShader.shaderResourceView2D = SC_Update._desktopFrame.ShaderResource;//
                                        //SENDING THE SCREENCAPTURE TO THE BUFFER FOR THE SHADER


                                        //RENDERING THE INSTANCED CHUNK 
                                        somechunkplayerspatiallocationscene[someindexcontainementscenegrid].arrayOfChunkData[c].matrixBuffer = somechunkplayerspatiallocationscene[someindexcontainementscenegrid].arrayOfMatrixBuff;
                                        //RENDERING THE INSTANCED CHUNK
                                        //SC_Update._shaderManager.renderinstancedplayerlocationchunk(somechunkplayerspatiallocationscene[someindexcontainementscenegrid].arrayOfChunkData[c], c, SC_Update._desktopFrame.ShaderResource, somechunkplayerspatiallocationscene[someindexcontainementscenegrid].voxeltype);
                                        //somechunkplayerspatiallocationscene[someindexcontainementscenegrid].arrayOfChunkData[c] = somechunkplayerspatiallocationscene[someindexcontainementscenegrid].shaderOfChunk.Renderer(somechunkplayerspatiallocationscene[someindexcontainementscenegrid].arrayOfChunkData[c], c, SC_Update._desktopFrame.ShaderResource, somechunkplayerspatiallocationscene[someindexcontainementscenegrid].voxeltype);

                                        somechunkplayerspatiallocationscene[someindexcontainementscenegrid].arrayOfChunkData[c] = somechunkplayerspatiallocationscene[someindexcontainementscenegrid].arrayOfChunkData[c].shaderOfChunk.Renderer(somechunkplayerspatiallocationscene[someindexcontainementscenegrid].arrayOfChunkData[c], c, SC_Update._desktopFrame.ShaderResource, somechunkplayerspatiallocationscene[someindexcontainementscenegrid].voxeltype);

                                    }
                                }
                            }
                        }
                    }
                }*/
                //SCENE CONTAINMENT GRID
                //SCENE CONTAINMENT GRID
                //SCENE CONTAINMENT GRID






                /*

                //CHUNK MESh
                //CHUNK MESh
                //CHUNK MESh
                for (int xxxx = 0; xxxx < somechunkmeshswidth; xxxx++)
                {
                    for (int yyyy = 0; yyyy < somechunkmeshsheight; yyyy++)
                    {
                        for (int zzzz = 0; zzzz < somechunkmeshsdepth; zzzz++)
                        {
                            var someindexchunkkeyboardpriminstance = xxxx + somechunkmeshswidth * (yyyy + somechunkmeshsheight * zzzz);

                            somechunkmesh[someindexchunkkeyboardpriminstance].arrayOfMatrixBuff[0].world = _worldMatrix;
                            somechunkmesh[someindexchunkkeyboardpriminstance].arrayOfMatrixBuff[0].view = _viewMatrix;
                            somechunkmesh[someindexchunkkeyboardpriminstance].arrayOfMatrixBuff[0].proj = _projectionMatrix;

                            /*somechunkmesh[someindexchunkkeyboardpriminstance].arrayOfMatrixBuff[0] = new SC_instancedChunkPrim.DMatrixBuffer()
                            {
                                world = _worldMatrix,
                                view = _viewMatrix,
                                proj = _projectionMatrix,
                            };*/


                            /*somechunkmesh[someindexchunkkeyboardpriminstance].lightBufferInstChunk[0] = new SC_instancedChunkPrim.DLightBufferEr()
                            {
                                ambientColor = ambientColor,
                                diffuseColor = diffuseColour,
                                lightDirection = rayDirFrontInstancesChunks,
                                padding0 = 0,
                                lightPosition = centerPosRighthandposRR,
                                padding1 = 100
                            };

                            lightpos.X = SC_Update._rightTouchMatrix.M41;
                            lightpos.Y = SC_Update._rightTouchMatrix.M42;
                            lightpos.Z = SC_Update._rightTouchMatrix.M43;


                            Quaternion somerighttouchquat;
                            Matrix somemat = SC_Update._rightTouchMatrix;
                            Quaternion.RotationMatrix(ref somemat, out somerighttouchquat);

                            Vector3 forwarddir = sc_maths._getDirection(Vector3.ForwardRH, somerighttouchquat);

                            //ambientColor = new Vector4(0.45f, 0.45f, 0.45f, 1.0f);
                            ambientColor = new Vector4(0.75f, 0.75f, 0.75f, 1.0f);
                            diffuseColour = new Vector4(1, 1, 1, 1);
                            //lightDirection = new Vector3(0, -1, -1);

                            somechunkmesh[someindexchunkkeyboardpriminstance].lightBufferInstChunk[0].lightDirection = forwarddir;
                            somechunkmesh[someindexchunkkeyboardpriminstance].lightBufferInstChunk[0].lightPosition = lightpos;

                            somechunkmesh[someindexchunkkeyboardpriminstance].lightBufferInstChunk[0].ambientColor = ambientColor;
                            somechunkmesh[someindexchunkkeyboardpriminstance].lightBufferInstChunk[0].diffuseColor = diffuseColour;



                            for (int x = 0; x < someglobalschunkmesh.numberOfObjectInWidth; x++)
                            {
                                for (int y = 0; y < someglobalschunkmesh.numberOfObjectInHeight; y++)
                                {
                                    for (int z = 0; z < someglobalschunkmesh.numberOfObjectInDepth; z++)
                                    {
                                        int c = x + someglobalschunkmesh.numberOfObjectInWidth * (y + someglobalschunkmesh.numberOfObjectInHeight * z);

                                        if (somechunkmesh[someindexchunkkeyboardpriminstance].arrayOfChunkData[c].switchForRender == 1)
                                        {
                                            var matrixBufferDescriptionVertex00 = new BufferDescription()
                                            {
                                                Usage = ResourceUsage.Dynamic,
                                                SizeInBytes = Marshal.SizeOf(typeof(SC_instancedChunk.DInstanceType)) * somechunkmesh[someindexchunkkeyboardpriminstance].instances.Length,
                                                BindFlags = BindFlags.VertexBuffer,
                                                CpuAccessFlags = CpuAccessFlags.Write,
                                                OptionFlags = ResourceOptionFlags.None,
                                                StructureByteStride = 0
                                            };

                                            var InstanceBuffer = new SharpDX.Direct3D11.Buffer(SC_console_directx.D3D.device, matrixBufferDescriptionVertex00);

                                            somechunkmesh[someindexchunkkeyboardpriminstance].arrayOfChunkData[c].SC_instancedChunk_Instances = somechunkmesh[someindexchunkkeyboardpriminstance].arrayofindexzeromesh[c].instances;
                                            somechunkmesh[someindexchunkkeyboardpriminstance].arrayOfChunkData[c].worldMatrix = _worldMatrix;
                                            somechunkmesh[someindexchunkkeyboardpriminstance].arrayOfChunkData[c].viewMatrix = _viewMatrix;
                                            somechunkmesh[someindexchunkkeyboardpriminstance].arrayOfChunkData[c].projectionMatrix = _projectionMatrix;

                                            //arrayOfChunkData[c].worldMatrix += arrayOfMatrixBuff[0].world;

                                            somechunkmesh[someindexchunkkeyboardpriminstance].arrayOfChunkData[c].matrixBuffer = somechunkmesh[someindexchunkkeyboardpriminstance].arrayOfMatrixBuff;

                                            //arrayOfChunkData[c].lightBuffer = lightBufferInstChunk;

                                            somechunkmesh[someindexchunkkeyboardpriminstance].arrayOfChunkData[c].instanceBuffer = InstanceBuffer;
                                            somechunkmesh[someindexchunkkeyboardpriminstance].arrayOfChunkData[c].arrayOfSomeMap = somechunkmesh[someindexchunkkeyboardpriminstance].arrayofindexzeromesh[c].arrayOfSomeMap;

                                            //arrayOfChunkData[c] = shaderOfChunk.Renderer(arrayOfChunkData[c], c);
                                        }
                                        else
                                        {
                                            float staticPlaneSize = someglobalschunkmesh.planeSize;
                                            float planeSize0 = someglobalschunkmesh.planeSize;
                                            float alternateStaticPlaneSize = 0;

                                            if (staticPlaneSize == 1)
                                            {
                                                staticPlaneSize = planeSize0 * 0.1f;
                                                alternateStaticPlaneSize = planeSize0 * 0.1f;
                                            }
                                            else if (staticPlaneSize == 0.1f)
                                            {
                                                staticPlaneSize = planeSize0;
                                                alternateStaticPlaneSize = planeSize0 * 10;
                                            }
                                            else if (staticPlaneSize == 0.01f)
                                            {
                                                staticPlaneSize = planeSize0;
                                                alternateStaticPlaneSize = planeSize0 * 1000;
                                            }


                                            for (int xx = 0; xx < someglobalschunkmesh.numberOfInstancesPerObjectInWidth; xx++)
                                            {
                                                //MainWindow.MessageBox((IntPtr)0, "" + noiseXZ, "sccs", 0);

                                                for (int yy = 0; yy < someglobalschunkmesh.numberOfInstancesPerObjectInHeight; yy++)
                                                {
                                                    for (int zz = 0; zz < someglobalschunkmesh.numberOfInstancesPerObjectInDepth; zz++)
                                                    {

                                                        float seed = (float)sc_maths.getSomeRandNum(3420, 9999999); //3420;

                                                        int cc = xx + someglobalschunkmesh.numberOfInstancesPerObjectInWidth * (yy + someglobalschunkmesh.numberOfInstancesPerObjectInHeight * zz);




                                                        /*if (sc_menu_scroller == 3 && somecounterresetcounter < somechunkmeshswidth * somechunkmeshsheight * somechunkmeshsdepth * someglobalschunkmesh.numberOfObjectInWidth * someglobalschunkmesh.numberOfObjectInHeight * someglobalschunkmesh.numberOfObjectInDepth * someglobalschunkmesh.numberOfInstancesPerObjectInWidth * someglobalschunkmesh.numberOfInstancesPerObjectInHeight * someglobalschunkmesh.numberOfInstancesPerObjectInDepth && resetvoxelladdercounter == 2)
                                                        {
                                                            //MainWindow.MessageBox((IntPtr)0, "menu option 3" , "sccs", 0);

                                                            int voxelchunkinvertoption = MainWindow.usetypeofvoxel;


                                                            somechunkmesh[someindexchunkkeyboardpriminstance].arrayofindexzeromesh[c].somechunk[cc].resetmap(out m11, out m12, out m13, out m14, out m21, out m22, out m23, out m24, out m31, out m32, out m33, out m34, out m41, out m42, out m43, out m44, -1, voxelchunkinvertoption);
                                                            //somechunkmesh[someindexchunkkeyboardpriminstance].arrayofindexzeromesh[c].somechunk[cc].setnewmap(out m11, out m12, out m13, out m14, out m21, out m22, out m23, out m24, out m31, out m32, out m33, out m34, out m41, out m42, out m43, out m44, -1, voxelchunkinvertoption); //


                                                            somechunkmesh[someindexchunkkeyboardpriminstance].arrayofindexzeromesh[c].instancesmatrix[cc].instancematrix.M11 = (float)m11;
                                                            somechunkmesh[someindexchunkkeyboardpriminstance].arrayofindexzeromesh[c].instancesmatrix[cc].instancematrix.M12 = (float)m12;
                                                            somechunkmesh[someindexchunkkeyboardpriminstance].arrayofindexzeromesh[c].instancesmatrix[cc].instancematrix.M13 = (float)m13;
                                                            somechunkmesh[someindexchunkkeyboardpriminstance].arrayofindexzeromesh[c].instancesmatrix[cc].instancematrix.M14 = (float)m14;

                                                            somechunkmesh[someindexchunkkeyboardpriminstance].arrayofindexzeromesh[c].instancesmatrix[cc].instancematrix.M21 = (float)m21;
                                                            somechunkmesh[someindexchunkkeyboardpriminstance].arrayofindexzeromesh[c].instancesmatrix[cc].instancematrix.M22 = (float)m22;
                                                            somechunkmesh[someindexchunkkeyboardpriminstance].arrayofindexzeromesh[c].instancesmatrix[cc].instancematrix.M23 = (float)m23;
                                                            somechunkmesh[someindexchunkkeyboardpriminstance].arrayofindexzeromesh[c].instancesmatrix[cc].instancematrix.M24 = (float)m24;

                                                            somechunkmesh[someindexchunkkeyboardpriminstance].arrayofindexzeromesh[c].instancesmatrix[cc].instancematrix.M31 = (float)m31;
                                                            somechunkmesh[someindexchunkkeyboardpriminstance].arrayofindexzeromesh[c].instancesmatrix[cc].instancematrix.M32 = (float)m32;
                                                            somechunkmesh[someindexchunkkeyboardpriminstance].arrayofindexzeromesh[c].instancesmatrix[cc].instancematrix.M33 = (float)m33;
                                                            somechunkmesh[someindexchunkkeyboardpriminstance].arrayofindexzeromesh[c].instancesmatrix[cc].instancematrix.M34 = (float)m34;

                                                            somechunkmesh[someindexchunkkeyboardpriminstance].arrayofindexzeromesh[c].instancesmatrix[cc].instancematrix.M41 = (float)m41;
                                                            somechunkmesh[someindexchunkkeyboardpriminstance].arrayofindexzeromesh[c].instancesmatrix[cc].instancematrix.M42 = (float)m42;
                                                            somechunkmesh[someindexchunkkeyboardpriminstance].arrayofindexzeromesh[c].instancesmatrix[cc].instancematrix.M43 = (float)m43;
                                                            somechunkmesh[someindexchunkkeyboardpriminstance].arrayofindexzeromesh[c].instancesmatrix[cc].instancematrix.M44 = (float)m44;

                                                            somechunkmesh[someindexchunkkeyboardpriminstance].arrayOfChunkData[c].copytobuffer = 1;

                                                            somecounterresetcounter++;
                                                        }*/
                                                        /*if (sc_menu_scroller == 3 && somecounterresetcounter >= somechunkmeshswidth * somechunkmeshsheight * somechunkmeshsdepth * someglobalschunkmesh.numberOfObjectInWidth * someglobalschunkmesh.numberOfObjectInHeight * someglobalschunkmesh.numberOfObjectInDepth * someglobalschunkmesh.numberOfInstancesPerObjectInWidth * someglobalschunkmesh.numberOfInstancesPerObjectInHeight * someglobalschunkmesh.numberOfInstancesPerObjectInDepth)
                                                        {
                                                            //MainWindow.MessageBox((IntPtr)0, "resetted map", "sccs", 0);

                                                            //sc_menu_scroller = 0;
                                                            //somecounterresetcounter = 0;
                                                        }











                                                        var somecountermax = (float)Math.Abs((somechunkmesh[someindexchunkkeyboardpriminstance].arrayofindexzeromesh[c].colorsNFaces[cc].colorsNFaces.W - (float)Math.Floor(somechunkmesh[someindexchunkkeyboardpriminstance].arrayofindexzeromesh[c].colorsNFaces[cc].colorsNFaces.W)) * 1000);

                                                        float noiseXZ = 100;
                                                        float noiseYZ = 100;
                                                        float noiseXY = 100;

                                                        float detailScale1 = 7;
                                                        float heightScale1 = 5;

                                                        //fastNoise = new FastNoise();

                                                        noiseXZ *= (fastNoise.GetNoise((x * planeSize0 + somechunkmesh[someindexchunkkeyboardpriminstance].arrayofindexzeromesh[c].colorsNFaces[cc].colorsNFaces.X + seed) / detailScale1, (z * planeSize0 + somechunkmesh[someindexchunkkeyboardpriminstance].arrayofindexzeromesh[c].colorsNFaces[cc].colorsNFaces.Z + seed) / detailScale1) * heightScale1);
                                                        float size0 = (1 / planeSize0) * somechunkmesh[someindexchunkkeyboardpriminstance].arrayofindexzeromesh[c].colorsNFaces[cc].colorsNFaces.Y;
                                                        noiseXZ -= size0;

                                                        //MainWindow.MessageBox((IntPtr)0, "c:" + somecountermax, "sccs error", 0);
                                                        noiseYZ *= (fastNoise.GetNoise((y * planeSize0 + somechunkmesh[someindexchunkkeyboardpriminstance].arrayofindexzeromesh[c].colorsNFaces[cc].colorsNFaces.Y + seed) / detailScale1, (z * planeSize0 + somechunkmesh[someindexchunkkeyboardpriminstance].arrayofindexzeromesh[c].colorsNFaces[cc].colorsNFaces.Z + seed) / detailScale1) * heightScale1);
                                                        float size1 = (1 / planeSize0) * somechunkmesh[someindexchunkkeyboardpriminstance].arrayofindexzeromesh[c].colorsNFaces[cc].colorsNFaces.X;
                                                        noiseYZ -= size1;


                                                        noiseXY *= (fastNoise.GetNoise((x * planeSize0 + somechunkmesh[someindexchunkkeyboardpriminstance].arrayofindexzeromesh[c].colorsNFaces[cc].colorsNFaces.X + seed) / detailScale1, (y * planeSize0 + somechunkmesh[someindexchunkkeyboardpriminstance].arrayofindexzeromesh[c].colorsNFaces[cc].colorsNFaces.Y + seed) / detailScale1) * heightScale1);
                                                        float size2 = (1 / planeSize0) * somechunkmesh[someindexchunkkeyboardpriminstance].arrayofindexzeromesh[c].colorsNFaces[cc].colorsNFaces.Z;
                                                        noiseXY -= size2;

                                                        //TOREADD FOR NOISE TEST ON COLOR

                                                        //noiseXZ *= fastNoise.GetNoise((((x * staticPlaneSize) + (somechunkmesh[someindexchunkkeyboardpriminstance].arrayofindexzeromesh[c].colorsNFaces[cc].colorsNFaces.X * alternateStaticPlaneSize) + seed) / _detailScale) * _HeightScale, (((y * staticPlaneSize) + (somechunkmesh[someindexchunkkeyboardpriminstance].arrayofindexzeromesh[c].colorsNFaces[cc].colorsNFaces.Y * alternateStaticPlaneSize) + seed) / _detailScale) * _HeightScale, (((z * staticPlaneSize) + (somechunkmesh[someindexchunkkeyboardpriminstance].arrayofindexzeromesh[c].colorsNFaces[cc].colorsNFaces.Z * alternateStaticPlaneSize) + seed) / _detailScale) * _HeightScale);

                                                        float someclampednoisexz = sc_maths.ClampValue(0.55f + (1 * noiseXZ), 0.35f, 0.75f);
                                                        float someclampednoiseyz = sc_maths.ClampValue(0.55f + (1 * noiseYZ), 0.35f, 0.75f);
                                                        float someclampednoisexy = sc_maths.ClampValue(0.55f + (1 * noiseXY), 0.35f, 0.75f);

                                                        //MainWindow.MessageBox((IntPtr)0, "someclampednoisexz:" + someclampednoisexz + "/someclampednoiseyz:" + someclampednoiseyz + "/someclampednoisexy:" + someclampednoisexy, "sccs", 0);
                                                        //MainWindow.MessageBox((IntPtr)0, "noiseXZ:" + noiseXZ + "/noiseYZ:" + noiseYZ + "/noiseXY:" + noiseXY, "sccs", 0);

                                                        //somechunkmesh[someindexchunkkeyboardpriminstance].arrayofindexzeromesh[c].colorsNFaces[cc].colorsNFaces.X =Math.Abs(0.15f + noiseXZ);// someclampednoisexz;
                                                        //somechunkmesh[someindexchunkkeyboardpriminstance].arrayofindexzeromesh[c].colorsNFaces[cc].colorsNFaces.Y = Math.Abs(0.25f + noiseYZ);// someclampednoiseyz;
                                                        //somechunkmesh[someindexchunkkeyboardpriminstance].arrayofindexzeromesh[c].colorsNFaces[cc].colorsNFaces.Z = Math.Abs(0.15f + noiseXY);// someclampednoisexy;

                                                        somechunkmesh[someindexchunkkeyboardpriminstance].arrayofindexzeromesh[c].colorsNFaces[cc].colorsNFaces.X = 0.35f + Math.Abs(someclampednoisexz);
                                                        somechunkmesh[someindexchunkkeyboardpriminstance].arrayofindexzeromesh[c].colorsNFaces[cc].colorsNFaces.Y = 0.35f + Math.Abs(someclampednoiseyz);
                                                        somechunkmesh[someindexchunkkeyboardpriminstance].arrayofindexzeromesh[c].colorsNFaces[cc].colorsNFaces.Z = 0.35f + Math.Abs(someclampednoisexy);

                                                        //somechunkmesh[someindexchunkkeyboardpriminstance].arrayofindexzeromesh[c].colorsNFaces[cc].colorsNFaces.W = 1.0f;

                                                        //this can be swapped with heightmaps values with some modifications here and there to bring bytes within a range of 0 to 255 rgba values or from within a range of 0.0f to 1.0f values.
                                                        if (Math.Truncate(somechunkmesh[someindexchunkkeyboardpriminstance].arrayofindexzeromesh[c].colorsNFaces[cc].colorsNFaces.W) >= somecountermax)
                                                        {

                                                            somechunkmesh[someindexchunkkeyboardpriminstance].arrayofindexzeromesh[c].colorsNFaces[cc].colorsNFaces.W = 0 + somecountermax * 0.001f;
                                                        }
                                                        somechunkmesh[someindexchunkkeyboardpriminstance].arrayofindexzeromesh[c].colorsNFaces[cc].colorsNFaces.W += 1f;

                                                        //TOREADD FOR NOISE TEST ON COLOR

                                                        //this can be swapped with heightmaps values with some modifications here and there to bring bytes within a range of 0 to 255 rgba values or from within a range of 0.0f to 1.0f values.
                                                    }
                                                }
                                            }
                                        }















                                        Matrix _WorldMatrix = WorldMatrix;
                                        Matrix matrixtouchright = SC_Update._rightTouchMatrix;//_player_rght_hnd[0][0]._arrayOfInstances[0].current_pos;

                                        int xii = 0;
                                        int yii = 0;
                                        int zii = 0;



                                        //ATTRACT FORCE LOGIC
                                        //ATTRACT FORCE LOGIC
                                        //ATTRACT FORCE LOGIC
                                        /*
                                        //arrayOfChunkData[c].worldMatrix += arrayOfMatrixBuff[0].world;
                                        if (SC_Update.handTriggerRight[1] >= 0.001f)
                                        {
                                            //MainWindow.MessageBox((IntPtr)0, "b: ", "", 0);
                                            for (int xxi = 0; xxi < someglobalschunkmesh.numberOfInstancesPerObjectInWidth; xxi++)
                                            {
                                                for (int yyi = 0; yyi < someglobalschunkmesh.numberOfInstancesPerObjectInHeight; yyi++)
                                                {
                                                    for (int zzi = 0; zzi < someglobalschunkmesh.numberOfInstancesPerObjectInDepth; zzi++)
                                                    {
                                                        int cc = xxi + someglobalschunkmesh.numberOfInstancesPerObjectInWidth * (yyi + someglobalschunkmesh.numberOfInstancesPerObjectInHeight * zzi);

                                                        //var dirToRightHand = new Vector3(_player_rght_hnd[0][0]._arrayOfInstances[0].current_pos.M41, _player_rght_hnd[0][0]._arrayOfInstances[0].current_pos.M42, _player_rght_hnd[0][0]._arrayOfInstances[0].current_pos.M43) - new Vector3(arrayOfChunkData[c].SC_instancedChunk_Instances[cc].instancePos.X, arrayOfChunkData[c].SC_instancedChunk_Instances[cc].instancePos.Y, arrayOfChunkData[c].SC_instancedChunk_Instances[cc].instancePos.Z);

                                                        var dirToRightHand = new Vector3(_player_rght_hnd[0][0]._arrayOfInstances[0].current_pos.M41, _player_rght_hnd[0][0]._arrayOfInstances[0].current_pos.M42, _player_rght_hnd[0][0]._arrayOfInstances[0].current_pos.M43) - new Vector3(somechunkmesh[someindexchunkkeyboardpriminstance].arrayofindexzeromesh[c].arrayOfScriptForInstances[cc].current_pos.M41, somechunkmesh[someindexchunkkeyboardpriminstance].arrayofindexzeromesh[c].arrayOfScriptForInstances[cc].current_pos.M42, somechunkmesh[someindexchunkkeyboardpriminstance].arrayofindexzeromesh[c].arrayOfScriptForInstances[cc].current_pos.M43);

                                                        var lengthofdir = dirToRightHand.Length();

                                                        //var moveRightHand = new JVector(_player_lft_hnd[0]._arrayOfInstances[0].current_pos.M41, _player_lft_hnd[0]._arrayOfInstances[0].current_pos.M42, _player_lft_hnd[0]._arrayOfInstances[0].current_pos.M43) - new JVector(_player_lft_hnd[0]._arrayOfInstances[0]._LASTPOSITIONFORPHYSICS.M41, _player_lft_hnd[0]._arrayOfInstances[0]._LASTPOSITIONFORPHYSICS.M42, _player_lft_hnd[0]._arrayOfInstances[0]._LASTPOSITIONFORPHYSICS.M43);

                                                        if (dirToRightHand != null)
                                                        {
                                                            dirToRightHand.Normalize();

                                                            lh_attract_force = new JVector(dirToRightHand.X, dirToRightHand.Y, dirToRightHand.Z) * 1;

                                                            lh_attract_force.Normalize();

                                                            lh_attract_force *= 0.5f; //0.1f

                                                            Vector4 otherVec4AttractForce = new Vector4(lh_attract_force.X, lh_attract_force.Y, lh_attract_force.Z, 1);

                                                            somechunkmesh[someindexchunkkeyboardpriminstance].arrayOfChunkData[c].SC_instancedChunk_Instances[cc].instancePos += otherVec4AttractForce;// new Vector4(lh_attract_force.X, lh_attract_force.Y, lh_attract_force.Z, 1);

                                                            somechunkmesh[someindexchunkkeyboardpriminstance].arrayofindexzeromesh[c].arrayOfScriptForInstances[cc].current_pos.M41 = somechunkmesh[someindexchunkkeyboardpriminstance].arrayOfChunkData[c].SC_instancedChunk_Instances[cc].instancePos.X;// otherVec4AttractForce.X;
                                                            somechunkmesh[someindexchunkkeyboardpriminstance].arrayofindexzeromesh[c].arrayOfScriptForInstances[cc].current_pos.M42 = somechunkmesh[someindexchunkkeyboardpriminstance].arrayOfChunkData[c].SC_instancedChunk_Instances[cc].instancePos.Y;//otherVec4AttractForce.Y;
                                                            somechunkmesh[someindexchunkkeyboardpriminstance].arrayofindexzeromesh[c].arrayOfScriptForInstances[cc].current_pos.M43 = somechunkmesh[someindexchunkkeyboardpriminstance].arrayOfChunkData[c].SC_instancedChunk_Instances[cc].instancePos.Z;//otherVec4AttractForce.Z;

                                                            somechunkmesh[someindexchunkkeyboardpriminstance].arrayofindexzeromesh[c].instances[cc].instancePos.X += otherVec4AttractForce.X;
                                                            somechunkmesh[someindexchunkkeyboardpriminstance].arrayofindexzeromesh[c].instances[cc].instancePos.Y += otherVec4AttractForce.Y;
                                                            somechunkmesh[someindexchunkkeyboardpriminstance].arrayofindexzeromesh[c].instances[cc].instancePos.Z += otherVec4AttractForce.Z;

                                                            //arrayOfChunkData[c].SC_instancedChunk_Instances[cc].instancePos.X

                                                            if (lh_attract_force != JVector.Zero && lh_attract_force != null && lh_attract_force.Length() > 0 && body != _grab_rigid_data._body)
                                                            {
                                                                //MessageBox((IntPtr)0, "" + "null dir 01", "Oculus Error", 0);
                                                                //MessageBox((IntPtr)0, "" + "not null force", "Oculus Error", 0);
                                                                //lh_attract_force.Normalize();

                                                                //if (has_water_buo_effect == 1)
                                                                //{
                                                                //    lh_attract_force *= force_4_screen * 10;
                                                               /// }
                                                                //else
                                                                //{
                                                                //    lh_attract_force *= force_4_screen * 1;
                                                                //}

                                                                //0.0045f

                                                                //lh_attract_force *= force_4_screen*1000;
                                                                //body.LinearVelocity += lh_attract_force;
                                                                //body.AddForce(lh_attract_force);

                                                                //worldMatrix

                                                                //arrayOfChunkData[c].arrayOfInstance[cc].instancePos += new Vector4(lh_attract_force.X, lh_attract_force.Y, lh_attract_force.Z, 1);

                                                                //body.AddTorque(force);
                                                            }
                                                        }
                                                        else
                                                        {
                                                            //Console.WriteLine("null dir");
                                                           //// MainWindow.MessageBox((IntPtr)0, "" + "null dir 01", "Oculus Error", 0);
                                                        }
                                                    }
                                                }
                                            }
                                        }




                                        //somechunkmesh[someindexchunkkeyboardpriminstance].arrayOfChunkData[c].viewMatrix = _viewMatrix;
                                        //somechunkmesh[someindexchunkkeyboardpriminstance].arrayOfChunkData[c].projectionMatrix = _projectionMatrix;

                                        //arrayOfChunkData[c].worldMatrix += arrayOfMatrixBuff[0].world;

                                        somechunkmesh[someindexchunkkeyboardpriminstance].lightBufferInstChunk = somechunkmesh[someindexchunkkeyboardpriminstance].arrayOfChunkData[c].lightBuffer;

                                        //SENDING THE SCREENCAPTURE TO THE BUFFER FOR THE SHADER
                                        //somechunkmesh[someindexchunkkeyboardpriminstance].shaderOfChunk.shaderResourceView2D = SC_Update._desktopFrame.ShaderResource;// SC_Update._desktopFrame.ShaderResourceArray;
                                        //somechunkmesh[someindexchunkkeyboardpriminstance].arrayOfChunkData[c].chunkShader.shaderResourceView2D = SC_Update._desktopFrame.ShaderResource;//
                                        //SENDING THE SCREENCAPTURE TO THE BUFFER FOR THE SHADER


                                        //RENDERING THE INSTANCED CHUNK 
                                        somechunkmesh[someindexchunkkeyboardpriminstance].arrayOfChunkData[c].matrixBuffer = somechunkmesh[someindexchunkkeyboardpriminstance].arrayOfMatrixBuff;
                                        //somechunkmesh[someindexchunkkeyboardpriminstance].arrayOfChunkData[c] = somechunkmesh[someindexchunkkeyboardpriminstance].shaderOfChunk.Renderer(somechunkmesh[someindexchunkkeyboardpriminstance].arrayOfChunkData[c], c, SC_Update._desktopFrame.ShaderResource, somechunkmesh[someindexchunkkeyboardpriminstance].voxeltype);
                                        //RENDERING THE INSTANCED CHUNK
                                        //SC_Update._shaderManager.renderinstancedchunk(somechunkmesh[someindexchunkkeyboardpriminstance].arrayOfChunkData[c], c, SC_Update._desktopFrame.ShaderResource, somechunkmesh[someindexchunkkeyboardpriminstance].voxeltype);

                                        //somechunkmesh[someindexchunkkeyboardpriminstance].arrayOfChunkData[c] = somechunkmesh[someindexchunkkeyboardpriminstance].shaderOfChunk.Renderer(somechunkmesh[someindexchunkkeyboardpriminstance].arrayOfChunkData[c], c, SC_Update._desktopFrame.ShaderResource, somechunkmesh[someindexchunkkeyboardpriminstance].voxeltype);
                                        somechunkmesh[someindexchunkkeyboardpriminstance].arrayOfChunkData[c] = somechunkmesh[someindexchunkkeyboardpriminstance].arrayOfChunkData[c].shaderOfChunk.Renderer(somechunkmesh[someindexchunkkeyboardpriminstance].arrayOfChunkData[c], c, SC_Update._desktopFrame.ShaderResource, somechunkmesh[someindexchunkkeyboardpriminstance].voxeltype);

                                    }
                                }
                            }
                        }
                    }
                }*/
                //CHUNK MESh
                //CHUNK MESh
                //CHUNK MESh




                /*
                //CHUNK MESH GRID
                //CHUNK MESH GRID
                //CHUNK MESH GRID
                for (int xxxx = 0; xxxx < somechunkmeshgridsw; xxxx++)
                {
                    for (int yyyy = 0; yyyy < somechunkmeshgridsh; yyyy++)
                    {
                        for (int zzzz = 0; zzzz < somechunkmeshgridsd; zzzz++)
                        {
                            var someindexsomechunkmeshgrid = xxxx + somechunkmeshgridsw * (yyyy + somechunkmeshgridsh * zzzz);


                            somechunkmeshgrid[someindexsomechunkmeshgrid].arrayOfMatrixBuff[0].world = _worldMatrix;
                            somechunkmeshgrid[someindexsomechunkmeshgrid].arrayOfMatrixBuff[0].view = _viewMatrix;
                            somechunkmeshgrid[someindexsomechunkmeshgrid].arrayOfMatrixBuff[0].proj = _projectionMatrix;

                            /*somechunkmeshgrid[someindexsomechunkmeshgrid].arrayOfMatrixBuff[0] = new SC_instancedChunkPrim.DMatrixBuffer()
                            {
                                world = _worldMatrix,
                                view = _viewMatrix,
                                proj = _projectionMatrix,
                            };*/


                            /*somechunkmeshgrid[someindexsomechunkmeshgrid].lightBufferInstChunk[0] = new SC_instancedChunkPrim.DLightBufferEr()
                            {
                                ambientColor = ambientColor,
                                diffuseColor = diffuseColour,
                                lightDirection = rayDirFrontInstancesChunks,
                                padding0 = 0,
                                lightPosition = centerPosRighthandposRR,
                                padding1 = 100
                            };

                            lightpos.X = SC_Update._rightTouchMatrix.M41;
                            lightpos.Y = SC_Update._rightTouchMatrix.M42;
                            lightpos.Z = SC_Update._rightTouchMatrix.M43;


                            Quaternion somerighttouchquat;
                            Matrix somemat = SC_Update._rightTouchMatrix;
                            Quaternion.RotationMatrix(ref somemat, out somerighttouchquat);

                            Vector3 forwarddir = sc_maths._getDirection(Vector3.ForwardRH, somerighttouchquat);

                            //ambientColor = new Vector4(0.45f, 0.45f, 0.45f, 1.0f);
                            ambientColor = new Vector4(0.75f, 0.75f, 0.75f, 1.0f);
                            diffuseColour = new Vector4(1, 1, 1, 1);
                            //lightDirection = new Vector3(0, -1, -1);

                            somechunkmeshgrid[someindexsomechunkmeshgrid].lightBufferInstChunk[0].lightDirection = forwarddir;
                            somechunkmeshgrid[someindexsomechunkmeshgrid].lightBufferInstChunk[0].lightPosition = lightpos;

                            somechunkmeshgrid[someindexsomechunkmeshgrid].lightBufferInstChunk[0].ambientColor = ambientColor;
                            somechunkmeshgrid[someindexsomechunkmeshgrid].lightBufferInstChunk[0].diffuseColor = diffuseColour;



                            for (int x = 0; x < someglobalschunkmeshgrid.numberOfObjectInWidth; x++)
                            {
                                for (int y = 0; y < someglobalschunkmeshgrid.numberOfObjectInHeight; y++)
                                {
                                    for (int z = 0; z < someglobalschunkmeshgrid.numberOfObjectInDepth; z++)
                                    {
                                        int c = x + someglobalschunkmeshgrid.numberOfObjectInWidth * (y + someglobalschunkmeshgrid.numberOfObjectInHeight * z);

                                        if (somechunkmeshgrid[someindexsomechunkmeshgrid].arrayOfChunkData[c].switchForRender == 1)
                                        {
                                            var matrixBufferDescriptionVertex00 = new BufferDescription()
                                            {
                                                Usage = ResourceUsage.Dynamic,
                                                SizeInBytes = Marshal.SizeOf(typeof(SC_instancedChunk.DInstanceType)) * somechunkmeshgrid[someindexsomechunkmeshgrid].instances.Length,
                                                BindFlags = BindFlags.VertexBuffer,
                                                CpuAccessFlags = CpuAccessFlags.Write,
                                                OptionFlags = ResourceOptionFlags.None,
                                                StructureByteStride = 0
                                            };

                                            var InstanceBuffer = new SharpDX.Direct3D11.Buffer(SC_console_directx.D3D.device, matrixBufferDescriptionVertex00);

                                            somechunkmeshgrid[someindexsomechunkmeshgrid].arrayOfChunkData[c].SC_instancedChunk_Instances = somechunkmeshgrid[someindexsomechunkmeshgrid].arrayofindexzeromesh[c].instances;
                                            somechunkmeshgrid[someindexsomechunkmeshgrid].arrayOfChunkData[c].worldMatrix = _worldMatrix;
                                            somechunkmeshgrid[someindexsomechunkmeshgrid].arrayOfChunkData[c].viewMatrix = _viewMatrix;
                                            somechunkmeshgrid[someindexsomechunkmeshgrid].arrayOfChunkData[c].projectionMatrix = _projectionMatrix;

                                            //arrayOfChunkData[c].worldMatrix += arrayOfMatrixBuff[0].world;

                                            somechunkmeshgrid[someindexsomechunkmeshgrid].arrayOfChunkData[c].matrixBuffer = somechunkmeshgrid[someindexsomechunkmeshgrid].arrayOfMatrixBuff;

                                            //arrayOfChunkData[c].lightBuffer = lightBufferInstChunk;

                                            somechunkmeshgrid[someindexsomechunkmeshgrid].arrayOfChunkData[c].instanceBuffer = InstanceBuffer;
                                            somechunkmeshgrid[someindexsomechunkmeshgrid].arrayOfChunkData[c].arrayOfSomeMap = somechunkmeshgrid[someindexsomechunkmeshgrid].arrayofindexzeromesh[c].arrayOfSomeMap;

                                            //arrayOfChunkData[c] = shaderOfChunk.Renderer(arrayOfChunkData[c], c);
                                        }
                                        else
                                        {
                                            float staticPlaneSize = someglobalschunkmeshgrid.planeSize;
                                            float planeSize0 = someglobalschunkmeshgrid.planeSize;
                                            float alternateStaticPlaneSize = 0;

                                            if (staticPlaneSize == 1)
                                            {
                                                staticPlaneSize = planeSize0 * 0.1f;
                                                alternateStaticPlaneSize = planeSize0 * 0.1f;
                                            }
                                            else if (staticPlaneSize == 0.1f)
                                            {
                                                staticPlaneSize = planeSize0;
                                                alternateStaticPlaneSize = planeSize0 * 10;
                                            }
                                            else if (staticPlaneSize == 0.01f)
                                            {
                                                staticPlaneSize = planeSize0;
                                                alternateStaticPlaneSize = planeSize0 * 1000;
                                            }


                                            for (int xx = 0; xx < someglobalschunkmeshgrid.numberOfInstancesPerObjectInWidth; xx++)
                                            {
                                                //MainWindow.MessageBox((IntPtr)0, "" + noiseXZ, "sccs", 0);

                                                for (int yy = 0; yy < someglobalschunkmeshgrid.numberOfInstancesPerObjectInHeight; yy++)
                                                {
                                                    for (int zz = 0; zz < someglobalschunkmeshgrid.numberOfInstancesPerObjectInDepth; zz++)
                                                    {

                                                        float seed = (float)sc_maths.getSomeRandNum(3420, 9999999); //3420;

                                                        int cc = xx + someglobalschunkmeshgrid.numberOfInstancesPerObjectInWidth * (yy + someglobalschunkmeshgrid.numberOfInstancesPerObjectInHeight * zz);




                                                        /*if (sc_menu_scroller == 3 && somecounterresetcounter < somechunkmeshgridswidth * somechunkmeshgridsheight * somechunkmeshgridsdepth * someglobalschunkmeshgrid.numberOfObjectInWidth * someglobalschunkmeshgrid.numberOfObjectInHeight * someglobalschunkmeshgrid.numberOfObjectInDepth * someglobalschunkmeshgrid.numberOfInstancesPerObjectInWidth * someglobalschunkmeshgrid.numberOfInstancesPerObjectInHeight * someglobalschunkmeshgrid.numberOfInstancesPerObjectInDepth && resetvoxelladdercounter == 2)
                                                        {
                                                            //MainWindow.MessageBox((IntPtr)0, "menu option 3" , "sccs", 0);

                                                            int voxelchunkinvertoption = MainWindow.usetypeofvoxel;


                                                            somechunkmeshgrid[someindexsomechunkmeshgrid].arrayofindexzeromesh[c].somechunk[cc].resetmap(out m11, out m12, out m13, out m14, out m21, out m22, out m23, out m24, out m31, out m32, out m33, out m34, out m41, out m42, out m43, out m44, -1, voxelchunkinvertoption);
                                                            //somechunkmeshgrid[someindexsomechunkmeshgrid].arrayofindexzeromesh[c].somechunk[cc].setnewmap(out m11, out m12, out m13, out m14, out m21, out m22, out m23, out m24, out m31, out m32, out m33, out m34, out m41, out m42, out m43, out m44, -1, voxelchunkinvertoption); //


                                                            somechunkmeshgrid[someindexsomechunkmeshgrid].arrayofindexzeromesh[c].instancesmatrix[cc].instancematrix.M11 = (float)m11;
                                                            somechunkmeshgrid[someindexsomechunkmeshgrid].arrayofindexzeromesh[c].instancesmatrix[cc].instancematrix.M12 = (float)m12;
                                                            somechunkmeshgrid[someindexsomechunkmeshgrid].arrayofindexzeromesh[c].instancesmatrix[cc].instancematrix.M13 = (float)m13;
                                                            somechunkmeshgrid[someindexsomechunkmeshgrid].arrayofindexzeromesh[c].instancesmatrix[cc].instancematrix.M14 = (float)m14;

                                                            somechunkmeshgrid[someindexsomechunkmeshgrid].arrayofindexzeromesh[c].instancesmatrix[cc].instancematrix.M21 = (float)m21;
                                                            somechunkmeshgrid[someindexsomechunkmeshgrid].arrayofindexzeromesh[c].instancesmatrix[cc].instancematrix.M22 = (float)m22;
                                                            somechunkmeshgrid[someindexsomechunkmeshgrid].arrayofindexzeromesh[c].instancesmatrix[cc].instancematrix.M23 = (float)m23;
                                                            somechunkmeshgrid[someindexsomechunkmeshgrid].arrayofindexzeromesh[c].instancesmatrix[cc].instancematrix.M24 = (float)m24;

                                                            somechunkmeshgrid[someindexsomechunkmeshgrid].arrayofindexzeromesh[c].instancesmatrix[cc].instancematrix.M31 = (float)m31;
                                                            somechunkmeshgrid[someindexsomechunkmeshgrid].arrayofindexzeromesh[c].instancesmatrix[cc].instancematrix.M32 = (float)m32;
                                                            somechunkmeshgrid[someindexsomechunkmeshgrid].arrayofindexzeromesh[c].instancesmatrix[cc].instancematrix.M33 = (float)m33;
                                                            somechunkmeshgrid[someindexsomechunkmeshgrid].arrayofindexzeromesh[c].instancesmatrix[cc].instancematrix.M34 = (float)m34;

                                                            somechunkmeshgrid[someindexsomechunkmeshgrid].arrayofindexzeromesh[c].instancesmatrix[cc].instancematrix.M41 = (float)m41;
                                                            somechunkmeshgrid[someindexsomechunkmeshgrid].arrayofindexzeromesh[c].instancesmatrix[cc].instancematrix.M42 = (float)m42;
                                                            somechunkmeshgrid[someindexsomechunkmeshgrid].arrayofindexzeromesh[c].instancesmatrix[cc].instancematrix.M43 = (float)m43;
                                                            somechunkmeshgrid[someindexsomechunkmeshgrid].arrayofindexzeromesh[c].instancesmatrix[cc].instancematrix.M44 = (float)m44;

                                                            somechunkmeshgrid[someindexsomechunkmeshgrid].arrayOfChunkData[c].copytobuffer = 1;

                                                            somecounterresetcounter++;
                                                        }*/
                                                        /*if (sc_menu_scroller == 3 && somecounterresetcounter >= somechunkmeshgridswidth * somechunkmeshgridsheight * somechunkmeshgridsdepth * someglobalschunkmeshgrid.numberOfObjectInWidth * someglobalschunkmeshgrid.numberOfObjectInHeight * someglobalschunkmeshgrid.numberOfObjectInDepth * someglobalschunkmeshgrid.numberOfInstancesPerObjectInWidth * someglobalschunkmeshgrid.numberOfInstancesPerObjectInHeight * someglobalschunkmeshgrid.numberOfInstancesPerObjectInDepth)
                                                        {
                                                            //MainWindow.MessageBox((IntPtr)0, "resetted map", "sccs", 0);

                                                            //sc_menu_scroller = 0;
                                                            //somecounterresetcounter = 0;
                                                        }











                                                        var somecountermax = (float)Math.Abs((somechunkmeshgrid[someindexsomechunkmeshgrid].arrayofindexzeromesh[c].colorsNFaces[cc].colorsNFaces.W - (float)Math.Floor(somechunkmeshgrid[someindexsomechunkmeshgrid].arrayofindexzeromesh[c].colorsNFaces[cc].colorsNFaces.W)) * 1000);

                                                        float noiseXZ = 100;
                                                        float noiseYZ = 100;
                                                        float noiseXY = 100;

                                                        float detailScale1 = 7;
                                                        float heightScale1 = 5;

                                                        //fastNoise = new FastNoise();

                                                        noiseXZ *= (fastNoise.GetNoise((x * planeSize0 + somechunkmeshgrid[someindexsomechunkmeshgrid].arrayofindexzeromesh[c].colorsNFaces[cc].colorsNFaces.X + seed) / detailScale1, (z * planeSize0 + somechunkmeshgrid[someindexsomechunkmeshgrid].arrayofindexzeromesh[c].colorsNFaces[cc].colorsNFaces.Z + seed) / detailScale1) * heightScale1);
                                                        float size0 = (1 / planeSize0) * somechunkmeshgrid[someindexsomechunkmeshgrid].arrayofindexzeromesh[c].colorsNFaces[cc].colorsNFaces.Y;
                                                        noiseXZ -= size0;

                                                        //MainWindow.MessageBox((IntPtr)0, "c:" + somecountermax, "sccs error", 0);
                                                        noiseYZ *= (fastNoise.GetNoise((y * planeSize0 + somechunkmeshgrid[someindexsomechunkmeshgrid].arrayofindexzeromesh[c].colorsNFaces[cc].colorsNFaces.Y + seed) / detailScale1, (z * planeSize0 + somechunkmeshgrid[someindexsomechunkmeshgrid].arrayofindexzeromesh[c].colorsNFaces[cc].colorsNFaces.Z + seed) / detailScale1) * heightScale1);
                                                        float size1 = (1 / planeSize0) * somechunkmeshgrid[someindexsomechunkmeshgrid].arrayofindexzeromesh[c].colorsNFaces[cc].colorsNFaces.X;
                                                        noiseYZ -= size1;


                                                        noiseXY *= (fastNoise.GetNoise((x * planeSize0 + somechunkmeshgrid[someindexsomechunkmeshgrid].arrayofindexzeromesh[c].colorsNFaces[cc].colorsNFaces.X + seed) / detailScale1, (y * planeSize0 + somechunkmeshgrid[someindexsomechunkmeshgrid].arrayofindexzeromesh[c].colorsNFaces[cc].colorsNFaces.Y + seed) / detailScale1) * heightScale1);
                                                        float size2 = (1 / planeSize0) * somechunkmeshgrid[someindexsomechunkmeshgrid].arrayofindexzeromesh[c].colorsNFaces[cc].colorsNFaces.Z;
                                                        noiseXY -= size2;

                                                        //TOREADD FOR NOISE TEST ON COLOR

                                                        //noiseXZ *= fastNoise.GetNoise((((x * staticPlaneSize) + (somechunkmeshgrid[someindexsomechunkmeshgrid].arrayofindexzeromesh[c].colorsNFaces[cc].colorsNFaces.X * alternateStaticPlaneSize) + seed) / _detailScale) * _HeightScale, (((y * staticPlaneSize) + (somechunkmeshgrid[someindexsomechunkmeshgrid].arrayofindexzeromesh[c].colorsNFaces[cc].colorsNFaces.Y * alternateStaticPlaneSize) + seed) / _detailScale) * _HeightScale, (((z * staticPlaneSize) + (somechunkmeshgrid[someindexsomechunkmeshgrid].arrayofindexzeromesh[c].colorsNFaces[cc].colorsNFaces.Z * alternateStaticPlaneSize) + seed) / _detailScale) * _HeightScale);

                                                        float someclampednoisexz = sc_maths.ClampValue(0.55f + (1 * noiseXZ), (xx * 0.05f), 0.75f);
                                                        float someclampednoiseyz = sc_maths.ClampValue(0.55f + (1 * noiseYZ), (yy * 0.05f), 0.75f);
                                                        float someclampednoisexy = sc_maths.ClampValue(0.55f + (1 * noiseXY), (zz * 0.05f), 0.75f);

                                                        //MainWindow.MessageBox((IntPtr)0, "someclampednoisexz:" + someclampednoisexz + "/someclampednoiseyz:" + someclampednoiseyz + "/someclampednoisexy:" + someclampednoisexy, "sccs", 0);
                                                        //MainWindow.MessageBox((IntPtr)0, "noiseXZ:" + noiseXZ + "/noiseYZ:" + noiseYZ + "/noiseXY:" + noiseXY, "sccs", 0);

                                                        //somechunkmeshgrid[someindexsomechunkmeshgrid].arrayofindexzeromesh[c].colorsNFaces[cc].colorsNFaces.X =Math.Abs(0.15f + noiseXZ);// someclampednoisexz;
                                                        //somechunkmeshgrid[someindexsomechunkmeshgrid].arrayofindexzeromesh[c].colorsNFaces[cc].colorsNFaces.Y = Math.Abs(0.25f + noiseYZ);// someclampednoiseyz;
                                                        //somechunkmeshgrid[someindexsomechunkmeshgrid].arrayofindexzeromesh[c].colorsNFaces[cc].colorsNFaces.Z = Math.Abs(0.15f + noiseXY);// someclampednoisexy;

                                                        somechunkmeshgrid[someindexsomechunkmeshgrid].arrayofindexzeromesh[c].colorsNFaces[cc].colorsNFaces.X = (xx * 0.05f) + Math.Abs(someclampednoisexz); //0.35f + Math.Abs(someclampednoisexz);
                                                        somechunkmeshgrid[someindexsomechunkmeshgrid].arrayofindexzeromesh[c].colorsNFaces[cc].colorsNFaces.Y = (yy * 0.05f) + Math.Abs(someclampednoiseyz); //0.35f + Math.Abs(someclampednoisexz);
                                                        somechunkmeshgrid[someindexsomechunkmeshgrid].arrayofindexzeromesh[c].colorsNFaces[cc].colorsNFaces.Z = (zz * 0.05f) + Math.Abs(someclampednoisexy); //0.35f + Math.Abs(someclampednoisexz);

                                                        //somechunkmeshgrid[someindexsomechunkmeshgrid].arrayofindexzeromesh[c].colorsNFaces[cc].colorsNFaces.W = 1.0f;

                                                        //this can be swapped with heightmaps values with some modifications here and there to bring bytes within a range of 0 to 255 rgba values or from within a range of 0.0f to 1.0f values.
                                                        if (Math.Truncate(somechunkmeshgrid[someindexsomechunkmeshgrid].arrayofindexzeromesh[c].colorsNFaces[cc].colorsNFaces.W) >= somecountermax)
                                                        {

                                                            somechunkmeshgrid[someindexsomechunkmeshgrid].arrayofindexzeromesh[c].colorsNFaces[cc].colorsNFaces.W = 0 + somecountermax * 0.001f;
                                                        }
                                                        somechunkmeshgrid[someindexsomechunkmeshgrid].arrayofindexzeromesh[c].colorsNFaces[cc].colorsNFaces.W += 1f;

                                                        //TOREADD FOR NOISE TEST ON COLOR

                                                        //this can be swapped with heightmaps values with some modifications here and there to bring bytes within a range of 0 to 255 rgba values or from within a range of 0.0f to 1.0f values.
                                                    }
                                                }
                                            }
                                        }















                                        Matrix _WorldMatrix = WorldMatrix;
                                        Matrix matrixtouchright = SC_Update._rightTouchMatrix;//_player_rght_hnd[0][0]._arrayOfInstances[0].current_pos;

                                        int xii = 0;
                                        int yii = 0;
                                        int zii = 0;



                                        //ATTRACT FORCE LOGIC
                                        //ATTRACT FORCE LOGIC
                                        //ATTRACT FORCE LOGIC
                                        /*
                                        //arrayOfChunkData[c].worldMatrix += arrayOfMatrixBuff[0].world;
                                        if (SC_Update.handTriggerRight[1] >= 0.001f)
                                        {
                                            //MainWindow.MessageBox((IntPtr)0, "b: ", "", 0);
                                            for (int xxi = 0; xxi < someglobalschunkmeshgrid.numberOfInstancesPerObjectInWidth; xxi++)
                                            {
                                                for (int yyi = 0; yyi < someglobalschunkmeshgrid.numberOfInstancesPerObjectInHeight; yyi++)
                                                {
                                                    for (int zzi = 0; zzi < someglobalschunkmeshgrid.numberOfInstancesPerObjectInDepth; zzi++)
                                                    {
                                                        int cc = xxi + someglobalschunkmeshgrid.numberOfInstancesPerObjectInWidth * (yyi + someglobalschunkmeshgrid.numberOfInstancesPerObjectInHeight * zzi);

                                                        //var dirToRightHand = new Vector3(_player_rght_hnd[0][0]._arrayOfInstances[0].current_pos.M41, _player_rght_hnd[0][0]._arrayOfInstances[0].current_pos.M42, _player_rght_hnd[0][0]._arrayOfInstances[0].current_pos.M43) - new Vector3(arrayOfChunkData[c].SC_instancedChunk_Instances[cc].instancePos.X, arrayOfChunkData[c].SC_instancedChunk_Instances[cc].instancePos.Y, arrayOfChunkData[c].SC_instancedChunk_Instances[cc].instancePos.Z);

                                                        var dirToRightHand = new Vector3(_player_rght_hnd[0][0]._arrayOfInstances[0].current_pos.M41, _player_rght_hnd[0][0]._arrayOfInstances[0].current_pos.M42, _player_rght_hnd[0][0]._arrayOfInstances[0].current_pos.M43) - new Vector3(somechunkmeshgrid[someindexsomechunkmeshgrid].arrayofindexzeromesh[c].arrayOfScriptForInstances[cc].current_pos.M41, somechunkmeshgrid[someindexsomechunkmeshgrid].arrayofindexzeromesh[c].arrayOfScriptForInstances[cc].current_pos.M42, somechunkmeshgrid[someindexsomechunkmeshgrid].arrayofindexzeromesh[c].arrayOfScriptForInstances[cc].current_pos.M43);

                                                        var lengthofdir = dirToRightHand.Length();

                                                        //var moveRightHand = new JVector(_player_lft_hnd[0]._arrayOfInstances[0].current_pos.M41, _player_lft_hnd[0]._arrayOfInstances[0].current_pos.M42, _player_lft_hnd[0]._arrayOfInstances[0].current_pos.M43) - new JVector(_player_lft_hnd[0]._arrayOfInstances[0]._LASTPOSITIONFORPHYSICS.M41, _player_lft_hnd[0]._arrayOfInstances[0]._LASTPOSITIONFORPHYSICS.M42, _player_lft_hnd[0]._arrayOfInstances[0]._LASTPOSITIONFORPHYSICS.M43);

                                                        if (dirToRightHand != null)
                                                        {
                                                            dirToRightHand.Normalize();

                                                            lh_attract_force = new JVector(dirToRightHand.X, dirToRightHand.Y, dirToRightHand.Z) * 1;

                                                            lh_attract_force.Normalize();

                                                            lh_attract_force *= 0.5f; //0.1f

                                                            Vector4 otherVec4AttractForce = new Vector4(lh_attract_force.X, lh_attract_force.Y, lh_attract_force.Z, 1);

                                                            somechunkmeshgrid[someindexsomechunkmeshgrid].arrayOfChunkData[c].SC_instancedChunk_Instances[cc].instancePos += otherVec4AttractForce;// new Vector4(lh_attract_force.X, lh_attract_force.Y, lh_attract_force.Z, 1);

                                                            somechunkmeshgrid[someindexsomechunkmeshgrid].arrayofindexzeromesh[c].arrayOfScriptForInstances[cc].current_pos.M41 = somechunkmeshgrid[someindexsomechunkmeshgrid].arrayOfChunkData[c].SC_instancedChunk_Instances[cc].instancePos.X;// otherVec4AttractForce.X;
                                                            somechunkmeshgrid[someindexsomechunkmeshgrid].arrayofindexzeromesh[c].arrayOfScriptForInstances[cc].current_pos.M42 = somechunkmeshgrid[someindexsomechunkmeshgrid].arrayOfChunkData[c].SC_instancedChunk_Instances[cc].instancePos.Y;//otherVec4AttractForce.Y;
                                                            somechunkmeshgrid[someindexsomechunkmeshgrid].arrayofindexzeromesh[c].arrayOfScriptForInstances[cc].current_pos.M43 = somechunkmeshgrid[someindexsomechunkmeshgrid].arrayOfChunkData[c].SC_instancedChunk_Instances[cc].instancePos.Z;//otherVec4AttractForce.Z;

                                                            somechunkmeshgrid[someindexsomechunkmeshgrid].arrayofindexzeromesh[c].instances[cc].instancePos.X += otherVec4AttractForce.X;
                                                            somechunkmeshgrid[someindexsomechunkmeshgrid].arrayofindexzeromesh[c].instances[cc].instancePos.Y += otherVec4AttractForce.Y;
                                                            somechunkmeshgrid[someindexsomechunkmeshgrid].arrayofindexzeromesh[c].instances[cc].instancePos.Z += otherVec4AttractForce.Z;

                                                            //arrayOfChunkData[c].SC_instancedChunk_Instances[cc].instancePos.X

                                                            if (lh_attract_force != JVector.Zero && lh_attract_force != null && lh_attract_force.Length() > 0 && body != _grab_rigid_data._body)
                                                            {
                                                                //MessageBox((IntPtr)0, "" + "null dir 01", "Oculus Error", 0);
                                                                //MessageBox((IntPtr)0, "" + "not null force", "Oculus Error", 0);
                                                                //lh_attract_force.Normalize();

                                                                //if (has_water_buo_effect == 1)
                                                                //{
                                                                //    lh_attract_force *= force_4_screen * 10;
                                                               /// }
                                                                //else
                                                                //{
                                                                //    lh_attract_force *= force_4_screen * 1;
                                                                //}

                                                                //0.0045f

                                                                //lh_attract_force *= force_4_screen*1000;
                                                                //body.LinearVelocity += lh_attract_force;
                                                                //body.AddForce(lh_attract_force);

                                                                //worldMatrix

                                                                //arrayOfChunkData[c].arrayOfInstance[cc].instancePos += new Vector4(lh_attract_force.X, lh_attract_force.Y, lh_attract_force.Z, 1);

                                                                //body.AddTorque(force);
                                                            }
                                                        }
                                                        else
                                                        {
                                                            //Console.WriteLine("null dir");
                                                           //// MainWindow.MessageBox((IntPtr)0, "" + "null dir 01", "Oculus Error", 0);
                                                        }
                                                    }
                                                }
                                            }
                                        }




                                        //somechunkmeshgrid[someindexsomechunkmeshgrid].arrayOfChunkData[c].viewMatrix = _viewMatrix;
                                        //somechunkmeshgrid[someindexsomechunkmeshgrid].arrayOfChunkData[c].projectionMatrix = _projectionMatrix;

                                        //arrayOfChunkData[c].worldMatrix += arrayOfMatrixBuff[0].world;






                                        somechunkmeshgrid[someindexsomechunkmeshgrid].lightBufferInstChunk = somechunkmeshgrid[someindexsomechunkmeshgrid].arrayOfChunkData[c].lightBuffer;

                                        //SENDING THE SCREENCAPTURE TO THE BUFFER FOR THE SHADER
                                        //somechunkmeshgrid[someindexsomechunkmeshgrid].shaderOfChunk.shaderResourceView2D = SC_Update._desktopFrame.ShaderResource;// SC_Update._desktopFrame.ShaderResourceArray;
                                        //somechunkmeshgrid[someindexsomechunkmeshgrid].arrayOfChunkData[c].chunkShader.shaderResourceView2D = SC_Update._desktopFrame.ShaderResource;//
                                        //SENDING THE SCREENCAPTURE TO THE BUFFER FOR THE SHADER

                                        //RENDERING THE INSTANCED CHUNK 
                                        somechunkmeshgrid[someindexsomechunkmeshgrid].arrayOfChunkData[c].matrixBuffer = somechunkmeshgrid[someindexsomechunkmeshgrid].arrayOfMatrixBuff;
                                        //RENDERING THE INSTANCED CHUNK

                                        //SC_Update._shaderManager.renderinstancedplayerlocationchunk(somechunkmeshgrid[someindexsomechunkmeshgrid].arrayOfChunkData[c], c, SC_Update._desktopFrame.ShaderResource, somechunkmeshgrid[someindexsomechunkmeshgrid].voxeltype);

                                        //somechunkmeshgrid[someindexsomechunkmeshgrid].arrayOfChunkData[c] = somechunkmeshgrid[someindexsomechunkmeshgrid].shaderOfChunk.Renderer(somechunkmeshgrid[someindexsomechunkmeshgrid].arrayOfChunkData[c], c, SC_Update._desktopFrame.ShaderResource, somechunkmeshgrid[someindexsomechunkmeshgrid].voxeltype);

                                        somechunkmeshgrid[someindexsomechunkmeshgrid].arrayOfChunkData[c] = somechunkmeshgrid[someindexsomechunkmeshgrid].arrayOfChunkData[c].shaderOfChunk.Renderer(somechunkmeshgrid[someindexsomechunkmeshgrid].arrayOfChunkData[c], c, SC_Update._desktopFrame.ShaderResource, somechunkmeshgrid[someindexsomechunkmeshgrid].voxeltype);



                                    }
                                }
                            }
                        }
                    }
                }*/
                //CHUNK MESH GRID
                //CHUNK MESH GRID
                //CHUNK MESH GRID









                //CHUNK MESH VIRTUAL KEYBOARD
                //CHUNK MESH VIRTUAL KEYBOARD
                //CHUNK MESH VIRTUAL KEYBOARD
                for (int xxxx = 0; xxxx < somechunkkeyboardw; xxxx++)
                {
                    for (int yyyy = 0; yyyy < somechunkkeyboardh; yyyy++)
                    {
                        for (int zzzz = 0; zzzz < somechunkkeyboardd; zzzz++)
                        {
                            var somechunkkeyboardindex = xxxx + somechunkkeyboardw * (yyyy + somechunkkeyboardh * zzzz);

                            somechunkkeyboard[somechunkkeyboardindex].arrayOfMatrixBuff[0].world = _worldMatrix;
                            somechunkkeyboard[somechunkkeyboardindex].arrayOfMatrixBuff[0].view = _viewMatrix;
                            somechunkkeyboard[somechunkkeyboardindex].arrayOfMatrixBuff[0].proj = _projectionMatrix;

                            /*somechunkkeyboard[somechunkkeyboardindex].arrayOfMatrixBuff[0] = new SC_instancedChunkPrim.DMatrixBuffer()
                            {
                                world = _worldMatrix,
                                view = _viewMatrix,
                                proj = _projectionMatrix,
                            };*/


                            /*somechunkkeyboard[somechunkkeyboardindex].lightBufferInstChunk[0] = new SC_instancedChunkPrim.DLightBufferEr()
                            {
                                ambientColor = ambientColor,
                                diffuseColor = diffuseColour,
                                lightDirection = rayDirFrontInstancesChunks,
                                padding0 = 0,
                                lightPosition = centerPosRighthandposRR,
                                padding1 = 100
                            };*/

                            lightpos.X = SC_Update._rightTouchMatrix.M41;
                            lightpos.Y = SC_Update._rightTouchMatrix.M42;
                            lightpos.Z = SC_Update._rightTouchMatrix.M43;


                            Quaternion somerighttouchquat;
                            Matrix somemat = SC_Update._rightTouchMatrix;
                            Quaternion.RotationMatrix(ref somemat, out somerighttouchquat);

                            Vector3 forwarddir = sc_maths._getDirection(Vector3.ForwardRH, somerighttouchquat);

                            //ambientColor = new Vector4(0.45f, 0.45f, 0.45f, 1.0f);
                            ambientColor = new Vector4(0.75f, 0.75f, 0.75f, 1.0f);
                            diffuseColour = new Vector4(1, 1, 1, 1);
                            //lightDirection = new Vector3(0, -1, -1);

                            somechunkkeyboard[somechunkkeyboardindex].lightBufferInstChunk[0].lightDirection = forwarddir;
                            somechunkkeyboard[somechunkkeyboardindex].lightBufferInstChunk[0].lightPosition = lightpos;

                            somechunkkeyboard[somechunkkeyboardindex].lightBufferInstChunk[0].ambientColor = ambientColor;
                            somechunkkeyboard[somechunkkeyboardindex].lightBufferInstChunk[0].diffuseColor = diffuseColour;

                            for (int x = 0; x < somechunkkeyboardglobals.numberOfObjectInWidth; x++)
                            {
                                for (int y = 0; y < somechunkkeyboardglobals.numberOfObjectInHeight; y++)
                                {
                                    for (int z = 0; z < somechunkkeyboardglobals.numberOfObjectInDepth; z++)
                                    {
                                        int c = x + somechunkkeyboardglobals.numberOfObjectInWidth * (y + somechunkkeyboardglobals.numberOfObjectInHeight * z);

                                        if (somechunkkeyboard[somechunkkeyboardindex].arrayOfChunkData[c].switchForRender == 1)
                                        {
                                            var matrixBufferDescriptionVertex00 = new BufferDescription()
                                            {
                                                Usage = ResourceUsage.Dynamic,
                                                SizeInBytes = Marshal.SizeOf(typeof(SC_instancedChunk.DInstanceType)) * somechunkkeyboard[somechunkkeyboardindex].instances.Length,
                                                BindFlags = BindFlags.VertexBuffer,
                                                CpuAccessFlags = CpuAccessFlags.Write,
                                                OptionFlags = ResourceOptionFlags.None,
                                                StructureByteStride = 0
                                            };

                                            var InstanceBuffer = new SharpDX.Direct3D11.Buffer(SC_console_directx.D3D.device, matrixBufferDescriptionVertex00);

                                            somechunkkeyboard[somechunkkeyboardindex].arrayOfChunkData[c].SC_instancedChunk_Instances = somechunkkeyboard[somechunkkeyboardindex].arrayofindexzeromesh[c].instances;
                                            somechunkkeyboard[somechunkkeyboardindex].arrayOfChunkData[c].worldMatrix = _worldMatrix;
                                            somechunkkeyboard[somechunkkeyboardindex].arrayOfChunkData[c].viewMatrix = _viewMatrix;
                                            somechunkkeyboard[somechunkkeyboardindex].arrayOfChunkData[c].projectionMatrix = _projectionMatrix;

                                            //arrayOfChunkData[c].worldMatrix += arrayOfMatrixBuff[0].world;

                                            somechunkkeyboard[somechunkkeyboardindex].arrayOfChunkData[c].matrixBuffer = somechunkkeyboard[somechunkkeyboardindex].arrayOfMatrixBuff;

                                            //arrayOfChunkData[c].lightBuffer = lightBufferInstChunk;

                                            somechunkkeyboard[somechunkkeyboardindex].arrayOfChunkData[c].instanceBuffer = InstanceBuffer;
                                            somechunkkeyboard[somechunkkeyboardindex].arrayOfChunkData[c].arrayOfSomeMap = somechunkkeyboard[somechunkkeyboardindex].arrayofindexzeromesh[c].arrayOfSomeMap;

                                            //arrayOfChunkData[c] = shaderOfChunk.Renderer(arrayOfChunkData[c], c);
                                        }
                                        else
                                        {
                                            float staticPlaneSize = somechunkkeyboardglobals.planeSize;
                                            float planeSize0 = somechunkkeyboardglobals.planeSize;
                                            float alternateStaticPlaneSize = 0;

                                            if (staticPlaneSize == 1)
                                            {
                                                staticPlaneSize = planeSize0 * 0.1f;
                                                alternateStaticPlaneSize = planeSize0 * 0.1f;
                                            }
                                            else if (staticPlaneSize == 0.1f)
                                            {
                                                staticPlaneSize = planeSize0;
                                                alternateStaticPlaneSize = planeSize0 * 10;
                                            }
                                            else if (staticPlaneSize == 0.01f)
                                            {
                                                staticPlaneSize = planeSize0;
                                                alternateStaticPlaneSize = planeSize0 * 1000;
                                            }


                                            for (int xx = 0; xx < somechunkkeyboardglobals.numberOfInstancesPerObjectInWidth; xx++)
                                            {
                                                //MainWindow.MessageBox((IntPtr)0, "" + noiseXZ, "sccs", 0);

                                                for (int yy = 0; yy < somechunkkeyboardglobals.numberOfInstancesPerObjectInHeight; yy++)
                                                {
                                                    for (int zz = 0; zz < somechunkkeyboardglobals.numberOfInstancesPerObjectInDepth; zz++)
                                                    {

                                                        float seed = (float)sc_maths.getSomeRandNum(3420, 9999999); //3420;

                                                        int cc = xx + somechunkkeyboardglobals.numberOfInstancesPerObjectInWidth * (yy + somechunkkeyboardglobals.numberOfInstancesPerObjectInHeight * zz);




                                                        /*if (sc_menu_scroller == 3 && somecounterresetcounter < somechunkkeyboardwidth * somechunkkeyboardheight * somechunkkeyboarddepth * somechunkkeyboardglobals.numberOfObjectInWidth * somechunkkeyboardglobals.numberOfObjectInHeight * somechunkkeyboardglobals.numberOfObjectInDepth * somechunkkeyboardglobals.numberOfInstancesPerObjectInWidth * somechunkkeyboardglobals.numberOfInstancesPerObjectInHeight * somechunkkeyboardglobals.numberOfInstancesPerObjectInDepth && resetvoxelladdercounter == 2)
                                                        {
                                                            //MainWindow.MessageBox((IntPtr)0, "menu option 3" , "sccs", 0);

                                                            int voxelchunkinvertoption = MainWindow.usetypeofvoxel;


                                                            somechunkkeyboard[somechunkkeyboardindex].arrayofindexzeromesh[c].somechunk[cc].resetmap(out m11, out m12, out m13, out m14, out m21, out m22, out m23, out m24, out m31, out m32, out m33, out m34, out m41, out m42, out m43, out m44, -1, voxelchunkinvertoption);
                                                            //somechunkkeyboard[somechunkkeyboardindex].arrayofindexzeromesh[c].somechunk[cc].setnewmap(out m11, out m12, out m13, out m14, out m21, out m22, out m23, out m24, out m31, out m32, out m33, out m34, out m41, out m42, out m43, out m44, -1, voxelchunkinvertoption); //


                                                            somechunkkeyboard[somechunkkeyboardindex].arrayofindexzeromesh[c].instancesmatrix[cc].instancematrix.M11 = (float)m11;
                                                            somechunkkeyboard[somechunkkeyboardindex].arrayofindexzeromesh[c].instancesmatrix[cc].instancematrix.M12 = (float)m12;
                                                            somechunkkeyboard[somechunkkeyboardindex].arrayofindexzeromesh[c].instancesmatrix[cc].instancematrix.M13 = (float)m13;
                                                            somechunkkeyboard[somechunkkeyboardindex].arrayofindexzeromesh[c].instancesmatrix[cc].instancematrix.M14 = (float)m14;

                                                            somechunkkeyboard[somechunkkeyboardindex].arrayofindexzeromesh[c].instancesmatrix[cc].instancematrix.M21 = (float)m21;
                                                            somechunkkeyboard[somechunkkeyboardindex].arrayofindexzeromesh[c].instancesmatrix[cc].instancematrix.M22 = (float)m22;
                                                            somechunkkeyboard[somechunkkeyboardindex].arrayofindexzeromesh[c].instancesmatrix[cc].instancematrix.M23 = (float)m23;
                                                            somechunkkeyboard[somechunkkeyboardindex].arrayofindexzeromesh[c].instancesmatrix[cc].instancematrix.M24 = (float)m24;

                                                            somechunkkeyboard[somechunkkeyboardindex].arrayofindexzeromesh[c].instancesmatrix[cc].instancematrix.M31 = (float)m31;
                                                            somechunkkeyboard[somechunkkeyboardindex].arrayofindexzeromesh[c].instancesmatrix[cc].instancematrix.M32 = (float)m32;
                                                            somechunkkeyboard[somechunkkeyboardindex].arrayofindexzeromesh[c].instancesmatrix[cc].instancematrix.M33 = (float)m33;
                                                            somechunkkeyboard[somechunkkeyboardindex].arrayofindexzeromesh[c].instancesmatrix[cc].instancematrix.M34 = (float)m34;

                                                            somechunkkeyboard[somechunkkeyboardindex].arrayofindexzeromesh[c].instancesmatrix[cc].instancematrix.M41 = (float)m41;
                                                            somechunkkeyboard[somechunkkeyboardindex].arrayofindexzeromesh[c].instancesmatrix[cc].instancematrix.M42 = (float)m42;
                                                            somechunkkeyboard[somechunkkeyboardindex].arrayofindexzeromesh[c].instancesmatrix[cc].instancematrix.M43 = (float)m43;
                                                            somechunkkeyboard[somechunkkeyboardindex].arrayofindexzeromesh[c].instancesmatrix[cc].instancematrix.M44 = (float)m44;

                                                            somechunkkeyboard[somechunkkeyboardindex].arrayOfChunkData[c].copytobuffer = 1;

                                                            somecounterresetcounter++;
                                                        }*/
                                                        /*if (sc_menu_scroller == 3 && somecounterresetcounter >= somechunkkeyboardwidth * somechunkkeyboardheight * somechunkkeyboarddepth * somechunkkeyboardglobals.numberOfObjectInWidth * somechunkkeyboardglobals.numberOfObjectInHeight * somechunkkeyboardglobals.numberOfObjectInDepth * somechunkkeyboardglobals.numberOfInstancesPerObjectInWidth * somechunkkeyboardglobals.numberOfInstancesPerObjectInHeight * somechunkkeyboardglobals.numberOfInstancesPerObjectInDepth)
                                                        {
                                                            //MainWindow.MessageBox((IntPtr)0, "resetted map", "sccs", 0);

                                                            //sc_menu_scroller = 0;
                                                            //somecounterresetcounter = 0;
                                                        }*/











                                                        var somecountermax = (float)Math.Abs((somechunkkeyboard[somechunkkeyboardindex].arrayofindexzeromesh[c].colorsNFaces[cc].colorsNFaces.W - (float)Math.Floor(somechunkkeyboard[somechunkkeyboardindex].arrayofindexzeromesh[c].colorsNFaces[cc].colorsNFaces.W)) * 1000);

                                                        float noiseXZ = 100;
                                                        float noiseYZ = 100;
                                                        float noiseXY = 100;

                                                        float detailScale1 = 7;
                                                        float heightScale1 = 5;

                                                        //fastNoise = new FastNoise();

                                                        noiseXZ *= (fastNoise.GetNoise((x * planeSize0 + somechunkkeyboard[somechunkkeyboardindex].arrayofindexzeromesh[c].colorsNFaces[cc].colorsNFaces.X + seed) / detailScale1, (z * planeSize0 + somechunkkeyboard[somechunkkeyboardindex].arrayofindexzeromesh[c].colorsNFaces[cc].colorsNFaces.Z + seed) / detailScale1) * heightScale1);
                                                        float size0 = (1 / planeSize0) * somechunkkeyboard[somechunkkeyboardindex].arrayofindexzeromesh[c].colorsNFaces[cc].colorsNFaces.Y;
                                                        noiseXZ -= size0;

                                                        //MainWindow.MessageBox((IntPtr)0, "c:" + somecountermax, "sccs error", 0);
                                                        noiseYZ *= (fastNoise.GetNoise((y * planeSize0 + somechunkkeyboard[somechunkkeyboardindex].arrayofindexzeromesh[c].colorsNFaces[cc].colorsNFaces.Y + seed) / detailScale1, (z * planeSize0 + somechunkkeyboard[somechunkkeyboardindex].arrayofindexzeromesh[c].colorsNFaces[cc].colorsNFaces.Z + seed) / detailScale1) * heightScale1);
                                                        float size1 = (1 / planeSize0) * somechunkkeyboard[somechunkkeyboardindex].arrayofindexzeromesh[c].colorsNFaces[cc].colorsNFaces.X;
                                                        noiseYZ -= size1;


                                                        noiseXY *= (fastNoise.GetNoise((x * planeSize0 + somechunkkeyboard[somechunkkeyboardindex].arrayofindexzeromesh[c].colorsNFaces[cc].colorsNFaces.X + seed) / detailScale1, (y * planeSize0 + somechunkkeyboard[somechunkkeyboardindex].arrayofindexzeromesh[c].colorsNFaces[cc].colorsNFaces.Y + seed) / detailScale1) * heightScale1);
                                                        float size2 = (1 / planeSize0) * somechunkkeyboard[somechunkkeyboardindex].arrayofindexzeromesh[c].colorsNFaces[cc].colorsNFaces.Z;
                                                        noiseXY -= size2;

                                                        //TOREADD FOR NOISE TEST ON COLOR

                                                        //noiseXZ *= fastNoise.GetNoise((((x * staticPlaneSize) + (somechunkkeyboard[somechunkkeyboardindex].arrayofindexzeromesh[c].colorsNFaces[cc].colorsNFaces.X * alternateStaticPlaneSize) + seed) / _detailScale) * _HeightScale, (((y * staticPlaneSize) + (somechunkkeyboard[somechunkkeyboardindex].arrayofindexzeromesh[c].colorsNFaces[cc].colorsNFaces.Y * alternateStaticPlaneSize) + seed) / _detailScale) * _HeightScale, (((z * staticPlaneSize) + (somechunkkeyboard[somechunkkeyboardindex].arrayofindexzeromesh[c].colorsNFaces[cc].colorsNFaces.Z * alternateStaticPlaneSize) + seed) / _detailScale) * _HeightScale);

                                                        float someclampednoisexz = sc_maths.ClampValue(0.55f + (1 * noiseXZ), 0.35f, 0.75f);
                                                        float someclampednoiseyz = sc_maths.ClampValue(0.55f + (1 * noiseYZ), 0.35f, 0.75f);
                                                        float someclampednoisexy = sc_maths.ClampValue(0.55f + (1 * noiseXY), 0.35f, 0.75f);

                                                        //MainWindow.MessageBox((IntPtr)0, "someclampednoisexz:" + someclampednoisexz + "/someclampednoiseyz:" + someclampednoiseyz + "/someclampednoisexy:" + someclampednoisexy, "sccs", 0);
                                                        //MainWindow.MessageBox((IntPtr)0, "noiseXZ:" + noiseXZ + "/noiseYZ:" + noiseYZ + "/noiseXY:" + noiseXY, "sccs", 0);

                                                        //somechunkkeyboard[somechunkkeyboardindex].arrayofindexzeromesh[c].colorsNFaces[cc].colorsNFaces.X =Math.Abs(0.15f + noiseXZ);// someclampednoisexz;
                                                        //somechunkkeyboard[somechunkkeyboardindex].arrayofindexzeromesh[c].colorsNFaces[cc].colorsNFaces.Y = Math.Abs(0.25f + noiseYZ);// someclampednoiseyz;
                                                        //somechunkkeyboard[somechunkkeyboardindex].arrayofindexzeromesh[c].colorsNFaces[cc].colorsNFaces.Z = Math.Abs(0.15f + noiseXY);// someclampednoisexy;

                                                        somechunkkeyboard[somechunkkeyboardindex].arrayofindexzeromesh[c].colorsNFaces[cc].colorsNFaces.X = 0.35f + Math.Abs(someclampednoisexz);
                                                        somechunkkeyboard[somechunkkeyboardindex].arrayofindexzeromesh[c].colorsNFaces[cc].colorsNFaces.Y = 0.35f + Math.Abs(someclampednoiseyz);
                                                        somechunkkeyboard[somechunkkeyboardindex].arrayofindexzeromesh[c].colorsNFaces[cc].colorsNFaces.Z = 0.35f + Math.Abs(someclampednoisexy);

                                                        //somechunkkeyboard[somechunkkeyboardindex].arrayofindexzeromesh[c].colorsNFaces[cc].colorsNFaces.W = 1.0f;

                                                        //this can be swapped with heightmaps values with some modifications here and there to bring bytes within a range of 0 to 255 rgba values or from within a range of 0.0f to 1.0f values.
                                                        if (Math.Truncate(somechunkkeyboard[somechunkkeyboardindex].arrayofindexzeromesh[c].colorsNFaces[cc].colorsNFaces.W) >= somecountermax)
                                                        {

                                                            somechunkkeyboard[somechunkkeyboardindex].arrayofindexzeromesh[c].colorsNFaces[cc].colorsNFaces.W = 0 + somecountermax * 0.001f;
                                                        }
                                                        somechunkkeyboard[somechunkkeyboardindex].arrayofindexzeromesh[c].colorsNFaces[cc].colorsNFaces.W += 1f;

                                                        //TOREADD FOR NOISE TEST ON COLOR

                                                        //this can be swapped with heightmaps values with some modifications here and there to bring bytes within a range of 0 to 255 rgba values or from within a range of 0.0f to 1.0f values.
                                                    }
                                                }
                                            }
                                        }















                                        Matrix _WorldMatrix = WorldMatrix;
                                        Matrix matrixtouchright = SC_Update._rightTouchMatrix;//_player_rght_hnd[0][0]._arrayOfInstances[0].current_pos;

                                        int xii = 0;
                                        int yii = 0;
                                        int zii = 0;



                                        //ATTRACT FORCE LOGIC
                                        //ATTRACT FORCE LOGIC
                                        //ATTRACT FORCE LOGIC
                                        /*
                                        //arrayOfChunkData[c].worldMatrix += arrayOfMatrixBuff[0].world;
                                        if (SC_Update.handTriggerRight[1] >= 0.001f)
                                        {
                                            //MainWindow.MessageBox((IntPtr)0, "b: ", "", 0);
                                            for (int xxi = 0; xxi < somechunkkeyboardglobals.numberOfInstancesPerObjectInWidth; xxi++)
                                            {
                                                for (int yyi = 0; yyi < somechunkkeyboardglobals.numberOfInstancesPerObjectInHeight; yyi++)
                                                {
                                                    for (int zzi = 0; zzi < somechunkkeyboardglobals.numberOfInstancesPerObjectInDepth; zzi++)
                                                    {
                                                        int cc = xxi + somechunkkeyboardglobals.numberOfInstancesPerObjectInWidth * (yyi + somechunkkeyboardglobals.numberOfInstancesPerObjectInHeight * zzi);

                                                        //var dirToRightHand = new Vector3(_player_rght_hnd[0][0]._arrayOfInstances[0].current_pos.M41, _player_rght_hnd[0][0]._arrayOfInstances[0].current_pos.M42, _player_rght_hnd[0][0]._arrayOfInstances[0].current_pos.M43) - new Vector3(arrayOfChunkData[c].SC_instancedChunk_Instances[cc].instancePos.X, arrayOfChunkData[c].SC_instancedChunk_Instances[cc].instancePos.Y, arrayOfChunkData[c].SC_instancedChunk_Instances[cc].instancePos.Z);

                                                        var dirToRightHand = new Vector3(_player_rght_hnd[0][0]._arrayOfInstances[0].current_pos.M41, _player_rght_hnd[0][0]._arrayOfInstances[0].current_pos.M42, _player_rght_hnd[0][0]._arrayOfInstances[0].current_pos.M43) - new Vector3(somechunkkeyboard[somechunkkeyboardindex].arrayofindexzeromesh[c].arrayOfScriptForInstances[cc].current_pos.M41, somechunkkeyboard[somechunkkeyboardindex].arrayofindexzeromesh[c].arrayOfScriptForInstances[cc].current_pos.M42, somechunkkeyboard[somechunkkeyboardindex].arrayofindexzeromesh[c].arrayOfScriptForInstances[cc].current_pos.M43);

                                                        var lengthofdir = dirToRightHand.Length();

                                                        //var moveRightHand = new JVector(_player_lft_hnd[0]._arrayOfInstances[0].current_pos.M41, _player_lft_hnd[0]._arrayOfInstances[0].current_pos.M42, _player_lft_hnd[0]._arrayOfInstances[0].current_pos.M43) - new JVector(_player_lft_hnd[0]._arrayOfInstances[0]._LASTPOSITIONFORPHYSICS.M41, _player_lft_hnd[0]._arrayOfInstances[0]._LASTPOSITIONFORPHYSICS.M42, _player_lft_hnd[0]._arrayOfInstances[0]._LASTPOSITIONFORPHYSICS.M43);

                                                        if (dirToRightHand != null)
                                                        {
                                                            dirToRightHand.Normalize();

                                                            lh_attract_force = new JVector(dirToRightHand.X, dirToRightHand.Y, dirToRightHand.Z) * 1;

                                                            lh_attract_force.Normalize();

                                                            lh_attract_force *= 0.5f; //0.1f

                                                            Vector4 otherVec4AttractForce = new Vector4(lh_attract_force.X, lh_attract_force.Y, lh_attract_force.Z, 1);

                                                            somechunkkeyboard[somechunkkeyboardindex].arrayOfChunkData[c].SC_instancedChunk_Instances[cc].instancePos += otherVec4AttractForce;// new Vector4(lh_attract_force.X, lh_attract_force.Y, lh_attract_force.Z, 1);

                                                            somechunkkeyboard[somechunkkeyboardindex].arrayofindexzeromesh[c].arrayOfScriptForInstances[cc].current_pos.M41 = somechunkkeyboard[somechunkkeyboardindex].arrayOfChunkData[c].SC_instancedChunk_Instances[cc].instancePos.X;// otherVec4AttractForce.X;
                                                            somechunkkeyboard[somechunkkeyboardindex].arrayofindexzeromesh[c].arrayOfScriptForInstances[cc].current_pos.M42 = somechunkkeyboard[somechunkkeyboardindex].arrayOfChunkData[c].SC_instancedChunk_Instances[cc].instancePos.Y;//otherVec4AttractForce.Y;
                                                            somechunkkeyboard[somechunkkeyboardindex].arrayofindexzeromesh[c].arrayOfScriptForInstances[cc].current_pos.M43 = somechunkkeyboard[somechunkkeyboardindex].arrayOfChunkData[c].SC_instancedChunk_Instances[cc].instancePos.Z;//otherVec4AttractForce.Z;

                                                            somechunkkeyboard[somechunkkeyboardindex].arrayofindexzeromesh[c].instances[cc].instancePos.X += otherVec4AttractForce.X;
                                                            somechunkkeyboard[somechunkkeyboardindex].arrayofindexzeromesh[c].instances[cc].instancePos.Y += otherVec4AttractForce.Y;
                                                            somechunkkeyboard[somechunkkeyboardindex].arrayofindexzeromesh[c].instances[cc].instancePos.Z += otherVec4AttractForce.Z;

                                                            //arrayOfChunkData[c].SC_instancedChunk_Instances[cc].instancePos.X

                                                            if (lh_attract_force != JVector.Zero && lh_attract_force != null && lh_attract_force.Length() > 0 && body != _grab_rigid_data._body)
                                                            {
                                                                //MessageBox((IntPtr)0, "" + "null dir 01", "Oculus Error", 0);
                                                                //MessageBox((IntPtr)0, "" + "not null force", "Oculus Error", 0);
                                                                //lh_attract_force.Normalize();

                                                                //if (has_water_buo_effect == 1)
                                                                //{
                                                                //    lh_attract_force *= force_4_screen * 10;
                                                               /// }
                                                                //else
                                                                //{
                                                                //    lh_attract_force *= force_4_screen * 1;
                                                                //}

                                                                //0.0045f

                                                                //lh_attract_force *= force_4_screen*1000;
                                                                //body.LinearVelocity += lh_attract_force;
                                                                //body.AddForce(lh_attract_force);

                                                                //worldMatrix

                                                                //arrayOfChunkData[c].arrayOfInstance[cc].instancePos += new Vector4(lh_attract_force.X, lh_attract_force.Y, lh_attract_force.Z, 1);

                                                                //body.AddTorque(force);
                                                            }
                                                        }
                                                        else
                                                        {
                                                            //Console.WriteLine("null dir");
                                                           //// MainWindow.MessageBox((IntPtr)0, "" + "null dir 01", "Oculus Error", 0);
                                                        }
                                                    }
                                                }
                                            }
                                        }*/




                                        //somechunkkeyboard[somechunkkeyboardindex].arrayOfChunkData[c].viewMatrix = _viewMatrix;
                                        //somechunkkeyboard[somechunkkeyboardindex].arrayOfChunkData[c].projectionMatrix = _projectionMatrix;

                                        //arrayOfChunkData[c].worldMatrix += arrayOfMatrixBuff[0].world;

                                        somechunkkeyboard[somechunkkeyboardindex].lightBufferInstChunk = somechunkkeyboard[somechunkkeyboardindex].arrayOfChunkData[c].lightBuffer;

                                        //SENDING THE SCREENCAPTURE TO THE BUFFER FOR THE SHADER
                                        //somechunkkeyboard[somechunkkeyboardindex].shaderOfChunk.shaderResourceView2D = SC_Update._desktopFrame.ShaderResource;// SC_Update._desktopFrame.ShaderResourceArray;
                                        //somechunkkeyboard[somechunkkeyboardindex].arrayOfChunkData[c].chunkShader.shaderResourceView2D = SC_Update._desktopFrame.ShaderResource;//
                                        //SENDING THE SCREENCAPTURE TO THE BUFFER FOR THE SHADER


                                        //RENDERING THE INSTANCED CHUNK 
                                        somechunkkeyboard[somechunkkeyboardindex].arrayOfChunkData[c].matrixBuffer = somechunkkeyboard[somechunkkeyboardindex].arrayOfMatrixBuff;
                                        //somechunkkeyboard[somechunkkeyboardindex].arrayOfChunkData[c] = somechunkkeyboard[somechunkkeyboardindex].shaderOfChunk.Renderer(somechunkkeyboard[somechunkkeyboardindex].arrayOfChunkData[c], c, null, somechunkkeyboard[somechunkkeyboardindex].voxeltype); //SC_Update._desktopFrame.ShaderResource
                                                                                                                                                                                                                                                                                                       //RENDERING THE INSTANCED CHUNK
                                                                                                                                                                                                                                                                                                       //SC_Update._shaderManager.renderinstancedchunk(somechunkkeyboard[somechunkkeyboardindex].arrayOfChunkData[c], c, SC_Update._desktopFrame.ShaderResource, somechunkkeyboard[somechunkkeyboardindex].voxeltype);

                                        //somechunkkeyboard[somechunkkeyboardindex].arrayOfChunkData[c] = somechunkkeyboard[somechunkkeyboardindex].arrayOfChunkData[c].shaderOfChunk.Renderer(somechunkkeyboard[somechunkkeyboardindex].arrayOfChunkData[c], c, null, somechunkkeyboard[somechunkkeyboardindex].voxeltype); //SC_Update._desktopFrame.ShaderResource

                                        somechunkkeyboard[somechunkkeyboardindex].arrayOfChunkData[c] = somechunkkeyboard[somechunkkeyboardindex].shaderOfChunk.Renderer(somechunkkeyboard[somechunkkeyboardindex].arrayOfChunkData[c], c, null, somechunkkeyboard[somechunkkeyboardindex].voxeltype); //SC_Update._desktopFrame.ShaderResource

                                    }
                                }
                            }
                        }
                    }
                }
                //CHUNK MESH VIRTUAL KEYBOARD
                //CHUNK MESH VIRTUAL KEYBOARD
                //CHUNK MESH VIRTUAL KEYBOARD





                /*
                //CHUNK MESH VIRTUAL KEYBOARD CONTAINMENT GRID
                //CHUNK MESH VIRTUAL KEYBOARD CONTAINMENT GRID
                //CHUNK MESH VIRTUAL KEYBOARD CONTAINMENT GRID
                for (int xxxx = 0; xxxx < somechunkkeyboardsgridw; xxxx++)
                {
                    for (int yyyy = 0; yyyy < somechunkkeyboardsgridh; yyyy++)
                    {
                        for (int zzzz = 0; zzzz < somechunkkeyboardsgridd; zzzz++)
                        {
                            var somechunkkeyboardgridindex = xxxx + somechunkkeyboardsgridw * (yyyy + somechunkkeyboardsgridh * zzzz);


                            //somechunkkeyboardgrid[somechunkkeyboardgridindex].worldmatofobj = somechunkkeyboardgrid[somechunkkeyboardgridindex].

                            somechunkkeyboardgrid[somechunkkeyboardgridindex].arrayOfMatrixBuff[0].world = _worldMatrix;
                            somechunkkeyboardgrid[somechunkkeyboardgridindex].arrayOfMatrixBuff[0].view = _viewMatrix;
                            somechunkkeyboardgrid[somechunkkeyboardgridindex].arrayOfMatrixBuff[0].proj = _projectionMatrix;

                            /*somechunkkeyboardgrid[somechunkkeyboardgridindex].arrayOfMatrixBuff[0] = new SC_instancedChunkPrim.DMatrixBuffer()
                            {
                                world = _worldMatrix,
                                view = _viewMatrix,
                                proj = _projectionMatrix,
                            };*/


                            /*somechunkkeyboardgrid[somechunkkeyboardgridindex].lightBufferInstChunk[0] = new SC_instancedChunkPrim.DLightBufferEr()
                            {
                                ambientColor = ambientColor,
                                diffuseColor = diffuseColour,
                                lightDirection = rayDirFrontInstancesChunks,
                                padding0 = 0,
                                lightPosition = centerPosRighthandposRR,
                                padding1 = 100
                            };

                            lightpos.X = SC_Update._rightTouchMatrix.M41;
                            lightpos.Y = SC_Update._rightTouchMatrix.M42;
                            lightpos.Z = SC_Update._rightTouchMatrix.M43;


                            Quaternion somerighttouchquat;
                            Matrix somemat = SC_Update._rightTouchMatrix;
                            Quaternion.RotationMatrix(ref somemat, out somerighttouchquat);

                            Vector3 forwarddir = sc_maths._getDirection(Vector3.ForwardRH, somerighttouchquat);

                            //ambientColor = new Vector4(0.45f, 0.45f, 0.45f, 1.0f);
                            ambientColor = new Vector4(0.75f, 0.75f, 0.75f, 1.0f);
                            diffuseColour = new Vector4(1, 1, 1, 1);
                            //lightDirection = new Vector3(0, -1, -1);

                            somechunkkeyboardgrid[somechunkkeyboardgridindex].lightBufferInstChunk[0].lightDirection = forwarddir;
                            somechunkkeyboardgrid[somechunkkeyboardgridindex].lightBufferInstChunk[0].lightPosition = lightpos;

                            somechunkkeyboardgrid[somechunkkeyboardgridindex].lightBufferInstChunk[0].ambientColor = ambientColor;
                            somechunkkeyboardgrid[somechunkkeyboardgridindex].lightBufferInstChunk[0].diffuseColor = diffuseColour;

                            for (int x = 0; x < somechunkkeyboardglobalsgrid.numberOfObjectInWidth; x++)
                            {
                                for (int y = 0; y < somechunkkeyboardglobalsgrid.numberOfObjectInHeight; y++)
                                {
                                    for (int z = 0; z < somechunkkeyboardglobalsgrid.numberOfObjectInDepth; z++)
                                    {
                                        int c = x + somechunkkeyboardglobalsgrid.numberOfObjectInWidth * (y + somechunkkeyboardglobalsgrid.numberOfObjectInHeight * z);

                                        if (somechunkkeyboardgrid[somechunkkeyboardgridindex].arrayOfChunkData[c].switchForRender == 1)
                                        {
                                            var matrixBufferDescriptionVertex00 = new BufferDescription()
                                            {
                                                Usage = ResourceUsage.Dynamic,
                                                SizeInBytes = Marshal.SizeOf(typeof(SC_instancedChunk.DInstanceType)) * somechunkkeyboardgrid[somechunkkeyboardgridindex].instances.Length,
                                                BindFlags = BindFlags.VertexBuffer,
                                                CpuAccessFlags = CpuAccessFlags.Write,
                                                OptionFlags = ResourceOptionFlags.None,
                                                StructureByteStride = 0
                                            };

                                            var InstanceBuffer = new SharpDX.Direct3D11.Buffer(SC_console_directx.D3D.device, matrixBufferDescriptionVertex00);

                                            somechunkkeyboardgrid[somechunkkeyboardgridindex].arrayOfChunkData[c].SC_instancedChunk_Instances = somechunkkeyboardgrid[somechunkkeyboardgridindex].arrayofindexzeromesh[c].instances;
                                            somechunkkeyboardgrid[somechunkkeyboardgridindex].arrayOfChunkData[c].worldMatrix = _worldMatrix;
                                            somechunkkeyboardgrid[somechunkkeyboardgridindex].arrayOfChunkData[c].viewMatrix = _viewMatrix;
                                            somechunkkeyboardgrid[somechunkkeyboardgridindex].arrayOfChunkData[c].projectionMatrix = _projectionMatrix;

                                            //arrayOfChunkData[c].worldMatrix += arrayOfMatrixBuff[0].world;

                                            somechunkkeyboardgrid[somechunkkeyboardgridindex].arrayOfChunkData[c].matrixBuffer = somechunkkeyboardgrid[somechunkkeyboardgridindex].arrayOfMatrixBuff;

                                            //arrayOfChunkData[c].lightBuffer = lightBufferInstChunk;

                                            somechunkkeyboardgrid[somechunkkeyboardgridindex].arrayOfChunkData[c].instanceBuffer = InstanceBuffer;
                                            somechunkkeyboardgrid[somechunkkeyboardgridindex].arrayOfChunkData[c].arrayOfSomeMap = somechunkkeyboardgrid[somechunkkeyboardgridindex].arrayofindexzeromesh[c].arrayOfSomeMap;

                                            //arrayOfChunkData[c] = shaderOfChunk.Renderer(arrayOfChunkData[c], c);
                                        }
                                        else
                                        {
                                            float staticPlaneSize = somechunkkeyboardglobalsgrid.planeSize;
                                            float planeSize0 = somechunkkeyboardglobalsgrid.planeSize;
                                            float alternateStaticPlaneSize = 0;

                                            if (staticPlaneSize == 1)
                                            {
                                                staticPlaneSize = planeSize0 * 0.1f;
                                                alternateStaticPlaneSize = planeSize0 * 0.1f;
                                            }
                                            else if (staticPlaneSize == 0.1f)
                                            {
                                                staticPlaneSize = planeSize0;
                                                alternateStaticPlaneSize = planeSize0 * 10;
                                            }
                                            else if (staticPlaneSize == 0.01f)
                                            {
                                                staticPlaneSize = planeSize0;
                                                alternateStaticPlaneSize = planeSize0 * 1000;
                                            }


                                            for (int xx = 0; xx < somechunkkeyboardglobalsgrid.numberOfInstancesPerObjectInWidth; xx++)
                                            {
                                                //MainWindow.MessageBox((IntPtr)0, "" + noiseXZ, "sccs", 0);

                                                for (int yy = 0; yy < somechunkkeyboardglobalsgrid.numberOfInstancesPerObjectInHeight; yy++)
                                                {
                                                    for (int zz = 0; zz < somechunkkeyboardglobalsgrid.numberOfInstancesPerObjectInDepth; zz++)
                                                    {

                                                        float seed = (float)sc_maths.getSomeRandNum(3420, 9999999); //3420;

                                                        int cc = xx + somechunkkeyboardglobalsgrid.numberOfInstancesPerObjectInWidth * (yy + somechunkkeyboardglobalsgrid.numberOfInstancesPerObjectInHeight * zz);




                                                        /*if (sc_menu_scroller == 3 && somecounterresetcounter < somechunkkeyboardgridswidth * somechunkkeyboardgridsheight * somechunkkeyboardgridsdepth * somechunkkeyboardglobalsgrid.numberOfObjectInWidth * somechunkkeyboardglobalsgrid.numberOfObjectInHeight * somechunkkeyboardglobalsgrid.numberOfObjectInDepth * somechunkkeyboardglobalsgrid.numberOfInstancesPerObjectInWidth * somechunkkeyboardglobalsgrid.numberOfInstancesPerObjectInHeight * somechunkkeyboardglobalsgrid.numberOfInstancesPerObjectInDepth && resetvoxelladdercounter == 2)
                                                        {
                                                            //MainWindow.MessageBox((IntPtr)0, "menu option 3" , "sccs", 0);

                                                            int voxelchunkinvertoption = MainWindow.usetypeofvoxel;


                                                            somechunkkeyboardgrid[somechunkkeyboardgridindex].arrayofindexzeromesh[c].somechunk[cc].resetmap(out m11, out m12, out m13, out m14, out m21, out m22, out m23, out m24, out m31, out m32, out m33, out m34, out m41, out m42, out m43, out m44, -1, voxelchunkinvertoption);
                                                            //somechunkkeyboardgrid[somechunkkeyboardgridindex].arrayofindexzeromesh[c].somechunk[cc].setnewmap(out m11, out m12, out m13, out m14, out m21, out m22, out m23, out m24, out m31, out m32, out m33, out m34, out m41, out m42, out m43, out m44, -1, voxelchunkinvertoption); //


                                                            somechunkkeyboardgrid[somechunkkeyboardgridindex].arrayofindexzeromesh[c].instancesmatrix[cc].instancematrix.M11 = (float)m11;
                                                            somechunkkeyboardgrid[somechunkkeyboardgridindex].arrayofindexzeromesh[c].instancesmatrix[cc].instancematrix.M12 = (float)m12;
                                                            somechunkkeyboardgrid[somechunkkeyboardgridindex].arrayofindexzeromesh[c].instancesmatrix[cc].instancematrix.M13 = (float)m13;
                                                            somechunkkeyboardgrid[somechunkkeyboardgridindex].arrayofindexzeromesh[c].instancesmatrix[cc].instancematrix.M14 = (float)m14;

                                                            somechunkkeyboardgrid[somechunkkeyboardgridindex].arrayofindexzeromesh[c].instancesmatrix[cc].instancematrix.M21 = (float)m21;
                                                            somechunkkeyboardgrid[somechunkkeyboardgridindex].arrayofindexzeromesh[c].instancesmatrix[cc].instancematrix.M22 = (float)m22;
                                                            somechunkkeyboardgrid[somechunkkeyboardgridindex].arrayofindexzeromesh[c].instancesmatrix[cc].instancematrix.M23 = (float)m23;
                                                            somechunkkeyboardgrid[somechunkkeyboardgridindex].arrayofindexzeromesh[c].instancesmatrix[cc].instancematrix.M24 = (float)m24;

                                                            somechunkkeyboardgrid[somechunkkeyboardgridindex].arrayofindexzeromesh[c].instancesmatrix[cc].instancematrix.M31 = (float)m31;
                                                            somechunkkeyboardgrid[somechunkkeyboardgridindex].arrayofindexzeromesh[c].instancesmatrix[cc].instancematrix.M32 = (float)m32;
                                                            somechunkkeyboardgrid[somechunkkeyboardgridindex].arrayofindexzeromesh[c].instancesmatrix[cc].instancematrix.M33 = (float)m33;
                                                            somechunkkeyboardgrid[somechunkkeyboardgridindex].arrayofindexzeromesh[c].instancesmatrix[cc].instancematrix.M34 = (float)m34;

                                                            somechunkkeyboardgrid[somechunkkeyboardgridindex].arrayofindexzeromesh[c].instancesmatrix[cc].instancematrix.M41 = (float)m41;
                                                            somechunkkeyboardgrid[somechunkkeyboardgridindex].arrayofindexzeromesh[c].instancesmatrix[cc].instancematrix.M42 = (float)m42;
                                                            somechunkkeyboardgrid[somechunkkeyboardgridindex].arrayofindexzeromesh[c].instancesmatrix[cc].instancematrix.M43 = (float)m43;
                                                            somechunkkeyboardgrid[somechunkkeyboardgridindex].arrayofindexzeromesh[c].instancesmatrix[cc].instancematrix.M44 = (float)m44;

                                                            somechunkkeyboardgrid[somechunkkeyboardgridindex].arrayOfChunkData[c].copytobuffer = 1;

                                                            somecounterresetcounter++;
                                                        }*/
                                                        /*if (sc_menu_scroller == 3 && somecounterresetcounter >= somechunkkeyboardgridswidth * somechunkkeyboardgridsheight * somechunkkeyboardgridsdepth * somechunkkeyboardglobalsgrid.numberOfObjectInWidth * somechunkkeyboardglobalsgrid.numberOfObjectInHeight * somechunkkeyboardglobalsgrid.numberOfObjectInDepth * somechunkkeyboardglobalsgrid.numberOfInstancesPerObjectInWidth * somechunkkeyboardglobalsgrid.numberOfInstancesPerObjectInHeight * somechunkkeyboardglobalsgrid.numberOfInstancesPerObjectInDepth)
                                                        {
                                                            //MainWindow.MessageBox((IntPtr)0, "resetted map", "sccs", 0);

                                                            //sc_menu_scroller = 0;
                                                            //somecounterresetcounter = 0;
                                                        }











                                                        var somecountermax = (float)Math.Abs((somechunkkeyboardgrid[somechunkkeyboardgridindex].arrayofindexzeromesh[c].colorsNFaces[cc].colorsNFaces.W - (float)Math.Floor(somechunkkeyboardgrid[somechunkkeyboardgridindex].arrayofindexzeromesh[c].colorsNFaces[cc].colorsNFaces.W)) * 1000);

                                                        float noiseXZ = 100;
                                                        float noiseYZ = 100;
                                                        float noiseXY = 100;

                                                        float detailScale1 = 7;
                                                        float heightScale1 = 5;

                                                        //fastNoise = new FastNoise();

                                                        noiseXZ *= (fastNoise.GetNoise((x * planeSize0 + somechunkkeyboardgrid[somechunkkeyboardgridindex].arrayofindexzeromesh[c].colorsNFaces[cc].colorsNFaces.X + seed) / detailScale1, (z * planeSize0 + somechunkkeyboardgrid[somechunkkeyboardgridindex].arrayofindexzeromesh[c].colorsNFaces[cc].colorsNFaces.Z + seed) / detailScale1) * heightScale1);
                                                        float size0 = (1 / planeSize0) * somechunkkeyboardgrid[somechunkkeyboardgridindex].arrayofindexzeromesh[c].colorsNFaces[cc].colorsNFaces.Y;
                                                        noiseXZ -= size0;

                                                        //MainWindow.MessageBox((IntPtr)0, "c:" + somecountermax, "sccs error", 0);
                                                        noiseYZ *= (fastNoise.GetNoise((y * planeSize0 + somechunkkeyboardgrid[somechunkkeyboardgridindex].arrayofindexzeromesh[c].colorsNFaces[cc].colorsNFaces.Y + seed) / detailScale1, (z * planeSize0 + somechunkkeyboardgrid[somechunkkeyboardgridindex].arrayofindexzeromesh[c].colorsNFaces[cc].colorsNFaces.Z + seed) / detailScale1) * heightScale1);
                                                        float size1 = (1 / planeSize0) * somechunkkeyboardgrid[somechunkkeyboardgridindex].arrayofindexzeromesh[c].colorsNFaces[cc].colorsNFaces.X;
                                                        noiseYZ -= size1;


                                                        noiseXY *= (fastNoise.GetNoise((x * planeSize0 + somechunkkeyboardgrid[somechunkkeyboardgridindex].arrayofindexzeromesh[c].colorsNFaces[cc].colorsNFaces.X + seed) / detailScale1, (y * planeSize0 + somechunkkeyboardgrid[somechunkkeyboardgridindex].arrayofindexzeromesh[c].colorsNFaces[cc].colorsNFaces.Y + seed) / detailScale1) * heightScale1);
                                                        float size2 = (1 / planeSize0) * somechunkkeyboardgrid[somechunkkeyboardgridindex].arrayofindexzeromesh[c].colorsNFaces[cc].colorsNFaces.Z;
                                                        noiseXY -= size2;

                                                        //TOREADD FOR NOISE TEST ON COLOR

                                                        //noiseXZ *= fastNoise.GetNoise((((x * staticPlaneSize) + (somechunkkeyboardgrid[somechunkkeyboardgridindex].arrayofindexzeromesh[c].colorsNFaces[cc].colorsNFaces.X * alternateStaticPlaneSize) + seed) / _detailScale) * _HeightScale, (((y * staticPlaneSize) + (somechunkkeyboardgrid[somechunkkeyboardgridindex].arrayofindexzeromesh[c].colorsNFaces[cc].colorsNFaces.Y * alternateStaticPlaneSize) + seed) / _detailScale) * _HeightScale, (((z * staticPlaneSize) + (somechunkkeyboardgrid[somechunkkeyboardgridindex].arrayofindexzeromesh[c].colorsNFaces[cc].colorsNFaces.Z * alternateStaticPlaneSize) + seed) / _detailScale) * _HeightScale);

                                                        float someclampednoisexz = sc_maths.ClampValue(0.55f + (1 * noiseXZ), 0.35f, 0.75f);
                                                        float someclampednoiseyz = sc_maths.ClampValue(0.55f + (1 * noiseYZ), 0.35f, 0.75f);
                                                        float someclampednoisexy = sc_maths.ClampValue(0.55f + (1 * noiseXY), 0.35f, 0.75f);

                                                        //MainWindow.MessageBox((IntPtr)0, "someclampednoisexz:" + someclampednoisexz + "/someclampednoiseyz:" + someclampednoiseyz + "/someclampednoisexy:" + someclampednoisexy, "sccs", 0);
                                                        //MainWindow.MessageBox((IntPtr)0, "noiseXZ:" + noiseXZ + "/noiseYZ:" + noiseYZ + "/noiseXY:" + noiseXY, "sccs", 0);

                                                        //somechunkkeyboardgrid[somechunkkeyboardgridindex].arrayofindexzeromesh[c].colorsNFaces[cc].colorsNFaces.X =Math.Abs(0.15f + noiseXZ);// someclampednoisexz;
                                                        //somechunkkeyboardgrid[somechunkkeyboardgridindex].arrayofindexzeromesh[c].colorsNFaces[cc].colorsNFaces.Y = Math.Abs(0.25f + noiseYZ);// someclampednoiseyz;
                                                        //somechunkkeyboardgrid[somechunkkeyboardgridindex].arrayofindexzeromesh[c].colorsNFaces[cc].colorsNFaces.Z = Math.Abs(0.15f + noiseXY);// someclampednoisexy;

                                                        somechunkkeyboardgrid[somechunkkeyboardgridindex].arrayofindexzeromesh[c].colorsNFaces[cc].colorsNFaces.X = 0.35f + Math.Abs(someclampednoisexz);
                                                        somechunkkeyboardgrid[somechunkkeyboardgridindex].arrayofindexzeromesh[c].colorsNFaces[cc].colorsNFaces.Y = 0.35f + Math.Abs(someclampednoiseyz);
                                                        somechunkkeyboardgrid[somechunkkeyboardgridindex].arrayofindexzeromesh[c].colorsNFaces[cc].colorsNFaces.Z = 0.35f + Math.Abs(someclampednoisexy);

                                                        //somechunkkeyboardgrid[somechunkkeyboardgridindex].arrayofindexzeromesh[c].colorsNFaces[cc].colorsNFaces.W = 1.0f;

                                                        //this can be swapped with heightmaps values with some modifications here and there to bring bytes within a range of 0 to 255 rgba values or from within a range of 0.0f to 1.0f values.
                                                        if (Math.Truncate(somechunkkeyboardgrid[somechunkkeyboardgridindex].arrayofindexzeromesh[c].colorsNFaces[cc].colorsNFaces.W) >= somecountermax)
                                                        {

                                                            somechunkkeyboardgrid[somechunkkeyboardgridindex].arrayofindexzeromesh[c].colorsNFaces[cc].colorsNFaces.W = 0 + somecountermax * 0.001f;
                                                        }
                                                        somechunkkeyboardgrid[somechunkkeyboardgridindex].arrayofindexzeromesh[c].colorsNFaces[cc].colorsNFaces.W += 1f;

                                                        //TOREADD FOR NOISE TEST ON COLOR

                                                        //this can be swapped with heightmaps values with some modifications here and there to bring bytes within a range of 0 to 255 rgba values or from within a range of 0.0f to 1.0f values.
                                                    }
                                                }
                                            }
                                        }















                                        Matrix _WorldMatrix = WorldMatrix;
                                        Matrix matrixtouchright = SC_Update._rightTouchMatrix;//_player_rght_hnd[0][0]._arrayOfInstances[0].current_pos;

                                        int xii = 0;
                                        int yii = 0;
                                        int zii = 0;



                                        //ATTRACT FORCE LOGIC
                                        //ATTRACT FORCE LOGIC
                                        //ATTRACT FORCE LOGIC
                                        /*
                                        //arrayOfChunkData[c].worldMatrix += arrayOfMatrixBuff[0].world;
                                        if (SC_Update.handTriggerRight[1] >= 0.001f)
                                        {
                                            //MainWindow.MessageBox((IntPtr)0, "b: ", "", 0);
                                            for (int xxi = 0; xxi < somechunkkeyboardglobalsgrid.numberOfInstancesPerObjectInWidth; xxi++)
                                            {
                                                for (int yyi = 0; yyi < somechunkkeyboardglobalsgrid.numberOfInstancesPerObjectInHeight; yyi++)
                                                {
                                                    for (int zzi = 0; zzi < somechunkkeyboardglobalsgrid.numberOfInstancesPerObjectInDepth; zzi++)
                                                    {
                                                        int cc = xxi + somechunkkeyboardglobalsgrid.numberOfInstancesPerObjectInWidth * (yyi + somechunkkeyboardglobalsgrid.numberOfInstancesPerObjectInHeight * zzi);

                                                        //var dirToRightHand = new Vector3(_player_rght_hnd[0][0]._arrayOfInstances[0].current_pos.M41, _player_rght_hnd[0][0]._arrayOfInstances[0].current_pos.M42, _player_rght_hnd[0][0]._arrayOfInstances[0].current_pos.M43) - new Vector3(arrayOfChunkData[c].SC_instancedChunk_Instances[cc].instancePos.X, arrayOfChunkData[c].SC_instancedChunk_Instances[cc].instancePos.Y, arrayOfChunkData[c].SC_instancedChunk_Instances[cc].instancePos.Z);

                                                        var dirToRightHand = new Vector3(_player_rght_hnd[0][0]._arrayOfInstances[0].current_pos.M41, _player_rght_hnd[0][0]._arrayOfInstances[0].current_pos.M42, _player_rght_hnd[0][0]._arrayOfInstances[0].current_pos.M43) - new Vector3(somechunkkeyboardgrid[somechunkkeyboardgridindex].arrayofindexzeromesh[c].arrayOfScriptForInstances[cc].current_pos.M41, somechunkkeyboardgrid[somechunkkeyboardgridindex].arrayofindexzeromesh[c].arrayOfScriptForInstances[cc].current_pos.M42, somechunkkeyboardgrid[somechunkkeyboardgridindex].arrayofindexzeromesh[c].arrayOfScriptForInstances[cc].current_pos.M43);

                                                        var lengthofdir = dirToRightHand.Length();

                                                        //var moveRightHand = new JVector(_player_lft_hnd[0]._arrayOfInstances[0].current_pos.M41, _player_lft_hnd[0]._arrayOfInstances[0].current_pos.M42, _player_lft_hnd[0]._arrayOfInstances[0].current_pos.M43) - new JVector(_player_lft_hnd[0]._arrayOfInstances[0]._LASTPOSITIONFORPHYSICS.M41, _player_lft_hnd[0]._arrayOfInstances[0]._LASTPOSITIONFORPHYSICS.M42, _player_lft_hnd[0]._arrayOfInstances[0]._LASTPOSITIONFORPHYSICS.M43);

                                                        if (dirToRightHand != null)
                                                        {
                                                            dirToRightHand.Normalize();

                                                            lh_attract_force = new JVector(dirToRightHand.X, dirToRightHand.Y, dirToRightHand.Z) * 1;

                                                            lh_attract_force.Normalize();

                                                            lh_attract_force *= 0.5f; //0.1f

                                                            Vector4 otherVec4AttractForce = new Vector4(lh_attract_force.X, lh_attract_force.Y, lh_attract_force.Z, 1);

                                                            somechunkkeyboardgrid[somechunkkeyboardgridindex].arrayOfChunkData[c].SC_instancedChunk_Instances[cc].instancePos += otherVec4AttractForce;// new Vector4(lh_attract_force.X, lh_attract_force.Y, lh_attract_force.Z, 1);

                                                            somechunkkeyboardgrid[somechunkkeyboardgridindex].arrayofindexzeromesh[c].arrayOfScriptForInstances[cc].current_pos.M41 = somechunkkeyboardgrid[somechunkkeyboardgridindex].arrayOfChunkData[c].SC_instancedChunk_Instances[cc].instancePos.X;// otherVec4AttractForce.X;
                                                            somechunkkeyboardgrid[somechunkkeyboardgridindex].arrayofindexzeromesh[c].arrayOfScriptForInstances[cc].current_pos.M42 = somechunkkeyboardgrid[somechunkkeyboardgridindex].arrayOfChunkData[c].SC_instancedChunk_Instances[cc].instancePos.Y;//otherVec4AttractForce.Y;
                                                            somechunkkeyboardgrid[somechunkkeyboardgridindex].arrayofindexzeromesh[c].arrayOfScriptForInstances[cc].current_pos.M43 = somechunkkeyboardgrid[somechunkkeyboardgridindex].arrayOfChunkData[c].SC_instancedChunk_Instances[cc].instancePos.Z;//otherVec4AttractForce.Z;

                                                            somechunkkeyboardgrid[somechunkkeyboardgridindex].arrayofindexzeromesh[c].instances[cc].instancePos.X += otherVec4AttractForce.X;
                                                            somechunkkeyboardgrid[somechunkkeyboardgridindex].arrayofindexzeromesh[c].instances[cc].instancePos.Y += otherVec4AttractForce.Y;
                                                            somechunkkeyboardgrid[somechunkkeyboardgridindex].arrayofindexzeromesh[c].instances[cc].instancePos.Z += otherVec4AttractForce.Z;

                                                            //arrayOfChunkData[c].SC_instancedChunk_Instances[cc].instancePos.X

                                                            if (lh_attract_force != JVector.Zero && lh_attract_force != null && lh_attract_force.Length() > 0 && body != _grab_rigid_data._body)
                                                            {
                                                                //MessageBox((IntPtr)0, "" + "null dir 01", "Oculus Error", 0);
                                                                //MessageBox((IntPtr)0, "" + "not null force", "Oculus Error", 0);
                                                                //lh_attract_force.Normalize();

                                                                //if (has_water_buo_effect == 1)
                                                                //{
                                                                //    lh_attract_force *= force_4_screen * 10;
                                                               /// }
                                                                //else
                                                                //{
                                                                //    lh_attract_force *= force_4_screen * 1;
                                                                //}

                                                                //0.0045f

                                                                //lh_attract_force *= force_4_screen*1000;
                                                                //body.LinearVelocity += lh_attract_force;
                                                                //body.AddForce(lh_attract_force);

                                                                //worldMatrix

                                                                //arrayOfChunkData[c].arrayOfInstance[cc].instancePos += new Vector4(lh_attract_force.X, lh_attract_force.Y, lh_attract_force.Z, 1);

                                                                //body.AddTorque(force);
                                                            }
                                                        }
                                                        else
                                                        {
                                                            //Console.WriteLine("null dir");
                                                           //// MainWindow.MessageBox((IntPtr)0, "" + "null dir 01", "Oculus Error", 0);
                                                        }
                                                    }
                                                }
                                            }
                                        }




                                        //somechunkkeyboardgrid[somechunkkeyboardgridindex].arrayOfChunkData[c].viewMatrix = _viewMatrix;
                                        //somechunkkeyboardgrid[somechunkkeyboardgridindex].arrayOfChunkData[c].projectionMatrix = _projectionMatrix;

                                        //arrayOfChunkData[c].worldMatrix += arrayOfMatrixBuff[0].world;

                                        somechunkkeyboardgrid[somechunkkeyboardgridindex].lightBufferInstChunk = somechunkkeyboardgrid[somechunkkeyboardgridindex].arrayOfChunkData[c].lightBuffer;

                                        //SENDING THE SCREENCAPTURE TO THE BUFFER FOR THE SHADER
                                        //somechunkkeyboardgrid[somechunkkeyboardgridindex].shaderOfChunk.shaderResourceView2D = SC_Update._desktopFrame.ShaderResource;// SC_Update._desktopFrame.ShaderResourceArray;
                                        //somechunkkeyboardgrid[somechunkkeyboardgridindex].arrayOfChunkData[c].chunkShader.shaderResourceView2D = SC_Update._desktopFrame.ShaderResource;//
                                        //SENDING THE SCREENCAPTURE TO THE BUFFER FOR THE SHADER


                                        //RENDERING THE INSTANCED CHUNK 
                                        somechunkkeyboardgrid[somechunkkeyboardgridindex].arrayOfChunkData[c].matrixBuffer = somechunkkeyboardgrid[somechunkkeyboardgridindex].arrayOfMatrixBuff;
                                        //somechunkkeyboardgrid[somechunkkeyboardgridindex].arrayOfChunkData[c] = somechunkkeyboardgrid[somechunkkeyboardgridindex].shaderOfChunk.Renderer(somechunkkeyboardgrid[somechunkkeyboardgridindex].arrayOfChunkData[c], c, null, somechunkkeyboardgrid[somechunkkeyboardgridindex].voxeltype); //SC_Update._desktopFrame.ShaderResource
                                                                                                                                                                                                                                                                                                                                       //RENDERING THE INSTANCED CHUNK
                                                                                                                                                                                                                                                                                                                                       //SC_Update._shaderManager.renderinstancedchunk(somechunkkeyboardgrid[somechunkkeyboardgridindex].arrayOfChunkData[c], c, SC_Update._desktopFrame.ShaderResource, somechunkkeyboardgrid[somechunkkeyboardgridindex].voxeltype);


                                        somechunkkeyboardgrid[somechunkkeyboardgridindex].arrayOfChunkData[c] = somechunkkeyboardgrid[somechunkkeyboardgridindex].arrayOfChunkData[c].shaderOfChunk.Renderer(somechunkkeyboardgrid[somechunkkeyboardgridindex].arrayOfChunkData[c], c, null, somechunkkeyboardgrid[somechunkkeyboardgridindex].voxeltype); //SC_Update._desktopFrame.ShaderResource
                                    }
                                }
                            }
                        }
                    }
                }*/
                //CHUNK MESH VIRTUAL KEYBOARD CONTAINMENT GRID
                //CHUNK MESH VIRTUAL KEYBOARD CONTAINMENT GRID
                //CHUNK MESH VIRTUAL KEYBOARD CONTAINMENT GRID






                /*
                SC_console_directx.D3D.DeviceContext.Rasterizer.State = SC_console_directx.D3D.RasterstateCullNone;

                SC_console_directx.D3D.TurnOnAlphaBlending();
                SC_console_directx.D3D.TurnZBufferOff();*/

                /*
                // SC_console_directx.D3D.TurnZBufferOn();

                // Initialize and set up the description of the stencil state.
                DepthStencilStateDescription depthStencilDesc = new DepthStencilStateDescription()
                {
                    IsDepthEnabled = true,
                    DepthWriteMask = DepthWriteMask.All,
                    DepthComparison = Comparison.Less,
                    IsStencilEnabled = true,
                    StencilReadMask = 0xFF,
                    StencilWriteMask = 0xFF,

                    // Stencil operation if pixel front-facing.
                    FrontFace = new DepthStencilOperationDescription()
                    {
                        FailOperation = StencilOperation.Keep,
                        DepthFailOperation = StencilOperation.Increment,
                        PassOperation = StencilOperation.Keep,
                        Comparison = Comparison.Always
                    },
                    // Stencil operation if pixel is back-facing.
                    BackFace = new DepthStencilOperationDescription()
                    {
                        FailOperation = StencilOperation.Keep,
                        DepthFailOperation = StencilOperation.Decrement,
                        PassOperation = StencilOperation.Keep,
                        Comparison = Comparison.Always
                    }
                };

                // Create the depth stencil state.
                var DepthStencilState = new DepthStencilState(SC_console_directx.D3D.device, depthStencilDesc);

                // Set the depth stencil state.
                SC_console_directx.D3D.device.ImmediateContext.OutputMerger.SetDepthStencilState(DepthStencilState, 1);
                //SC_console_directx.D3D.eyeTextures[0].DepthStencilView.Device.ImmediateContext.OutputMerger.SetDepthStencilState(DepthStencilState, 0);
                //SC_console_directx.D3D.eyeTextures[1].DepthStencilView.Device.ImmediateContext.OutputMerger.SetDepthStencilState(DepthStencilState, 0);
                */


                //VOXEL VIRTUAL DESKTOP
                //VOXEL VIRTUAL DESKTOP
                //VOXEL VIRTUAL DESKTOP
                for (int xxxx = 0; xxxx < somevoxelvirtualdesktopw; xxxx++)
                {
                    for (int yyyy = 0; yyyy < somevoxelvirtualdesktoph; yyyy++)
                    {
                        for (int zzzz = 0; zzzz < somevoxelvirtualdesktopd; zzzz++)
                        {
                            var somevoxelvirtualdesktopindex = xxxx + somevoxelvirtualdesktopw * (yyyy + somevoxelvirtualdesktoph * zzzz);

                            somevoxelvirtualdesktop[somevoxelvirtualdesktopindex].arrayOfMatrixBuff[0].world = _worldMatrix;
                            somevoxelvirtualdesktop[somevoxelvirtualdesktopindex].arrayOfMatrixBuff[0].view = _viewMatrix;
                            somevoxelvirtualdesktop[somevoxelvirtualdesktopindex].arrayOfMatrixBuff[0].proj = _projectionMatrix;

                            /*somevoxelvirtualdesktop[somevoxelvirtualdesktopindex].arrayOfMatrixBuff[0] = new SC_instancedChunkPrim.DMatrixBuffer()
                            {
                                world = _worldMatrix,
                                view = _viewMatrix,
                                proj = _projectionMatrix,
                            };*/


                            /*somevoxelvirtualdesktop[somevoxelvirtualdesktopindex].lightBufferInstChunk[0] = new SC_instancedChunkPrim.DLightBufferEr()
                            {
                                ambientColor = ambientColor,
                                diffuseColor = diffuseColour,
                                lightDirection = rayDirFrontInstancesChunks,
                                padding0 = 0,
                                lightPosition = centerPosRighthandposRR,
                                padding1 = 100
                            };*/

                            lightpos.X = SC_Update._rightTouchMatrix.M41;
                            lightpos.Y = SC_Update._rightTouchMatrix.M42;
                            lightpos.Z = SC_Update._rightTouchMatrix.M43;


                            Quaternion somerighttouchquat;
                            Matrix somemat = SC_Update._rightTouchMatrix;
                            Quaternion.RotationMatrix(ref somemat, out somerighttouchquat);

                            Vector3 forwarddir = sc_maths._getDirection(Vector3.ForwardRH, somerighttouchquat);

                            //ambientColor = new Vector4(0.45f, 0.45f, 0.45f, 1.0f);
                            ambientColor = new Vector4(0.75f, 0.75f, 0.75f, 1.0f);
                            diffuseColour = new Vector4(1, 1, 1, 1);
                            //lightDirection = new Vector3(0, -1, -1);

                            somevoxelvirtualdesktop[somevoxelvirtualdesktopindex].lightBufferInstChunk[0].lightDirection = forwarddir;
                            somevoxelvirtualdesktop[somevoxelvirtualdesktopindex].lightBufferInstChunk[0].lightPosition = lightpos;

                            somevoxelvirtualdesktop[somevoxelvirtualdesktopindex].lightBufferInstChunk[0].ambientColor = ambientColor;
                            somevoxelvirtualdesktop[somevoxelvirtualdesktopindex].lightBufferInstChunk[0].diffuseColor = diffuseColour;

                            for (int x = 0; x < somevoxelvirtualdesktopglobals.numberOfObjectInWidth; x++)
                            {
                                for (int y = 0; y < somevoxelvirtualdesktopglobals.numberOfObjectInHeight; y++)
                                {
                                    for (int z = 0; z < somevoxelvirtualdesktopglobals.numberOfObjectInDepth; z++)
                                    {
                                        int c = x + somevoxelvirtualdesktopglobals.numberOfObjectInWidth * (y + somevoxelvirtualdesktopglobals.numberOfObjectInHeight * z);


                                        somevoxelvirtualdesktop[somevoxelvirtualdesktopindex].arrayOfChunkData[c].someovrdir[0].ovrdirf = SC_Update.dirikvoxelbodyInstanceForward0;
                                        somevoxelvirtualdesktop[somevoxelvirtualdesktopindex].arrayOfChunkData[c].someovrdir[0].ovrdirr = SC_Update.dirikvoxelbodyInstanceRight0;
                                        somevoxelvirtualdesktop[somevoxelvirtualdesktopindex].arrayOfChunkData[c].someovrdir[0].ovrdiru = SC_Update.dirikvoxelbodyInstanceUp0;

                                     

                                        if (somevoxelvirtualdesktop[somevoxelvirtualdesktopindex].arrayOfChunkData[c].switchForRender == 1)
                                        {
                                            var matrixBufferDescriptionVertex00 = new BufferDescription()
                                            {
                                                Usage = ResourceUsage.Dynamic,
                                                SizeInBytes = Marshal.SizeOf(typeof(SC_instancedChunk.DInstanceType)) * somevoxelvirtualdesktop[somevoxelvirtualdesktopindex].instances.Length,
                                                BindFlags = BindFlags.VertexBuffer,
                                                CpuAccessFlags = CpuAccessFlags.Write,
                                                OptionFlags = ResourceOptionFlags.None,
                                                StructureByteStride = 0
                                            };

                                            var InstanceBuffer = new SharpDX.Direct3D11.Buffer(SC_console_directx.D3D.device, matrixBufferDescriptionVertex00);

                                            somevoxelvirtualdesktop[somevoxelvirtualdesktopindex].arrayOfChunkData[c].SC_instancedChunk_Instances = somevoxelvirtualdesktop[somevoxelvirtualdesktopindex].arrayofindexzeromesh[c].instances;
                                            somevoxelvirtualdesktop[somevoxelvirtualdesktopindex].arrayOfChunkData[c].worldMatrix = _worldMatrix;
                                            somevoxelvirtualdesktop[somevoxelvirtualdesktopindex].arrayOfChunkData[c].viewMatrix = _viewMatrix;
                                            somevoxelvirtualdesktop[somevoxelvirtualdesktopindex].arrayOfChunkData[c].projectionMatrix = _projectionMatrix;

                                            //arrayOfChunkData[c].worldMatrix += arrayOfMatrixBuff[0].world;

                                            somevoxelvirtualdesktop[somevoxelvirtualdesktopindex].arrayOfChunkData[c].matrixBuffer = somevoxelvirtualdesktop[somevoxelvirtualdesktopindex].arrayOfMatrixBuff;

                                            //arrayOfChunkData[c].lightBuffer = lightBufferInstChunk;

                                            somevoxelvirtualdesktop[somevoxelvirtualdesktopindex].arrayOfChunkData[c].instanceBuffer = InstanceBuffer;
                                            somevoxelvirtualdesktop[somevoxelvirtualdesktopindex].arrayOfChunkData[c].arrayOfSomeMap = somevoxelvirtualdesktop[somevoxelvirtualdesktopindex].arrayofindexzeromesh[c].arrayOfSomeMap;

                                            //arrayOfChunkData[c] = shaderOfChunk.Renderer(arrayOfChunkData[c], c);
                                        }
                                        else
                                        {
                                            float staticPlaneSize = somevoxelvirtualdesktopglobals.planeSize;
                                            float planeSize0 = somevoxelvirtualdesktopglobals.planeSize;
                                            float alternateStaticPlaneSize = 0;

                                            if (staticPlaneSize == 1)
                                            {
                                                staticPlaneSize = planeSize0 * 0.1f;
                                                alternateStaticPlaneSize = planeSize0 * 0.1f;
                                            }
                                            else if (staticPlaneSize == 0.1f)
                                            {
                                                staticPlaneSize = planeSize0;
                                                alternateStaticPlaneSize = planeSize0 * 10;
                                            }
                                            else if (staticPlaneSize == 0.01f)
                                            {
                                                staticPlaneSize = planeSize0;
                                                alternateStaticPlaneSize = planeSize0 * 1000;
                                            }


                                            for (int xx = 0; xx < somevoxelvirtualdesktopglobals.numberOfInstancesPerObjectInWidth; xx++)
                                            {
                                                //MainWindow.MessageBox((IntPtr)0, "" + noiseXZ, "sccs", 0);

                                                for (int yy = 0; yy < somevoxelvirtualdesktopglobals.numberOfInstancesPerObjectInHeight; yy++)
                                                {
                                                    for (int zz = 0; zz < somevoxelvirtualdesktopglobals.numberOfInstancesPerObjectInDepth; zz++)
                                                    {

                                                        float seed = (float)sc_maths.getSomeRandNum(3420, 9999999); //3420;

                                                        int cc = xx + somevoxelvirtualdesktopglobals.numberOfInstancesPerObjectInWidth * (yy + somevoxelvirtualdesktopglobals.numberOfInstancesPerObjectInHeight * zz);




                                                        /*if (sc_menu_scroller == 3 && somecounterresetcounter < somevoxelvirtualdesktopswidth * somevoxelvirtualdesktopsheight * somevoxelvirtualdesktopsdepth * somevoxelvirtualdesktopglobals.numberOfObjectInWidth * somevoxelvirtualdesktopglobals.numberOfObjectInHeight * somevoxelvirtualdesktopglobals.numberOfObjectInDepth * somevoxelvirtualdesktopglobals.numberOfInstancesPerObjectInWidth * somevoxelvirtualdesktopglobals.numberOfInstancesPerObjectInHeight * somevoxelvirtualdesktopglobals.numberOfInstancesPerObjectInDepth && resetvoxelladdercounter == 2)
                                                        {
                                                            //MainWindow.MessageBox((IntPtr)0, "menu option 3" , "sccs", 0);

                                                            int voxelchunkinvertoption = MainWindow.usetypeofvoxel;


                                                            somevoxelvirtualdesktop[somevoxelvirtualdesktopindex].arrayofindexzeromesh[c].somechunk[cc].resetmap(out m11, out m12, out m13, out m14, out m21, out m22, out m23, out m24, out m31, out m32, out m33, out m34, out m41, out m42, out m43, out m44, -1, voxelchunkinvertoption);
                                                            //somevoxelvirtualdesktop[somevoxelvirtualdesktopindex].arrayofindexzeromesh[c].somechunk[cc].setnewmap(out m11, out m12, out m13, out m14, out m21, out m22, out m23, out m24, out m31, out m32, out m33, out m34, out m41, out m42, out m43, out m44, -1, voxelchunkinvertoption); //


                                                            somevoxelvirtualdesktop[somevoxelvirtualdesktopindex].arrayofindexzeromesh[c].instancesmatrix[cc].instancematrix.M11 = (float)m11;
                                                            somevoxelvirtualdesktop[somevoxelvirtualdesktopindex].arrayofindexzeromesh[c].instancesmatrix[cc].instancematrix.M12 = (float)m12;
                                                            somevoxelvirtualdesktop[somevoxelvirtualdesktopindex].arrayofindexzeromesh[c].instancesmatrix[cc].instancematrix.M13 = (float)m13;
                                                            somevoxelvirtualdesktop[somevoxelvirtualdesktopindex].arrayofindexzeromesh[c].instancesmatrix[cc].instancematrix.M14 = (float)m14;

                                                            somevoxelvirtualdesktop[somevoxelvirtualdesktopindex].arrayofindexzeromesh[c].instancesmatrix[cc].instancematrix.M21 = (float)m21;
                                                            somevoxelvirtualdesktop[somevoxelvirtualdesktopindex].arrayofindexzeromesh[c].instancesmatrix[cc].instancematrix.M22 = (float)m22;
                                                            somevoxelvirtualdesktop[somevoxelvirtualdesktopindex].arrayofindexzeromesh[c].instancesmatrix[cc].instancematrix.M23 = (float)m23;
                                                            somevoxelvirtualdesktop[somevoxelvirtualdesktopindex].arrayofindexzeromesh[c].instancesmatrix[cc].instancematrix.M24 = (float)m24;

                                                            somevoxelvirtualdesktop[somevoxelvirtualdesktopindex].arrayofindexzeromesh[c].instancesmatrix[cc].instancematrix.M31 = (float)m31;
                                                            somevoxelvirtualdesktop[somevoxelvirtualdesktopindex].arrayofindexzeromesh[c].instancesmatrix[cc].instancematrix.M32 = (float)m32;
                                                            somevoxelvirtualdesktop[somevoxelvirtualdesktopindex].arrayofindexzeromesh[c].instancesmatrix[cc].instancematrix.M33 = (float)m33;
                                                            somevoxelvirtualdesktop[somevoxelvirtualdesktopindex].arrayofindexzeromesh[c].instancesmatrix[cc].instancematrix.M34 = (float)m34;

                                                            somevoxelvirtualdesktop[somevoxelvirtualdesktopindex].arrayofindexzeromesh[c].instancesmatrix[cc].instancematrix.M41 = (float)m41;
                                                            somevoxelvirtualdesktop[somevoxelvirtualdesktopindex].arrayofindexzeromesh[c].instancesmatrix[cc].instancematrix.M42 = (float)m42;
                                                            somevoxelvirtualdesktop[somevoxelvirtualdesktopindex].arrayofindexzeromesh[c].instancesmatrix[cc].instancematrix.M43 = (float)m43;
                                                            somevoxelvirtualdesktop[somevoxelvirtualdesktopindex].arrayofindexzeromesh[c].instancesmatrix[cc].instancematrix.M44 = (float)m44;

                                                            somevoxelvirtualdesktop[somevoxelvirtualdesktopindex].arrayOfChunkData[c].copytobuffer = 1;

                                                            somecounterresetcounter++;
                                                        }*/
                                                        /*if (sc_menu_scroller == 3 && somecounterresetcounter >= somevoxelvirtualdesktopswidth * somevoxelvirtualdesktopsheight * somevoxelvirtualdesktopsdepth * somevoxelvirtualdesktopglobals.numberOfObjectInWidth * somevoxelvirtualdesktopglobals.numberOfObjectInHeight * somevoxelvirtualdesktopglobals.numberOfObjectInDepth * somevoxelvirtualdesktopglobals.numberOfInstancesPerObjectInWidth * somevoxelvirtualdesktopglobals.numberOfInstancesPerObjectInHeight * somevoxelvirtualdesktopglobals.numberOfInstancesPerObjectInDepth)
                                                        {
                                                            //MainWindow.MessageBox((IntPtr)0, "resetted map", "sccs", 0);

                                                            //sc_menu_scroller = 0;
                                                            //somecounterresetcounter = 0;
                                                        }*/











                                                        var somecountermax = (float)Math.Abs((somevoxelvirtualdesktop[somevoxelvirtualdesktopindex].arrayofindexzeromesh[c].colorsNFaces[cc].colorsNFaces.W - (float)Math.Floor(somevoxelvirtualdesktop[somevoxelvirtualdesktopindex].arrayofindexzeromesh[c].colorsNFaces[cc].colorsNFaces.W)) * 1000);

                                                        float noiseXZ = 100;
                                                        float noiseYZ = 100;
                                                        float noiseXY = 100;

                                                        float detailScale1 = 7;
                                                        float heightScale1 = 5;

                                                        //fastNoise = new FastNoise();

                                                        noiseXZ *= (fastNoise.GetNoise((x * planeSize0 + somevoxelvirtualdesktop[somevoxelvirtualdesktopindex].arrayofindexzeromesh[c].colorsNFaces[cc].colorsNFaces.X + seed) / detailScale1, (z * planeSize0 + somevoxelvirtualdesktop[somevoxelvirtualdesktopindex].arrayofindexzeromesh[c].colorsNFaces[cc].colorsNFaces.Z + seed) / detailScale1) * heightScale1);
                                                        float size0 = (1 / planeSize0) * somevoxelvirtualdesktop[somevoxelvirtualdesktopindex].arrayofindexzeromesh[c].colorsNFaces[cc].colorsNFaces.Y;
                                                        noiseXZ -= size0;

                                                        //MainWindow.MessageBox((IntPtr)0, "c:" + somecountermax, "sccs error", 0);
                                                        noiseYZ *= (fastNoise.GetNoise((y * planeSize0 + somevoxelvirtualdesktop[somevoxelvirtualdesktopindex].arrayofindexzeromesh[c].colorsNFaces[cc].colorsNFaces.Y + seed) / detailScale1, (z * planeSize0 + somevoxelvirtualdesktop[somevoxelvirtualdesktopindex].arrayofindexzeromesh[c].colorsNFaces[cc].colorsNFaces.Z + seed) / detailScale1) * heightScale1);
                                                        float size1 = (1 / planeSize0) * somevoxelvirtualdesktop[somevoxelvirtualdesktopindex].arrayofindexzeromesh[c].colorsNFaces[cc].colorsNFaces.X;
                                                        noiseYZ -= size1;


                                                        noiseXY *= (fastNoise.GetNoise((x * planeSize0 + somevoxelvirtualdesktop[somevoxelvirtualdesktopindex].arrayofindexzeromesh[c].colorsNFaces[cc].colorsNFaces.X + seed) / detailScale1, (y * planeSize0 + somevoxelvirtualdesktop[somevoxelvirtualdesktopindex].arrayofindexzeromesh[c].colorsNFaces[cc].colorsNFaces.Y + seed) / detailScale1) * heightScale1);
                                                        float size2 = (1 / planeSize0) * somevoxelvirtualdesktop[somevoxelvirtualdesktopindex].arrayofindexzeromesh[c].colorsNFaces[cc].colorsNFaces.Z;
                                                        noiseXY -= size2;

                                                        //TOREADD FOR NOISE TEST ON COLOR

                                                        //noiseXZ *= fastNoise.GetNoise((((x * staticPlaneSize) + (somevoxelvirtualdesktop[somevoxelvirtualdesktopindex].arrayofindexzeromesh[c].colorsNFaces[cc].colorsNFaces.X * alternateStaticPlaneSize) + seed) / _detailScale) * _HeightScale, (((y * staticPlaneSize) + (somevoxelvirtualdesktop[somevoxelvirtualdesktopindex].arrayofindexzeromesh[c].colorsNFaces[cc].colorsNFaces.Y * alternateStaticPlaneSize) + seed) / _detailScale) * _HeightScale, (((z * staticPlaneSize) + (somevoxelvirtualdesktop[somevoxelvirtualdesktopindex].arrayofindexzeromesh[c].colorsNFaces[cc].colorsNFaces.Z * alternateStaticPlaneSize) + seed) / _detailScale) * _HeightScale);

                                                        float someclampednoisexz = sc_maths.ClampValue(0.55f + (1 * noiseXZ), 0.35f, 0.75f);
                                                        float someclampednoiseyz = sc_maths.ClampValue(0.55f + (1 * noiseYZ), 0.35f, 0.75f);
                                                        float someclampednoisexy = sc_maths.ClampValue(0.55f + (1 * noiseXY), 0.35f, 0.75f);

                                                        //MainWindow.MessageBox((IntPtr)0, "someclampednoisexz:" + someclampednoisexz + "/someclampednoiseyz:" + someclampednoiseyz + "/someclampednoisexy:" + someclampednoisexy, "sccs", 0);
                                                        //MainWindow.MessageBox((IntPtr)0, "noiseXZ:" + noiseXZ + "/noiseYZ:" + noiseYZ + "/noiseXY:" + noiseXY, "sccs", 0);

                                                        //somevoxelvirtualdesktop[somevoxelvirtualdesktopindex].arrayofindexzeromesh[c].colorsNFaces[cc].colorsNFaces.X =Math.Abs(0.15f + noiseXZ);// someclampednoisexz;
                                                        //somevoxelvirtualdesktop[somevoxelvirtualdesktopindex].arrayofindexzeromesh[c].colorsNFaces[cc].colorsNFaces.Y = Math.Abs(0.25f + noiseYZ);// someclampednoiseyz;
                                                        //somevoxelvirtualdesktop[somevoxelvirtualdesktopindex].arrayofindexzeromesh[c].colorsNFaces[cc].colorsNFaces.Z = Math.Abs(0.15f + noiseXY);// someclampednoisexy;

                                                        somevoxelvirtualdesktop[somevoxelvirtualdesktopindex].arrayofindexzeromesh[c].colorsNFaces[cc].colorsNFaces.X = 0.35f + Math.Abs(someclampednoisexz);
                                                        somevoxelvirtualdesktop[somevoxelvirtualdesktopindex].arrayofindexzeromesh[c].colorsNFaces[cc].colorsNFaces.Y = 0.35f + Math.Abs(someclampednoiseyz);
                                                        somevoxelvirtualdesktop[somevoxelvirtualdesktopindex].arrayofindexzeromesh[c].colorsNFaces[cc].colorsNFaces.Z = 0.35f + Math.Abs(someclampednoisexy);

                                                        //somevoxelvirtualdesktop[somevoxelvirtualdesktopindex].arrayofindexzeromesh[c].colorsNFaces[cc].colorsNFaces.W = 1.0f;

                                                        //this can be swapped with heightmaps values with some modifications here and there to bring bytes within a range of 0 to 255 rgba values or from within a range of 0.0f to 1.0f values.
                                                        if (Math.Truncate(somevoxelvirtualdesktop[somevoxelvirtualdesktopindex].arrayofindexzeromesh[c].colorsNFaces[cc].colorsNFaces.W) >= somecountermax)
                                                        {

                                                            somevoxelvirtualdesktop[somevoxelvirtualdesktopindex].arrayofindexzeromesh[c].colorsNFaces[cc].colorsNFaces.W = 0 + somecountermax * 0.001f;
                                                        }
                                                        somevoxelvirtualdesktop[somevoxelvirtualdesktopindex].arrayofindexzeromesh[c].colorsNFaces[cc].colorsNFaces.W += 1f;

                                                        //TOREADD FOR NOISE TEST ON COLOR

                                                        //this can be swapped with heightmaps values with some modifications here and there to bring bytes within a range of 0 to 255 rgba values or from within a range of 0.0f to 1.0f values.
                                                    }
                                                }
                                            }
                                        }















                                        Matrix _WorldMatrix = WorldMatrix;
                                        Matrix matrixtouchright = SC_Update._rightTouchMatrix;//_player_rght_hnd[0][0]._arrayOfInstances[0].current_pos;

                                        int xii = 0;
                                        int yii = 0;
                                        int zii = 0;



                                        //ATTRACT FORCE LOGIC
                                        //ATTRACT FORCE LOGIC
                                        //ATTRACT FORCE LOGIC
                                        /*
                                        //arrayOfChunkData[c].worldMatrix += arrayOfMatrixBuff[0].world;
                                        if (SC_Update.handTriggerRight[1] >= 0.001f)
                                        {
                                            //MainWindow.MessageBox((IntPtr)0, "b: ", "", 0);
                                            for (int xxi = 0; xxi < somevoxelvirtualdesktopglobals.numberOfInstancesPerObjectInWidth; xxi++)
                                            {
                                                for (int yyi = 0; yyi < somevoxelvirtualdesktopglobals.numberOfInstancesPerObjectInHeight; yyi++)
                                                {
                                                    for (int zzi = 0; zzi < somevoxelvirtualdesktopglobals.numberOfInstancesPerObjectInDepth; zzi++)
                                                    {
                                                        int cc = xxi + somevoxelvirtualdesktopglobals.numberOfInstancesPerObjectInWidth * (yyi + somevoxelvirtualdesktopglobals.numberOfInstancesPerObjectInHeight * zzi);

                                                        //var dirToRightHand = new Vector3(_player_rght_hnd[0][0]._arrayOfInstances[0].current_pos.M41, _player_rght_hnd[0][0]._arrayOfInstances[0].current_pos.M42, _player_rght_hnd[0][0]._arrayOfInstances[0].current_pos.M43) - new Vector3(arrayOfChunkData[c].SC_instancedChunk_Instances[cc].instancePos.X, arrayOfChunkData[c].SC_instancedChunk_Instances[cc].instancePos.Y, arrayOfChunkData[c].SC_instancedChunk_Instances[cc].instancePos.Z);

                                                        var dirToRightHand = new Vector3(_player_rght_hnd[0][0]._arrayOfInstances[0].current_pos.M41, _player_rght_hnd[0][0]._arrayOfInstances[0].current_pos.M42, _player_rght_hnd[0][0]._arrayOfInstances[0].current_pos.M43) - new Vector3(somevoxelvirtualdesktop[somevoxelvirtualdesktopindex].arrayofindexzeromesh[c].arrayOfScriptForInstances[cc].current_pos.M41, somevoxelvirtualdesktop[somevoxelvirtualdesktopindex].arrayofindexzeromesh[c].arrayOfScriptForInstances[cc].current_pos.M42, somevoxelvirtualdesktop[somevoxelvirtualdesktopindex].arrayofindexzeromesh[c].arrayOfScriptForInstances[cc].current_pos.M43);

                                                        var lengthofdir = dirToRightHand.Length();

                                                        //var moveRightHand = new JVector(_player_lft_hnd[0]._arrayOfInstances[0].current_pos.M41, _player_lft_hnd[0]._arrayOfInstances[0].current_pos.M42, _player_lft_hnd[0]._arrayOfInstances[0].current_pos.M43) - new JVector(_player_lft_hnd[0]._arrayOfInstances[0]._LASTPOSITIONFORPHYSICS.M41, _player_lft_hnd[0]._arrayOfInstances[0]._LASTPOSITIONFORPHYSICS.M42, _player_lft_hnd[0]._arrayOfInstances[0]._LASTPOSITIONFORPHYSICS.M43);

                                                        if (dirToRightHand != null)
                                                        {
                                                            dirToRightHand.Normalize();

                                                            lh_attract_force = new JVector(dirToRightHand.X, dirToRightHand.Y, dirToRightHand.Z) * 1;

                                                            lh_attract_force.Normalize();

                                                            lh_attract_force *= 0.5f; //0.1f

                                                            Vector4 otherVec4AttractForce = new Vector4(lh_attract_force.X, lh_attract_force.Y, lh_attract_force.Z, 1);

                                                            somevoxelvirtualdesktop[somevoxelvirtualdesktopindex].arrayOfChunkData[c].SC_instancedChunk_Instances[cc].instancePos += otherVec4AttractForce;// new Vector4(lh_attract_force.X, lh_attract_force.Y, lh_attract_force.Z, 1);

                                                            somevoxelvirtualdesktop[somevoxelvirtualdesktopindex].arrayofindexzeromesh[c].arrayOfScriptForInstances[cc].current_pos.M41 = somevoxelvirtualdesktop[somevoxelvirtualdesktopindex].arrayOfChunkData[c].SC_instancedChunk_Instances[cc].instancePos.X;// otherVec4AttractForce.X;
                                                            somevoxelvirtualdesktop[somevoxelvirtualdesktopindex].arrayofindexzeromesh[c].arrayOfScriptForInstances[cc].current_pos.M42 = somevoxelvirtualdesktop[somevoxelvirtualdesktopindex].arrayOfChunkData[c].SC_instancedChunk_Instances[cc].instancePos.Y;//otherVec4AttractForce.Y;
                                                            somevoxelvirtualdesktop[somevoxelvirtualdesktopindex].arrayofindexzeromesh[c].arrayOfScriptForInstances[cc].current_pos.M43 = somevoxelvirtualdesktop[somevoxelvirtualdesktopindex].arrayOfChunkData[c].SC_instancedChunk_Instances[cc].instancePos.Z;//otherVec4AttractForce.Z;

                                                            somevoxelvirtualdesktop[somevoxelvirtualdesktopindex].arrayofindexzeromesh[c].instances[cc].instancePos.X += otherVec4AttractForce.X;
                                                            somevoxelvirtualdesktop[somevoxelvirtualdesktopindex].arrayofindexzeromesh[c].instances[cc].instancePos.Y += otherVec4AttractForce.Y;
                                                            somevoxelvirtualdesktop[somevoxelvirtualdesktopindex].arrayofindexzeromesh[c].instances[cc].instancePos.Z += otherVec4AttractForce.Z;

                                                            //arrayOfChunkData[c].SC_instancedChunk_Instances[cc].instancePos.X

                                                            if (lh_attract_force != JVector.Zero && lh_attract_force != null && lh_attract_force.Length() > 0 && body != _grab_rigid_data._body)
                                                            {
                                                                //MessageBox((IntPtr)0, "" + "null dir 01", "Oculus Error", 0);
                                                                //MessageBox((IntPtr)0, "" + "not null force", "Oculus Error", 0);
                                                                //lh_attract_force.Normalize();

                                                                //if (has_water_buo_effect == 1)
                                                                //{
                                                                //    lh_attract_force *= force_4_screen * 10;
                                                               /// }
                                                                //else
                                                                //{
                                                                //    lh_attract_force *= force_4_screen * 1;
                                                                //}

                                                                //0.0045f

                                                                //lh_attract_force *= force_4_screen*1000;
                                                                //body.LinearVelocity += lh_attract_force;
                                                                //body.AddForce(lh_attract_force);

                                                                //worldMatrix

                                                                //arrayOfChunkData[c].arrayOfInstance[cc].instancePos += new Vector4(lh_attract_force.X, lh_attract_force.Y, lh_attract_force.Z, 1);

                                                                //body.AddTorque(force);
                                                            }
                                                        }
                                                        else
                                                        {
                                                            //Console.WriteLine("null dir");
                                                           //// MainWindow.MessageBox((IntPtr)0, "" + "null dir 01", "Oculus Error", 0);
                                                        }
                                                    }
                                                }
                                            }
                                        }*/




                                        //somevoxelvirtualdesktop[somevoxelvirtualdesktopindex].arrayOfChunkData[c].viewMatrix = _viewMatrix;
                                        //somevoxelvirtualdesktop[somevoxelvirtualdesktopindex].arrayOfChunkData[c].projectionMatrix = _projectionMatrix;

                                        //arrayOfChunkData[c].worldMatrix += arrayOfMatrixBuff[0].world;

                                        somevoxelvirtualdesktop[somevoxelvirtualdesktopindex].lightBufferInstChunk = somevoxelvirtualdesktop[somevoxelvirtualdesktopindex].arrayOfChunkData[c].lightBuffer;

                                        //SENDING THE SCREENCAPTURE TO THE BUFFER FOR THE SHADER
                                        //somevoxelvirtualdesktop[somevoxelvirtualdesktopindex].shaderOfChunk.shaderResourceView2D = SC_Update._desktopFrame.ShaderResource;// SC_Update._desktopFrame.ShaderResourceArray;
                                        //somevoxelvirtualdesktop[somevoxelvirtualdesktopindex].arrayOfChunkData[c].chunkShader.shaderResourceView2D = SC_Update._desktopFrame.ShaderResource;//
                                        //SENDING THE SCREENCAPTURE TO THE BUFFER FOR THE SHADER


                                        //RENDERING THE INSTANCED CHUNK 
                                        somevoxelvirtualdesktop[somevoxelvirtualdesktopindex].arrayOfChunkData[c].matrixBuffer = somevoxelvirtualdesktop[somevoxelvirtualdesktopindex].arrayOfMatrixBuff;
                                        //somevoxelvirtualdesktop[somevoxelvirtualdesktopindex].arrayOfChunkData[c] = somevoxelvirtualdesktop[somevoxelvirtualdesktopindex].shaderOfChunk.Renderer(somevoxelvirtualdesktop[somevoxelvirtualdesktopindex].arrayOfChunkData[c], c, SC_Update._desktopFrame.ShaderResource, somevoxelvirtualdesktop[somevoxelvirtualdesktopindex].voxeltype);
                                        //RENDERING THE INSTANCED CHUNK
                                        //somevoxelvirtualdesktop[somevoxelvirtualdesktopindex].arrayOfChunkData[c] = somevoxelvirtualdesktop[somevoxelvirtualdesktopindex].arrayOfChunkData[c].shaderOfChunk.Renderer(somevoxelvirtualdesktop[somevoxelvirtualdesktopindex].arrayOfChunkData[c], c, SC_Update._desktopFrame.ShaderResource, somevoxelvirtualdesktop[somevoxelvirtualdesktopindex].voxeltype);
                                        //SC_Update._shaderManager.renderinstancedchunk(somevoxelvirtualdesktop[somevoxelvirtualdesktopindex].arrayOfChunkData[c], c, SC_Update._desktopFrame.ShaderResource, somevoxelvirtualdesktop[somevoxelvirtualdesktopindex].voxeltype);

                                        //somechunkkeyboardgrid[somevoxelvirtualdesktopindex].
                                       // somechunkkeyboardgrid[somevoxelvirtualdesktopindex].arrayOfChunkData[c].shaderOfChunk.device.ImmediateContext.Rasterizer.State = SC_console_directx.D3D.RasterstateCullNone;

                                        //somechunkkeyboardgrid[somevoxelvirtualdesktopindex].arrayOfChunkData[c].vertexBuffer.Device.ImmediateContext.Rasterizer.State = SC_console_directx.D3D.RasterstateCullNone;
                                        //somechunkkeyboardgrid[somevoxelvirtualdesktopindex].arrayOfChunkData[c].IndicesBuffer.Device.ImmediateContext.Rasterizer.State = SC_console_directx.D3D.RasterstateCullNone;
                                        //somechunkkeyboardgrid[somevoxelvirtualdesktopindex].arrayOfChunkData[c].VertexShader.Device.ImmediateContext.Rasterizer.State = SC_console_directx.D3D.RasterstateCullNone;
                                        //somechunkkeyboardgrid[somevoxelvirtualdesktopindex].arrayOfChunkData[c].PixelShader.Device.ImmediateContext.Rasterizer.State = SC_console_directx.D3D.RasterstateCullNone;

                                        //somevoxelvirtualdesktop[somevoxelvirtualdesktopindex].arrayOfChunkData[c] = somevoxelvirtualdesktop[somevoxelvirtualdesktopindex].arrayOfChunkData[c].shaderOfChunk.Renderer(somevoxelvirtualdesktop[somevoxelvirtualdesktopindex].arrayOfChunkData[c], c, SC_Update._desktopFrame.ShaderResource, somevoxelvirtualdesktop[somevoxelvirtualdesktopindex].voxeltype);


                                        somevoxelvirtualdesktop[somevoxelvirtualdesktopindex].arrayOfChunkData[c] = somevoxelvirtualdesktop[somevoxelvirtualdesktopindex].shaderOfChunk.Renderer(somevoxelvirtualdesktop[somevoxelvirtualdesktopindex].arrayOfChunkData[c], c, SC_Update._desktopFrame.ShaderResource, somevoxelvirtualdesktop[somevoxelvirtualdesktopindex].voxeltype);




                                        //somechunkkeyboardgrid[somevoxelvirtualdesktopindex].arrayOfChunkData[c].shaderOfChunk.device.ImmediateContext.Rasterizer.State = SC_console_directx.D3D.RasterstateCullBack;


                                    }
                                }
                            }
                        }
                    }
                }
                //VOXEL VIRTUAL DESKTOP
                //VOXEL VIRTUAL DESKTOP
                //VOXEL VIRTUAL DESKTOP



                //SC_console_directx.D3D.DeviceContext.Rasterizer.State = SC_console_directx.D3D.RasterstateCullBack;
                ///SC_console_directx.D3D.TurnOffAlphaBlending();
                //SC_console_directx.D3D.TurnZBufferOn();







                //SC_console_directx.D3D.SetBackBufferRenderTarget();





                /*
                // Initialize and set up the description of the stencil state.
                DepthStencilStateDescription depthStencilDesc0 = new DepthStencilStateDescription()
                {
                    IsDepthEnabled = false,
                    DepthWriteMask = DepthWriteMask.All,
                    DepthComparison = Comparison.Less,
                    IsStencilEnabled = true,
                    StencilReadMask = 0xFF,
                    StencilWriteMask = 0xFF,

                    // Stencil operation if pixel front-facing.
                    FrontFace = new DepthStencilOperationDescription()
                    {
                        FailOperation = StencilOperation.Keep,
                        DepthFailOperation = StencilOperation.Increment,
                        PassOperation = StencilOperation.Keep,
                        Comparison = Comparison.Always
                    },
                    // Stencil operation if pixel is back-facing.
                    BackFace = new DepthStencilOperationDescription()
                    {
                        FailOperation = StencilOperation.Keep,
                        DepthFailOperation = StencilOperation.Decrement,
                        PassOperation = StencilOperation.Keep,
                        Comparison = Comparison.Always
                    }
                };

                // Create the depth stencil state.
                var DepthStencilState0 = new DepthStencilState(SC_console_directx.D3D.device, depthStencilDesc0);

                // Set the depth stencil state.
                SC_console_directx.D3D.device.ImmediateContext.OutputMerger.SetDepthStencilState(DepthStencilState0, 1);
                //SC_console_directx.D3D.eyeTextures[0].DepthStencilView.Device.ImmediateContext.OutputMerger.SetDepthStencilState(DepthStencilState0, 0);
                //SC_console_directx.D3D.eyeTextures[1].DepthStencilView.Device.ImmediateContext.OutputMerger.SetDepthStencilState(DepthStencilState0, 0);
                */













                /*
                //VOXEL VIRTUAL DESKTOP GRID
                //VOXEL VIRTUAL DESKTOP GRID
                //VOXEL VIRTUAL DESKTOP GRID
                for (int xxxx = 0; xxxx < somevoxelvirtualdesktopgridw; xxxx++)
                {
                    for (int yyyy = 0; yyyy < somevoxelvirtualdesktopgridh; yyyy++)
                    {
                        for (int zzzz = 0; zzzz < somevoxelvirtualdesktopgridd; zzzz++)
                        {
                            var somevoxelvirtualdesktopgridindex = xxxx + somevoxelvirtualdesktopgridw * (yyyy + somevoxelvirtualdesktopgridh * zzzz);

                            somevoxelvirtualdesktopgrid[somevoxelvirtualdesktopgridindex].arrayOfMatrixBuff[0].world = _worldMatrix;
                            somevoxelvirtualdesktopgrid[somevoxelvirtualdesktopgridindex].arrayOfMatrixBuff[0].view = _viewMatrix;
                            somevoxelvirtualdesktopgrid[somevoxelvirtualdesktopgridindex].arrayOfMatrixBuff[0].proj = _projectionMatrix;

                            //somevoxelvirtualdesktopgrid[somevoxelvirtualdesktopgridindex].arrayOfMatrixBuff[0] = new SC_instancedChunkPrim.DMatrixBuffer()
                            //{
                            //    world = _worldMatrix,
                            //    view = _viewMatrix,
                            //    proj = _projectionMatrix,
                            //};


                            //somevoxelvirtualdesktopgrid[somevoxelvirtualdesktopgridindex].lightBufferInstChunk[0] = new SC_instancedChunkPrim.DLightBufferEr()
                            //{
                            //    ambientColor = ambientColor,
                            //    diffuseColor = diffuseColour,
                            //    lightDirection = rayDirFrontInstancesChunks,
                            //    padding0 = 0,
                            //    lightPosition = centerPosRighthandposRR,
                            //    padding1 = 100
                            //};

                            lightpos.X = SC_Update._rightTouchMatrix.M41;
                            lightpos.Y = SC_Update._rightTouchMatrix.M42;
                            lightpos.Z = SC_Update._rightTouchMatrix.M43;


                            Quaternion somerighttouchquat;
                            Matrix somemat = SC_Update._rightTouchMatrix;
                            Quaternion.RotationMatrix(ref somemat, out somerighttouchquat);

                            Vector3 forwarddir = sc_maths._getDirection(Vector3.ForwardRH, somerighttouchquat);

                            //ambientColor = new Vector4(0.45f, 0.45f, 0.45f, 1.0f);
                            ambientColor = new Vector4(0.75f, 0.75f, 0.75f, 1.0f);
                            diffuseColour = new Vector4(1, 1, 1, 1);
                            //lightDirection = new Vector3(0, -1, -1);

                            somevoxelvirtualdesktopgrid[somevoxelvirtualdesktopgridindex].lightBufferInstChunk[0].lightDirection = forwarddir;
                            somevoxelvirtualdesktopgrid[somevoxelvirtualdesktopgridindex].lightBufferInstChunk[0].lightPosition = lightpos;

                            somevoxelvirtualdesktopgrid[somevoxelvirtualdesktopgridindex].lightBufferInstChunk[0].ambientColor = ambientColor;
                            somevoxelvirtualdesktopgrid[somevoxelvirtualdesktopgridindex].lightBufferInstChunk[0].diffuseColor = diffuseColour;

                            for (int x = 0; x < somevoxelvirtualdesktopglobalsgrid.numberOfObjectInWidth; x++)
                            {
                                for (int y = 0; y < somevoxelvirtualdesktopglobalsgrid.numberOfObjectInHeight; y++)
                                {
                                    for (int z = 0; z < somevoxelvirtualdesktopglobalsgrid.numberOfObjectInDepth; z++)
                                    {
                                        int c = x + somevoxelvirtualdesktopglobalsgrid.numberOfObjectInWidth * (y + somevoxelvirtualdesktopglobalsgrid.numberOfObjectInHeight * z);

                                        if (somevoxelvirtualdesktopgrid[somevoxelvirtualdesktopgridindex].arrayOfChunkData[c].switchForRender == 1)
                                        {
                                            var matrixBufferDescriptionVertex00 = new BufferDescription()
                                            {
                                                Usage = ResourceUsage.Dynamic,
                                                SizeInBytes = Marshal.SizeOf(typeof(SC_instancedChunk.DInstanceType)) * somevoxelvirtualdesktopgrid[somevoxelvirtualdesktopgridindex].instances.Length,
                                                BindFlags = BindFlags.VertexBuffer,
                                                CpuAccessFlags = CpuAccessFlags.Write,
                                                OptionFlags = ResourceOptionFlags.None,
                                                StructureByteStride = 0
                                            };

                                            var InstanceBuffer = new SharpDX.Direct3D11.Buffer(SC_console_directx.D3D.device, matrixBufferDescriptionVertex00);

                                            somevoxelvirtualdesktopgrid[somevoxelvirtualdesktopgridindex].arrayOfChunkData[c].SC_instancedChunk_Instances = somevoxelvirtualdesktopgrid[somevoxelvirtualdesktopgridindex].arrayofindexzeromesh[c].instances;
                                            somevoxelvirtualdesktopgrid[somevoxelvirtualdesktopgridindex].arrayOfChunkData[c].worldMatrix = _worldMatrix;
                                            somevoxelvirtualdesktopgrid[somevoxelvirtualdesktopgridindex].arrayOfChunkData[c].viewMatrix = _viewMatrix;
                                            somevoxelvirtualdesktopgrid[somevoxelvirtualdesktopgridindex].arrayOfChunkData[c].projectionMatrix = _projectionMatrix;

                                            //arrayOfChunkData[c].worldMatrix += arrayOfMatrixBuff[0].world;

                                            somevoxelvirtualdesktopgrid[somevoxelvirtualdesktopgridindex].arrayOfChunkData[c].matrixBuffer = somevoxelvirtualdesktopgrid[somevoxelvirtualdesktopgridindex].arrayOfMatrixBuff;

                                            //arrayOfChunkData[c].lightBuffer = lightBufferInstChunk;

                                            somevoxelvirtualdesktopgrid[somevoxelvirtualdesktopgridindex].arrayOfChunkData[c].instanceBuffer = InstanceBuffer;
                                            somevoxelvirtualdesktopgrid[somevoxelvirtualdesktopgridindex].arrayOfChunkData[c].arrayOfSomeMap = somevoxelvirtualdesktopgrid[somevoxelvirtualdesktopgridindex].arrayofindexzeromesh[c].arrayOfSomeMap;

                                            //arrayOfChunkData[c] = shaderOfChunk.Renderer(arrayOfChunkData[c], c);
                                        }
                                        else
                                        {
                                            float staticPlaneSize = somevoxelvirtualdesktopglobalsgrid.planeSize;
                                            float planeSize0 = somevoxelvirtualdesktopglobalsgrid.planeSize;
                                            float alternateStaticPlaneSize = 0;

                                            if (staticPlaneSize == 1)
                                            {
                                                staticPlaneSize = planeSize0 * 0.1f;
                                                alternateStaticPlaneSize = planeSize0 * 0.1f;
                                            }
                                            else if (staticPlaneSize == 0.1f)
                                            {
                                                staticPlaneSize = planeSize0;
                                                alternateStaticPlaneSize = planeSize0 * 10;
                                            }
                                            else if (staticPlaneSize == 0.01f)
                                            {
                                                staticPlaneSize = planeSize0;
                                                alternateStaticPlaneSize = planeSize0 * 1000;
                                            }


                                            for (int xx = 0; xx < somevoxelvirtualdesktopglobalsgrid.numberOfInstancesPerObjectInWidth; xx++)
                                            {
                                                //MainWindow.MessageBox((IntPtr)0, "" + noiseXZ, "sccs", 0);

                                                for (int yy = 0; yy < somevoxelvirtualdesktopglobalsgrid.numberOfInstancesPerObjectInHeight; yy++)
                                                {
                                                    for (int zz = 0; zz < somevoxelvirtualdesktopglobalsgrid.numberOfInstancesPerObjectInDepth; zz++)
                                                    {

                                                        float seed = (float)sc_maths.getSomeRandNum(3420, 9999999); //3420;

                                                        int cc = xx + somevoxelvirtualdesktopglobalsgrid.numberOfInstancesPerObjectInWidth * (yy + somevoxelvirtualdesktopglobalsgrid.numberOfInstancesPerObjectInHeight * zz);




                                                        /*if (sc_menu_scroller == 3 && somecounterresetcounter < somevoxelvirtualdesktopgridswidth * somevoxelvirtualdesktopgridsheight * somevoxelvirtualdesktopgridsdepth * somevoxelvirtualdesktopglobalsgrid.numberOfObjectInWidth * somevoxelvirtualdesktopglobalsgrid.numberOfObjectInHeight * somevoxelvirtualdesktopglobalsgrid.numberOfObjectInDepth * somevoxelvirtualdesktopglobalsgrid.numberOfInstancesPerObjectInWidth * somevoxelvirtualdesktopglobalsgrid.numberOfInstancesPerObjectInHeight * somevoxelvirtualdesktopglobalsgrid.numberOfInstancesPerObjectInDepth && resetvoxelladdercounter == 2)
                                                        {
                                                            //MainWindow.MessageBox((IntPtr)0, "menu option 3" , "sccs", 0);

                                                            int voxelchunkinvertoption = MainWindow.usetypeofvoxel;


                                                            somevoxelvirtualdesktopgrid[somevoxelvirtualdesktopgridindex].arrayofindexzeromesh[c].somechunk[cc].resetmap(out m11, out m12, out m13, out m14, out m21, out m22, out m23, out m24, out m31, out m32, out m33, out m34, out m41, out m42, out m43, out m44, -1, voxelchunkinvertoption);
                                                            //somevoxelvirtualdesktopgrid[somevoxelvirtualdesktopgridindex].arrayofindexzeromesh[c].somechunk[cc].setnewmap(out m11, out m12, out m13, out m14, out m21, out m22, out m23, out m24, out m31, out m32, out m33, out m34, out m41, out m42, out m43, out m44, -1, voxelchunkinvertoption); //


                                                            somevoxelvirtualdesktopgrid[somevoxelvirtualdesktopgridindex].arrayofindexzeromesh[c].instancesmatrix[cc].instancematrix.M11 = (float)m11;
                                                            somevoxelvirtualdesktopgrid[somevoxelvirtualdesktopgridindex].arrayofindexzeromesh[c].instancesmatrix[cc].instancematrix.M12 = (float)m12;
                                                            somevoxelvirtualdesktopgrid[somevoxelvirtualdesktopgridindex].arrayofindexzeromesh[c].instancesmatrix[cc].instancematrix.M13 = (float)m13;
                                                            somevoxelvirtualdesktopgrid[somevoxelvirtualdesktopgridindex].arrayofindexzeromesh[c].instancesmatrix[cc].instancematrix.M14 = (float)m14;

                                                            somevoxelvirtualdesktopgrid[somevoxelvirtualdesktopgridindex].arrayofindexzeromesh[c].instancesmatrix[cc].instancematrix.M21 = (float)m21;
                                                            somevoxelvirtualdesktopgrid[somevoxelvirtualdesktopgridindex].arrayofindexzeromesh[c].instancesmatrix[cc].instancematrix.M22 = (float)m22;
                                                            somevoxelvirtualdesktopgrid[somevoxelvirtualdesktopgridindex].arrayofindexzeromesh[c].instancesmatrix[cc].instancematrix.M23 = (float)m23;
                                                            somevoxelvirtualdesktopgrid[somevoxelvirtualdesktopgridindex].arrayofindexzeromesh[c].instancesmatrix[cc].instancematrix.M24 = (float)m24;

                                                            somevoxelvirtualdesktopgrid[somevoxelvirtualdesktopgridindex].arrayofindexzeromesh[c].instancesmatrix[cc].instancematrix.M31 = (float)m31;
                                                            somevoxelvirtualdesktopgrid[somevoxelvirtualdesktopgridindex].arrayofindexzeromesh[c].instancesmatrix[cc].instancematrix.M32 = (float)m32;
                                                            somevoxelvirtualdesktopgrid[somevoxelvirtualdesktopgridindex].arrayofindexzeromesh[c].instancesmatrix[cc].instancematrix.M33 = (float)m33;
                                                            somevoxelvirtualdesktopgrid[somevoxelvirtualdesktopgridindex].arrayofindexzeromesh[c].instancesmatrix[cc].instancematrix.M34 = (float)m34;

                                                            somevoxelvirtualdesktopgrid[somevoxelvirtualdesktopgridindex].arrayofindexzeromesh[c].instancesmatrix[cc].instancematrix.M41 = (float)m41;
                                                            somevoxelvirtualdesktopgrid[somevoxelvirtualdesktopgridindex].arrayofindexzeromesh[c].instancesmatrix[cc].instancematrix.M42 = (float)m42;
                                                            somevoxelvirtualdesktopgrid[somevoxelvirtualdesktopgridindex].arrayofindexzeromesh[c].instancesmatrix[cc].instancematrix.M43 = (float)m43;
                                                            somevoxelvirtualdesktopgrid[somevoxelvirtualdesktopgridindex].arrayofindexzeromesh[c].instancesmatrix[cc].instancematrix.M44 = (float)m44;

                                                            somevoxelvirtualdesktopgrid[somevoxelvirtualdesktopgridindex].arrayOfChunkData[c].copytobuffer = 1;

                                                            somecounterresetcounter++;
                                                        }



                                                        //if (sc_menu_scroller == 3 && somecounterresetcounter >= somevoxelvirtualdesktopgridswidth * somevoxelvirtualdesktopgridsheight * somevoxelvirtualdesktopgridsdepth * somevoxelvirtualdesktopglobalsgrid.numberOfObjectInWidth * somevoxelvirtualdesktopglobalsgrid.numberOfObjectInHeight * somevoxelvirtualdesktopglobalsgrid.numberOfObjectInDepth * somevoxelvirtualdesktopglobalsgrid.numberOfInstancesPerObjectInWidth * somevoxelvirtualdesktopglobalsgrid.numberOfInstancesPerObjectInHeight * somevoxelvirtualdesktopglobalsgrid.numberOfInstancesPerObjectInDepth)
                                                        //{
                                                            //MainWindow.MessageBox((IntPtr)0, "resetted map", "sccs", 0);

                                                            //sc_menu_scroller = 0;
                                                            //somecounterresetcounter = 0;
                                                        //}











                                                        var somecountermax = (float)Math.Abs((somevoxelvirtualdesktopgrid[somevoxelvirtualdesktopgridindex].arrayofindexzeromesh[c].colorsNFaces[cc].colorsNFaces.W - (float)Math.Floor(somevoxelvirtualdesktopgrid[somevoxelvirtualdesktopgridindex].arrayofindexzeromesh[c].colorsNFaces[cc].colorsNFaces.W)) * 1000);

                                                        float noiseXZ = 100;
                                                        float noiseYZ = 100;
                                                        float noiseXY = 100;

                                                        float detailScale1 = 7;
                                                        float heightScale1 = 5;

                                                        //fastNoise = new FastNoise();

                                                        noiseXZ *= (fastNoise.GetNoise((x * planeSize0 + somevoxelvirtualdesktopgrid[somevoxelvirtualdesktopgridindex].arrayofindexzeromesh[c].colorsNFaces[cc].colorsNFaces.X + seed) / detailScale1, (z * planeSize0 + somevoxelvirtualdesktopgrid[somevoxelvirtualdesktopgridindex].arrayofindexzeromesh[c].colorsNFaces[cc].colorsNFaces.Z + seed) / detailScale1) * heightScale1);
                                                        float size0 = (1 / planeSize0) * somevoxelvirtualdesktopgrid[somevoxelvirtualdesktopgridindex].arrayofindexzeromesh[c].colorsNFaces[cc].colorsNFaces.Y;
                                                        noiseXZ -= size0;

                                                        //MainWindow.MessageBox((IntPtr)0, "c:" + somecountermax, "sccs error", 0);
                                                        noiseYZ *= (fastNoise.GetNoise((y * planeSize0 + somevoxelvirtualdesktopgrid[somevoxelvirtualdesktopgridindex].arrayofindexzeromesh[c].colorsNFaces[cc].colorsNFaces.Y + seed) / detailScale1, (z * planeSize0 + somevoxelvirtualdesktopgrid[somevoxelvirtualdesktopgridindex].arrayofindexzeromesh[c].colorsNFaces[cc].colorsNFaces.Z + seed) / detailScale1) * heightScale1);
                                                        float size1 = (1 / planeSize0) * somevoxelvirtualdesktopgrid[somevoxelvirtualdesktopgridindex].arrayofindexzeromesh[c].colorsNFaces[cc].colorsNFaces.X;
                                                        noiseYZ -= size1;


                                                        noiseXY *= (fastNoise.GetNoise((x * planeSize0 + somevoxelvirtualdesktopgrid[somevoxelvirtualdesktopgridindex].arrayofindexzeromesh[c].colorsNFaces[cc].colorsNFaces.X + seed) / detailScale1, (y * planeSize0 + somevoxelvirtualdesktopgrid[somevoxelvirtualdesktopgridindex].arrayofindexzeromesh[c].colorsNFaces[cc].colorsNFaces.Y + seed) / detailScale1) * heightScale1);
                                                        float size2 = (1 / planeSize0) * somevoxelvirtualdesktopgrid[somevoxelvirtualdesktopgridindex].arrayofindexzeromesh[c].colorsNFaces[cc].colorsNFaces.Z;
                                                        noiseXY -= size2;

                                                        //TOREADD FOR NOISE TEST ON COLOR

                                                        //noiseXZ *= fastNoise.GetNoise((((x * staticPlaneSize) + (somevoxelvirtualdesktopgrid[somevoxelvirtualdesktopgridindex].arrayofindexzeromesh[c].colorsNFaces[cc].colorsNFaces.X * alternateStaticPlaneSize) + seed) / _detailScale) * _HeightScale, (((y * staticPlaneSize) + (somevoxelvirtualdesktopgrid[somevoxelvirtualdesktopgridindex].arrayofindexzeromesh[c].colorsNFaces[cc].colorsNFaces.Y * alternateStaticPlaneSize) + seed) / _detailScale) * _HeightScale, (((z * staticPlaneSize) + (somevoxelvirtualdesktopgrid[somevoxelvirtualdesktopgridindex].arrayofindexzeromesh[c].colorsNFaces[cc].colorsNFaces.Z * alternateStaticPlaneSize) + seed) / _detailScale) * _HeightScale);

                                                        float someclampednoisexz = sc_maths.ClampValue(0.55f + (1 * noiseXZ), 0.35f, 0.75f);
                                                        float someclampednoiseyz = sc_maths.ClampValue(0.55f + (1 * noiseYZ), 0.35f, 0.75f);
                                                        float someclampednoisexy = sc_maths.ClampValue(0.55f + (1 * noiseXY), 0.35f, 0.75f);

                                                        //MainWindow.MessageBox((IntPtr)0, "someclampednoisexz:" + someclampednoisexz + "/someclampednoiseyz:" + someclampednoiseyz + "/someclampednoisexy:" + someclampednoisexy, "sccs", 0);
                                                        //MainWindow.MessageBox((IntPtr)0, "noiseXZ:" + noiseXZ + "/noiseYZ:" + noiseYZ + "/noiseXY:" + noiseXY, "sccs", 0);

                                                        //somevoxelvirtualdesktopgrid[somevoxelvirtualdesktopgridindex].arrayofindexzeromesh[c].colorsNFaces[cc].colorsNFaces.X =Math.Abs(0.15f + noiseXZ);// someclampednoisexz;
                                                        //somevoxelvirtualdesktopgrid[somevoxelvirtualdesktopgridindex].arrayofindexzeromesh[c].colorsNFaces[cc].colorsNFaces.Y = Math.Abs(0.25f + noiseYZ);// someclampednoiseyz;
                                                        //somevoxelvirtualdesktopgrid[somevoxelvirtualdesktopgridindex].arrayofindexzeromesh[c].colorsNFaces[cc].colorsNFaces.Z = Math.Abs(0.15f + noiseXY);// someclampednoisexy;

                                                        somevoxelvirtualdesktopgrid[somevoxelvirtualdesktopgridindex].arrayofindexzeromesh[c].colorsNFaces[cc].colorsNFaces.X = 0.35f + Math.Abs(someclampednoisexz);
                                                        somevoxelvirtualdesktopgrid[somevoxelvirtualdesktopgridindex].arrayofindexzeromesh[c].colorsNFaces[cc].colorsNFaces.Y = 0.35f + Math.Abs(someclampednoiseyz);
                                                        somevoxelvirtualdesktopgrid[somevoxelvirtualdesktopgridindex].arrayofindexzeromesh[c].colorsNFaces[cc].colorsNFaces.Z = 0.35f + Math.Abs(someclampednoisexy);

                                                        //somevoxelvirtualdesktopgrid[somevoxelvirtualdesktopgridindex].arrayofindexzeromesh[c].colorsNFaces[cc].colorsNFaces.W = 1.0f;

                                                        //this can be swapped with heightmaps values with some modifications here and there to bring bytes within a range of 0 to 255 rgba values or from within a range of 0.0f to 1.0f values.
                                                        if (Math.Truncate(somevoxelvirtualdesktopgrid[somevoxelvirtualdesktopgridindex].arrayofindexzeromesh[c].colorsNFaces[cc].colorsNFaces.W) >= somecountermax)
                                                        {

                                                            somevoxelvirtualdesktopgrid[somevoxelvirtualdesktopgridindex].arrayofindexzeromesh[c].colorsNFaces[cc].colorsNFaces.W = 0 + somecountermax * 0.001f;
                                                        }
                                                        somevoxelvirtualdesktopgrid[somevoxelvirtualdesktopgridindex].arrayofindexzeromesh[c].colorsNFaces[cc].colorsNFaces.W += 1f;

                                                        //TOREADD FOR NOISE TEST ON COLOR

                                                        //this can be swapped with heightmaps values with some modifications here and there to bring bytes within a range of 0 to 255 rgba values or from within a range of 0.0f to 1.0f values.
                                                    }
                                                }
                                            }
                                        }















                                        Matrix _WorldMatrix = WorldMatrix;
                                        Matrix matrixtouchright = SC_Update._rightTouchMatrix;//_player_rght_hnd[0][0]._arrayOfInstances[0].current_pos;

                                        int xii = 0;
                                        int yii = 0;
                                        int zii = 0;



                                        //ATTRACT FORCE LOGIC
                                        //ATTRACT FORCE LOGIC
                                        //ATTRACT FORCE LOGIC
                                        /*
                                        //arrayOfChunkData[c].worldMatrix += arrayOfMatrixBuff[0].world;
                                        if (SC_Update.handTriggerRight[1] >= 0.001f)
                                        {
                                            //MainWindow.MessageBox((IntPtr)0, "b: ", "", 0);
                                            for (int xxi = 0; xxi < somevoxelvirtualdesktopglobalsgrid.numberOfInstancesPerObjectInWidth; xxi++)
                                            {
                                                for (int yyi = 0; yyi < somevoxelvirtualdesktopglobalsgrid.numberOfInstancesPerObjectInHeight; yyi++)
                                                {
                                                    for (int zzi = 0; zzi < somevoxelvirtualdesktopglobalsgrid.numberOfInstancesPerObjectInDepth; zzi++)
                                                    {
                                                        int cc = xxi + somevoxelvirtualdesktopglobalsgrid.numberOfInstancesPerObjectInWidth * (yyi + somevoxelvirtualdesktopglobalsgrid.numberOfInstancesPerObjectInHeight * zzi);

                                                        //var dirToRightHand = new Vector3(_player_rght_hnd[0][0]._arrayOfInstances[0].current_pos.M41, _player_rght_hnd[0][0]._arrayOfInstances[0].current_pos.M42, _player_rght_hnd[0][0]._arrayOfInstances[0].current_pos.M43) - new Vector3(arrayOfChunkData[c].SC_instancedChunk_Instances[cc].instancePos.X, arrayOfChunkData[c].SC_instancedChunk_Instances[cc].instancePos.Y, arrayOfChunkData[c].SC_instancedChunk_Instances[cc].instancePos.Z);

                                                        var dirToRightHand = new Vector3(_player_rght_hnd[0][0]._arrayOfInstances[0].current_pos.M41, _player_rght_hnd[0][0]._arrayOfInstances[0].current_pos.M42, _player_rght_hnd[0][0]._arrayOfInstances[0].current_pos.M43) - new Vector3(somevoxelvirtualdesktopgrid[somevoxelvirtualdesktopgridindex].arrayofindexzeromesh[c].arrayOfScriptForInstances[cc].current_pos.M41, somevoxelvirtualdesktopgrid[somevoxelvirtualdesktopgridindex].arrayofindexzeromesh[c].arrayOfScriptForInstances[cc].current_pos.M42, somevoxelvirtualdesktopgrid[somevoxelvirtualdesktopgridindex].arrayofindexzeromesh[c].arrayOfScriptForInstances[cc].current_pos.M43);

                                                        var lengthofdir = dirToRightHand.Length();

                                                        //var moveRightHand = new JVector(_player_lft_hnd[0]._arrayOfInstances[0].current_pos.M41, _player_lft_hnd[0]._arrayOfInstances[0].current_pos.M42, _player_lft_hnd[0]._arrayOfInstances[0].current_pos.M43) - new JVector(_player_lft_hnd[0]._arrayOfInstances[0]._LASTPOSITIONFORPHYSICS.M41, _player_lft_hnd[0]._arrayOfInstances[0]._LASTPOSITIONFORPHYSICS.M42, _player_lft_hnd[0]._arrayOfInstances[0]._LASTPOSITIONFORPHYSICS.M43);

                                                        if (dirToRightHand != null)
                                                        {
                                                            dirToRightHand.Normalize();

                                                            lh_attract_force = new JVector(dirToRightHand.X, dirToRightHand.Y, dirToRightHand.Z) * 1;

                                                            lh_attract_force.Normalize();

                                                            lh_attract_force *= 0.5f; //0.1f

                                                            Vector4 otherVec4AttractForce = new Vector4(lh_attract_force.X, lh_attract_force.Y, lh_attract_force.Z, 1);

                                                            somevoxelvirtualdesktopgrid[somevoxelvirtualdesktopgridindex].arrayOfChunkData[c].SC_instancedChunk_Instances[cc].instancePos += otherVec4AttractForce;// new Vector4(lh_attract_force.X, lh_attract_force.Y, lh_attract_force.Z, 1);

                                                            somevoxelvirtualdesktopgrid[somevoxelvirtualdesktopgridindex].arrayofindexzeromesh[c].arrayOfScriptForInstances[cc].current_pos.M41 = somevoxelvirtualdesktopgrid[somevoxelvirtualdesktopgridindex].arrayOfChunkData[c].SC_instancedChunk_Instances[cc].instancePos.X;// otherVec4AttractForce.X;
                                                            somevoxelvirtualdesktopgrid[somevoxelvirtualdesktopgridindex].arrayofindexzeromesh[c].arrayOfScriptForInstances[cc].current_pos.M42 = somevoxelvirtualdesktopgrid[somevoxelvirtualdesktopgridindex].arrayOfChunkData[c].SC_instancedChunk_Instances[cc].instancePos.Y;//otherVec4AttractForce.Y;
                                                            somevoxelvirtualdesktopgrid[somevoxelvirtualdesktopgridindex].arrayofindexzeromesh[c].arrayOfScriptForInstances[cc].current_pos.M43 = somevoxelvirtualdesktopgrid[somevoxelvirtualdesktopgridindex].arrayOfChunkData[c].SC_instancedChunk_Instances[cc].instancePos.Z;//otherVec4AttractForce.Z;

                                                            somevoxelvirtualdesktopgrid[somevoxelvirtualdesktopgridindex].arrayofindexzeromesh[c].instances[cc].instancePos.X += otherVec4AttractForce.X;
                                                            somevoxelvirtualdesktopgrid[somevoxelvirtualdesktopgridindex].arrayofindexzeromesh[c].instances[cc].instancePos.Y += otherVec4AttractForce.Y;
                                                            somevoxelvirtualdesktopgrid[somevoxelvirtualdesktopgridindex].arrayofindexzeromesh[c].instances[cc].instancePos.Z += otherVec4AttractForce.Z;

                                                            //arrayOfChunkData[c].SC_instancedChunk_Instances[cc].instancePos.X

                                                            if (lh_attract_force != JVector.Zero && lh_attract_force != null && lh_attract_force.Length() > 0 && body != _grab_rigid_data._body)
                                                            {
                                                                //MessageBox((IntPtr)0, "" + "null dir 01", "Oculus Error", 0);
                                                                //MessageBox((IntPtr)0, "" + "not null force", "Oculus Error", 0);
                                                                //lh_attract_force.Normalize();

                                                                //if (has_water_buo_effect == 1)
                                                                //{
                                                                //    lh_attract_force *= force_4_screen * 10;
                                                               /// }
                                                                //else
                                                                //{
                                                                //    lh_attract_force *= force_4_screen * 1;
                                                                //}

                                                                //0.0045f

                                                                //lh_attract_force *= force_4_screen*1000;
                                                                //body.LinearVelocity += lh_attract_force;
                                                                //body.AddForce(lh_attract_force);

                                                                //worldMatrix

                                                                //arrayOfChunkData[c].arrayOfInstance[cc].instancePos += new Vector4(lh_attract_force.X, lh_attract_force.Y, lh_attract_force.Z, 1);

                                                                //body.AddTorque(force);
                                                            }
                                                        }
                                                        else
                                                        {
                                                            //Console.WriteLine("null dir");
                                                           //// MainWindow.MessageBox((IntPtr)0, "" + "null dir 01", "Oculus Error", 0);
                                                        }
                                                    }
                                                }
                                            }
                                        }




                                        //somevoxelvirtualdesktopgrid[somevoxelvirtualdesktopgridindex].arrayOfChunkData[c].viewMatrix = _viewMatrix;
                                        //somevoxelvirtualdesktopgrid[somevoxelvirtualdesktopgridindex].arrayOfChunkData[c].projectionMatrix = _projectionMatrix;

                                        //arrayOfChunkData[c].worldMatrix += arrayOfMatrixBuff[0].world;

                                        somevoxelvirtualdesktopgrid[somevoxelvirtualdesktopgridindex].lightBufferInstChunk = somevoxelvirtualdesktopgrid[somevoxelvirtualdesktopgridindex].arrayOfChunkData[c].lightBuffer;

                                        //SENDING THE SCREENCAPTURE TO THE BUFFER FOR THE SHADER
                                        //somevoxelvirtualdesktopgrid[somevoxelvirtualdesktopgridindex].shaderOfChunk.shaderResourceView2D = SC_Update._desktopFrame.ShaderResource;// SC_Update._desktopFrame.ShaderResourceArray;
                                        //somevoxelvirtualdesktopgrid[somevoxelvirtualdesktopgridindex].arrayOfChunkData[c].chunkShader.shaderResourceView2D = SC_Update._desktopFrame.ShaderResource;//
                                        //SENDING THE SCREENCAPTURE TO THE BUFFER FOR THE SHADER


                                        //RENDERING THE INSTANCED CHUNK 
                                        somevoxelvirtualdesktopgrid[somevoxelvirtualdesktopgridindex].arrayOfChunkData[c].matrixBuffer = somevoxelvirtualdesktopgrid[somevoxelvirtualdesktopgridindex].arrayOfMatrixBuff;
                                        somevoxelvirtualdesktopgrid[somevoxelvirtualdesktopgridindex].arrayOfChunkData[c] = somevoxelvirtualdesktopgrid[somevoxelvirtualdesktopgridindex].shaderOfChunk.Renderer(somevoxelvirtualdesktopgrid[somevoxelvirtualdesktopgridindex].arrayOfChunkData[c], c, SC_Update._desktopFrame.ShaderResource, somevoxelvirtualdesktopgrid[somevoxelvirtualdesktopgridindex].voxeltype);
                                        //RENDERING THE INSTANCED CHUNK
                                        //somevoxelvirtualdesktopgrid[somevoxelvirtualdesktopgridindex].arrayOfChunkData[c] = somevoxelvirtualdesktopgrid[somevoxelvirtualdesktopgridindex].arrayOfChunkData[c].shaderOfChunk.Renderer(somevoxelvirtualdesktopgrid[somevoxelvirtualdesktopgridindex].arrayOfChunkData[c], c, SC_Update._desktopFrame.ShaderResource, somevoxelvirtualdesktopgrid[somevoxelvirtualdesktopgridindex].voxeltype);


                                        //TOREADD
                                        //SC_Update._shaderManager.renderinstancedchunk(somevoxelvirtualdesktopgrid[somevoxelvirtualdesktopgridindex].arrayOfChunkData[c], c, SC_Update._desktopFrame.ShaderResource, somevoxelvirtualdesktopgrid[somevoxelvirtualdesktopgridindex].voxeltype);
                                        //TOREADD

                                    }
                                }
                            }
                        }
                    }
                }*/
                //VOXEL VIRTUAL DESKTOP GRID
                //VOXEL VIRTUAL DESKTOP GRID
                //VOXEL VIRTUAL DESKTOP GRID







                /*
                ///////////////////////////////SECTION FOR VOXEL ROOM//////////////////////////////
                //CHUNK MESH VIRTUAL KEYBOARD CONTAINMENT GRID
                //CHUNK MESH VIRTUAL KEYBOARD CONTAINMENT GRID
                //CHUNK MESH VIRTUAL KEYBOARD CONTAINMENT GRID
                for (int xxxx = 0; xxxx < somevoxelroomw; xxxx++)
                {
                    for (int yyyy = 0; yyyy < somevoxelroomh; yyyy++)
                    {
                        for (int zzzz = 0; zzzz < somevoxelroomd; zzzz++)
                        {
                            var somevoxelroomindex = xxxx + somevoxelroomw * (yyyy + somevoxelroomh * zzzz);


                            //somevoxelroom[somevoxelroomindex].worldmatofobj = somevoxelroom[somevoxelroomindex].

                            somevoxelroom[somevoxelroomindex].arrayOfMatrixBuff[0].world = _worldMatrix;
                            somevoxelroom[somevoxelroomindex].arrayOfMatrixBuff[0].view = _viewMatrix;
                            somevoxelroom[somevoxelroomindex].arrayOfMatrixBuff[0].proj = _projectionMatrix;

                            /*somevoxelroom[somevoxelroomindex].arrayOfMatrixBuff[0] = new SC_instancedChunkPrim.DMatrixBuffer()
                            {
                                world = _worldMatrix,
                                view = _viewMatrix,
                                proj = _projectionMatrix,
                            };*/


                            /*somevoxelroom[somevoxelroomindex].lightBufferInstChunk[0] = new SC_instancedChunkPrim.DLightBufferEr()
                            {
                                ambientColor = ambientColor,
                                diffuseColor = diffuseColour,
                                lightDirection = rayDirFrontInstancesChunks,
                                padding0 = 0,
                                lightPosition = centerPosRighthandposRR,
                                padding1 = 100
                            };

                            lightpos.X = SC_Update._rightTouchMatrix.M41;
                            lightpos.Y = SC_Update._rightTouchMatrix.M42;
                            lightpos.Z = SC_Update._rightTouchMatrix.M43;


                            Quaternion somerighttouchquat;
                            Matrix somemat = SC_Update._rightTouchMatrix;
                            Quaternion.RotationMatrix(ref somemat, out somerighttouchquat);

                            Vector3 forwarddir = sc_maths._getDirection(Vector3.ForwardRH, somerighttouchquat);

                            //ambientColor = new Vector4(0.45f, 0.45f, 0.45f, 1.0f);
                            ambientColor = new Vector4(0.75f, 0.75f, 0.75f, 1.0f);
                            diffuseColour = new Vector4(1, 1, 1, 1);
                            //lightDirection = new Vector3(0, -1, -1);

                            somevoxelroom[somevoxelroomindex].lightBufferInstChunk[0].lightDirection = forwarddir;
                            somevoxelroom[somevoxelroomindex].lightBufferInstChunk[0].lightPosition = lightpos;

                            somevoxelroom[somevoxelroomindex].lightBufferInstChunk[0].ambientColor = ambientColor;
                            somevoxelroom[somevoxelroomindex].lightBufferInstChunk[0].diffuseColor = diffuseColour;

                            for (int x = 0; x < somevoxelroomglobals.numberOfObjectInWidth; x++)
                            {
                                for (int y = 0; y < somevoxelroomglobals.numberOfObjectInHeight; y++)
                                {
                                    for (int z = 0; z < somevoxelroomglobals.numberOfObjectInDepth; z++)
                                    {
                                        int c = x + somevoxelroomglobals.numberOfObjectInWidth * (y + somevoxelroomglobals.numberOfObjectInHeight * z);

                                        if (somevoxelroom[somevoxelroomindex].arrayOfChunkData[c].switchForRender == 1)
                                        {
                                            var matrixBufferDescriptionVertex00 = new BufferDescription()
                                            {
                                                Usage = ResourceUsage.Dynamic,
                                                SizeInBytes = Marshal.SizeOf(typeof(SC_instancedChunk.DInstanceType)) * somevoxelroom[somevoxelroomindex].instances.Length,
                                                BindFlags = BindFlags.VertexBuffer,
                                                CpuAccessFlags = CpuAccessFlags.Write,
                                                OptionFlags = ResourceOptionFlags.None,
                                                StructureByteStride = 0
                                            };

                                            var InstanceBuffer = new SharpDX.Direct3D11.Buffer(SC_console_directx.D3D.device, matrixBufferDescriptionVertex00);

                                            somevoxelroom[somevoxelroomindex].arrayOfChunkData[c].SC_instancedChunk_Instances = somevoxelroom[somevoxelroomindex].arrayofindexzeromesh[c].instances;
                                            somevoxelroom[somevoxelroomindex].arrayOfChunkData[c].worldMatrix = _worldMatrix;
                                            somevoxelroom[somevoxelroomindex].arrayOfChunkData[c].viewMatrix = _viewMatrix;
                                            somevoxelroom[somevoxelroomindex].arrayOfChunkData[c].projectionMatrix = _projectionMatrix;

                                            //arrayOfChunkData[c].worldMatrix += arrayOfMatrixBuff[0].world;

                                            somevoxelroom[somevoxelroomindex].arrayOfChunkData[c].matrixBuffer = somevoxelroom[somevoxelroomindex].arrayOfMatrixBuff;

                                            //arrayOfChunkData[c].lightBuffer = lightBufferInstChunk;

                                            somevoxelroom[somevoxelroomindex].arrayOfChunkData[c].instanceBuffer = InstanceBuffer;
                                            somevoxelroom[somevoxelroomindex].arrayOfChunkData[c].arrayOfSomeMap = somevoxelroom[somevoxelroomindex].arrayofindexzeromesh[c].arrayOfSomeMap;

                                            //arrayOfChunkData[c] = shaderOfChunk.Renderer(arrayOfChunkData[c], c);
                                        }
                                        else
                                        {
                                            float staticPlaneSize = somevoxelroomglobals.planeSize;
                                            float planeSize0 = somevoxelroomglobals.planeSize;
                                            float alternateStaticPlaneSize = 0;

                                            if (staticPlaneSize == 1)
                                            {
                                                staticPlaneSize = planeSize0 * 0.1f;
                                                alternateStaticPlaneSize = planeSize0 * 0.1f;
                                            }
                                            else if (staticPlaneSize == 0.1f)
                                            {
                                                staticPlaneSize = planeSize0;
                                                alternateStaticPlaneSize = planeSize0 * 10;
                                            }
                                            else if (staticPlaneSize == 0.01f)
                                            {
                                                staticPlaneSize = planeSize0;
                                                alternateStaticPlaneSize = planeSize0 * 1000;
                                            }


                                            for (int xx = 0; xx < somevoxelroomglobals.numberOfInstancesPerObjectInWidth; xx++)
                                            {
                                                //MainWindow.MessageBox((IntPtr)0, "" + noiseXZ, "sccs", 0);

                                                for (int yy = 0; yy < somevoxelroomglobals.numberOfInstancesPerObjectInHeight; yy++)
                                                {
                                                    for (int zz = 0; zz < somevoxelroomglobals.numberOfInstancesPerObjectInDepth; zz++)
                                                    {

                                                        float seed = (float)sc_maths.getSomeRandNum(3420, 9999999); //3420;

                                                        int cc = xx + somevoxelroomglobals.numberOfInstancesPerObjectInWidth * (yy + somevoxelroomglobals.numberOfInstancesPerObjectInHeight * zz);




                                                        /*if (sc_menu_scroller == 3 && somecounterresetcounter < somevoxelroomswidth * somevoxelroomsheight * somevoxelroomsdepth * somevoxelroomglobals.numberOfObjectInWidth * somevoxelroomglobals.numberOfObjectInHeight * somevoxelroomglobals.numberOfObjectInDepth * somevoxelroomglobals.numberOfInstancesPerObjectInWidth * somevoxelroomglobals.numberOfInstancesPerObjectInHeight * somevoxelroomglobals.numberOfInstancesPerObjectInDepth && resetvoxelladdercounter == 2)
                                                        {
                                                            //MainWindow.MessageBox((IntPtr)0, "menu option 3" , "sccs", 0);

                                                            int voxelchunkinvertoption = MainWindow.usetypeofvoxel;


                                                            somevoxelroom[somevoxelroomindex].arrayofindexzeromesh[c].somechunk[cc].resetmap(out m11, out m12, out m13, out m14, out m21, out m22, out m23, out m24, out m31, out m32, out m33, out m34, out m41, out m42, out m43, out m44, -1, voxelchunkinvertoption);
                                                            //somevoxelroom[somevoxelroomindex].arrayofindexzeromesh[c].somechunk[cc].setnewmap(out m11, out m12, out m13, out m14, out m21, out m22, out m23, out m24, out m31, out m32, out m33, out m34, out m41, out m42, out m43, out m44, -1, voxelchunkinvertoption); //


                                                            somevoxelroom[somevoxelroomindex].arrayofindexzeromesh[c].instancesmatrix[cc].instancematrix.M11 = (float)m11;
                                                            somevoxelroom[somevoxelroomindex].arrayofindexzeromesh[c].instancesmatrix[cc].instancematrix.M12 = (float)m12;
                                                            somevoxelroom[somevoxelroomindex].arrayofindexzeromesh[c].instancesmatrix[cc].instancematrix.M13 = (float)m13;
                                                            somevoxelroom[somevoxelroomindex].arrayofindexzeromesh[c].instancesmatrix[cc].instancematrix.M14 = (float)m14;

                                                            somevoxelroom[somevoxelroomindex].arrayofindexzeromesh[c].instancesmatrix[cc].instancematrix.M21 = (float)m21;
                                                            somevoxelroom[somevoxelroomindex].arrayofindexzeromesh[c].instancesmatrix[cc].instancematrix.M22 = (float)m22;
                                                            somevoxelroom[somevoxelroomindex].arrayofindexzeromesh[c].instancesmatrix[cc].instancematrix.M23 = (float)m23;
                                                            somevoxelroom[somevoxelroomindex].arrayofindexzeromesh[c].instancesmatrix[cc].instancematrix.M24 = (float)m24;

                                                            somevoxelroom[somevoxelroomindex].arrayofindexzeromesh[c].instancesmatrix[cc].instancematrix.M31 = (float)m31;
                                                            somevoxelroom[somevoxelroomindex].arrayofindexzeromesh[c].instancesmatrix[cc].instancematrix.M32 = (float)m32;
                                                            somevoxelroom[somevoxelroomindex].arrayofindexzeromesh[c].instancesmatrix[cc].instancematrix.M33 = (float)m33;
                                                            somevoxelroom[somevoxelroomindex].arrayofindexzeromesh[c].instancesmatrix[cc].instancematrix.M34 = (float)m34;

                                                            somevoxelroom[somevoxelroomindex].arrayofindexzeromesh[c].instancesmatrix[cc].instancematrix.M41 = (float)m41;
                                                            somevoxelroom[somevoxelroomindex].arrayofindexzeromesh[c].instancesmatrix[cc].instancematrix.M42 = (float)m42;
                                                            somevoxelroom[somevoxelroomindex].arrayofindexzeromesh[c].instancesmatrix[cc].instancematrix.M43 = (float)m43;
                                                            somevoxelroom[somevoxelroomindex].arrayofindexzeromesh[c].instancesmatrix[cc].instancematrix.M44 = (float)m44;

                                                            somevoxelroom[somevoxelroomindex].arrayOfChunkData[c].copytobuffer = 1;

                                                            somecounterresetcounter++;
                                                        }*/
                                                        /*if (sc_menu_scroller == 3 && somecounterresetcounter >= somevoxelroomswidth * somevoxelroomsheight * somevoxelroomsdepth * somevoxelroomglobals.numberOfObjectInWidth * somevoxelroomglobals.numberOfObjectInHeight * somevoxelroomglobals.numberOfObjectInDepth * somevoxelroomglobals.numberOfInstancesPerObjectInWidth * somevoxelroomglobals.numberOfInstancesPerObjectInHeight * somevoxelroomglobals.numberOfInstancesPerObjectInDepth)
                                                        {
                                                            //MainWindow.MessageBox((IntPtr)0, "resetted map", "sccs", 0);

                                                            //sc_menu_scroller = 0;
                                                            //somecounterresetcounter = 0;
                                                        }











                                                        var somecountermax = (float)Math.Abs((somevoxelroom[somevoxelroomindex].arrayofindexzeromesh[c].colorsNFaces[cc].colorsNFaces.W - (float)Math.Floor(somevoxelroom[somevoxelroomindex].arrayofindexzeromesh[c].colorsNFaces[cc].colorsNFaces.W)) * 1000);

                                                        float noiseXZ = 100;
                                                        float noiseYZ = 100;
                                                        float noiseXY = 100;

                                                        float detailScale1 = 7;
                                                        float heightScale1 = 5;

                                                        //fastNoise = new FastNoise();

                                                        noiseXZ *= (fastNoise.GetNoise((x * planeSize0 + somevoxelroom[somevoxelroomindex].arrayofindexzeromesh[c].colorsNFaces[cc].colorsNFaces.X + seed) / detailScale1, (z * planeSize0 + somevoxelroom[somevoxelroomindex].arrayofindexzeromesh[c].colorsNFaces[cc].colorsNFaces.Z + seed) / detailScale1) * heightScale1);
                                                        float size0 = (1 / planeSize0) * somevoxelroom[somevoxelroomindex].arrayofindexzeromesh[c].colorsNFaces[cc].colorsNFaces.Y;
                                                        noiseXZ -= size0;

                                                        //MainWindow.MessageBox((IntPtr)0, "c:" + somecountermax, "sccs error", 0);
                                                        noiseYZ *= (fastNoise.GetNoise((y * planeSize0 + somevoxelroom[somevoxelroomindex].arrayofindexzeromesh[c].colorsNFaces[cc].colorsNFaces.Y + seed) / detailScale1, (z * planeSize0 + somevoxelroom[somevoxelroomindex].arrayofindexzeromesh[c].colorsNFaces[cc].colorsNFaces.Z + seed) / detailScale1) * heightScale1);
                                                        float size1 = (1 / planeSize0) * somevoxelroom[somevoxelroomindex].arrayofindexzeromesh[c].colorsNFaces[cc].colorsNFaces.X;
                                                        noiseYZ -= size1;


                                                        noiseXY *= (fastNoise.GetNoise((x * planeSize0 + somevoxelroom[somevoxelroomindex].arrayofindexzeromesh[c].colorsNFaces[cc].colorsNFaces.X + seed) / detailScale1, (y * planeSize0 + somevoxelroom[somevoxelroomindex].arrayofindexzeromesh[c].colorsNFaces[cc].colorsNFaces.Y + seed) / detailScale1) * heightScale1);
                                                        float size2 = (1 / planeSize0) * somevoxelroom[somevoxelroomindex].arrayofindexzeromesh[c].colorsNFaces[cc].colorsNFaces.Z;
                                                        noiseXY -= size2;

                                                        //TOREADD FOR NOISE TEST ON COLOR

                                                        //noiseXZ *= fastNoise.GetNoise((((x * staticPlaneSize) + (somevoxelroom[somevoxelroomindex].arrayofindexzeromesh[c].colorsNFaces[cc].colorsNFaces.X * alternateStaticPlaneSize) + seed) / _detailScale) * _HeightScale, (((y * staticPlaneSize) + (somevoxelroom[somevoxelroomindex].arrayofindexzeromesh[c].colorsNFaces[cc].colorsNFaces.Y * alternateStaticPlaneSize) + seed) / _detailScale) * _HeightScale, (((z * staticPlaneSize) + (somevoxelroom[somevoxelroomindex].arrayofindexzeromesh[c].colorsNFaces[cc].colorsNFaces.Z * alternateStaticPlaneSize) + seed) / _detailScale) * _HeightScale);

                                                        float someclampednoisexz = sc_maths.ClampValue(0.55f + (1 * noiseXZ), 0.35f, 0.75f);
                                                        float someclampednoiseyz = sc_maths.ClampValue(0.55f + (1 * noiseYZ), 0.35f, 0.75f);
                                                        float someclampednoisexy = sc_maths.ClampValue(0.55f + (1 * noiseXY), 0.35f, 0.75f);

                                                        //MainWindow.MessageBox((IntPtr)0, "someclampednoisexz:" + someclampednoisexz + "/someclampednoiseyz:" + someclampednoiseyz + "/someclampednoisexy:" + someclampednoisexy, "sccs", 0);
                                                        //MainWindow.MessageBox((IntPtr)0, "noiseXZ:" + noiseXZ + "/noiseYZ:" + noiseYZ + "/noiseXY:" + noiseXY, "sccs", 0);

                                                        //somevoxelroom[somevoxelroomindex].arrayofindexzeromesh[c].colorsNFaces[cc].colorsNFaces.X =Math.Abs(0.15f + noiseXZ);// someclampednoisexz;
                                                        //somevoxelroom[somevoxelroomindex].arrayofindexzeromesh[c].colorsNFaces[cc].colorsNFaces.Y = Math.Abs(0.25f + noiseYZ);// someclampednoiseyz;
                                                        //somevoxelroom[somevoxelroomindex].arrayofindexzeromesh[c].colorsNFaces[cc].colorsNFaces.Z = Math.Abs(0.15f + noiseXY);// someclampednoisexy;

                                                        somevoxelroom[somevoxelroomindex].arrayofindexzeromesh[c].colorsNFaces[cc].colorsNFaces.X = 0.35f + Math.Abs(someclampednoisexz);
                                                        somevoxelroom[somevoxelroomindex].arrayofindexzeromesh[c].colorsNFaces[cc].colorsNFaces.Y = 0.35f + Math.Abs(someclampednoiseyz);
                                                        somevoxelroom[somevoxelroomindex].arrayofindexzeromesh[c].colorsNFaces[cc].colorsNFaces.Z = 0.35f + Math.Abs(someclampednoisexy);

                                                        //somevoxelroom[somevoxelroomindex].arrayofindexzeromesh[c].colorsNFaces[cc].colorsNFaces.W = 1.0f;

                                                        //this can be swapped with heightmaps values with some modifications here and there to bring bytes within a range of 0 to 255 rgba values or from within a range of 0.0f to 1.0f values.
                                                        if (Math.Truncate(somevoxelroom[somevoxelroomindex].arrayofindexzeromesh[c].colorsNFaces[cc].colorsNFaces.W) >= somecountermax)
                                                        {

                                                            somevoxelroom[somevoxelroomindex].arrayofindexzeromesh[c].colorsNFaces[cc].colorsNFaces.W = 0 + somecountermax * 0.001f;
                                                        }
                                                        somevoxelroom[somevoxelroomindex].arrayofindexzeromesh[c].colorsNFaces[cc].colorsNFaces.W += 1f;

                                                        //TOREADD FOR NOISE TEST ON COLOR

                                                        //this can be swapped with heightmaps values with some modifications here and there to bring bytes within a range of 0 to 255 rgba values or from within a range of 0.0f to 1.0f values.
                                                    }
                                                }
                                            }
                                        }















                                        Matrix _WorldMatrix = WorldMatrix;
                                        Matrix matrixtouchright = SC_Update._rightTouchMatrix;//_player_rght_hnd[0][0]._arrayOfInstances[0].current_pos;

                                        int xii = 0;
                                        int yii = 0;
                                        int zii = 0;



                                        //ATTRACT FORCE LOGIC
                                        //ATTRACT FORCE LOGIC
                                        //ATTRACT FORCE LOGIC
                                        /*
                                        //arrayOfChunkData[c].worldMatrix += arrayOfMatrixBuff[0].world;
                                        if (SC_Update.handTriggerRight[1] >= 0.001f)
                                        {
                                            //MainWindow.MessageBox((IntPtr)0, "b: ", "", 0);
                                            for (int xxi = 0; xxi < somevoxelroomglobals.numberOfInstancesPerObjectInWidth; xxi++)
                                            {
                                                for (int yyi = 0; yyi < somevoxelroomglobals.numberOfInstancesPerObjectInHeight; yyi++)
                                                {
                                                    for (int zzi = 0; zzi < somevoxelroomglobals.numberOfInstancesPerObjectInDepth; zzi++)
                                                    {
                                                        int cc = xxi + somevoxelroomglobals.numberOfInstancesPerObjectInWidth * (yyi + somevoxelroomglobals.numberOfInstancesPerObjectInHeight * zzi);

                                                        //var dirToRightHand = new Vector3(_player_rght_hnd[0][0]._arrayOfInstances[0].current_pos.M41, _player_rght_hnd[0][0]._arrayOfInstances[0].current_pos.M42, _player_rght_hnd[0][0]._arrayOfInstances[0].current_pos.M43) - new Vector3(arrayOfChunkData[c].SC_instancedChunk_Instances[cc].instancePos.X, arrayOfChunkData[c].SC_instancedChunk_Instances[cc].instancePos.Y, arrayOfChunkData[c].SC_instancedChunk_Instances[cc].instancePos.Z);

                                                        var dirToRightHand = new Vector3(_player_rght_hnd[0][0]._arrayOfInstances[0].current_pos.M41, _player_rght_hnd[0][0]._arrayOfInstances[0].current_pos.M42, _player_rght_hnd[0][0]._arrayOfInstances[0].current_pos.M43) - new Vector3(somevoxelroom[somevoxelroomindex].arrayofindexzeromesh[c].arrayOfScriptForInstances[cc].current_pos.M41, somevoxelroom[somevoxelroomindex].arrayofindexzeromesh[c].arrayOfScriptForInstances[cc].current_pos.M42, somevoxelroom[somevoxelroomindex].arrayofindexzeromesh[c].arrayOfScriptForInstances[cc].current_pos.M43);

                                                        var lengthofdir = dirToRightHand.Length();

                                                        //var moveRightHand = new JVector(_player_lft_hnd[0]._arrayOfInstances[0].current_pos.M41, _player_lft_hnd[0]._arrayOfInstances[0].current_pos.M42, _player_lft_hnd[0]._arrayOfInstances[0].current_pos.M43) - new JVector(_player_lft_hnd[0]._arrayOfInstances[0]._LASTPOSITIONFORPHYSICS.M41, _player_lft_hnd[0]._arrayOfInstances[0]._LASTPOSITIONFORPHYSICS.M42, _player_lft_hnd[0]._arrayOfInstances[0]._LASTPOSITIONFORPHYSICS.M43);

                                                        if (dirToRightHand != null)
                                                        {
                                                            dirToRightHand.Normalize();

                                                            lh_attract_force = new JVector(dirToRightHand.X, dirToRightHand.Y, dirToRightHand.Z) * 1;

                                                            lh_attract_force.Normalize();

                                                            lh_attract_force *= 0.5f; //0.1f

                                                            Vector4 otherVec4AttractForce = new Vector4(lh_attract_force.X, lh_attract_force.Y, lh_attract_force.Z, 1);

                                                            somevoxelroom[somevoxelroomindex].arrayOfChunkData[c].SC_instancedChunk_Instances[cc].instancePos += otherVec4AttractForce;// new Vector4(lh_attract_force.X, lh_attract_force.Y, lh_attract_force.Z, 1);

                                                            somevoxelroom[somevoxelroomindex].arrayofindexzeromesh[c].arrayOfScriptForInstances[cc].current_pos.M41 = somevoxelroom[somevoxelroomindex].arrayOfChunkData[c].SC_instancedChunk_Instances[cc].instancePos.X;// otherVec4AttractForce.X;
                                                            somevoxelroom[somevoxelroomindex].arrayofindexzeromesh[c].arrayOfScriptForInstances[cc].current_pos.M42 = somevoxelroom[somevoxelroomindex].arrayOfChunkData[c].SC_instancedChunk_Instances[cc].instancePos.Y;//otherVec4AttractForce.Y;
                                                            somevoxelroom[somevoxelroomindex].arrayofindexzeromesh[c].arrayOfScriptForInstances[cc].current_pos.M43 = somevoxelroom[somevoxelroomindex].arrayOfChunkData[c].SC_instancedChunk_Instances[cc].instancePos.Z;//otherVec4AttractForce.Z;

                                                            somevoxelroom[somevoxelroomindex].arrayofindexzeromesh[c].instances[cc].instancePos.X += otherVec4AttractForce.X;
                                                            somevoxelroom[somevoxelroomindex].arrayofindexzeromesh[c].instances[cc].instancePos.Y += otherVec4AttractForce.Y;
                                                            somevoxelroom[somevoxelroomindex].arrayofindexzeromesh[c].instances[cc].instancePos.Z += otherVec4AttractForce.Z;

                                                            //arrayOfChunkData[c].SC_instancedChunk_Instances[cc].instancePos.X

                                                            if (lh_attract_force != JVector.Zero && lh_attract_force != null && lh_attract_force.Length() > 0 && body != _grab_rigid_data._body)
                                                            {
                                                                //MessageBox((IntPtr)0, "" + "null dir 01", "Oculus Error", 0);
                                                                //MessageBox((IntPtr)0, "" + "not null force", "Oculus Error", 0);
                                                                //lh_attract_force.Normalize();

                                                                //if (has_water_buo_effect == 1)
                                                                //{
                                                                //    lh_attract_force *= force_4_screen * 10;
                                                               /// }
                                                                //else
                                                                //{
                                                                //    lh_attract_force *= force_4_screen * 1;
                                                                //}

                                                                //0.0045f

                                                                //lh_attract_force *= force_4_screen*1000;
                                                                //body.LinearVelocity += lh_attract_force;
                                                                //body.AddForce(lh_attract_force);

                                                                //worldMatrix

                                                                //arrayOfChunkData[c].arrayOfInstance[cc].instancePos += new Vector4(lh_attract_force.X, lh_attract_force.Y, lh_attract_force.Z, 1);

                                                                //body.AddTorque(force);
                                                            }
                                                        }
                                                        else
                                                        {
                                                            //Console.WriteLine("null dir");
                                                           //// MainWindow.MessageBox((IntPtr)0, "" + "null dir 01", "Oculus Error", 0);
                                                        }
                                                    }
                                                }
                                            }
                                        }




                                        //somevoxelroom[somevoxelroomindex].arrayOfChunkData[c].viewMatrix = _viewMatrix;
                                        //somevoxelroom[somevoxelroomindex].arrayOfChunkData[c].projectionMatrix = _projectionMatrix;

                                        //arrayOfChunkData[c].worldMatrix += arrayOfMatrixBuff[0].world;

                                        somevoxelroom[somevoxelroomindex].lightBufferInstChunk = somevoxelroom[somevoxelroomindex].arrayOfChunkData[c].lightBuffer;

                                        //SENDING THE SCREENCAPTURE TO THE BUFFER FOR THE SHADER
                                        //somevoxelroom[somevoxelroomindex].shaderOfChunk.shaderResourceView2D = SC_Update._desktopFrame.ShaderResource;// SC_Update._desktopFrame.ShaderResourceArray;
                                        //somevoxelroom[somevoxelroomindex].arrayOfChunkData[c].chunkShader.shaderResourceView2D = SC_Update._desktopFrame.ShaderResource;//
                                        //SENDING THE SCREENCAPTURE TO THE BUFFER FOR THE SHADER


                                        //RENDERING THE INSTANCED CHUNK 
                                        somevoxelroom[somevoxelroomindex].arrayOfChunkData[c].matrixBuffer = somevoxelroom[somevoxelroomindex].arrayOfMatrixBuff;
                                        //somevoxelroom[somevoxelroomindex].arrayOfChunkData[c] = somevoxelroom[somevoxelroomindex].shaderOfChunk.Renderer(somevoxelroom[somevoxelroomindex].arrayOfChunkData[c], c, null, somevoxelroom[somevoxelroomindex].voxeltype); //SC_Update._desktopFrame.ShaderResource
                                        //RENDERING THE INSTANCED CHUNK
                                        //SC_Update._shaderManager.renderinstancedchunk(somevoxelroom[somevoxelroomindex].arrayOfChunkData[c], c, SC_Update._desktopFrame.ShaderResource, somevoxelroom[somevoxelroomindex].voxeltype);


                                        somevoxelroom[somevoxelroomindex].arrayOfChunkData[c] = somevoxelroom[somevoxelroomindex].arrayOfChunkData[c].shaderOfChunk.Renderer(somevoxelroom[somevoxelroomindex].arrayOfChunkData[c], c, null, somevoxelroom[somevoxelroomindex].voxeltype); //SC_Update._desktopFrame.ShaderResource


                                    }
                                }
                            }
                        }
                    }
                }*/
                //CHUNK MESH VIRTUAL KEYBOARD CONTAINMENT GRID
                //CHUNK MESH VIRTUAL KEYBOARD CONTAINMENT GRID
                //CHUNK MESH VIRTUAL KEYBOARD CONTAINMENT GRID







                /*
                ///////////////////////////////SECTION FOR VOXEL ROOM//////////////////////////////
                //VOXEL ROOM GRID
                //VOXEL ROOM GRID
                //VOXEL ROOM GRID
                for (int xxxx = 0; xxxx < somevoxelroomgridw; xxxx++)
                {
                    for (int yyyy = 0; yyyy < somevoxelroomgridh; yyyy++)
                    {
                        for (int zzzz = 0; zzzz < somevoxelroomgridd; zzzz++)
                        {
                            var somevoxelroomindex = xxxx + somevoxelroomgridw * (yyyy + somevoxelroomgridh * zzzz);


                            //somevoxelroom[somevoxelroomindex].worldmatofobj = somevoxelroom[somevoxelroomindex].

                            somevoxelroom[somevoxelroomindex].arrayOfMatrixBuff[0].world = _worldMatrix;
                            somevoxelroom[somevoxelroomindex].arrayOfMatrixBuff[0].view = _viewMatrix;
                            somevoxelroom[somevoxelroomindex].arrayOfMatrixBuff[0].proj = _projectionMatrix;

                            /*somevoxelroom[somevoxelroomindex].arrayOfMatrixBuff[0] = new SC_instancedChunkPrim.DMatrixBuffer()
                            {
                                world = _worldMatrix,
                                view = _viewMatrix,
                                proj = _projectionMatrix,
                            };*/


                            /*somevoxelroom[somevoxelroomindex].lightBufferInstChunk[0] = new SC_instancedChunkPrim.DLightBufferEr()
                            {
                                ambientColor = ambientColor,
                                diffuseColor = diffuseColour,
                                lightDirection = rayDirFrontInstancesChunks,
                                padding0 = 0,
                                lightPosition = centerPosRighthandposRR,
                                padding1 = 100
                            };

                            lightpos.X = SC_Update._rightTouchMatrix.M41;
                            lightpos.Y = SC_Update._rightTouchMatrix.M42;
                            lightpos.Z = SC_Update._rightTouchMatrix.M43;


                            Quaternion somerighttouchquat;
                            Matrix somemat = SC_Update._rightTouchMatrix;
                            Quaternion.RotationMatrix(ref somemat, out somerighttouchquat);

                            Vector3 forwarddir = sc_maths._getDirection(Vector3.ForwardRH, somerighttouchquat);

                            //ambientColor = new Vector4(0.45f, 0.45f, 0.45f, 1.0f);
                            ambientColor = new Vector4(0.75f, 0.75f, 0.75f, 1.0f);
                            diffuseColour = new Vector4(1, 1, 1, 1);
                            //lightDirection = new Vector3(0, -1, -1);

                            somevoxelroom[somevoxelroomindex].lightBufferInstChunk[0].lightDirection = forwarddir;
                            somevoxelroom[somevoxelroomindex].lightBufferInstChunk[0].lightPosition = lightpos;

                            somevoxelroom[somevoxelroomindex].lightBufferInstChunk[0].ambientColor = ambientColor;
                            somevoxelroom[somevoxelroomindex].lightBufferInstChunk[0].diffuseColor = diffuseColour;

                            for (int x = 0; x < somevoxelroomgridglobals.numberOfObjectInWidth; x++)
                            {
                                for (int y = 0; y < somevoxelroomgridglobals.numberOfObjectInHeight; y++)
                                {
                                    for (int z = 0; z < somevoxelroomgridglobals.numberOfObjectInDepth; z++)
                                    {
                                        int c = x + somevoxelroomgridglobals.numberOfObjectInWidth * (y + somevoxelroomgridglobals.numberOfObjectInHeight * z);

                                        if (somevoxelroom[somevoxelroomindex].arrayOfChunkData[c].switchForRender == 1)
                                        {
                                            var matrixBufferDescriptionVertex00 = new BufferDescription()
                                            {
                                                Usage = ResourceUsage.Dynamic,
                                                SizeInBytes = Marshal.SizeOf(typeof(SC_instancedChunk.DInstanceType)) * somevoxelroom[somevoxelroomindex].instances.Length,
                                                BindFlags = BindFlags.VertexBuffer,
                                                CpuAccessFlags = CpuAccessFlags.Write,
                                                OptionFlags = ResourceOptionFlags.None,
                                                StructureByteStride = 0
                                            };

                                            var InstanceBuffer = new SharpDX.Direct3D11.Buffer(SC_console_directx.D3D.device, matrixBufferDescriptionVertex00);

                                            somevoxelroom[somevoxelroomindex].arrayOfChunkData[c].SC_instancedChunk_Instances = somevoxelroom[somevoxelroomindex].arrayofindexzeromesh[c].instances;
                                            somevoxelroom[somevoxelroomindex].arrayOfChunkData[c].worldMatrix = _worldMatrix;
                                            somevoxelroom[somevoxelroomindex].arrayOfChunkData[c].viewMatrix = _viewMatrix;
                                            somevoxelroom[somevoxelroomindex].arrayOfChunkData[c].projectionMatrix = _projectionMatrix;

                                            //arrayOfChunkData[c].worldMatrix += arrayOfMatrixBuff[0].world;

                                            somevoxelroom[somevoxelroomindex].arrayOfChunkData[c].matrixBuffer = somevoxelroom[somevoxelroomindex].arrayOfMatrixBuff;

                                            //arrayOfChunkData[c].lightBuffer = lightBufferInstChunk;

                                            somevoxelroom[somevoxelroomindex].arrayOfChunkData[c].instanceBuffer = InstanceBuffer;
                                            somevoxelroom[somevoxelroomindex].arrayOfChunkData[c].arrayOfSomeMap = somevoxelroom[somevoxelroomindex].arrayofindexzeromesh[c].arrayOfSomeMap;

                                            //arrayOfChunkData[c] = shaderOfChunk.Renderer(arrayOfChunkData[c], c);
                                        }
                                        else
                                        {
                                            float staticPlaneSize = somevoxelroomgridglobals.planeSize;
                                            float planeSize0 = somevoxelroomgridglobals.planeSize;
                                            float alternateStaticPlaneSize = 0;

                                            if (staticPlaneSize == 1)
                                            {
                                                staticPlaneSize = planeSize0 * 0.1f;
                                                alternateStaticPlaneSize = planeSize0 * 0.1f;
                                            }
                                            else if (staticPlaneSize == 0.1f)
                                            {
                                                staticPlaneSize = planeSize0;
                                                alternateStaticPlaneSize = planeSize0 * 10;
                                            }
                                            else if (staticPlaneSize == 0.01f)
                                            {
                                                staticPlaneSize = planeSize0;
                                                alternateStaticPlaneSize = planeSize0 * 1000;
                                            }


                                            for (int xx = 0; xx < somevoxelroomgridglobals.numberOfInstancesPerObjectInWidth; xx++)
                                            {
                                                //MainWindow.MessageBox((IntPtr)0, "" + noiseXZ, "sccs", 0);

                                                for (int yy = 0; yy < somevoxelroomgridglobals.numberOfInstancesPerObjectInHeight; yy++)
                                                {
                                                    for (int zz = 0; zz < somevoxelroomgridglobals.numberOfInstancesPerObjectInDepth; zz++)
                                                    {

                                                        float seed = (float)sc_maths.getSomeRandNum(3420, 9999999); //3420;

                                                        int cc = xx + somevoxelroomgridglobals.numberOfInstancesPerObjectInWidth * (yy + somevoxelroomgridglobals.numberOfInstancesPerObjectInHeight * zz);




                                                        /*if (sc_menu_scroller == 3 && somecounterresetcounter < somevoxelroomswidth * somevoxelroomsheight * somevoxelroomsdepth * somevoxelroomgridglobals.numberOfObjectInWidth * somevoxelroomgridglobals.numberOfObjectInHeight * somevoxelroomgridglobals.numberOfObjectInDepth * somevoxelroomgridglobals.numberOfInstancesPerObjectInWidth * somevoxelroomgridglobals.numberOfInstancesPerObjectInHeight * somevoxelroomgridglobals.numberOfInstancesPerObjectInDepth && resetvoxelladdercounter == 2)
                                                        {
                                                            //MainWindow.MessageBox((IntPtr)0, "menu option 3" , "sccs", 0);

                                                            int voxelchunkinvertoption = MainWindow.usetypeofvoxel;


                                                            somevoxelroom[somevoxelroomindex].arrayofindexzeromesh[c].somechunk[cc].resetmap(out m11, out m12, out m13, out m14, out m21, out m22, out m23, out m24, out m31, out m32, out m33, out m34, out m41, out m42, out m43, out m44, -1, voxelchunkinvertoption);
                                                            //somevoxelroom[somevoxelroomindex].arrayofindexzeromesh[c].somechunk[cc].setnewmap(out m11, out m12, out m13, out m14, out m21, out m22, out m23, out m24, out m31, out m32, out m33, out m34, out m41, out m42, out m43, out m44, -1, voxelchunkinvertoption); //


                                                            somevoxelroom[somevoxelroomindex].arrayofindexzeromesh[c].instancesmatrix[cc].instancematrix.M11 = (float)m11;
                                                            somevoxelroom[somevoxelroomindex].arrayofindexzeromesh[c].instancesmatrix[cc].instancematrix.M12 = (float)m12;
                                                            somevoxelroom[somevoxelroomindex].arrayofindexzeromesh[c].instancesmatrix[cc].instancematrix.M13 = (float)m13;
                                                            somevoxelroom[somevoxelroomindex].arrayofindexzeromesh[c].instancesmatrix[cc].instancematrix.M14 = (float)m14;

                                                            somevoxelroom[somevoxelroomindex].arrayofindexzeromesh[c].instancesmatrix[cc].instancematrix.M21 = (float)m21;
                                                            somevoxelroom[somevoxelroomindex].arrayofindexzeromesh[c].instancesmatrix[cc].instancematrix.M22 = (float)m22;
                                                            somevoxelroom[somevoxelroomindex].arrayofindexzeromesh[c].instancesmatrix[cc].instancematrix.M23 = (float)m23;
                                                            somevoxelroom[somevoxelroomindex].arrayofindexzeromesh[c].instancesmatrix[cc].instancematrix.M24 = (float)m24;

                                                            somevoxelroom[somevoxelroomindex].arrayofindexzeromesh[c].instancesmatrix[cc].instancematrix.M31 = (float)m31;
                                                            somevoxelroom[somevoxelroomindex].arrayofindexzeromesh[c].instancesmatrix[cc].instancematrix.M32 = (float)m32;
                                                            somevoxelroom[somevoxelroomindex].arrayofindexzeromesh[c].instancesmatrix[cc].instancematrix.M33 = (float)m33;
                                                            somevoxelroom[somevoxelroomindex].arrayofindexzeromesh[c].instancesmatrix[cc].instancematrix.M34 = (float)m34;

                                                            somevoxelroom[somevoxelroomindex].arrayofindexzeromesh[c].instancesmatrix[cc].instancematrix.M41 = (float)m41;
                                                            somevoxelroom[somevoxelroomindex].arrayofindexzeromesh[c].instancesmatrix[cc].instancematrix.M42 = (float)m42;
                                                            somevoxelroom[somevoxelroomindex].arrayofindexzeromesh[c].instancesmatrix[cc].instancematrix.M43 = (float)m43;
                                                            somevoxelroom[somevoxelroomindex].arrayofindexzeromesh[c].instancesmatrix[cc].instancematrix.M44 = (float)m44;

                                                            somevoxelroom[somevoxelroomindex].arrayOfChunkData[c].copytobuffer = 1;

                                                            somecounterresetcounter++;
                                                        }*/
                                                        /*if (sc_menu_scroller == 3 && somecounterresetcounter >= somevoxelroomswidth * somevoxelroomsheight * somevoxelroomsdepth * somevoxelroomgridglobals.numberOfObjectInWidth * somevoxelroomgridglobals.numberOfObjectInHeight * somevoxelroomgridglobals.numberOfObjectInDepth * somevoxelroomgridglobals.numberOfInstancesPerObjectInWidth * somevoxelroomgridglobals.numberOfInstancesPerObjectInHeight * somevoxelroomgridglobals.numberOfInstancesPerObjectInDepth)
                                                        {
                                                            //MainWindow.MessageBox((IntPtr)0, "resetted map", "sccs", 0);

                                                            //sc_menu_scroller = 0;
                                                            //somecounterresetcounter = 0;
                                                        }











                                                        var somecountermax = (float)Math.Abs((somevoxelroom[somevoxelroomindex].arrayofindexzeromesh[c].colorsNFaces[cc].colorsNFaces.W - (float)Math.Floor(somevoxelroom[somevoxelroomindex].arrayofindexzeromesh[c].colorsNFaces[cc].colorsNFaces.W)) * 1000);

                                                        float noiseXZ = 100;
                                                        float noiseYZ = 100;
                                                        float noiseXY = 100;

                                                        float detailScale1 = 7;
                                                        float heightScale1 = 5;

                                                        //fastNoise = new FastNoise();

                                                        noiseXZ *= (fastNoise.GetNoise((x * planeSize0 + somevoxelroom[somevoxelroomindex].arrayofindexzeromesh[c].colorsNFaces[cc].colorsNFaces.X + seed) / detailScale1, (z * planeSize0 + somevoxelroom[somevoxelroomindex].arrayofindexzeromesh[c].colorsNFaces[cc].colorsNFaces.Z + seed) / detailScale1) * heightScale1);
                                                        float size0 = (1 / planeSize0) * somevoxelroom[somevoxelroomindex].arrayofindexzeromesh[c].colorsNFaces[cc].colorsNFaces.Y;
                                                        noiseXZ -= size0;

                                                        //MainWindow.MessageBox((IntPtr)0, "c:" + somecountermax, "sccs error", 0);
                                                        noiseYZ *= (fastNoise.GetNoise((y * planeSize0 + somevoxelroom[somevoxelroomindex].arrayofindexzeromesh[c].colorsNFaces[cc].colorsNFaces.Y + seed) / detailScale1, (z * planeSize0 + somevoxelroom[somevoxelroomindex].arrayofindexzeromesh[c].colorsNFaces[cc].colorsNFaces.Z + seed) / detailScale1) * heightScale1);
                                                        float size1 = (1 / planeSize0) * somevoxelroom[somevoxelroomindex].arrayofindexzeromesh[c].colorsNFaces[cc].colorsNFaces.X;
                                                        noiseYZ -= size1;


                                                        noiseXY *= (fastNoise.GetNoise((x * planeSize0 + somevoxelroom[somevoxelroomindex].arrayofindexzeromesh[c].colorsNFaces[cc].colorsNFaces.X + seed) / detailScale1, (y * planeSize0 + somevoxelroom[somevoxelroomindex].arrayofindexzeromesh[c].colorsNFaces[cc].colorsNFaces.Y + seed) / detailScale1) * heightScale1);
                                                        float size2 = (1 / planeSize0) * somevoxelroom[somevoxelroomindex].arrayofindexzeromesh[c].colorsNFaces[cc].colorsNFaces.Z;
                                                        noiseXY -= size2;

                                                        //TOREADD FOR NOISE TEST ON COLOR

                                                        //noiseXZ *= fastNoise.GetNoise((((x * staticPlaneSize) + (somevoxelroom[somevoxelroomindex].arrayofindexzeromesh[c].colorsNFaces[cc].colorsNFaces.X * alternateStaticPlaneSize) + seed) / _detailScale) * _HeightScale, (((y * staticPlaneSize) + (somevoxelroom[somevoxelroomindex].arrayofindexzeromesh[c].colorsNFaces[cc].colorsNFaces.Y * alternateStaticPlaneSize) + seed) / _detailScale) * _HeightScale, (((z * staticPlaneSize) + (somevoxelroom[somevoxelroomindex].arrayofindexzeromesh[c].colorsNFaces[cc].colorsNFaces.Z * alternateStaticPlaneSize) + seed) / _detailScale) * _HeightScale);

                                                        float someclampednoisexz = sc_maths.ClampValue(0.55f + (1 * noiseXZ), 0.35f, 0.75f);
                                                        float someclampednoiseyz = sc_maths.ClampValue(0.55f + (1 * noiseYZ), 0.35f, 0.75f);
                                                        float someclampednoisexy = sc_maths.ClampValue(0.55f + (1 * noiseXY), 0.35f, 0.75f);

                                                        //MainWindow.MessageBox((IntPtr)0, "someclampednoisexz:" + someclampednoisexz + "/someclampednoiseyz:" + someclampednoiseyz + "/someclampednoisexy:" + someclampednoisexy, "sccs", 0);
                                                        //MainWindow.MessageBox((IntPtr)0, "noiseXZ:" + noiseXZ + "/noiseYZ:" + noiseYZ + "/noiseXY:" + noiseXY, "sccs", 0);

                                                        //somevoxelroom[somevoxelroomindex].arrayofindexzeromesh[c].colorsNFaces[cc].colorsNFaces.X =Math.Abs(0.15f + noiseXZ);// someclampednoisexz;
                                                        //somevoxelroom[somevoxelroomindex].arrayofindexzeromesh[c].colorsNFaces[cc].colorsNFaces.Y = Math.Abs(0.25f + noiseYZ);// someclampednoiseyz;
                                                        //somevoxelroom[somevoxelroomindex].arrayofindexzeromesh[c].colorsNFaces[cc].colorsNFaces.Z = Math.Abs(0.15f + noiseXY);// someclampednoisexy;

                                                        somevoxelroom[somevoxelroomindex].arrayofindexzeromesh[c].colorsNFaces[cc].colorsNFaces.X = 0.35f + Math.Abs(someclampednoisexz);
                                                        somevoxelroom[somevoxelroomindex].arrayofindexzeromesh[c].colorsNFaces[cc].colorsNFaces.Y = 0.35f + Math.Abs(someclampednoiseyz);
                                                        somevoxelroom[somevoxelroomindex].arrayofindexzeromesh[c].colorsNFaces[cc].colorsNFaces.Z = 0.35f + Math.Abs(someclampednoisexy);

                                                        //somevoxelroom[somevoxelroomindex].arrayofindexzeromesh[c].colorsNFaces[cc].colorsNFaces.W = 1.0f;

                                                        //this can be swapped with heightmaps values with some modifications here and there to bring bytes within a range of 0 to 255 rgba values or from within a range of 0.0f to 1.0f values.
                                                        if (Math.Truncate(somevoxelroom[somevoxelroomindex].arrayofindexzeromesh[c].colorsNFaces[cc].colorsNFaces.W) >= somecountermax)
                                                        {

                                                            somevoxelroom[somevoxelroomindex].arrayofindexzeromesh[c].colorsNFaces[cc].colorsNFaces.W = 0 + somecountermax * 0.001f;
                                                        }
                                                        somevoxelroom[somevoxelroomindex].arrayofindexzeromesh[c].colorsNFaces[cc].colorsNFaces.W += 1f;

                                                        //TOREADD FOR NOISE TEST ON COLOR

                                                        //this can be swapped with heightmaps values with some modifications here and there to bring bytes within a range of 0 to 255 rgba values or from within a range of 0.0f to 1.0f values.
                                                    }
                                                }
                                            }
                                        }















                                        Matrix _WorldMatrix = WorldMatrix;
                                        Matrix matrixtouchright = SC_Update._rightTouchMatrix;//_player_rght_hnd[0][0]._arrayOfInstances[0].current_pos;

                                        int xii = 0;
                                        int yii = 0;
                                        int zii = 0;



                                        //ATTRACT FORCE LOGIC
                                        //ATTRACT FORCE LOGIC
                                        //ATTRACT FORCE LOGIC
                                        /*
                                        //arrayOfChunkData[c].worldMatrix += arrayOfMatrixBuff[0].world;
                                        if (SC_Update.handTriggerRight[1] >= 0.001f)
                                        {
                                            //MainWindow.MessageBox((IntPtr)0, "b: ", "", 0);
                                            for (int xxi = 0; xxi < somevoxelroomgridglobals.numberOfInstancesPerObjectInWidth; xxi++)
                                            {
                                                for (int yyi = 0; yyi < somevoxelroomgridglobals.numberOfInstancesPerObjectInHeight; yyi++)
                                                {
                                                    for (int zzi = 0; zzi < somevoxelroomgridglobals.numberOfInstancesPerObjectInDepth; zzi++)
                                                    {
                                                        int cc = xxi + somevoxelroomgridglobals.numberOfInstancesPerObjectInWidth * (yyi + somevoxelroomgridglobals.numberOfInstancesPerObjectInHeight * zzi);

                                                        //var dirToRightHand = new Vector3(_player_rght_hnd[0][0]._arrayOfInstances[0].current_pos.M41, _player_rght_hnd[0][0]._arrayOfInstances[0].current_pos.M42, _player_rght_hnd[0][0]._arrayOfInstances[0].current_pos.M43) - new Vector3(arrayOfChunkData[c].SC_instancedChunk_Instances[cc].instancePos.X, arrayOfChunkData[c].SC_instancedChunk_Instances[cc].instancePos.Y, arrayOfChunkData[c].SC_instancedChunk_Instances[cc].instancePos.Z);

                                                        var dirToRightHand = new Vector3(_player_rght_hnd[0][0]._arrayOfInstances[0].current_pos.M41, _player_rght_hnd[0][0]._arrayOfInstances[0].current_pos.M42, _player_rght_hnd[0][0]._arrayOfInstances[0].current_pos.M43) - new Vector3(somevoxelroom[somevoxelroomindex].arrayofindexzeromesh[c].arrayOfScriptForInstances[cc].current_pos.M41, somevoxelroom[somevoxelroomindex].arrayofindexzeromesh[c].arrayOfScriptForInstances[cc].current_pos.M42, somevoxelroom[somevoxelroomindex].arrayofindexzeromesh[c].arrayOfScriptForInstances[cc].current_pos.M43);

                                                        var lengthofdir = dirToRightHand.Length();

                                                        //var moveRightHand = new JVector(_player_lft_hnd[0]._arrayOfInstances[0].current_pos.M41, _player_lft_hnd[0]._arrayOfInstances[0].current_pos.M42, _player_lft_hnd[0]._arrayOfInstances[0].current_pos.M43) - new JVector(_player_lft_hnd[0]._arrayOfInstances[0]._LASTPOSITIONFORPHYSICS.M41, _player_lft_hnd[0]._arrayOfInstances[0]._LASTPOSITIONFORPHYSICS.M42, _player_lft_hnd[0]._arrayOfInstances[0]._LASTPOSITIONFORPHYSICS.M43);

                                                        if (dirToRightHand != null)
                                                        {
                                                            dirToRightHand.Normalize();

                                                            lh_attract_force = new JVector(dirToRightHand.X, dirToRightHand.Y, dirToRightHand.Z) * 1;

                                                            lh_attract_force.Normalize();

                                                            lh_attract_force *= 0.5f; //0.1f

                                                            Vector4 otherVec4AttractForce = new Vector4(lh_attract_force.X, lh_attract_force.Y, lh_attract_force.Z, 1);

                                                            somevoxelroom[somevoxelroomindex].arrayOfChunkData[c].SC_instancedChunk_Instances[cc].instancePos += otherVec4AttractForce;// new Vector4(lh_attract_force.X, lh_attract_force.Y, lh_attract_force.Z, 1);

                                                            somevoxelroom[somevoxelroomindex].arrayofindexzeromesh[c].arrayOfScriptForInstances[cc].current_pos.M41 = somevoxelroom[somevoxelroomindex].arrayOfChunkData[c].SC_instancedChunk_Instances[cc].instancePos.X;// otherVec4AttractForce.X;
                                                            somevoxelroom[somevoxelroomindex].arrayofindexzeromesh[c].arrayOfScriptForInstances[cc].current_pos.M42 = somevoxelroom[somevoxelroomindex].arrayOfChunkData[c].SC_instancedChunk_Instances[cc].instancePos.Y;//otherVec4AttractForce.Y;
                                                            somevoxelroom[somevoxelroomindex].arrayofindexzeromesh[c].arrayOfScriptForInstances[cc].current_pos.M43 = somevoxelroom[somevoxelroomindex].arrayOfChunkData[c].SC_instancedChunk_Instances[cc].instancePos.Z;//otherVec4AttractForce.Z;

                                                            somevoxelroom[somevoxelroomindex].arrayofindexzeromesh[c].instances[cc].instancePos.X += otherVec4AttractForce.X;
                                                            somevoxelroom[somevoxelroomindex].arrayofindexzeromesh[c].instances[cc].instancePos.Y += otherVec4AttractForce.Y;
                                                            somevoxelroom[somevoxelroomindex].arrayofindexzeromesh[c].instances[cc].instancePos.Z += otherVec4AttractForce.Z;

                                                            //arrayOfChunkData[c].SC_instancedChunk_Instances[cc].instancePos.X

                                                            if (lh_attract_force != JVector.Zero && lh_attract_force != null && lh_attract_force.Length() > 0 && body != _grab_rigid_data._body)
                                                            {
                                                                //MessageBox((IntPtr)0, "" + "null dir 01", "Oculus Error", 0);
                                                                //MessageBox((IntPtr)0, "" + "not null force", "Oculus Error", 0);
                                                                //lh_attract_force.Normalize();

                                                                //if (has_water_buo_effect == 1)
                                                                //{
                                                                //    lh_attract_force *= force_4_screen * 10;
                                                               /// }
                                                                //else
                                                                //{
                                                                //    lh_attract_force *= force_4_screen * 1;
                                                                //}

                                                                //0.0045f

                                                                //lh_attract_force *= force_4_screen*1000;
                                                                //body.LinearVelocity += lh_attract_force;
                                                                //body.AddForce(lh_attract_force);

                                                                //worldMatrix

                                                                //arrayOfChunkData[c].arrayOfInstance[cc].instancePos += new Vector4(lh_attract_force.X, lh_attract_force.Y, lh_attract_force.Z, 1);

                                                                //body.AddTorque(force);
                                                            }
                                                        }
                                                        else
                                                        {
                                                            //Console.WriteLine("null dir");
                                                           //// MainWindow.MessageBox((IntPtr)0, "" + "null dir 01", "Oculus Error", 0);
                                                        }
                                                    }
                                                }
                                            }
                                        }




                                        //somevoxelroomgrid[somevoxelroomindex].arrayOfChunkData[c].viewMatrix = _viewMatrix;
                                        //somevoxelroomgrid[somevoxelroomindex].arrayOfChunkData[c].projectionMatrix = _projectionMatrix;

                                        //arrayOfChunkData[c].worldMatrix += arrayOfMatrixBuff[0].world;

                                        somevoxelroomgrid[somevoxelroomindex].lightBufferInstChunk = somevoxelroomgrid[somevoxelroomindex].arrayOfChunkData[c].lightBuffer;

                                        //SENDING THE SCREENCAPTURE TO THE BUFFER FOR THE SHADER
                                        //somevoxelroomgrid[somevoxelroomindex].shaderOfChunk.shaderResourceView2D = SC_Update._desktopFrame.ShaderResource;// SC_Update._desktopFrame.ShaderResourceArray;
                                        //somevoxelroomgrid[somevoxelroomindex].arrayOfChunkData[c].chunkShader.shaderResourceView2D = SC_Update._desktopFrame.ShaderResource;//
                                        //SENDING THE SCREENCAPTURE TO THE BUFFER FOR THE SHADER


                                        //RENDERING THE INSTANCED CHUNK 
                                        somevoxelroomgrid[somevoxelroomindex].arrayOfChunkData[c].matrixBuffer = somevoxelroomgrid[somevoxelroomindex].arrayOfMatrixBuff;
                                        //somevoxelroomgrid[somevoxelroomindex].arrayOfChunkData[c] = somevoxelroomgrid[somevoxelroomindex].shaderOfChunk.Renderer(somevoxelroomgrid[somevoxelroomindex].arrayOfChunkData[c], c, null, somevoxelroomgrid[somevoxelroomindex].voxeltype); //SC_Update._desktopFrame.ShaderResource
                                        //RENDERING THE INSTANCED CHUNK
                                        //SC_Update._shaderManager.renderinstancedchunk(somevoxelroomgrid[somevoxelroomindex].arrayOfChunkData[c], c, SC_Update._desktopFrame.ShaderResource, somevoxelroomgrid[somevoxelroomindex].voxeltype);

                                        somevoxelroomgrid[somevoxelroomindex].arrayOfChunkData[c] = somevoxelroomgrid[somevoxelroomindex].arrayOfChunkData[c].shaderOfChunk.Renderer(somevoxelroomgrid[somevoxelroomindex].arrayOfChunkData[c], c, null, somevoxelroomgrid[somevoxelroomindex].voxeltype); //SC_Update._desktopFrame.ShaderResource



                                    }
                                }
                            }
                        }
                    }
                }*/







            }
            catch (Exception ex)
            {

            }



            return scgraphicssecpackagemessage.scjittertasks;
        }








        //scmessageobjectjitter[][] _sc_jitter_tasks, Matrix viewMatrix, Matrix projectionMatrix, Vector3 OFFSETPOS, Matrix originRot, Matrix rotatingMatrix, Matrix hmdrotMatrix, Matrix hmd_matrix, Matrix rotatingMatrixForPelvis, Matrix _rightTouchMatrix, Matrix _leftTouchMatrix, Posef handPoseRight, Posef handPoseLeft, Matrix oriProjectionMatrix, Matrix extramatrix
        public unsafe scmessageobjectjitter[][] workOnSomething(scgraphicssecpackage scgraphicssecpackagemessage)
        {


            // , ,,, ,,, , ,, , , 
            scmessageobjectjitter[][] _sc_jitter_tasks = scgraphicssecpackagemessage.scjittertasks;
            Matrix viewMatrix = scgraphicssecpackagemessage.viewMatrix;
            Matrix projectionMatrix = scgraphicssecpackagemessage.projectionMatrix; //_projectionMatrix;
            Matrix originRot = scgraphicssecpackagemessage.originRot; // originRot;
            Matrix rotatingMatrix = scgraphicssecpackagemessage.rotatingMatrix; //rotatingMatrix;
            Matrix hmdrotMatrix = scgraphicssecpackagemessage.hmdmatrixRot; //hmdmatrixRot;
            Matrix hmd_matrix = scgraphicssecpackagemessage.hmd_matrix; //hmd_matrix;
            Matrix rotatingMatrixForPelvis = scgraphicssecpackagemessage.rotatingMatrixForPelvis; //rotatingMatrixForPelvis;
            Matrix _rightTouchMatrix = scgraphicssecpackagemessage.rightTouchMatrix; //_rightTouchMatrix;
            Matrix _leftTouchMatrix = scgraphicssecpackagemessage.leftTouchMatrix; //_leftTouchMatrix;
            Matrix oriProjectionMatrix = scgraphicssecpackagemessage.oriProjectionMatrix; //oriProjectionMatrix;
            Matrix extramatrix = scgraphicssecpackagemessage.someextrapelvismatrix; //someextrapelvismatrix;
            Vector3 OFFSETPOS = scgraphicssecpackagemessage.offsetpos; // OFFSETPOS;
            Posef handPoseRight = scgraphicssecpackagemessage.handPoseRight; //handPoseRight;
            Posef handPoseLeft = scgraphicssecpackagemessage.handPoseLeft; //handPoseLeft;



            //viewMatrix_ = viewMatrix;




            //oculuscontrolsNRecordSoundNMousePointer();












            try
            {















                /*
                if (_some_frame_counter_grab_right_hand[0][0][0] > 1)
                {
                    Vector3 current_handposR = new Vector3(_player_rght_hnd[0][0]._arrayOfInstances[0].current_pos.M41, _player_rght_hnd[0][0]._arrayOfInstances[0].current_pos.M42, _player_rght_hnd[0][0]._arrayOfInstances[0].current_pos.M43);
                    var centerPosRighthandposR = new Vector3(final_hand_pos_right_locked.M41, final_hand_pos_right_locked.M42, final_hand_pos_right_locked.M43);
                    Quaternion.RotationMatrix(ref final_hand_pos_right_locked, out _rightTouchQuat);
                    var rayDirFront = sc_maths._getDirection(Vector3.ForwardRH, _rightTouchQuat);
                    someRay = new Ray(centerPosRighthandposR, rayDirFront);


                    if ((SCCoreSystems.sc_console.SC_console_directx.BodyTag)body.Tag == SCCoreSystems.sc_console.SC_console_directx.BodyTag.physicsInstancedScreen)
                    {
                        Quaternion _quat_screen000;
                        Matrix mater = _world_screen_list[0][0]._arrayOfInstances[0].current_pos;
                        Quaternion.RotationMatrix(ref mater, out _quat_screen000);
                        var screenNormal = sc_maths._getDirection(Vector3.ForwardRH, _quat_screen000);
                        screenNormal.Normalize();

                        var planer = new Plane(new Vector3(mater.M41, mater.M42, mater.M43), screenNormal);
                        intersecter = someRay.Intersects(ref planer, out intersectPointRight);

                        var handToScreenNormalDistance = sc_maths.sc_check_distance_node_3d(current_handposR, intersectPointRight, 2, 2, 2, 2, 2, 2, 2, 2, 2);

                        if (handToScreenNormalDistance < 0.25f && intersectPointRight != Vector3.Zero)
                        {
                            MainWindow.MessageBox((IntPtr)0, "" + "resulter", "sc core systems Error", 0);


                            if (buttonPressedOculusTouchRight == 1) // grabObject
                            {
                                Quaternion.RotationMatrix(ref WorldMatrix, out quaterr);

                                var centerPosRight = new SharpDX.Vector3(current_handposR.X, current_handposR.Y, current_handposR.Z);    //Point3D                                                                                                                            //var rayoriginLeft = centerPosLeft;
                                //var rayDirForward = sc_maths._getDirection(SharpDX.Vector3.ForwardRH, quaterr);
                                var _ray = new SharpDX.Ray(centerPosRight, rayDirFront);


                                JVector ray = new JVector(_ray.Direction.X, _ray.Direction.Y, _ray.Direction.Z);
                                //JVector camp = Conversion.ToJitterVector(Camera.Position);
                                ray = JVector.Normalize(ray) * 0.25f;


                                var camp = new JVector(centerPosRight.X, centerPosRight.Y, centerPosRight.Z);

                                bool resulter = _jitter_world.CollisionSystem.Raycast(camp, ray, RaycastCallback, out grabBody, out hitNormal, out fraction);

                                if (resulter)
                                {
                                    MainWindow.MessageBox((IntPtr)0, "" + "resulter", "sc core systems Error", 0);
                                    var hitPoint = camp + fraction * ray;

                                    if (_distanceConstraintRight != null)
                                    {
                                        _jitter_world.RemoveConstraint(_distanceConstraintRight);
                                    }


                                    JVector lanchor = new JVector(current_handposR.X, current_handposR.Y, current_handposR.Z) - grabBody.Position; //hitPoint
                                    lanchor = JVector.Transform(lanchor, JMatrix.Transpose(grabBody.Orientation));

                                    _distanceConstraintRight = new PointPointDistance(_player_rght_hnd[0][0]._arrayOfInstances[0].transform.Component.rigidbody, grabBody, camp, hitPoint);

                                    _distanceConstraintRight.Softness = 0.0001f;
                                    _distanceConstraintRight.BiasFactor = 0.1f;
                                    _distanceConstraintRight.Distance = 0.001f;

                                    _jitter_world.AddConstraint(_distanceConstraintRight);

                                    _lastFraction = fraction;
                                    _lastRigidGrab = grabBody;
                                    _some_frame_counter_grab_right_hand[0][0][0] = 0;
                                    _some_frame_counter_grab_right_hand_swtch[0][0][0] = 1;
                                }
                                else
                                {

                                }
                            }
                        }
                        else
                        {

                        }
                    }
                    else
                    {
                       bool _boundingBoxer = _jitter_world.CollisionSystem.CheckBoundingBoxes(body, _player_rght_hnd[0][0]._arrayOfInstances[0].transform.Component.rigidbody);

                        if (_boundingBoxer)
                        {
                            if (_distanceConstraintRight != null)
                            {
                                _jitter_world.RemoveConstraint(_distanceConstraintRight);
                            }

                            var centerPosRight = new JVector(current_handposR.X, current_handposR.Y, current_handposR.Z);
                            JVector lanchor = new JVector(current_handposR.X, current_handposR.Y, current_handposR.Z) - grabBody.Position; //hitPoint
                            lanchor = JVector.Transform(lanchor, JMatrix.Transpose(grabBody.Orientation));

                            _distanceConstraintRight = new PointPointDistance(_player_rght_hnd[0][0]._arrayOfInstances[0].transform.Component.rigidbody, grabBody, centerPosRight, lanchor);

                            _distanceConstraintRight.Softness = 0.0001f;
                            _distanceConstraintRight.BiasFactor = 0.1f;
                            _distanceConstraintRight.Distance = 0.001f;

                            _jitter_world.AddConstraint(_distanceConstraintRight);

                            _lastFraction = fraction;
                            _lastRigidGrab = grabBody;
                            _some_frame_counter_grab_right_hand[0][0][0] = 0;
                            _some_frame_counter_grab_right_hand_swtch[0][0][0] = 1;

                        }
                        else
                        {

                        }
                    }

                }

                if (_some_frame_counter_grab_right_hand_swtch[0][0][0] == 0) //keep counting up when switch is at 0
                {
                    _some_frame_counter_grab_right_hand[0][0][0]++;
                }
                else
                {
                    if (buttonPressedOculusTouchRight == 2) // release grabbed object
                    {
                        if (_distanceConstraintRight != null)
                        {
                            _jitter_world.RemoveConstraint(_distanceConstraintRight);
                        }
                        grabBody = null;
                        _lastRigidGrab = null;
                        _some_frame_counter_grab_right_hand_swtch[0][0][0] = 0;
                    }
                }*/




                /*Vector3 current_handposR = new Vector3(_player_rght_hnd[0][0]._arrayOfInstances[0].current_pos.M41, _player_rght_hnd[0][0]._arrayOfInstances[0].current_pos.M42, _player_rght_hnd[0][0]._arrayOfInstances[0].current_pos.M43);
                var centerPosRighthandposR = new Vector3(final_hand_pos_right_locked.M41, final_hand_pos_right_locked.M42, final_hand_pos_right_locked.M43);
                Quaternion.RotationMatrix(ref final_hand_pos_right_locked, out _rightTouchQuat);
                var rayDirFront = sc_maths._getDirection(Vector3.ForwardRH, _rightTouchQuat);
                someRay = new Ray(centerPosRighthandposR, rayDirFront);

                Quaternion _quat_screen000;
                Matrix mater = worldMatrix_instances_screens[0][0][0];
                Quaternion.RotationMatrix(ref mater, out _quat_screen000);
                var screenNormal = sc_maths._getDirection(Vector3.ForwardRH, _quat_screen000);
                screenNormal.Normalize();

                var planer = new Plane(new Vector3(mater.M41, mater.M42, mater.M43), screenNormal);
                intersecter = someRay.Intersects(ref planer, out intersectPointRight);


                var handToScreenNormalDistance = sc_maths.sc_check_distance_node_3d(current_handposR, intersectPointRight, 2, 2, 2, 2, 2, 2, 2, 2, 2);


                if (handToScreenNormalDistance < 0.1f && intersectPointRight != Vector3.Zero)
                {

                }*/





                /*Vector3 current_handposR = new Vector3(_player_rght_hnd[0][0]._arrayOfInstances[0].current_pos.M41, _player_rght_hnd[0][0]._arrayOfInstances[0].current_pos.M42, _player_rght_hnd[0][0]._arrayOfInstances[0].current_pos.M43);

                Quaternion quater;
                Quaternion.RotationMatrix(ref WorldMatrix, out quater);

                var centerPosRight = new SharpDX.Vector3(current_handposR.X, current_handposR.Y, current_handposR.Z);    //Point3D                                                                                                                            //var rayoriginLeft = centerPosLeft;
                var rayDirForward = sc_maths._getDirection(SharpDX.Vector3.ForwardRH, quater);
                var _ray = new SharpDX.Ray(centerPosRight, rayDirForward);

                float fraction;

                JVector ray = new JVector(_ray.Direction.X, _ray.Direction.Y, _ray.Direction.Z);
                //JVector camp = Conversion.ToJitterVector(Camera.Position);
                ray = JVector.Normalize(ray) * 0.25f;

                RigidBody grabBody;
                JVector hitNormal;
                var camp = new JVector(centerPosRight.X, centerPosRight.Y, centerPosRight.Z);

                bool resulter = _jitter_world.CollisionSystem.Raycast(camp, ray, RaycastCallback, out grabBody, out hitNormal, out fraction);

                if (buttonPressedOculusTouchRight == 1)
                {
                    if (resulter)
                    {
                        var hitPoint = camp + fraction * ray;

                        if (_distanceConstraintRight != null)
                        {
                            _jitter_world.RemoveConstraint(_distanceConstraintRight);
                        }


                        JVector lanchor = new JVector(current_handposR.X, current_handposR.Y, current_handposR.Z) - grabBody.Position; //hitPoint
                        lanchor = JVector.Transform(lanchor, JMatrix.Transpose(grabBody.Orientation));

                        _distanceConstraintRight = new PointPointDistance(_player_rght_hnd[0][0]._arrayOfInstances[0].transform.Component.rigidbody, grabBody, camp, hitPoint);

                        _distanceConstraintRight.Softness = 0.0001f;
                        _distanceConstraintRight.BiasFactor = 0.1f;
                        _distanceConstraintRight.Distance = 0.001f;

                        _jitter_world.AddConstraint(_distanceConstraintRight);

                        _lastFraction = fraction;
                        _lastRigidGrab = grabBody;
                        _hasGrabbed = true;
                    }
                }

                if (_hasGrabbed)
                {

                }

                if (buttonPressedOculusTouchRight == 2)
                {
                    if (_distanceConstraintRight != null)
                    {
                        _jitter_world.RemoveConstraint(_distanceConstraintRight);
                    }
                    grabBody = null;
                    _lastRigidGrab = null;
                    _hasGrabbed = false;
                }*/



















                //Console.Title = MainWindow._MainWindow_name + " ### " + " Made by ninekorn" + " ### " + " => " + "disabled cubes: " + _inactive_counter_cubes + " disabled voxels: " + _inactive_counter_voxels;

                //_SC_modL_lft_hnd_BUFFER[0].lightPosition = lightpos;
                //_SC_modL_lft_hnd_BUFFER[0].lightDirection = dirLight;


                //_SC_modL_lft_shldr_BUFFER[0].lightPosition = lightpos;
                //_SC_modL_lft_shldr_BUFFER[0].lightDirection = dirLight;

                /*_SC_modL_lft_elbow_target_BUFFER[0].lightPosition = lightpos;
                _SC_modL_lft_elbow_target_BUFFER[0].lightDirection = dirLight;
                _SC_modL_lft_elbow_target_two_BUFFER[0].lightPosition = lightpos;
                _SC_modL_lft_elbow_target_two_BUFFER[0].lightDirection = dirLight;
                _SC_modL_lft_upper_arm_BUFFER[0].lightPosition = lightpos;
                _SC_modL_lft_upper_arm_BUFFER[0].lightDirection = dirLight;
                _SC_modL_lft_lower_arm_BUFFER[0].lightPosition = lightpos;
                _SC_modL_lft_lower_arm_BUFFER[0].lightDirection = dirLight;*/


                hmdmatrixRot_ = hmdrotMatrix;

                OriginRot = originRot;
                RotatingMatrix = rotatingMatrix;
                RotatingMatrixForPelvis = rotatingMatrixForPelvis;

                /*//TERRAIN SINGLEOBJECT
                _terrain[0][0].Render(SC_console_directx.D3D.device.ImmediateContext);
                SC_Update._shaderManager.RenderInstancedObject(SC_console_directx.D3D.device.ImmediateContext, _terrain[0][0].IndexCount, _terrain[0][0].InstanceCount, _terrain[0][0]._POSITION, viewMatrix, projectionMatrix, _basicTexture.TextureResource, _DLightBuffer_cube, _terrain[0][0]);
                //END OF

                //SPECTRUM SINGLEOBJECT
                _world_spectrum_list[0][0].Render(SC_console_directx.D3D.device.ImmediateContext);
                SC_Update._shaderManager.RenderInstancedObjectSpectrum(SC_console_directx.D3D.device.ImmediateContext, _world_spectrum_list[0][0].IndexCount, _world_spectrum_list[0][0].InstanceCount, _world_spectrum_list[0][0]._POSITION, viewMatrix, projectionMatrix, _basicTexture.TextureResource, _DLightBuffer_spectrum, _world_spectrum_list[0][0]);
                //END OF

                //TERRAIN SINGLEOBJECT
                _floor[0][0].Render(SC_console_directx.D3D.device.ImmediateContext);
                SC_Update._shaderManager.RenderInstancedObject(SC_console_directx.D3D.device.ImmediateContext, _floor[0][0].IndexCount, _floor[0][0].InstanceCount, _floor[0][0]._POSITION, viewMatrix, projectionMatrix, _basicTexture.TextureResource, _DLightBuffer_cube, _floor[0][0]);
                //END OF

                //PHYSICS GRID
                _world_grid_list[0][0].Render(SC_console_directx.D3D.device.ImmediateContext);
                SC_Update._shaderManager.RenderInstancedGrid(SC_console_directx.D3D.device.ImmediateContext, _world_grid_list[0][0].IndexCount, _world_grid_list[0][0].InstanceCount, _world_grid_list[0][0]._POSITION, viewMatrix, projectionMatrix, SC_Update._desktopFrame.ShaderResource, _DLightBuffer_grid, _world_grid_list[0][0]); // oculusRiftDir
                */


                /*float timeSinceStart = (float)(DateTime.Now - SC_Update.startTime).TotalSeconds;
                Matrix world = Matrix.Scaling(1.0f) * Matrix.RotationX(timeSinceStart * disco_sphere_rot_speed) * Matrix.RotationY(timeSinceStart * 2 * disco_sphere_rot_speed) * Matrix.RotationZ(timeSinceStart * 3 * disco_sphere_rot_speed);
                _icoSphere._TEMPPOSITION = world;// _icoSphere._TEMPPOSITION;
                _icoSphere._TEMPPOSITION.M42 = 5;
                _icoSphere.Render(SC_console_directx.D3D.device.ImmediateContext);
                SC_Update._shaderManager.RenderIcoShader(SC_console_directx.D3D.device.ImmediateContext, _icoSphere.IndexCount, _icoSphere._TEMPPOSITION, viewMatrix, projectionMatrix, _icoVertexCount, 1);
                */
















                /*
                // Turn off the Z buffer to begin all 2D rendering.
                SC_console_directx.D3D.TurnZBufferOff();

                // Turn on the alpha blending before rendering the text.
                SC_console_directx.D3D.TurnOnAlphaBlending();

                // Render the text user interface elements.
                //if (!Text.Render(D3D.DeviceContext, FontShader, worldMatrix, orthoD3DMatrix))
                //    return false;

                // Turn off alpha blending after rendering the text.
                SC_console_directx.D3D.TurnOffAlphaBlending();

                // Turn the Z buffer back on now that all 2D rendering has completed.
                SC_console_directx.D3D.TurnZBufferOn();*/






















                //TO READD FOR SOME containmentgrid SCENE LOGIC
                //TO READD FOR SOME containmentgrid SCENE LOGIC
                //TO READD FOR SOME containmentgrid SCENE LOGIC
                /*Quaternion quater;

                Matrix Matter = ikarmvoxel[0]._player_rght_hnd[0][0]._arrayOfInstances[0]._LASTPOSITION;// _world_screen_list[0]._arrayOfInstances[0].current_pos;
                SharpDX.Quaternion.RotationMatrix(ref Matter, out quater);
                var matrixRight = ikarmvoxel[0]._player_rght_hnd[0][0]._arrayOfInstances[0]._LASTPOSITION;
                Vector3 dirTo = sc_maths._getDirection(Vector3.ForwardRH, quater);
                Vector3 tempvec0 = new Vector3(matrixRight.M41, matrixRight.M42, matrixRight.M43);
                tempvec0 = tempvec0 + (dirTo * ikarmvoxel[0]._player_rght_hnd[0][0]._total_torso_height * 3.5f);
                matrixRight.M41 = tempvec0.X;
                matrixRight.M42 = tempvec0.Y;
                matrixRight.M43 = tempvec0.Z;

                Matter = ikarmvoxel[0]._player_rght_hnd[0][0]._arrayOfInstances[0]._LASTPOSITION;// _world_screen_list[0]._arrayOfInstances[0].current_pos;
                SharpDX.Quaternion.RotationMatrix(ref Matter, out quater);
                var matrixLeft = ikarmvoxel[0]._player_rght_hnd[0][0]._arrayOfInstances[0]._LASTPOSITION;
                dirTo = sc_maths._getDirection(Vector3.ForwardRH, quater);
                Vector3 tempvec1 = new Vector3(matrixLeft.M41, matrixLeft.M42, matrixLeft.M43);
                tempvec1 = tempvec1 + (dirTo * ikarmvoxel[0]._player_rght_hnd[0][0]._total_torso_height * 3.5f);
                matrixLeft.M41 = tempvec1.X;
                matrixLeft.M42 = tempvec1.Y;
                matrixLeft.M43 = tempvec1.Z;

                SharpDX.Quaternion.RotationMatrix(ref matrixLeft, out quater);*/

                /*worldMatrix_instances_containment_grid_RH[0][0][0] = matrixRight;
                _world_containment_grid_list_RH[0][0]._arrayOfInstances[0].current_pos = matrixRight;

                worldMatrix_instances_containment_grid_LH[0][0][0] = matrixLeft;
                _world_containment_grid_list_LH[0][0]._arrayOfInstances[0].current_pos = matrixLeft;*/

                //TO READD FOR SOME containmentgrid SCENE LOGIC
                //TO READD FOR SOME containmentgrid SCENE LOGIC
                //TO READD FOR SOME containmentgrid SCENE LOGIC


















                /*
                //CONTAINMENT BOX TEST
                var _WorldMatrixContainer = _world_screen_list[0][0]._arrayOfInstances[0].current_pos;
                //_WorldMatrixContainer.M41 = 0.5f;
                //_WorldMatrixContainer.M42 = 0.5f;
                //_WorldMatrixContainer.M43 = 1;
                var positionOfDContainer = new Vector3(_WorldMatrixContainer.M41, _WorldMatrixContainer.M42, _WorldMatrixContainer.M43);

                float posXDTouchContainer = (float)(Math.Round(matrixLeft.M41, 1));// * 0.01f;
                float posYDTouchContainer = (float)(Math.Round(matrixLeft.M42, 1));// * 0.01f;
                float posZDTouchContainer = (float)(Math.Round(matrixLeft.M43, 1));// * 0.01f;

                float posXOfDContainer = (float)(Math.Round(positionOfDContainer.X, 1));// * 0.01f;
                float posYOfDContainer = (float)(Math.Round(positionOfDContainer.Y, 1));// * 0.01f;
                float posZOfDContainer = (float)(Math.Round(positionOfDContainer.Z, 1));// * 0.01f;

                float xxx;
                float yyy;
                float zzz;

                for (int x = -ChunkWidth_L; x <= ChunkWidth_R; x++)
                {
                    for (int y = -ChunkHeight_L; y <= ChunkHeight_R; y++)
                    {
                        for (int z = -ChunkDepth_L; z <= ChunkDepth_R; z++)
                        {
                            float posX = (x);
                            float posY = (y);
                            float posZ = (z);

                            var xxi = x;
                            var yyi = y;
                            var zzi = z;

                            if (xxi < 0)
                            {
                                xxi *= -1;
                                xxi = (ChunkWidth_R) + xxi;
                            }
                            if (yyi < 0)
                            {
                                yyi *= -1;
                                yyi = (ChunkHeight_R) + yyi;
                            }
                            if (zzi < 0)
                            {
                                zzi *= -1;
                                zzi = (ChunkDepth_R) + zzi;
                            }

                            int _index = xxi + (ChunkWidth_L + ChunkWidth_R + 1) * (yyi + (ChunkHeight_L + ChunkHeight_R + 1) * zzi);


                            //xxx = (xu * 0.1f);
                            //yyy = (yu * 0.1f);
                            //zzz = (zu * 0.1f);
                            xxx = (float)(Math.Round((xxi * 0.1f), 1));
                            yyy = (float)(Math.Round((yyi * 0.1f), 1));
                            zzz = (float)(Math.Round((zzi * 0.1f), 1));


                            //float[] array = getDirection(quater, xxx, yyy, zzz);
                            //arrayX[xii + (_widther + _widther) * (yii + (_widther + _widther) * zii)] = (float)(Math.Round(array[0], 1));
                            //arrayY[xii + (_heighter + _heighter) * (yii + (_heighter + _heighter) * zii)] =  (float)(Math.Round(array[1], 1));
                            //arrayZ[xii + (_depther + _depther) * (yii + (_depther + _depther) * zii)] =  (float)(Math.Round(array[2], 1));

                            //SharpDX.Matrix.Translation(xxx, yyy, zzz, out translationMatrix);
                            var _WorldMatrix = WorldMatrix;

                            _WorldMatrix.M41 = xxx;
                            _WorldMatrix.M42 = yyy;
                            _WorldMatrix.M43 = zzz;

                            //SharpDX.Matrix.Multiply(ref _WorldMatrix, ref translationMatrix, out _WorldMatrix);
                            SharpDX.Matrix.Multiply(ref _WorldMatrix, ref matrixLeft, out WorldMatrix);

                            //arrayX[xii + (_widther + _widther) * (yii + (_widther + _widther) * zii)] = _WorldMatrix.M41;
                            //arrayY[xii + (_heighter + _heighter) * (yii + (_heighter + _heighter) * zii)] = _WorldMatrix.M42;
                            //arrayZ[xii + (_depther + _depther) * (yii + (_depther + _depther) * zii)] = _WorldMatrix.M43;

                            arrayX[xxi + (ChunkWidth_L + ChunkWidth_R + 1) * (yyi + (ChunkHeight_L + ChunkHeight_R + 1) * zzi)] = (float)(Math.Round(WorldMatrix.M41, 1));
                            arrayY[xxi + (ChunkWidth_L + ChunkWidth_R + 1) * (yyi + (ChunkHeight_L + ChunkHeight_R + 1) * zzi)] = (float)(Math.Round(WorldMatrix.M42, 1));
                            arrayZ[xxi + (ChunkWidth_L + ChunkWidth_R + 1) * (yyi + (ChunkHeight_L + ChunkHeight_R + 1) * zzi)] = (float)(Math.Round(WorldMatrix.M43, 1));

                        }
                    }
                }*/








                /*
                //OCULUS RIFT HEADSET OFFSET CALCULATIONS SO THAT THE HEAD MESH COVERS THE HEADSET IN FIRST PERSON VIEW
                //OCULUS RIFT HEADSET OFFSET CALCULATIONS SO THAT THE HEAD MESH COVERS THE HEADSET IN FIRST PERSON VIEW
                //OCULUS RIFT HEADSET OFFSET CALCULATIONS SO THAT THE HEAD MESH COVERS THE HEADSET IN FIRST PERSON VIEW
                Matrix sometempmat = ikvoxelbody[0]._player_head[0][0]._arrayOfInstances[0].current_pos;
                Quaternion somedirquat1;
                Quaternion.RotationMatrix(ref sometempmat, out somedirquat1);
                var dirikvoxelbodyInstanceRight0 = -sc_maths._newgetdirleft(somedirquat1);
                var dirikvoxelbodyInstanceUp0 = sc_maths._newgetdirup(somedirquat1);
                var dirikvoxelbodyInstanceForward0 = sc_maths._newgetdirforward(somedirquat1);


                Vector3 tempOffset = OFFSETPOS;

                //int usethirdpersonview = 1;

                if (MainWindow.usethirdpersonview == 0)
                {
                    tempOffset.X = SC_Update.viewPosition.X;
                    tempOffset.Y = SC_Update.viewPosition.Y;
                    tempOffset.Z = SC_Update.viewPosition.Z;

                    tempOffset.Y = tempOffset.Y - ikvoxelbody[0]._player_head[0][0]._arrayOfInstances[0]._TEMPPIVOT.M42;
                    tempOffset = tempOffset + (dirikvoxelbodyInstanceUp0 * -0.125f);
                }
                else if (MainWindow.usethirdpersonview == 1)
                {

                    //OFFSETPOS.X = SC_Update.viewPosition.X;
                    //OFFSETPOS.Y = SC_Update.viewPosition.Y;
                    //OFFSETPOS.Z = SC_Update.viewPosition.Z;

                    //OFFSETPOS = OFFSETPOS + (dirikvoxelbodyInstanceUp0 * -0.125f);
                    //SC_Update.viewPosition = SC_Update.viewPosition + (dirikvoxelbodyInstanceRight0 * -1.5f);





                    //tempmatter = hmd_matrix * rotatingMatrixForPelvis * hmdmatrixRot;
                    Quaternion quatt;
                    Quaternion.RotationMatrix(ref SC_Update.tempmatter, out quatt);
                    // quatt.Invert();

                    //THIRD PERSON VR VIEW. COMMENT THIS PART OUT TO HAVE FIRST PERSON VIEW
                    Vector3 forwardOVR = sc_maths._getDirection(Vector3.ForwardRH, quatt);
                    Vector3 upOVR = sc_maths._getDirection(Vector3.Up, quatt);
                    Vector3 rightOVR = sc_maths._getDirection(Vector3.Right, quatt);
                    upOVR.Normalize();
                    rightOVR.Normalize();
                    forwardOVR.Normalize();

                    forwardOVR *= -0.5f; // -1.0f

                    Vector3 thirdpersonview = OFFSETPOS + (-forwardOVR * 2.0f); //1.5f // + (upOVR * 0.25f)

                    OFFSETPOS.X = thirdpersonview.X;// SC_Update.viewPosition.X;
                    OFFSETPOS.Y = thirdpersonview.Y;// SC_Update.viewPosition.Y;
                    OFFSETPOS.Z = thirdpersonview.Z;// SC_Update.viewPosition.Z;
                }*/



                //OCULUS RIFT HEADSET OFFSET CALCULATIONS SO THAT THE HEAD MESH COVERS THE HEADSET IN FIRST PERSON VIEW
                //OCULUS RIFT HEADSET OFFSET CALCULATIONS SO THAT THE HEAD MESH COVERS THE HEADSET IN FIRST PERSON VIEW
                //OCULUS RIFT HEADSET OFFSET CALCULATIONS SO THAT THE HEAD MESH COVERS THE HEADSET IN FIRST PERSON VIEW





                //OFFSETPOS = OFFSETPOS + (dirikvoxelbodyInstanceUp0 * 0.0275f);
                //OFFSETPOS = OFFSETPOS + (dirikvoxelbodyInstanceRight0 * 0.1f);
                //OFFSETPOS = SC_Update.viewPosition + (dirikvoxelbodyInstanceUp0 * 0.0275f);// + new Vector3(0,-0.025f,-0.045f);// + new Vector3(ikvoxelbody[0]._player_head[0][0]._arrayOfInstances[0].current_pos.M41, ikvoxelbody[0]._player_head[0][0]._arrayOfInstances[0].current_pos.M42, ikvoxelbody[0]._player_head[0][0]._arrayOfInstances[0].current_pos.M43);
                //OFFSETPOS = OFFSETPOS + (dirikvoxelbodyInstanceForward0 * -0.0475f);
                //OFFSETPOS = OFFSETPOS + (dirikvoxelbodyInstanceRight0 * 0.1f);

                finalRotationMatrix = originRot * rotatingMatrix * rotatingMatrixForPelvis * hmdrotMatrix;


                /*for (int xxx = -somechunkpriminstancesikvoxelbodywidthL; xxx <= somechunkpriminstancesikvoxelbodywidthR; xxx++)
                {
                    for (int yyy = -somechunkpriminstancesikvoxelbodyheightL; yyy <= somechunkpriminstancesikvoxelbodyheightR; yyy++)
                    {
                        for (int zzz = -somechunkpriminstancesikvoxelbodydepthL; zzz <= somechunkpriminstancesikvoxelbodydepthR; zzz++)
                        {
                            float posX = (xxx);
                            float posY = (yyy);
                            float posZ = (zzz);

                            var xxi = xxx;
                            var yyi = yyy;
                            var zzi = zzz;

                            if (xxi < 0)
                            {
                                xxi *= -1;
                                xxi = (somechunkpriminstancesikvoxelbodywidthR) + xxi;
                            }
                            if (yyi < 0)
                            {
                                yyi *= -1;
                                yyi = (somechunkpriminstancesikvoxelbodyheightR) + yyi;
                            }
                            if (zzi < 0)
                            {
                                zzi *= -1;
                                zzi = (somechunkpriminstancesikvoxelbodydepthR) + zzi;
                            }

                            int somechunkpriminstanceikvoxelbodyindex = xxi + (somechunkpriminstancesikvoxelbodywidthL + somechunkpriminstancesikvoxelbodywidthR ) * (yyi + (somechunkpriminstancesikvoxelbodyheightL + somechunkpriminstancesikvoxelbodyheightR ) * zzi);

                            _sc_jitter_tasks = ikvoxelbody[somechunkpriminstanceikvoxelbodyindex].setikbodytargetnlimbspositionsNrotations(_sc_jitter_tasks, viewMatrix, projectionMatrix, OFFSETPOS, originRot, rotatingMatrix, hmdrotMatrix, hmd_matrix, ikvoxelbody[somechunkpriminstanceikvoxelbodyindex]._player_pelvis[0][0]._arrayOfInstances[0].current_pos, _rightTouchMatrix, _leftTouchMatrix, handPoseRight, handPoseLeft, oriProjectionMatrix, ikvoxelbody[somechunkpriminstanceikvoxelbodyindex]._player_torso[0][0], lightpos, dirLight, finalRotationMatrix, ikvoxelbody[somechunkpriminstanceikvoxelbodyindex]._player_pelvis[0][0], hmd_matrix_current, extramatrix, hmdmatrixcurrentforpelvis);
                            _sc_jitter_tasks = ikvoxelbody[somechunkpriminstanceikvoxelbodyindex].ikbodyrender(_sc_jitter_tasks, viewMatrix, projectionMatrix, OFFSETPOS, originRot, rotatingMatrix, hmdrotMatrix, hmd_matrix, rotatingMatrixForPelvis, _rightTouchMatrix, _leftTouchMatrix, handPoseRight, handPoseLeft, oriProjectionMatrix);

                        }
                    }
                }*/







                //IK RIGHTHANDGRAB OFFSET CALCULATIONS SO THAT THE HEAD MESH COVERS THE HEADSET IN FIRST PERSON VIEW
                //IK RIGHTHANDGRAB OFFSET CALCULATIONS SO THAT THE HEAD MESH COVERS THE HEADSET IN FIRST PERSON VIEW
                //IK RIGHTHANDGRAB OFFSET CALCULATIONS SO THAT THE HEAD MESH COVERS THE HEADSET IN FIRST PERSON VIEW
                /*sometempmat = _rightTouchMatrix;// ikarmvoxel[0]._player_rght_hnd[0][0]._arrayOfInstances[0].current_pos;
                Quaternion.RotationMatrix(ref sometempmat, out somedirquat1);

                dirikvoxelbodyInstanceRight0 = -sc_maths._newgetdirleft(somedirquat1);
                dirikvoxelbodyInstanceUp0 = sc_maths._newgetdirup(somedirquat1);
                dirikvoxelbodyInstanceForward0 = sc_maths._newgetdirforward(somedirquat1);


                //Vector3 somevec0 = new Vector3(sometempmat.M41, sometempmat.M42, sometempmat.M43);
                Vector3 tempvector = Vector3.Zero;
                //tempvector.X = SC_Update.viewPosition.X;
                //tempvector.Y = SC_Update.viewPosition.Y;
                //tempvector.Z = SC_Update.viewPosition.Z;

                //tempvector.Y = tempvector.Y - ikarmvoxel[0]._player_rght_hnd[0][0]._arrayOfInstances[0].current_pos.M42;
                tempvector =  (dirikvoxelbodyInstanceForward0 * -0.0125f);
                //IK RIGHTHANDGRAB OFFSET CALCULATIONS SO THAT THE HEAD MESH COVERS THE HEADSET IN FIRST PERSON VIEW
                //IK RIGHTHANDGRAB OFFSET CALCULATIONS SO THAT THE HEAD MESH COVERS THE HEADSET IN FIRST PERSON VIEW
                //IK RIGHTHANDGRAB OFFSET CALCULATIONS SO THAT THE HEAD MESH COVERS THE HEADSET IN FIRST PERSON VIEW



                //directionvectoroffsets[0] = new Vector3(0, 0, 0);
                //directionvectoroffsets[1] = new Vector3(0, 0, 0);
                //directionvectoroffsets[2] = new Vector3(0, 0, 0);
                directionvectoroffsets[3] = tempvector;*/
                //directionvectoroffsets[3] = new Vector3(0, 0, 0);


                /*for (int xxx = -somechunkpriminstancesikarmvoxelwidthL; xxx <= somechunkpriminstancesikarmvoxelwidthR; xxx++)
                {
                    for (int yyy = -somechunkpriminstancesikarmvoxelheightL; yyy <= somechunkpriminstancesikarmvoxelheightR; yyy++)
                    {
                        for (int zzz = -somechunkpriminstancesikarmvoxeldepthL; zzz <= somechunkpriminstancesikarmvoxeldepthR; zzz++)
                        {
                            float posX = (xxx);
                            float posY = (yyy);
                            float posZ = (zzz);

                            var xxi = xxx;
                            var yyi = yyy;
                            var zzi = zzz;

                            if (xxi < 0)
                            {
                                xxi *= -1;
                                xxi = (somechunkpriminstancesikarmvoxelwidthR) + xxi;
                            }
                            if (yyi < 0)
                            {
                                yyi *= -1;
                                yyi = (somechunkpriminstancesikarmvoxelheightR) + yyi;
                            }
                            if (zzi < 0)
                            {
                                zzi *= -1;
                                zzi = (somechunkpriminstancesikarmvoxeldepthR) + zzi;
                            }

                            int somechunkpriminstanceikarmvoxelindex = xxi + (somechunkpriminstancesikarmvoxelwidthL + somechunkpriminstancesikarmvoxelwidthR) * (yyi + (somechunkpriminstancesikarmvoxelheightL + somechunkpriminstancesikarmvoxelheightR ) * zzi);


                            var sometest = ikarmvoxel[somechunkpriminstanceikarmvoxelindex];


                            _sc_jitter_tasks = ikarmvoxel[somechunkpriminstanceikarmvoxelindex].setiktargetnlimbspositionsNrotations(_sc_jitter_tasks, viewMatrix, projectionMatrix, OFFSETPOS, originRot, rotatingMatrix, hmdrotMatrix, hmd_matrix, ikvoxelbody[0]._player_pelvis[0][0]._arrayOfInstances[0].current_pos, _rightTouchMatrix, _leftTouchMatrix, handPoseRight, handPoseLeft, oriProjectionMatrix, ikvoxelbody[0]._player_torso[0][0], lightpos, dirLight, finalRotationMatrix, ikvoxelbody[0]._player_pelvis[0][0], ikvoxelbody[0], somechunkpriminstanceikarmvoxelindex, rotatingMatrixForPelvis, extramatrix, directionvectoroffsets);
                            _sc_jitter_tasks = ikarmvoxel[somechunkpriminstanceikarmvoxelindex].ikarmrender(_sc_jitter_tasks, viewMatrix, projectionMatrix, OFFSETPOS, originRot, rotatingMatrix, hmdrotMatrix, hmd_matrix, rotatingMatrixForPelvis, _rightTouchMatrix, _leftTouchMatrix, handPoseRight, handPoseLeft, oriProjectionMatrix);

                        }
                    }
                }*/














                /*
                _player_r_hand_grab[0][0].Render(SC_console_directx.D3D.device.ImmediateContext);
                SC_Update._shaderManager._rend_torso(SC_console_directx.D3D.device.ImmediateContext, _player_r_hand_grab[0][0].IndexCount, _player_r_hand_grab[0][0].InstanceCount, _player_r_hand_grab[0][0]._POSITION, viewMatrix, projectionMatrix, null, _SC_modL_rght_hnd_BUFFER, _player_r_hand_grab[0][0]);
                */






                /*if (writeProcess == 0)
                {

                    Process[] processlist = Process.GetProcesses();

                    foreach (Process process in processlist)
                    {

                        //Console.WriteLine(process.ProcessName);
                        if (process.ProcessName == "msedge" && process.MainWindowHandle != IntPtr.Zero)
                        {
                            //Console.WriteLine("Process: {0} ID: {1} Window title: {2}", process.ProcessName, process.Id, process.MainWindowTitle);
                            Console.WriteLine("msedge" + " " + process.MainWindowHandle);
                            MSEdgeHandle = process.MainWindowHandle;

                            //MessageBox((IntPtr)0, "ED" + " " + process.MainWindowHandle, "sccoresystems0", 0);

                        }
                    }
                    //WebBrowser youtubePlayer = new WebBrowser();
                    //youtubePlayer.Navigate("http://www.youtube.com/embed/M7lc1UVf-VE");
                    writeProcess = 1;
                }*/


                //Rectangle bonds = new Rectangle();
                //GetWindowRect(handle, bonds);
                //Bitmap bmp = new Bitmap(bonds.Width, bonds.Height);


                /*var detector = new BrowserDetector();
                if (detector.BrowserIsOpen())
                {
                    //MessageBox.Show(this, "Browser Was Detected As Open", "Success", MessageBoxButtons.OK);
                    //MainWindow.MessageBox((IntPtr)0, "Browser opened", "sccoresystems0", 0);
                    Console.WriteLine("Browser opened");
                }
                else
                {
                    //MessageBox.Show(this, "Please Open Browser", "Error", MessageBoxButtons.OK, MessageBoxIcon.Error);
                    //MainWindow.MessageBox((IntPtr)0, "Browser not opened", "sccoresystems0", 0);
                }



                IntPtr hWnd = FindWindowByCaption(IntPtr.Zero, "msedge.exe");

                if (hWnd != IntPtr.Zero)
                {
                    Console.WriteLine(hWnd + "test0");
                    //MainWindow.MessageBox((IntPtr)0, hWnd + "test0", "sccoresystems0", 0);
                }*/



                /*MSEdgeHandle = IntPtr.Zero;
                // Enumerate over windows.
                EnumWindows((handle, param) =>
                {
                    // Get the class name. We are looking for ApplicationFrameWindow.
                    var className = new StringBuilder(256);
                    GetClassName(handle, className, className.Capacity);

                    // Get the window text. We're looking for Microsoft Edge.
                    int windowTextSize = GetWindowTextLength(handle);
                    var windowText = new StringBuilder(windowTextSize + 1);
                    GetWindowText(handle, windowText, windowText.Capacity);

                    // Check if we have a match. If we do, minimize that window.
                    if (windowText.ToString().Contains("Microsoft Edge")) //className.ToString().Contains("ApplicationFrameWindow") &&
                    {
                        MSEdgeHandle = handle;
                        //ShowWindow(handle, SW_SHOWMINIMIZED);
                        //Console.WriteLine("edge is opened");
                        //Rectangle bonds = new Rectangle();
                        //GetWindowRect(handle, bonds);
                        //Console.WriteLine(" h: " + bonds.Height + " w: " + bonds.Width + " edge is opened");
                    }

                    // Return true so that we continue enumerating,
                    // in case there are multiple instances.
                    return true;
                }, IntPtr.Zero);*/



                /*if (SC_Update._desktopFrame._texture2DFinal != null && setArray == 0)
                {
                    arrayOfPixData = new int[SC_Update._desktopFrame._texture2DFinal.Description.Width * SC_Update._desktopFrame._texture2DFinal.Description.Height * 3];
                    setArray = 1;
                }*/


                /*if (MSEdgeHandle != IntPtr.Zero && SC_Update._desktopFrame._texture2DFinal != null)
                {
                    System.Drawing.Rectangle rect = new System.Drawing.Rectangle();

                    // Then we call the GetWindowRect function, passing in a reference to the rect object.
                    GetWindowRect(MSEdgeHandle, ref rect);

                    // And then we get the resulting rectangle. The tricky part here is that this rectangle includes
                    // not only the location of the window, but also the size, but not in the form we're used to.
                    //Console.WriteLine(rect.ToString());

                    /*RECT rct;

                    if (!GetWindowRect(MSEdgeHandle, out rct))
                    {
                        Console.WriteLine("failed to get rect");
                    }
                    //MessageBox.Show(rct.ToString());
                    //Console.WriteLine(rct.ToString() + " edge is opened");

                    //myRect.X = rect.Left;
                    //myRect.Y = rect.Top;
                    //myRect.Width = rect.Right - rect.Left + 1;
                    //myRect.Height = rect.Bottom - rect.Top + 1;

                    //Rectangle bonds = new Rectangle();
                    //GetWindowRect(MSEdgeHandle, bonds);
                    Console.WriteLine(" h: " + rect.Top + " w: " + rect.Left + " edge is opened");
                    //Console.WriteLine(" h: " + myRect.Width + " w: " + myRect.Height + " edge is opened");
                }*/











                /*
                if (Terrain.vertices != null)
                {
                    //Console.WriteLine("test0");
                    //MainWindow.MessageBox((IntPtr)0, "!null","msg", 0);

                    if (Terrain.vertices.Length > 0 && SC_Update._desktopDupe.arrayOfPixData.Length > 0)
                    {
                        if (SC_Update._desktopFrame._texture2DFinal != null && SC_Update._desktopDupe != null)
                        {
                            //SC_Update._desktopFrame.
                            //var HeightMapSobel = new List<DHeightMapType>(); //SC_Update._desktopFrame._texture2DFinal.Description.Width * SC_Update._desktopFrame._texture2DFinal.Description.Height

                            //var dataBox = SC_console_directx.D3D.device.ImmediateContext.MapSubresource(SC_Update._desktopFrame._texture2DFinal, 0, SharpDX.Direct3D11.MapMode.Read, SharpDX.Direct3D11.MapFlags.None);
                            //IntPtr interptr = dataBox.DataPointer;
                            //SC_console_directx.D3D.device.ImmediateContext.UnmapSubresource(SC_Update._desktopFrame._texture2DFinal, 0);






                            /*for (var j = 0; j < SC_Update._desktopFrame._texture2DFinal.Description.Height; j++)
                            {
                                for (var i = 0; i < SC_Update._desktopFrame._texture2DFinal.Description.Width; i++)
                                {
                                    var bytePoser = ((j * SC_Update._desktopFrame._texture2DFinal.Description.Width) + i) * 3;

                                    /*HeightMapSobel.Add(new DHeightMapType()
                                    {
                                        x = i,
                                        y = SC_Update._desktopDupe._textureByteArray[bytePoser],// image.GetPixel(i, j).R,
                                        z = j
                                    });

                                    arrayOfPixData[bytePoser + 0] = i;
                                    arrayOfPixData[bytePoser + 1] = SC_Update._desktopDupe._textureByteArray[bytePoser];
                                    arrayOfPixData[bytePoser + 2] = j;
                                }
                            }*/




                //int memoryBitmapStride = SC_Update._desktopFrame._texture2DFinal.Description.Width * 4;

                /*var image = new System.Drawing.Bitmap(SC_Update._desktopFrame._texture2DFinal.Description.Width, SC_Update._desktopFrame._texture2DFinal.Description.Height, memoryBitmapStride, System.Drawing.Imaging.PixelFormat.Format32bppArgb, interptr);

                // Read the image data into the height map
                for (var j = 0; j < SC_Update._desktopFrame._texture2DFinal.Description.Height; j++)
                {
                    for (var i = 0; i < SC_Update._desktopFrame._texture2DFinal.Description.Width; i++)
                    {
                        HeightMapSobel.Add(new DHeightMapType()
                        {
                            x = i,
                            y = image.GetPixel(i, j).R,
                            z = j
                        });
                    }
                }*/

                /*byte* ptr = (byte*)interptr.ToPointer();
                int _pixelSize = 3;
                int _nWidth = SC_Update._desktopFrame._texture2DFinal.Description.Width * _pixelSize;
                int _nHeight = SC_Update._desktopFrame._texture2DFinal.Description.Height;


                for (int y = 0; y < _nHeight; y++)
                {
                    for (int x = 0; x < _nWidth; x++)
                    {
                        if (x % _pixelSize == 0 || x == 0)
                        {
                            var bytePoser = ((y * _nWidth) + x);

                            var test0 = ptr[bytePoser + 0];
                            var test1 = ptr[bytePoser + 1];
                            var test2 = ptr[bytePoser + 2];

                            try
                            {
                                HeightMapSobel.Add(new DHeightMapType()
                                {
                                    x = x,
                                    y = test0,
                                    z = y
                                });
                            }
                            catch (Exception ex)
                            {
                                MainWindow.MessageBox((IntPtr)0, " _ " + ex.ToString(), "sccs message", 0);
                            }

                            ptr++;
                        }
                    }
                }
                */






                /*int memoryBitmapStride = _width * 4;

                // It can happen that the stride on the GPU is bigger then the stride on the bitmap in main memory (_width * 4)
                if (dataBox.RowPitch == memoryBitmapStride)
                {
                    // Stride is the same
                    Marshal.Copy(sourcePtr, _textureByteArray, 0, _bytesTotal);
                }
                else
                {
                    // Stride not the same - copy line by line
                    for (int y = 0; y < _height; y++)
                    {
                        Marshal.Copy(sourcePtr + y * dataBox.RowPitch, _textureByteArray, y * memoryBitmapStride, memoryBitmapStride);
                    }
                }*/



                //image.Dispose();
                //DeleteObject(interptr);
                /*
                int index = 0;

                for (int j = 0; j < (SC_Update._desktopFrame._texture2DFinal.Description.Height - 1); j++)
                {
                    for (int i = 0; i < (SC_Update._desktopFrame._texture2DFinal.Description.Width - 1); i++)
                    {
                        /*int indexBottomLeft1 = ((SC_Update._desktopFrame._texture2DFinal.Description.Height * j) + i);          // Bottom left.
                        int indexBottomRight2 = ((SC_Update._desktopFrame._texture2DFinal.Description.Height * j) + (i + 1));      // Bottom right.
                        int indexUpperLeft3 = ((SC_Update._desktopFrame._texture2DFinal.Description.Height * (j + 1)) + i);      // Upper left.
                        int indexUpperRight4 = ((SC_Update._desktopFrame._texture2DFinal.Description.Height * (j + 1)) + (i + 1));  // Upper right.
                        */

                //SharpDX.Color.Lerp(SharpDX.Color.Lerp(bl, br, xLerp), SharpDX.Color.Lerp(tl, tr, xLerp), y * ratioY - yy);

                /*Terrain.vertices[index].position = new Vector3(SC_Update._desktopDupe.arrayOfPixData[indexUpperLeft3].x, SC_Update._desktopDupe.arrayOfPixData[indexUpperLeft3].y, SC_Update._desktopDupe.arrayOfPixData[indexUpperLeft3].z);
                Terrain.vertices[index].position = new Vector3(SC_Update._desktopDupe.arrayOfPixData[indexUpperRight4].x, SC_Update._desktopDupe.arrayOfPixData[indexUpperRight4].y, SC_Update._desktopDupe.arrayOfPixData[indexUpperRight4].z);
                Terrain.vertices[index].position = new Vector3(SC_Update._desktopDupe.arrayOfPixData[indexUpperRight4].x, SC_Update._desktopDupe.arrayOfPixData[indexUpperRight4].y, SC_Update._desktopDupe.arrayOfPixData[indexUpperRight4].z);
                Terrain.vertices[index].position = new Vector3(SC_Update._desktopDupe.arrayOfPixData[indexBottomLeft1].x, SC_Update._desktopDupe.arrayOfPixData[indexBottomLeft1].y, SC_Update._desktopDupe.arrayOfPixData[indexBottomLeft1].z);
                Terrain.vertices[index].position = new Vector3(SC_Update._desktopDupe.arrayOfPixData[indexBottomLeft1].x, SC_Update._desktopDupe.arrayOfPixData[indexBottomLeft1].y, SC_Update._desktopDupe.arrayOfPixData[indexBottomLeft1].z);
                Terrain.vertices[index].position = new Vector3(SC_Update._desktopDupe.arrayOfPixData[indexUpperLeft3].x, SC_Update._desktopDupe.arrayOfPixData[indexUpperLeft3].y, SC_Update._desktopDupe.arrayOfPixData[indexUpperLeft3].z);
                Terrain.vertices[index].position = new Vector3(SC_Update._desktopDupe.arrayOfPixData[indexBottomLeft1].x, SC_Update._desktopDupe.arrayOfPixData[indexBottomLeft1].y, SC_Update._desktopDupe.arrayOfPixData[indexBottomLeft1].z);
                Terrain.vertices[index].position = new Vector3(SC_Update._desktopDupe.arrayOfPixData[indexUpperRight4].x, SC_Update._desktopDupe.arrayOfPixData[indexUpperRight4].y, SC_Update._desktopDupe.arrayOfPixData[indexUpperRight4].z);
                Terrain.vertices[index].position = new Vector3(SC_Update._desktopDupe.arrayOfPixData[indexUpperRight4].x, SC_Update._desktopDupe.arrayOfPixData[indexUpperRight4].y, SC_Update._desktopDupe.arrayOfPixData[indexUpperRight4].z);
                Terrain.vertices[index].position = new Vector3(SC_Update._desktopDupe.arrayOfPixData[indexBottomRight2].x, SC_Update._desktopDupe.arrayOfPixData[indexBottomRight2].y, SC_Update._desktopDupe.arrayOfPixData[indexBottomRight2].z);
                Terrain.vertices[index].position = new Vector3(SC_Update._desktopDupe.arrayOfPixData[indexBottomRight2].x, SC_Update._desktopDupe.arrayOfPixData[indexBottomRight2].y, SC_Update._desktopDupe.arrayOfPixData[indexBottomRight2].z);
                Terrain.vertices[index].position = new Vector3(SC_Update._desktopDupe.arrayOfPixData[indexBottomLeft1].x, SC_Update._desktopDupe.arrayOfPixData[indexBottomLeft1].y, SC_Update._desktopDupe.arrayOfPixData[indexBottomLeft1].z);
                */

                /*Terrain.vertices[index].position = new Vector3(SC_Update._desktopDupe.arrayOfPixData[indexUpperLeft3], SC_Update._desktopDupe.arrayOfPixData[indexUpperLeft3], SC_Update._desktopDupe.arrayOfPixData[indexUpperLeft3]);
                Terrain.vertices[index].position = new Vector3(SC_Update._desktopDupe.arrayOfPixData[indexUpperRight4], SC_Update._desktopDupe.arrayOfPixData[indexUpperRight4], SC_Update._desktopDupe.arrayOfPixData[indexUpperRight4]);
                Terrain.vertices[index].position = new Vector3(SC_Update._desktopDupe.arrayOfPixData[indexUpperRight4], SC_Update._desktopDupe.arrayOfPixData[indexUpperRight4], SC_Update._desktopDupe.arrayOfPixData[indexUpperRight4]);
                Terrain.vertices[index].position = new Vector3(SC_Update._desktopDupe.arrayOfPixData[indexBottomLeft1], SC_Update._desktopDupe.arrayOfPixData[indexBottomLeft1], SC_Update._desktopDupe.arrayOfPixData[indexBottomLeft1]);
                Terrain.vertices[index].position = new Vector3(SC_Update._desktopDupe.arrayOfPixData[indexBottomLeft1], SC_Update._desktopDupe.arrayOfPixData[indexBottomLeft1], SC_Update._desktopDupe.arrayOfPixData[indexBottomLeft1]);
                Terrain.vertices[index].position = new Vector3(SC_Update._desktopDupe.arrayOfPixData[indexUpperLeft3], SC_Update._desktopDupe.arrayOfPixData[indexUpperLeft3], SC_Update._desktopDupe.arrayOfPixData[indexUpperLeft3]);
                Terrain.vertices[index].position = new Vector3(SC_Update._desktopDupe.arrayOfPixData[indexBottomLeft1], SC_Update._desktopDupe.arrayOfPixData[indexBottomLeft1], SC_Update._desktopDupe.arrayOfPixData[indexBottomLeft1]);
                Terrain.vertices[index].position = new Vector3(SC_Update._desktopDupe.arrayOfPixData[indexUpperRight4], SC_Update._desktopDupe.arrayOfPixData[indexUpperRight4], SC_Update._desktopDupe.arrayOfPixData[indexUpperRight4]);
                Terrain.vertices[index].position = new Vector3(SC_Update._desktopDupe.arrayOfPixData[indexUpperRight4], SC_Update._desktopDupe.arrayOfPixData[indexUpperRight4], SC_Update._desktopDupe.arrayOfPixData[indexUpperRight4]);
                Terrain.vertices[index].position = new Vector3(SC_Update._desktopDupe.arrayOfPixData[indexBottomRight2], SC_Update._desktopDupe.arrayOfPixData[indexBottomRight2], SC_Update._desktopDupe.arrayOfPixData[indexBottomRight2]);
                Terrain.vertices[index].position = new Vector3(SC_Update._desktopDupe.arrayOfPixData[indexBottomRight2], SC_Update._desktopDupe.arrayOfPixData[indexBottomRight2], SC_Update._desktopDupe.arrayOfPixData[indexBottomRight2]);
                Terrain.vertices[index].position = new Vector3(SC_Update._desktopDupe.arrayOfPixData[indexBottomLeft1], SC_Update._desktopDupe.arrayOfPixData[indexBottomLeft1], SC_Update._desktopDupe.arrayOfPixData[indexBottomLeft1]);

                index++;
            }
        }
    }

    //MainWindow.MessageBox((IntPtr)0, Terrain.vertices.Length + "!null", "msg", 0);

    //Console.WriteLine("test0");

    //IntPtr ptrVert = Marshal.UnsafeAddrOfPinnedArrayElement(Terrain.vertices, 0);

    //Guid guid = new Guid();

    //Terrain.VertexBuffer.SetPrivateData(guid, Terrain.vertices.Length, ptrVert);

    Terrain.VertexBuffer = SharpDX.Direct3D11.Buffer.Create(SC_console_directx.D3D.device, SharpDX.Direct3D11.BindFlags.VertexBuffer, Terrain.vertices);

    //Terrain.VertexBuffer.SetPrivateData

    // Render the terrain GRID buffers.
    Terrain.Render(SC_console_directx.D3D.DeviceContext);
    // Render the model using the color shader.
    SC_Update._shaderManager.RenderGrid(SC_console_directx.D3D.DeviceContext, Terrain.IndexCount, sc_maths.Scaling(heightmapscale) * worldMatrix_instances_r_hand_grab[0][0][0], viewMatrix, projectionMatrix);
    //DeleteObject(ptrVert);
    }
    }
    else
    {

    }*/






                /*// Read the image data into the height map
                for (var j = 0; j < terrainheightmap.m_TerrainHeight; j++)
                {
                    for (var i = 0; i < terrainheightmap.m_TerrainWidth; i++)
                    {

                        /*fixed (byte* textureByteArray = SC_Update._desktopFrame.frameByteArray) //, totalArray = _totalArray
                        {
                            int posY = 0;
                            for (int yyyy = yyPlayerShip; yyyy < yyPlayerShip + heightOfRectanglePlayerShip; yyyy++)
                            {
                                for (int xxxx = xxPlayerShip; xxxx < xxPlayerShip + widthOfRectanglePlayerShip; xxxx++)
                                {
                                    /*var bytePoser = ((yyyy * 1920) + xxxx) * 4;

                                    textureByteArray[bytePoser + 0] = 255;
                                    textureByteArray[bytePoser + 1] = 0;
                                    textureByteArray[bytePoser + 2] = 0;
                                    textureByteArray[bytePoser + 3] = 255;
                                    posY++;
                                }
                            }
                        }*/


                //float someheighmapx = 

                //terrainheightmap.HeightMap[(j * terrainheightmap.m_TerrainHeight) +i].x = 
                /*HeightMap.Add(new DHeightMapType()
                 {
                     x = i,
                     y = bitmap.GetPixel(i, j).R,
                     z = j
                 });
            }
        }*/







                /*for (var j = 0; j < terrainheightmap.m_TerrainHeight; j++)
                {
                    for (var i = 0; i < terrainheightmap.m_TerrainWidth; i++)
                    {

                    }
                }*/








                var source_rect = new System.Drawing.Rectangle(0, 0, SC_Update._desktopDupe._textureDescriptionFinal.Width, SC_Update._desktopDupe._textureDescriptionFinal.Height);

                var region = new ResourceRegion(0, 0, 0, SC_Update._desktopDupe.wid, SC_Update._desktopDupe.hgt, 1);

                region = new ResourceRegion(source_rect.X, source_rect.Y, 0, SC_Update._desktopDupe._textureDescriptionFinal.Width, SC_Update._desktopDupe._textureDescriptionFinal.Height, 1);

                for (int row = 0; row < terrainheightmap.m_TerrainWidth; row++) //SC_Update._desktopDupe.num_rows
                {
                    source_rect.X = 0;

                    for (int col = 0; col < terrainheightmap.m_TerrainHeight; col++) //SC_Update._desktopDupe.num_cols
                    {
                        var mainArrayIndex = (row * terrainheightmap.m_TerrainHeight) + col;

                        region.Left = source_rect.X;

                        region.Top = source_rect.Y;

                        //_device.ImmediateContext.CopySubresourceRegion(_texture2DFinal, 0, region, arrayOfTexture2DFrac[mainArrayIndex], 0);
                        //ShaderResourceViewArray[mainArrayIndex] = new ShaderResourceView(_device, _texture2DFinal, resourceViewDescription);
                        //_device.ImmediateContext.GenerateMips(ShaderResourceViewArray[mainArrayIndex]);

                        //for (int tex2D = 0; tex2D < 10 * 10; tex2D++)
                        //{
                        //    arrayOfTexture2DFrac[tex2D] = new Texture2D(_device, _textureDescriptionFinalFrac);
                        //}

                        int memoryBitmapStride0 = SC_Update._desktopDupe.wid * 4;// _textureDescription.Width * 4;

                        int columns0 = SC_Update._desktopDupe.wid;// _textureDescription.Width;
                        int rows0 = SC_Update._desktopDupe.hgt;// _textureDescription.Height;

                        float someheightmapx = row;
                        float someheightmapy = SC_Update._desktopDupe._textureByteArray[((col * terrainheightmap.m_TerrainHeight) + row) + 0]; //
                        float someheightmapz = col;

                        /*DTerrainHeightMap.DHeightMapType someheightmapdata = new DTerrainHeightMap.DHeightMapType();
                        someheightmapdata.x = terrainheightmap.HeightMap[((col * terrainheightmap.m_TerrainHeight) + row) + 0].x;
                        someheightmapdata.y = someheightmapy;
                        someheightmapdata.z = terrainheightmap.HeightMap[((col * terrainheightmap.m_TerrainHeight) + row) + 0].z;
                        terrainheightmap.HeightMap[((col * terrainheightmap.m_TerrainWidth) + row) + 0] = someheightmapdata;*/


                        //CURRENT TESTS FAIL WITHOUT MUCH OF CALCULATING. GO FETCH YOUR OLD TESTS
                        /*for (int x = 0; x < SC_Update._desktopDupe.wid; x++) // 192
                        {
                            for (int y = 0; y < SC_Update._desktopDupe.hgt; y++) //108
                            {
                                DTerrainHeightMap.DHeightMapType someheightmapdata = new DTerrainHeightMap.DHeightMapType();
                                someheightmapdata.x = terrainheightmap.HeightMap[(((col + y) * terrainheightmap.m_TerrainHeight) + (row + x)) + 0].x;
                                someheightmapdata.y = someheightmapy;
                                 someheightmapdata.z = terrainheightmap.HeightMap[(((col + y) * terrainheightmap.m_TerrainHeight) + (row + x)) + 0].z;
                                terrainheightmap.HeightMap[((col * terrainheightmap.m_TerrainWidth) + row) + 0] = someheightmapdata;
                            }
                        }*/
                        //CURRENT TESTS FAIL WITHOUT MUCH OF CALCULATING. GO FETCH YOUR OLD TESTS



                        /*DTerrainHeightMap.DHeightMapType someheightmapdata = new DTerrainHeightMap.DHeightMapType();
                        someheightmapdata.x = terrainheightmap.HeightMap[((col * terrainheightmap.m_TerrainHeight) + (row + x)) + 0].x;
                        someheightmapdata.y = someheightmapy;
                        someheightmapdata.z = terrainheightmap.HeightMap[((col * terrainheightmap.m_TerrainHeight) + (row + z)) + 0].z;
                        terrainheightmap.HeightMap[((col * terrainheightmap.m_TerrainWidth) + row) + 0] = someheightmapdata;*/
                        ///Marshal.Copy(interptr + y * SC_Update._desktopDupe.rowpitch, SC_Update._desktopDupe._textureByteArray, y * memoryBitmapStride0, memoryBitmapStride0);





                        //terrainheightmap.HeightMap[((col * terrainheightmap.m_TerrainHeight) + row) + 1] = someheightmapdata;
                        /*terrainheightmap.HeightMap[((col * terrainheightmap.m_TerrainHeight) + row) + 2] = someheightmapdata;
                        terrainheightmap.HeightMap[((col * terrainheightmap.m_TerrainHeight) + row) + 3] = someheightmapdata;*/

                        //terrainheightmap.HeightMap[(col * terrainheightmap.m_TerrainHeight) + row].x =

                        /*HeightMap.Add(new DHeightMapType()
                        {
                            x = i,
                            y = bitmap.GetPixel(i, j).R,
                            z = j
                        });*/

                        /*IntPtr interptr = Marshal.UnsafeAddrOfPinnedArrayElement(SC_Update._desktopDupe._textureByteArray, 0);// dataBox.DataPointer;

                        // It can happen that the stride on the GPU is bigger then the stride on the bitmap in main memory (_width * 4)
                        if (SC_Update._desktopDupe.rowpitch == memoryBitmapStride0)
                        {
                            // Stride is the same
                            Marshal.Copy(interptr, SC_Update._desktopDupe._textureByteArray, 0, SC_Update._desktopDupe.wid * SC_Update._desktopDupe.hgt * 4);
                        }
                        else
                        {
                            // Stride not the same - copy line by line
                            for (int y = 0; y < SC_Update._desktopDupe._height; y++)
                            {
                                Marshal.Copy(interptr + y * SC_Update._desktopDupe.rowpitch, SC_Update._desktopDupe._textureByteArray, y * memoryBitmapStride0, memoryBitmapStride0);
                            }
                        }*/

                        source_rect.X += SC_Update._desktopDupe.wid;
                    }
                    source_rect.Y += SC_Update._desktopDupe.hgt;
                }


                //terrainheightmap.HeightMap[0].x = 






                //terrainheightmap.InitializeBuffers(SC_console_directx.D3D.device);








                //_player_l_hand_grab[0][0].Render(SC_console_directx.D3D.device.ImmediateContext);
                //SC_Update._shaderManager._rend_torso(SC_console_directx.D3D.device.ImmediateContext, _player_l_hand_grab[0][0].IndexCount, _player_l_hand_grab[0][0].InstanceCount, _player_l_hand_grab[0][0]._POSITION, viewMatrix, projectionMatrix, null, _SC_modL_lft_hnd_BUFFER, _player_l_hand_grab[0][0]);




























                //shaderOfChunk.shaderResourceView2D = _basicTexture.TextureResource ; //SC_Update._desktopFrame.ShaderResource;

                Matrix _worldMatrix = Matrix.Identity;
                Matrix _viewMatrix = viewMatrix;
                Matrix _projectionMatrix = oriProjectionMatrix;
                //_worldMatrix.Transpose();
                _viewMatrix.Transpose();
                //_projectionMatrix.Transpose();

                //SCCS EXERCICES
                //int widthmeshclass = someglobalschunkmesh.numberOfObjectInWidth;
                //int heightmeshclass = someglobalschunkmesh.numberOfObjectInHeight;
                //int depthmeshclass = someglobalschunkmesh.numberOfObjectInDepth;
                //int xmm = (int)((Math.Floor((matrixtouchright.M41 / someglobalschunkmesh.tinyChunkWidth))) * someglobalschunkmesh.planeSize);
                //int ymm = (int)((Math.Floor((matrixtouchright.M42 / someglobalschunkmesh.tinyChunkHeight))) * someglobalschunkmesh.planeSize);
                //int zmm = (int)((Math.Floor((matrixtouchright.M43 / someglobalschunkmesh.tinyChunkDepth))) * someglobalschunkmesh.planeSize);
                //Vector3 somehandposright = new Vector3(matrixtouchright.M41, matrixtouchright.M42, matrixtouchright.M43);
                //int xmm = (int)((Math.Floor((matrixtouchright.M41 / (someglobalschunkmesh.numberOfInstancesPerObjectInWidth * someglobalschunkmesh.tinyChunkWidth)))) * (someglobalschunkmesh.numberOfInstancesPerObjectInWidth * someglobalschunkmesh.tinyChunkWidth) * someglobalschunkmesh.planeSize);
                //int ymm = (int)((Math.Floor((matrixtouchright.M42 / (someglobalschunkmesh.numberOfInstancesPerObjectInHeight * someglobalschunkmesh.tinyChunkHeight)))) * (someglobalschunkmesh.numberOfInstancesPerObjectInHeight * someglobalschunkmesh.tinyChunkHeight) * someglobalschunkmesh.planeSize);
                //int zmm = (int)((Math.Floor((matrixtouchright.M43 / (someglobalschunkmesh.numberOfInstancesPerObjectInDepth * someglobalschunkmesh.tinyChunkDepth)))) * (someglobalschunkmesh.numberOfInstancesPerObjectInDepth * someglobalschunkmesh.tinyChunkDepth) * someglobalschunkmesh.planeSize);
                //float mulx = someglobalschunkmesh.numberOfInstancesPerObjectInWidth * someglobalschunkmesh.tinyChunkWidth;
                //float muly = someglobalschunkmesh.numberOfInstancesPerObjectInHeight * someglobalschunkmesh.tinyChunkHeight;
                //float mulz = someglobalschunkmesh.numberOfInstancesPerObjectInDepth * someglobalschunkmesh.tinyChunkDepth;
                //EXAMPLES OF ROUNDING/FLOORING/CEILING BULLSHIT
                //float somex = (float)(Math.Floor(1.2345f * (0.1f * 100)) * 0.1f);// == 1.2
                //float somex = (float)(Math.Round(1.2345f * (0.1f * 100)) * 0.1f);// == 1.2
                //float somex = (float)(Math.Ceiling(1.2345f * (0.1f * 100)) * 0.1f);// == 1.3
                //float somefx = (float)(Math.Ceiling(1.2345f /4) * 4); // == 4
                //float somefx = (float)(Math.Round(1.2345f / 4) * 4); // == 0
                //float somefx = (float)(Math.Floor(1.2345f / 4) * 4); // == 0
                //float somefx = (float)(Math.Floor(1.2345f / (4 * 4)) * (4 * 4)); // == 0
                //float somefx = (float)(Math.Ceiling(1.2345f / (4*4)) * (4 * 4)); // 16
                //float somefx = (float)((Math.Ceiling(1.2345f / (4 * 4)) * (4 * 4)) / (4 * 4)); // 1
                //float somefx = (float)((Math.Floor(12.5f / (mulx)) * (mulx)) / (mulx)); // 1
                //float somefx = (float)((Math.Round(12.5f / (mulx)) * (mulx)) / (mulx)); // 2
                //var fractionOf0 = realplanetwidth / someglobalschunkmesh.planeSize;// 4 / 1 = 4
                //int somefx = (int)Math.Floor((12.5f / someglobalschunkmesh.planeSize) / fractionOf0); // 3
                //float somefx = (float)((Math.Round(3.5f / 4) * 4)); // 4
                //float somefx = (float)((Math.Round(3.5f / 4) * 4) / 4); // 1
                //float somefx = (float)((Math.Round(12.5f * (mulx)) / (mulx))); // 12.5f
                //var fractionOf0 = (realplanetwidth / someglobalschunkmesh.planeSize)/ mulx;
                //float somefx = (float)(Math.Floor(1.2f / fractionOf0) * fractionOf0); // 1.0f
                //var fractionOf0 = (realplanetwidth / someglobalschunkmesh.planeSize)/ mulx;
                //float somefx = (float)(Math.Floor(1.275f / fractionOf0) * fractionOf0); // 1.25f
                //float somefx = (float)(Math.Floor(matrixtouchright.M41)); // 4.1 floored == 4.0f <==> 4.0f / numberOfInstancesPerObjectInWidth = 1
                //SCCS EXERCICES

                if (playerusebrush == 0)
                {

                    for (int insti = 0; insti < ikarmvoxel[3]._player_r_hand_grab[0][0]._arrayOfInstances.Length; insti++) // ikarmvoxel[3]._player_r_hand_grab[0][0]._arrayOfInstances.Length
                    {

                        Vector3 pivotpositionpickaxe = new Vector3(ikarmvoxel[3]._player_r_hand_grab[0][0]._arrayOfInstances[insti].current_pos.M41, ikarmvoxel[3]._player_r_hand_grab[0][0]._arrayOfInstances[insti].current_pos.M42, ikarmvoxel[3]._player_r_hand_grab[0][0]._arrayOfInstances[insti].current_pos.M43);
                        Vector3 temppickaxetiplocation = new Vector3(ikarmvoxel[3]._player_r_hand_grab[0][0]._chunk.listofpickaxetipbytes[0].X, ikarmvoxel[3]._player_r_hand_grab[0][0]._chunk.listofpickaxetipbytes[0].Y, ikarmvoxel[3]._player_r_hand_grab[0][0]._chunk.listofpickaxetipbytes[0].Z);
                        var MOVINGPOINTER = new Vector3(ikvoxelbody[0]._player_torso[0][0]._arrayOfInstances[insti]._ORIGINPOSITION.M41, ikvoxelbody[0]._player_torso[0][0]._arrayOfInstances[insti]._ORIGINPOSITION.M42, ikvoxelbody[0]._player_torso[0][0]._arrayOfInstances[insti]._ORIGINPOSITION.M43);

                        var rotposmatrix = ikarmvoxel[3]._player_r_hand_grab[0][0]._arrayOfInstances[insti].current_pos;// _player_rght_shldr[0][0]._ORIGINPOSITION;

                        Quaternion somequat;
                        Quaternion.RotationMatrix(ref rotposmatrix, out somequat);

                        var direction_feet_forward_ori = sc_maths._getDirection(Vector3.ForwardRH, somequat);
                        var direction_feet_right_ori = sc_maths._getDirection(Vector3.Right, somequat);
                        var direction_feet_up_ori = sc_maths._getDirection(Vector3.Up, somequat);

                        var diffNormPosX = (MOVINGPOINTER.X) - ikarmvoxel[3]._player_r_hand_grab[0][0]._arrayOfInstances[insti].current_pos.M41;
                        var diffNormPosY = (MOVINGPOINTER.Y) - ikarmvoxel[3]._player_r_hand_grab[0][0]._arrayOfInstances[insti].current_pos.M42;
                        var diffNormPosZ = (MOVINGPOINTER.Z) - ikarmvoxel[3]._player_r_hand_grab[0][0]._arrayOfInstances[insti].current_pos.M43;

                        var pickaxetippoint = MOVINGPOINTER;

                        //var tempPoint = pickaxetippoint + (direction_feet_right_ori * (diffNormPosX));
                        //tempPoint = tempPoint + (direction_feet_up_ori * (diffNormPosY));
                        //tempPoint = tempPoint + (direction_feet_forward_ori * (diffNormPosZ));

                        //var MOVINGPOINTER1 = tempPoint + new Vector3(ikarmvoxel[3]._player_r_hand_grab[0][0]._arrayOfInstances[insti].current_pos.M41, ikarmvoxel[3]._player_r_hand_grab[0][0]._arrayOfInstances[insti].current_pos.M42, ikarmvoxel[3]._player_r_hand_grab[0][0]._arrayOfInstances[insti].current_pos.M43);
                        var MOVINGPOINTER1 = new Vector3(ikarmvoxel[3]._player_r_hand_grab[0][0]._arrayOfInstances[insti].current_pos.M41, ikarmvoxel[3]._player_r_hand_grab[0][0]._arrayOfInstances[insti].current_pos.M42, ikarmvoxel[3]._player_r_hand_grab[0][0]._arrayOfInstances[insti].current_pos.M43);

                        //float somezvalue = ikarmvoxel[3]._player_r_hand_grab[0][0]._total_torso_height;

                        pickaxetippoint = MOVINGPOINTER1 + (direction_feet_up_ori * (-temppickaxetiplocation.Y * ikarmvoxel[3].voxel_general_size));
                        pickaxetippoint = pickaxetippoint + (direction_feet_forward_ori * (-temppickaxetiplocation.Z * ikarmvoxel[3].voxel_general_size));

                        //SET THE BYTE LOCATOR OBJECT TO THE LOCATION OF THE BYTE ON THE PICKAXE TIP IN ORDER TO HAVE A VISUAL ON WHERE THE ROUNDED BYTE LOCATOR IS
                        //SET THE BYTE LOCATOR OBJECT TO THE LOCATION OF THE BYTE ON THE PICKAXE TIP IN ORDER TO HAVE A VISUAL ON WHERE THE ROUNDED BYTE LOCATOR IS
                        worldMatrix_instances_voxel_cube[0][0][1].M41 = pickaxetippoint.X;
                        worldMatrix_instances_voxel_cube[0][0][1].M42 = pickaxetippoint.Y;
                        worldMatrix_instances_voxel_cube[0][0][1].M43 = pickaxetippoint.Z;
                        //SET THE BYTE LOCATOR OBJECT TO THE LOCATION OF THE BYTE ON THE PICKAXE TIP IN ORDER TO HAVE A VISUAL ON WHERE THE ROUNDED BYTE LOCATOR IS
                        //SET THE BYTE LOCATOR OBJECT TO THE LOCATION OF THE BYTE ON THE PICKAXE TIP IN ORDER TO HAVE A VISUAL ON WHERE THE ROUNDED BYTE LOCATOR IS

                        pivotpositionpickaxe = new Vector3(ikarmvoxel[3]._player_r_hand_grab[0][0]._arrayOfInstances[insti].current_pos.M41, ikarmvoxel[3]._player_r_hand_grab[0][0]._arrayOfInstances[insti].current_pos.M42, ikarmvoxel[3]._player_r_hand_grab[0][0]._arrayOfInstances[insti].current_pos.M43);
                        temppickaxetiplocation = new Vector3(ikarmvoxel[3]._player_r_hand_grab[0][0]._chunk.listofpickaxetipbytes[0].X, ikarmvoxel[3]._player_r_hand_grab[0][0]._chunk.listofpickaxetipbytes[0].Y, ikarmvoxel[3]._player_r_hand_grab[0][0]._chunk.listofpickaxetipbytes[0].Z);
                        MOVINGPOINTER = new Vector3(ikvoxelbody[0]._player_torso[0][0]._arrayOfInstances[insti]._ORIGINPOSITION.M41, ikvoxelbody[0]._player_torso[0][0]._arrayOfInstances[insti]._ORIGINPOSITION.M42, ikvoxelbody[0]._player_torso[0][0]._arrayOfInstances[insti]._ORIGINPOSITION.M43);

                        rotposmatrix = ikarmvoxel[3]._player_r_hand_grab[0][0]._arrayOfInstances[insti].current_pos;// _player_rght_shldr[0][0]._ORIGINPOSITION;

                        //Quaternion somequat;
                        Quaternion.RotationMatrix(ref rotposmatrix, out somequat);

                        direction_feet_forward_ori = sc_maths._getDirection(Vector3.ForwardRH, somequat);
                        direction_feet_right_ori = sc_maths._getDirection(Vector3.Right, somequat);
                        direction_feet_up_ori = sc_maths._getDirection(Vector3.Up, somequat);

                        diffNormPosX = (MOVINGPOINTER.X) - ikarmvoxel[3]._player_r_hand_grab[0][0]._arrayOfInstances[insti].current_pos.M41;
                        diffNormPosY = (MOVINGPOINTER.Y) - ikarmvoxel[3]._player_r_hand_grab[0][0]._arrayOfInstances[insti].current_pos.M42;
                        diffNormPosZ = (MOVINGPOINTER.Z) - ikarmvoxel[3]._player_r_hand_grab[0][0]._arrayOfInstances[insti].current_pos.M43;

                        //pickaxetippoint = MOVINGPOINTER;

                        //var tempPoint = pickaxetippoint + (direction_feet_right_ori * (diffNormPosX));
                        //tempPoint = tempPoint + (direction_feet_up_ori * (diffNormPosY));
                        //tempPoint = tempPoint + (direction_feet_forward_ori * (diffNormPosZ));

                        //var MOVINGPOINTER1 = tempPoint + new Vector3(ikarmvoxel[3]._player_r_hand_grab[0][0]._arrayOfInstances[insti].current_pos.M41, ikarmvoxel[3]._player_r_hand_grab[0][0]._arrayOfInstances[insti].current_pos.M42, ikarmvoxel[3]._player_r_hand_grab[0][0]._arrayOfInstances[insti].current_pos.M43);
                        MOVINGPOINTER1 = new Vector3(ikarmvoxel[3]._player_r_hand_grab[0][0]._arrayOfInstances[insti].current_pos.M41, ikarmvoxel[3]._player_r_hand_grab[0][0]._arrayOfInstances[insti].current_pos.M42, ikarmvoxel[3]._player_r_hand_grab[0][0]._arrayOfInstances[insti].current_pos.M43);

                        //float somezvalue = ikarmvoxel[3]._player_r_hand_grab[0][0]._total_torso_height;

                        pickaxetippoint = MOVINGPOINTER1 + (direction_feet_up_ori * (-temppickaxetiplocation.Y * ikarmvoxel[3].voxel_general_size));
                        pickaxetippoint = pickaxetippoint + (direction_feet_forward_ori * (-temppickaxetiplocation.Z * ikarmvoxel[3].voxel_general_size));




                        //SET THE BYTE LOCATOR OBJECT TO THE LOCATION OF THE BYTE ON THE CHUNK IN ORDER TO HAVE A VISUAL ON WHERE THE BYTE LOCATOR IS IN CODE
                        //SET THE BYTE LOCATOR OBJECT TO THE LOCATION OF THE BYTE ON THE CHUNK IN ORDER TO HAVE A VISUAL ON WHERE THE BYTE LOCATOR IS IN CODE
                        //SET THE BYTE LOCATOR OBJECT TO THE LOCATION OF THE BYTE ON THE CHUNK IN ORDER TO HAVE A VISUAL ON WHERE THE BYTE LOCATOR IS IN CODE
                        worldMatrix_instances_voxel_cube[0][0][1].M41 = pickaxetippoint.X;
                        worldMatrix_instances_voxel_cube[0][0][1].M42 = pickaxetippoint.Y;
                        worldMatrix_instances_voxel_cube[0][0][1].M43 = pickaxetippoint.Z;
                        //SET THE BYTE LOCATOR OBJECT TO THE LOCATION OF THE BYTE ON THE CHUNK IN ORDER TO HAVE A VISUAL ON WHERE THE BYTE LOCATOR IS IN CODE
                        //SET THE BYTE LOCATOR OBJECT TO THE LOCATION OF THE BYTE ON THE CHUNK IN ORDER TO HAVE A VISUAL ON WHERE THE BYTE LOCATOR IS IN CODE
                        //SET THE BYTE LOCATOR OBJECT TO THE LOCATION OF THE BYTE ON THE CHUNK IN ORDER TO HAVE A VISUAL ON WHERE THE BYTE LOCATOR IS IN CODE


                        float planeSize = somevoxelvirtualdesktopglobals.planeSize;

                        //float somesizedfx = (float)(Math.Floor(pickaxetippoint.X / planeSize) * planeSize); // 35 + 1 = 36
                        //float somesizedfy = (float)(Math.Floor(pickaxetippoint.Y / planeSize) * planeSize); // 
                        //float somesizedfz = (float)(Math.Floor(pickaxetippoint.Z / planeSize) * planeSize); //

                        //ORIGINAL MADE BY STEVE CHASSÉ
                        //int somefx = (int)Math.Abs(Math.Floor(((ikarmvoxel[3]._player_rght_hnd[0][0]._arrayOfInstances[insti].current_pos.M41) - somevoxelvirtualdesktop[0].worldmatofobj.M41) / planeSize)); // 35 + 1 = 36
                        //int somefy = (int)Math.Abs(Math.Floor(((ikarmvoxel[3]._player_rght_hnd[0][0]._arrayOfInstances[insti].current_pos.M42) - somevoxelvirtualdesktop[0].worldmatofobj.M42) / planeSize)); // 
                        //int somefz = (int)Math.Abs(Math.Floor(((ikarmvoxel[3]._player_rght_hnd[0][0]._arrayOfInstances[insti].current_pos.M43) - somevoxelvirtualdesktop[0].worldmatofobj.M43) / planeSize)); //
                        //ORIGINAL MADE BY STEVE CHASSÉ



                        int somefx = (int)Math.Abs(Math.Round(((pickaxetippoint.X) - somevoxelvirtualdesktop[0].worldmatofobj.M41) / planeSize)); // 35 + 1 = 36
                        int somefy = (int)Math.Abs(Math.Round(((pickaxetippoint.Y) - somevoxelvirtualdesktop[0].worldmatofobj.M42) / planeSize)); // 
                        int somefz = (int)Math.Abs(Math.Round(((pickaxetippoint.Z) - somevoxelvirtualdesktop[0].worldmatofobj.M43) / planeSize)); //


                        //somefx = (int)Math.Abs(Math.Round(((pickaxetippoint.X)) / planeSize)); // 35 + 1 = 36
                        //somefy = (int)Math.Abs(Math.Round(((pickaxetippoint.Y)) / planeSize)); // 
                        //somefz = (int)Math.Abs(Math.Round(((pickaxetippoint.Z)) / planeSize)); //

                        //if (somefx >= 0 && somefy >= 0 && somefz >= 0)
                        {
                            //BYTES INDEX FAST MODULO ALTERNATIVE FOUND ON A GOOGLE SEARCH WITH SOME BENCHMARKS AND IT SEEMED TO BE THAT LOOPING WAS FASTER THAN USING MODULO... DEPENDING MAYBE ON OTHER THINGS. ILL TEST LATER.
                            int theNumberx = somevoxelvirtualdesktopglobals.tinyChunkWidth;
                            int remainderbytesx = 0;
                            int totalTimesx = 0;

                            for (int ii = 0; ii <= somefx; ii++)
                            {
                                if (remainderbytesx == theNumberx)
                                {
                                    remainderbytesx = 0;
                                    totalTimesx++;
                                }
                                if (totalTimesx * theNumberx >= somefx) // >=?? why not only >
                                {
                                    break;
                                }
                                remainderbytesx++;
                            }

                            int theNumbery = somevoxelvirtualdesktopglobals.tinyChunkHeight;
                            int remainderbytesy = 0;
                            int totalTimesy = 0;

                            for (int ii = 0; ii <= somefy; ii++)
                            {
                                if (remainderbytesy == theNumbery)
                                {
                                    remainderbytesy = 0;
                                    totalTimesy++;
                                }
                                if (totalTimesy * theNumbery >= somefy) // >=?? why not only >
                                {
                                    break;
                                }
                                remainderbytesy++;
                            }

                            int theNumberz = somevoxelvirtualdesktopglobals.tinyChunkDepth;
                            int remainderbytesz = 0;
                            int totalTimesz = 0;

                            for (int ii = 0; ii <= somefz; ii++)
                            {
                                if (remainderbytesz == theNumberz)
                                {
                                    remainderbytesz = 0;
                                    totalTimesz++;
                                }
                                if (totalTimesz * theNumberz >= somefz) // >=?? why not only >
                                {
                                    break;
                                }
                                remainderbytesz++;
                            }
                            //BYTES INDEX 

                            //
                            int indexbytex = ((somefx - (totalTimesx * theNumberx)));
                            int indexbytey = ((somefy - (totalTimesy * theNumbery)));
                            int indexbytez = ((somefz - (totalTimesz * theNumberz)));
                            int indexofbyte = (indexbytex) + (somevoxelvirtualdesktopglobals.tinyChunkWidth) * ((indexbytey) + (somevoxelvirtualdesktopglobals.tinyChunkHeight) * (indexbytez));
                            //

                            /*//MESH INSTANCE INDEX FAST MODULO 
                            theNumberx = somevoxelvirtualdesktopglobals.tinyChunkWidth;
                            int remaindermeshinstx = 0;
                            totalTimesx = 0;

                            for (int ii = 0; ii <= somefx; ii++)
                            {
                                if (remaindermeshinstx == theNumberx)
                                {
                                    remaindermeshinstx = 0;
                                    totalTimesx++;
                                }
                                if (totalTimesx * theNumberx >= somefx) // >=?? why not only >
                                {
                                    break;
                                }
                                remaindermeshinstx++;
                            }

                            theNumbery = somevoxelvirtualdesktopglobals.tinyChunkHeight;
                            int remaindermeshinsty = 0;
                            totalTimesy = 0;

                            for (int ii = 0; ii <= somefy; ii++)
                            {
                                if (remaindermeshinsty == theNumbery)
                                {
                                    remaindermeshinsty = 0;
                                    totalTimesy++;
                                }
                                if (totalTimesy * theNumbery >= somefy) // >=?? why not only >
                                {
                                    break;
                                }
                                remaindermeshinsty++;
                            }

                            theNumberz = somevoxelvirtualdesktopglobals.tinyChunkDepth;  //somevoxelvirtualdesktopglobals.tinyChunkDepth;
                            int remaindermeshinstz = 0;
                            totalTimesz = 0;

                            for (int ii = 0; ii <= somefz; ii++) // 35
                            {
                                if (remaindermeshinstz == theNumberz) //16
                                {
                                    remaindermeshinstz = 0;
                                    totalTimesz++;
                                }
                                if (totalTimesz * theNumberz >= somefz) // >=?? why not only >
                                {
                                    break;
                                }
                                remaindermeshinstz++;
                            }
                            //MESH INSTANCE INDEX FAST MODULO*/

                            //
                            int indexofmeshinstx = totalTimesx;// ((somefx - (totalTimesx * theNumberx))); // 35 - 30 = 5 
                            int indexofmeshinsty = totalTimesy;// ((somefy - (totalTimesy * theNumbery)));
                            int indexofmeshinstz = totalTimesz;// ((somefz - (totalTimesz * theNumberz)));
                                                               //int indexofmeshinstx = totalTimesx;// ((somefx - (totalTimesx * theNumberx))); // 35 - 30 = 5 
                                                               //int indexofmeshinsty = totalTimesy;//  ((somefy - (totalTimesy * theNumbery))); 
                                                               //int indexofmeshinstz = totalTimesz;// ((somefz - (totalTimesz * theNumberz)));
                                                               //int indexofmeshinstx = ((somefx - (totalTimesx * theNumberx))); // 35 - 30 = 5 
                                                               //int indexofmeshinsty = ((somefy - (totalTimesy * theNumbery)));
                                                               //int indexofmeshinstz = ((somefz - (totalTimesz * theNumberz)));


                            /*if (indexofmeshinstx >= somevoxelvirtualdesktopglobals.numberOfInstancesPerObjectInWidth)
                            {
                                indexofmeshinstx = indexofmeshinstx % somevoxelvirtualdesktopglobals.numberOfInstancesPerObjectInWidth;
                            }
                            if (indexofmeshinsty >= somevoxelvirtualdesktopglobals.numberOfInstancesPerObjectInHeight)
                            {
                                indexofmeshinsty = indexofmeshinsty % somevoxelvirtualdesktopglobals.numberOfInstancesPerObjectInHeight;
                            }
                            if (indexofmeshinstz >= somevoxelvirtualdesktopglobals.numberOfInstancesPerObjectInDepth)
                            {
                                indexofmeshinstz = indexofmeshinstz % somevoxelvirtualdesktopglobals.numberOfInstancesPerObjectInDepth;
                            }*/

                            int indexofmeshinst = (indexofmeshinstx) + (somevoxelvirtualdesktopglobals.numberOfInstancesPerObjectInWidth) * ((indexofmeshinsty) + (somevoxelvirtualdesktopglobals.numberOfInstancesPerObjectInHeight) * (indexofmeshinstz));
                            //


                            /*//MESH ZERO INDEX FAST MODULO 
                            theNumberx = somevoxelvirtualdesktopglobals.tinyChunkDepth * somevoxelvirtualdesktopglobals.numberOfInstancesPerObjectInDepth;
                            int remaindermeshzerox = 0;
                            totalTimesx = 0;

                            for (int ii = 0; ii <= somefx; ii++)
                            {
                                if (remaindermeshzerox == theNumberx)
                                {
                                    remaindermeshzerox = 0;
                                    totalTimesx++;
                                }
                                if (totalTimesx * theNumberx >= somefx) // >=?? why not only >
                                {
                                    break;
                                }
                                remaindermeshzerox++;
                            }

                            theNumbery = somevoxelvirtualdesktopglobals.tinyChunkDepth * somevoxelvirtualdesktopglobals.numberOfInstancesPerObjectInDepth;
                            int remaindermeshzeroy = 0;
                            totalTimesy = 0;

                            for (int ii = 0; ii <= somefy; ii++)
                            {
                                if (remaindermeshzeroy == theNumbery)
                                {
                                    remaindermeshzeroy = 0;
                                    totalTimesy++;
                                }
                                if (totalTimesy * theNumbery >= somefy) // >=?? why not only >
                                {
                                    break;
                                }
                                remaindermeshzeroy++;
                            }

                            theNumberz = somevoxelvirtualdesktopglobals.tinyChunkDepth * somevoxelvirtualdesktopglobals.numberOfInstancesPerObjectInDepth;  //somevoxelvirtualdesktopglobals.tinyChunkDepth;
                            int remaindermeshzeroz = 0;
                            totalTimesz = 0;

                            for (int ii = 0; ii <= somefz; ii++)
                            {
                                if (remaindermeshzeroz == theNumberz)
                                {
                                    remaindermeshzeroz = 0;
                                    totalTimesz++;
                                }
                                if (totalTimesz * theNumberz >= somefz) // >=?? why not only >
                                {
                                    break;
                                }
                                remaindermeshzeroz++;
                            }*/
                            //MESH ZERO INDEX FAST MODULO 


                            if (totalTimesx >= somevoxelvirtualdesktopglobals.numberOfObjectInWidth)
                            {
                                totalTimesx = totalTimesx % somevoxelvirtualdesktopglobals.numberOfObjectInWidth;
                            }
                            if (totalTimesy >= somevoxelvirtualdesktopglobals.numberOfObjectInHeight)
                            {
                                totalTimesy = totalTimesy % somevoxelvirtualdesktopglobals.numberOfObjectInHeight;
                            }
                            if (totalTimesz >= somevoxelvirtualdesktopglobals.numberOfObjectInDepth)
                            {
                                totalTimesz = totalTimesz % somevoxelvirtualdesktopglobals.numberOfObjectInDepth;
                            }



                            //
                            int indexmeshzerox = totalTimesx;//((somefx - (totalTimesx * theNumberx)));
                            int indexmeshzeroy = totalTimesy;//((somefy - (totalTimesy * theNumbery)));
                            int indexmeshzeroz = totalTimesz;//((somefz - (totalTimesz * theNumberz)));
                            int indexofmeshzero = (indexmeshzerox) + (somevoxelvirtualdesktopglobals.numberOfObjectInWidth) * ((indexmeshzeroy) + (somevoxelvirtualdesktopglobals.numberOfObjectInHeight) * (indexmeshzeroz));
                            //


                            //MAIN OBJECT INDEX FAST MODULO 
                            theNumberx = somevoxelvirtualdesktopglobals.tinyChunkWidth * somevoxelvirtualdesktopglobals.numberOfInstancesPerObjectInWidth * somevoxelvirtualdesktopglobals.numberOfObjectInWidth;
                            int remaindermainobjectx = 0;
                            totalTimesx = 0;

                            for (int ii = 0; ii <= somefx; ii++)
                            {
                                if (remaindermainobjectx == theNumberx)
                                {
                                    remaindermainobjectx = 0;
                                    totalTimesx++;
                                }
                                if (totalTimesx * theNumberx >= somefx) // >=?? why not only >
                                {
                                    break;
                                }
                                remaindermainobjectx++;
                            }

                            theNumbery = somevoxelvirtualdesktopglobals.tinyChunkHeight * somevoxelvirtualdesktopglobals.numberOfInstancesPerObjectInHeight * somevoxelvirtualdesktopglobals.numberOfObjectInHeight;
                            int remaindermainobjecty = 0;
                            totalTimesy = 0;

                            for (int ii = 0; ii <= somefy; ii++)
                            {
                                if (remaindermainobjecty == theNumbery)
                                {
                                    remaindermainobjecty = 0;
                                    totalTimesy++;
                                }
                                if (totalTimesy * theNumbery >= somefy) // >=?? why not only >
                                {
                                    break;
                                }
                                remaindermainobjecty++;
                            }

                            theNumberz = somevoxelvirtualdesktopglobals.tinyChunkDepth * somevoxelvirtualdesktopglobals.numberOfInstancesPerObjectInDepth * somevoxelvirtualdesktopglobals.numberOfObjectInDepth;  //somevoxelvirtualdesktopglobals.tinyChunkDepth;
                            int remaindermainobjectz = 0;
                            totalTimesz = 0;

                            for (int ii = 0; ii <= somefz; ii++)
                            {
                                if (remaindermainobjectz == theNumberz)
                                {
                                    remaindermainobjectz = 0;
                                    totalTimesz++;
                                }
                                if (totalTimesz * theNumberz >= somefz) // >=?? why not only >
                                {
                                    break;
                                }
                                remaindermainobjectz++;
                            }
                            //MAIN OBJECT INDEX FAST MODULO 


                            if (totalTimesx >= somevoxelvirtualdesktopw)
                            {
                                totalTimesx = totalTimesx % somevoxelvirtualdesktopw;
                            }
                            if (totalTimesy >= somevoxelvirtualdesktoph)
                            {
                                totalTimesy = totalTimesy % somevoxelvirtualdesktoph;
                            }
                            if (totalTimesz >= somevoxelvirtualdesktopd)
                            {
                                totalTimesz = totalTimesz % somevoxelvirtualdesktopd;
                            }

                            //
                            //int indexmainobjectx = totalTimesx; //((somefx - (totalTimesx * theNumberx)));
                            //int indexmainobjecty = totalTimesy; //((somefy - (totalTimesy * theNumbery)));
                            //int indexmainobjectz = totalTimesz; //((somefz - (totalTimesz * theNumberz)));
                            //int indexmainobjectx = ((somefx - (totalTimesx * theNumberx)));
                            //int indexmainobjecty = ((somefy - (totalTimesy * theNumbery)));
                            //int indexmainobjectz = ((somefz - (totalTimesz * theNumberz)));
                            int indexmainobjectx = totalTimesx;// ((somefx - (totalTimesx * theNumberx)));
                            int indexmainobjecty = totalTimesy;// ((somefy - (totalTimesy * theNumbery)));
                            int indexmainobjectz = totalTimesz;// ((somefz - (totalTimesz * theNumberz)));

                            int indexofmainobject = (indexmainobjectx) + (somevoxelvirtualdesktopw) * ((indexmainobjecty) + (somevoxelvirtualdesktoph) * (indexmainobjectz));
                            //

                            //int diffx = (int)(Math.Floor(SC_Update._rightTouchMatrix.M41 - somevoxelvirtualdesktop[indexofmainobject].arrayofindexzeromesh[indexofmeshzero].somechunk[indexofmeshinst].somechunkpos.X));
                            //int diffy = (int)(Math.Floor(SC_Update._rightTouchMatrix.M42 - somevoxelvirtualdesktop[indexofmainobject].arrayofindexzeromesh[indexofmeshzero].somechunk[indexofmeshinst].somechunkpos.Y));
                            //int diffz = (int)(Math.Floor(SC_Update._rightTouchMatrix.M43 - somevoxelvirtualdesktop[indexofmainobject].arrayofindexzeromesh[indexofmeshzero].somechunk[indexofmeshinst].somechunkpos.Z));

                            //CONSOLE DEBUG
                            //CONSOLE DEBUG
                            //CONSOLE DEBUG

                            if (consolewritecounter >= consolewritecountermax)
                            {
                                if (consolewritecounterswtc == 0)
                                {

                                    consolewritecounterswtc = 1;
                                }

                                /*for (int sc = 0; sc < 30; sc++) //Console.WindowWidth - 1
                                {
                                    Console.SetCursorPosition(sc, 0);
                                    Console.WriteLine(" ");
                                    //Console.SetCursorPosition(sc, 1);
                                    //Console.WriteLine(" ");
                                    //Console.SetCursorPosition(sc, 1);
                                    //Console.WriteLine(" ");
                                    //Console.SetCursorPosition(sc, 3);
                                    //Console.WriteLine(" ");
                                    //Console.SetCursorPosition(sc, 4);
                                    //Console.WriteLine(" ");
                                }*/

                                //Console.SetCursorPosition(0, 0);
                                //Console.WriteLine("x:" + +mainx + "/y:" + mainy + "/z:" + mainz);

                                //Console.SetCursorPosition(0, 1);
                                //Console.WriteLine("secx:" + +secx + "/secy:" + secy + "/secz:" + secz);

                                //Console.SetCursorPosition(0, 0);
                                //Console.WriteLine("somefx:" + +somefx + "/somefy:" + somefy + "/somefz:" + somefz);

                                //Console.SetCursorPosition(0, 0);
                                //Console.WriteLine("fobjmeshx:" + +fobjmeshx + "/fobjmeshy:" + fobjmeshy + "/fobjmeshz:" + fobjmeshz);

                                //Console.Title = "fobjmeshx:" + +fobjmeshx + "/fobjmeshy:" + fobjmeshy + "/fobjmeshz:" + fobjmeshz;
                                //Console.Title = "fobjmeshx:" + +fobjmeshx + "/fobjmeshy:" + fobjmeshy + "/fobjmeshz:" + fobjmeshz;
                                //Console.Title = "finstx:" + +finstx + "/finsty:" + finsty + "/finstz:" + finstz;
                                //Console.Title = "mainx:" + mainx + "/mainy:" + mainy + "/mainz:" + mainz;
                                //Console.Title = "someothermainx:" + someothermainx + "/someothermainy:" + someothermainy + "/someothermainz:" + someothermainz + "/fobjmeshx:" + +fobjmeshx + "/fobjmeshy:" + fobjmeshy + "/fobjmeshz:" + fobjmeshz;
                                //Console.Title = "/someothermainx:" + someothermainx + "/someothermainy:" + someothermainy + "/someothermainz:" + someothermainz +"/fobjmeshmainx:" + fobjmeshmainx + "/fobjmeshmainy:" + fobjmeshmainy + "/fobjmeshmainz:" + fobjmeshmainz + "/fobjmeshx:" + +fobjmeshx + "/fobjmeshy:" + fobjmeshy + "/fobjmeshz:" + fobjmeshz;

                                //Console.Title = "someinstx:" + (int)someinstx + "/someinsty:" + (int)someinsty + "/someinstz:" + (int)someinstz;

                                //Console.Title = "somefx:" + +somefx + "/somefy:" + somefy + "/somefz:" + somefz;


                                //Console.Title = "indexbytex:" + (int)indexbytex + "/indexbytey:" + (int)indexbytey + "/indexbytez:" + (int)indexbytez;
                                //Console.Title = "indexofmeshinstx:" + (int)indexofmeshinstx + "/indexofmeshinsty:" + (int)indexofmeshinsty + "/indexofmeshinstz:" + (int)indexofmeshinstz;


                                //Console.Title = "/tx:" + totalTimesx + "/ty:" + totalTimesy + "/tz:" + totalTimesz + "/rx:" + remaindermainobjectx + "/ry:" + remaindermainobjecty + "/rz:" + remaindermainobjectz + "/mx:" + indexmainobjectx + "/my:" + indexmainobjecty + "/mz:" + indexmainobjectz + "/msx:" + (int)indexmeshzerox + "/msy:" + (int)indexmeshzeroy + "/msz:" + (int)indexmeshzeroz + "/msix:" + (int)indexofmeshinstx + "/msiy:" + (int)indexofmeshinsty + "/msiz:" + (int)indexofmeshinstz + "/indexbytex:" + (int)indexbytex + "/indexbytey:" + (int)indexbytey + "/indexbytez:" + (int)indexbytez;


                                //Console.Title = "/indexmeshzerox:" + (int)indexmeshzerox + "/indexmeshzeroy:" + (int)indexmeshzeroy + "/indexmeshzeroz:" + (int)indexmeshzeroz;


                                consolewritecounter = 0;
                            }
                            consolewritecounter++;

                            //CONSOLE DEBUG
                            //CONSOLE DEBUG
                            //CONSOLE DEBUG

                            //indexofmainobject = someothermainindex;

                            if (indexofmainobject >= 0 && indexofmainobject < somevoxelvirtualdesktopw * somevoxelvirtualdesktoph * somevoxelvirtualdesktopd)
                            {
                                if (indexofmeshzero >= 0 && indexofmeshzero < somevoxelvirtualdesktopglobals.numberOfObjectInWidth * somevoxelvirtualdesktopglobals.numberOfObjectInHeight * somevoxelvirtualdesktopglobals.numberOfObjectInDepth)
                                {
                                    if (indexofmeshinst >= 0 && indexofmeshinst < somevoxelvirtualdesktopglobals.numberOfInstancesPerObjectInWidth * somevoxelvirtualdesktopglobals.numberOfInstancesPerObjectInHeight * somevoxelvirtualdesktopglobals.numberOfInstancesPerObjectInDepth)
                                    {
                                        someinstancebytesindex = indexofbyte;

                                        if (someinstancebytesindex >= 0 && someinstancebytesindex < somevoxelvirtualdesktopglobals.tinyChunkWidth * somevoxelvirtualdesktopglobals.tinyChunkHeight * somevoxelvirtualdesktopglobals.tinyChunkDepth)
                                        {
                                            int currentIndex = someinstancebytesindex;
                                            int someOtherIndex = currentIndex;

                                            double currentMapData = -1;

                                            int chosenmap = 0;

                                            int somemul = 0;

                                            if (currentIndex >= 0 && currentIndex <= 63)
                                            {
                                                if (currentIndex >= 0 && currentIndex <= 3)
                                                {
                                                    currentMapData = (double)somevoxelvirtualdesktop[indexofmainobject].arrayofindexzeromesh[indexofmeshzero].instancesmatrix[indexofmeshinst].instancematrix.M11;//input.one;                                                                                                                                                                                                 //// MainWindow.MessageBox((IntPtr)0, "sccs:" + "map:" + (double)somevoxelvirtualdesktop[indexofmainobject].arrayofindexzeromesh[indexofmeshzero].instancesmatrix[indexofmeshinst].instancematrix.M11 , "sccs message 0", 0);

                                                    if (currentIndex >= 0 && currentIndex <= 1)
                                                    {
                                                        int somemax = 1;
                                                        someOtherIndex = 1 + ((somemax - someOtherIndex) * 2);
                                                    }
                                                    else if (currentIndex >= 2 && currentIndex <= 3)
                                                    {
                                                        int somemax = 3;
                                                        someOtherIndex = 0 + ((somemax - someOtherIndex) * 2);
                                                    }
                                                    chosenmap = 0;
                                                }
                                                else if (currentIndex >= 4 && currentIndex <= 7)
                                                {
                                                    currentMapData = (double)somevoxelvirtualdesktop[indexofmainobject].arrayofindexzeromesh[indexofmeshzero].instancesmatrix[indexofmeshinst].instancematrix.M12;//input.oneTwo;
                                                                                                                                                                                                                  //// MainWindow.MessageBox((IntPtr)0, "sccs:" + "map:" + (double)somevoxelvirtualdesktop[indexofmainobject].arrayofindexzeromesh[indexofmeshzero].instancesmatrix[indexofmeshinst].instancematrix.M12 , "sccs message 0", 0);

                                                    if (currentIndex >= 4 && currentIndex <= 5)
                                                    {
                                                        int somemax = 5;
                                                        someOtherIndex = 1 + ((somemax - someOtherIndex) * 2);
                                                    }
                                                    else if (currentIndex >= 6 && currentIndex <= 7)
                                                    {
                                                        int somemax = 7;
                                                        someOtherIndex = 0 + ((somemax - someOtherIndex) * 2);
                                                    }
                                                    chosenmap = 1;
                                                }
                                                else if (currentIndex >= 8 && currentIndex <= 11)
                                                {
                                                    currentMapData = (double)somevoxelvirtualdesktop[indexofmainobject].arrayofindexzeromesh[indexofmeshzero].instancesmatrix[indexofmeshinst].instancematrix.M13;
                                                    //// MainWindow.MessageBox((IntPtr)0, "sccs:" + "map:" + (double)somevoxelvirtualdesktop[indexofmainobject].arrayofindexzeromesh[indexofmeshzero].instancesmatrix[indexofmeshinst].instancematrix.M13 , "sccs message 0", 0);

                                                    if (currentIndex >= 8 && currentIndex <= 9)
                                                    {
                                                        int somemax = 9;
                                                        someOtherIndex = 1 + ((somemax - someOtherIndex) * 2);
                                                    }
                                                    else if (currentIndex >= 10 && currentIndex <= 11)
                                                    {
                                                        int somemax = 11;
                                                        someOtherIndex = 0 + ((somemax - someOtherIndex) * 2);
                                                    }
                                                    chosenmap = 2;
                                                }

                                                else if (currentIndex >= 12 && currentIndex <= 15)
                                                {
                                                    currentMapData = (double)somevoxelvirtualdesktop[indexofmainobject].arrayofindexzeromesh[indexofmeshzero].instancesmatrix[indexofmeshinst].instancematrix.M14;//input.twoTwo;
                                                                                                                                                                                                                  //// MainWindow.MessageBox((IntPtr)0, "sccs:" + "map:" + (double)somevoxelvirtualdesktop[indexofmainobject].arrayofindexzeromesh[indexofmeshzero].instancesmatrix[indexofmeshinst].instancematrix.M14 , "sccs message 0", 0);

                                                    if (currentIndex >= 12 && currentIndex <= 13)
                                                    {
                                                        int somemax = 13;
                                                        someOtherIndex = 1 + ((somemax - someOtherIndex) * 2);
                                                    }
                                                    else if (currentIndex >= 14 && currentIndex <= 15)
                                                    {
                                                        int somemax = 15;
                                                        someOtherIndex = 0 + ((somemax - someOtherIndex) * 2);
                                                    }
                                                    chosenmap = 3;
                                                }
                                                else if (currentIndex >= 16 && currentIndex <= 19)
                                                {
                                                    currentMapData = (double)somevoxelvirtualdesktop[indexofmainobject].arrayofindexzeromesh[indexofmeshzero].instancesmatrix[indexofmeshinst].instancematrix.M21;//input.three;
                                                                                                                                                                                                                  //// MainWindow.MessageBox((IntPtr)0, "sccs:" + "map:" + (double)somevoxelvirtualdesktop[indexofmainobject].arrayofindexzeromesh[indexofmeshzero].instancesmatrix[indexofmeshinst].instancematrix.M21 , "sccs message 0", 0);

                                                    if (currentIndex >= 16 && currentIndex <= 17)
                                                    {
                                                        int somemax = 17;
                                                        someOtherIndex = 1 + ((somemax - someOtherIndex) * 2);
                                                    }
                                                    else if (currentIndex >= 18 && currentIndex <= 19)
                                                    {
                                                        int somemax = 19;
                                                        someOtherIndex = 0 + ((somemax - someOtherIndex) * 2);
                                                    }
                                                    chosenmap = 4;
                                                }
                                                else if (currentIndex >= 20 && currentIndex <= 23)
                                                {
                                                    currentMapData = (double)somevoxelvirtualdesktop[indexofmainobject].arrayofindexzeromesh[indexofmeshzero].instancesmatrix[indexofmeshinst].instancematrix.M22; //input.mapmatrix1.y;//input.threeTwo;
                                                                                                                                                                                                                   //// MainWindow.MessageBox((IntPtr)0, "sccs:" + "map:" + (double)somevoxelvirtualdesktop[indexofmainobject].arrayofindexzeromesh[indexofmeshzero].instancesmatrix[indexofmeshinst].instancematrix.M22 , "sccs message 0", 0);

                                                    if (currentIndex >= 20 && currentIndex <= 21)
                                                    {
                                                        int somemax = 21;
                                                        someOtherIndex = 1 + ((somemax - someOtherIndex) * 2);
                                                    }
                                                    else if (currentIndex >= 22 && currentIndex <= 23)
                                                    {
                                                        int somemax = 23;
                                                        someOtherIndex = 0 + ((somemax - someOtherIndex) * 2);
                                                    }
                                                    chosenmap = 5;
                                                }
                                                else if (currentIndex >= 24 && currentIndex <= 27)
                                                {
                                                    currentMapData = (double)somevoxelvirtualdesktop[indexofmainobject].arrayofindexzeromesh[indexofmeshzero].instancesmatrix[indexofmeshinst].instancematrix.M23; //input.mapmatrix1.z;//input.four;
                                                                                                                                                                                                                   //// MainWindow.MessageBox((IntPtr)0, "sccs:" + "map:" + (double)somevoxelvirtualdesktop[indexofmainobject].arrayofindexzeromesh[indexofmeshzero].instancesmatrix[indexofmeshinst].instancematrix.M23 , "sccs message 0", 0);

                                                    if (currentIndex >= 24 && currentIndex <= 25)
                                                    {
                                                        int somemax = 25;
                                                        someOtherIndex = 1 + ((somemax - someOtherIndex) * 2);
                                                    }
                                                    else if (currentIndex >= 26 && currentIndex <= 27)
                                                    {
                                                        int somemax = 27;
                                                        someOtherIndex = 0 + ((somemax - someOtherIndex) * 2);
                                                    }
                                                    chosenmap = 6;
                                                }
                                                else if (currentIndex >= 28 && currentIndex <= 31)
                                                {
                                                    currentMapData = (double)somevoxelvirtualdesktop[indexofmainobject].arrayofindexzeromesh[indexofmeshzero].instancesmatrix[indexofmeshinst].instancematrix.M24; // input.mapmatrix1.w;//input.fourTwo;
                                                                                                                                                                                                                   //// MainWindow.MessageBox((IntPtr)0, "sccs:" + "map:" + (double)somevoxelvirtualdesktop[indexofmainobject].arrayofindexzeromesh[indexofmeshzero].instancesmatrix[indexofmeshinst].instancematrix.M24 , "sccs message 0", 0);

                                                    if (currentIndex >= 28 && currentIndex <= 29)
                                                    {
                                                        int somemax = 29;
                                                        someOtherIndex = 1 + ((somemax - someOtherIndex) * 2);
                                                    }
                                                    else if (currentIndex >= 30 && currentIndex <= 31)
                                                    {
                                                        int somemax = 31;
                                                        someOtherIndex = 0 + ((somemax - someOtherIndex) * 2);
                                                    }
                                                    chosenmap = 7;
                                                }
                                                else if (currentIndex >= 32 && currentIndex <= 35)
                                                {
                                                    currentMapData = (double)somevoxelvirtualdesktop[indexofmainobject].arrayofindexzeromesh[indexofmeshzero].instancesmatrix[indexofmeshinst].instancematrix.M31; // input.mapmatrix1.w;//input.fourTwo;
                                                                                                                                                                                                                   //// MainWindow.MessageBox((IntPtr)0, "sccs:" + "map:" + (double)somevoxelvirtualdesktop[indexofmainobject].arrayofindexzeromesh[indexofmeshzero].instancesmatrix[indexofmeshinst].instancematrix.M31, "sccs message 0", 0);

                                                    if (currentIndex >= 32 && currentIndex <= 33)
                                                    {
                                                        int somemax = 33;
                                                        someOtherIndex = 1 + ((somemax - someOtherIndex) * 2);
                                                    }
                                                    else if (currentIndex >= 34 && currentIndex <= 35)
                                                    {
                                                        int somemax = 35;
                                                        someOtherIndex = 0 + ((somemax - someOtherIndex) * 2);
                                                    }
                                                    chosenmap = 8;
                                                }
                                                else if (currentIndex >= 36 && currentIndex <= 39)
                                                {
                                                    currentMapData = (double)somevoxelvirtualdesktop[indexofmainobject].arrayofindexzeromesh[indexofmeshzero].instancesmatrix[indexofmeshinst].instancematrix.M32; // input.mapmatrix1.w;//input.fourTwo;
                                                                                                                                                                                                                   //// MainWindow.MessageBox((IntPtr)0, "sccs:" + "map:" + (double)somevoxelvirtualdesktop[indexofmainobject].arrayofindexzeromesh[indexofmeshzero].instancesmatrix[indexofmeshinst].instancematrix.M32, "sccs message 0", 0);

                                                    if (currentIndex >= 36 && currentIndex <= 37)
                                                    {
                                                        int somemax = 37;
                                                        someOtherIndex = 1 + ((somemax - someOtherIndex) * 2);
                                                    }
                                                    else if (currentIndex >= 38 && currentIndex <= 39)
                                                    {
                                                        int somemax = 39;
                                                        someOtherIndex = 0 + ((somemax - someOtherIndex) * 2);
                                                    }
                                                    chosenmap = 9;
                                                }
                                                else if (currentIndex >= 40 && currentIndex <= 43)
                                                {
                                                    currentMapData = (double)somevoxelvirtualdesktop[indexofmainobject].arrayofindexzeromesh[indexofmeshzero].instancesmatrix[indexofmeshinst].instancematrix.M33; // input.mapmatrix1.w;//input.fourTwo;
                                                                                                                                                                                                                   //// MainWindow.MessageBox((IntPtr)0, "sccs:" + "map:" + (double)somevoxelvirtualdesktop[indexofmainobject].arrayofindexzeromesh[indexofmeshzero].instancesmatrix[indexofmeshinst].instancematrix.M33, "sccs message 0", 0);

                                                    if (currentIndex >= 40 && currentIndex <= 41)
                                                    {
                                                        int somemax = 41;
                                                        someOtherIndex = 1 + ((somemax - someOtherIndex) * 2);
                                                    }
                                                    else if (currentIndex >= 42 && currentIndex <= 43)
                                                    {
                                                        int somemax = 43;
                                                        someOtherIndex = 0 + ((somemax - someOtherIndex) * 2);
                                                    }
                                                    chosenmap = 10;
                                                }
                                                else if (currentIndex >= 44 && currentIndex <= 47)
                                                {
                                                    currentMapData = (double)somevoxelvirtualdesktop[indexofmainobject].arrayofindexzeromesh[indexofmeshzero].instancesmatrix[indexofmeshinst].instancematrix.M34; // input.mapmatrix1.w;//input.fourTwo;
                                                                                                                                                                                                                   //// MainWindow.MessageBox((IntPtr)0, "sccs:" + "map:" + (double)somevoxelvirtualdesktop[indexofmainobject].arrayofindexzeromesh[indexofmeshzero].instancesmatrix[indexofmeshinst].instancematrix.M34, "sccs message 0", 0);

                                                    if (currentIndex >= 44 && currentIndex <= 45)
                                                    {
                                                        int somemax = 45;
                                                        someOtherIndex = 1 + ((somemax - someOtherIndex) * 2);
                                                    }
                                                    else if (currentIndex >= 46 && currentIndex <= 47)
                                                    {
                                                        int somemax = 47;
                                                        someOtherIndex = 0 + ((somemax - someOtherIndex) * 2);
                                                    }
                                                    chosenmap = 11;
                                                }
                                                else if (currentIndex >= 48 && currentIndex <= 51)
                                                {
                                                    currentMapData = (double)somevoxelvirtualdesktop[indexofmainobject].arrayofindexzeromesh[indexofmeshzero].instancesmatrix[indexofmeshinst].instancematrix.M41; // input.mapmatrix1.w;//input.fourTwo;
                                                                                                                                                                                                                   //// MainWindow.MessageBox((IntPtr)0, "sccs:" + "map:" + (double)somevoxelvirtualdesktop[indexofmainobject].arrayofindexzeromesh[indexofmeshzero].instancesmatrix[indexofmeshinst].instancematrix.M41, "sccs message 0", 0);

                                                    if (currentIndex >= 48 && currentIndex <= 49)
                                                    {
                                                        int somemax = 49;
                                                        someOtherIndex = 1 + ((somemax - someOtherIndex) * 2);
                                                    }
                                                    else if (currentIndex >= 50 && currentIndex <= 51)
                                                    {
                                                        int somemax = 51;
                                                        someOtherIndex = 0 + ((somemax - someOtherIndex) * 2);
                                                    }
                                                    chosenmap = 12;
                                                }
                                                else if (currentIndex >= 52 && currentIndex <= 55)
                                                {
                                                    currentMapData = (double)somevoxelvirtualdesktop[indexofmainobject].arrayofindexzeromesh[indexofmeshzero].instancesmatrix[indexofmeshinst].instancematrix.M42; // input.mapmatrix1.w;//input.fourTwo;
                                                                                                                                                                                                                   //// MainWindow.MessageBox((IntPtr)0, "sccs:" + "map:" + (double)somevoxelvirtualdesktop[indexofmainobject].arrayofindexzeromesh[indexofmeshzero].instancesmatrix[indexofmeshinst].instancematrix.M42, "sccs message 0", 0);

                                                    if (currentIndex >= 52 && currentIndex <= 53)
                                                    {
                                                        int somemax = 53;
                                                        someOtherIndex = 1 + ((somemax - someOtherIndex) * 2);
                                                    }
                                                    else if (currentIndex >= 54 && currentIndex <= 55)
                                                    {
                                                        int somemax = 55;
                                                        someOtherIndex = 0 + ((somemax - someOtherIndex) * 2);
                                                    }
                                                    chosenmap = 13;
                                                }
                                                else if (currentIndex >= 56 && currentIndex <= 59)
                                                {
                                                    currentMapData = (double)somevoxelvirtualdesktop[indexofmainobject].arrayofindexzeromesh[indexofmeshzero].instancesmatrix[indexofmeshinst].instancematrix.M43; // input.mapmatrix1.w;//input.fourTwo;
                                                                                                                                                                                                                   //// MainWindow.MessageBox((IntPtr)0, "sccs:" + "map:" + (double)somevoxelvirtualdesktop[indexofmainobject].arrayofindexzeromesh[indexofmeshzero].instancesmatrix[indexofmeshinst].instancematrix.M43 , "sccs message 0", 0);

                                                    if (currentIndex >= 56 && currentIndex <= 57)
                                                    {
                                                        int somemax = 57;
                                                        someOtherIndex = 1 + ((somemax - someOtherIndex) * 2);
                                                    }
                                                    else if (currentIndex >= 58 && currentIndex <= 59)
                                                    {
                                                        int somemax = 59;
                                                        someOtherIndex = 0 + ((somemax - someOtherIndex) * 2);
                                                    }
                                                    chosenmap = 14;
                                                }
                                                else if (currentIndex >= 60 && currentIndex <= 63)
                                                {
                                                    currentMapData = (double)somevoxelvirtualdesktop[indexofmainobject].arrayofindexzeromesh[indexofmeshzero].instancesmatrix[indexofmeshinst].instancematrix.M44; // input.mapmatrix1.w;//input.fourTwo;
                                                                                                                                                                                                                   //// MainWindow.MessageBox((IntPtr)0, "sccs:" + "map:" + (double)somevoxelvirtualdesktop[indexofmainobject].arrayofindexzeromesh[indexofmeshzero].instancesmatrix[indexofmeshinst].instancematrix.M44 , "sccs message 0", 0);

                                                    if (currentIndex >= 60 && currentIndex <= 61)
                                                    {
                                                        int somemax = 61;
                                                        someOtherIndex = 1 + ((somemax - someOtherIndex) * 2);
                                                    }
                                                    else if (currentIndex >= 62 && currentIndex <= 63)
                                                    {
                                                        int somemax = 63;
                                                        someOtherIndex = 0 + ((somemax - someOtherIndex) * 2);
                                                    }
                                                    chosenmap = 15;
                                                }


                                                //someOtherIndex = 2;

                                                double someothermul0 = 10.0;
                                                double someothermul1 = 1.0;

                                                if (someOtherIndex == 0)
                                                {
                                                    someothermul0 = 100.0;
                                                    someothermul1 = 0.1;
                                                }
                                                else if (someOtherIndex == 1)
                                                {
                                                    someothermul0 = 1000.0;
                                                    someothermul1 = 0.01;
                                                }
                                                else if (someOtherIndex == 2)
                                                {
                                                    someothermul0 = 10000.0;
                                                    someothermul1 = 0.001;
                                                }
                                                else if (someOtherIndex == 3)
                                                {
                                                    someothermul0 = 100000.0;
                                                    someothermul1 = 0.0001;
                                                }

                                                double[] arrayOfDigits = new double[4];// = {0,0,0,0,0,0,0,0,0};

                                                //double someorimap = 51234;
                                                double somemap = currentMapData;// 51234; //currentMapData

                                                double tempsomemap;
                                                double someotherbyte;

                                                for (int i = 0; i < 4; i++) //111111111 // 6th digit //someOtherIndex
                                                {
                                                    tempsomemap = somemap;
                                                    somemap = (somemap * 0.1);
                                                    //MainWindow.MessageBox((IntPtr)0, "/somemap:" + somemap, "sccs message 1", 0);
                                                    var somevalue = Math.Floor((double)(int)((somemap - (int)somemap) * someothermul0)) * someothermul1;
                                                    somevalue = somevalue - (Math.Floor(somevalue * 0.1) * 10);

                                                    arrayOfDigits[i] = somevalue;

                                                    //MainWindow.MessageBox((IntPtr)0, "/arrayOfDigits[i]:" + arrayOfDigits[i] + "/somevalue:" + somevalue, "sccs message 1", 0);
                                                }




                                                double[] arrayOfDigits1 = new double[5];// = {0,0,0,0,0,0,0,0,0};

                                                //double someorimap = 51234;
                                                double somemap1 = currentMapData;// 51234; //currentMapData

                                                double tempsomemap1;
                                                double someotherbyte1;

                                                for (int i = 0; i < 5; i++) //111111111 // 6th digit //someOtherIndex
                                                {
                                                    tempsomemap1 = somemap1;
                                                    somemap1 = (somemap1 * 0.1);
                                                    //MainWindow.MessageBox((IntPtr)0, "/somemap:" + somemap, "sccs message 1", 0);
                                                    var somevalue1 = Math.Floor((double)(int)((somemap1 - (int)somemap1) * 100000.0)) * 0.0001;
                                                    somevalue1 = somevalue1 - (Math.Floor(somevalue1 * 0.1) * 10);

                                                    arrayOfDigits1[i] = somevalue1;

                                                    //MainWindow.MessageBox((IntPtr)0, "/arrayOfDigits[i]:" + arrayOfDigits[i] + "/somevalue:" + somevalue, "sccs message 1", 0);
                                                }

                                                //MainWindow.MessageBox((IntPtr)0, "/arrayOfDigits1[i]:" + arrayOfDigits1[arrayOfDigits1.Length-1], "sccs message 1", 0);

                                                var someotherindex1 = 3 - someOtherIndex;

                                                if (someOtherIndex == 0)
                                                {
                                                    someothermul0 = 10.0;
                                                    someothermul1 = 1.0;
                                                }
                                                else if (someOtherIndex == 1)
                                                {
                                                    someothermul0 = 100.0;
                                                    someothermul1 = 0.1;
                                                }
                                                else if (someOtherIndex == 2)
                                                {
                                                    someothermul0 = 1000.0;
                                                    someothermul1 = 0.01;
                                                }
                                                else if (someOtherIndex == 3)
                                                {
                                                    someothermul0 = 10000.0;
                                                    someothermul1 = 0.001;
                                                }

                                                //currentMapData = 51234.0;
                                                currentMapData *= 0.0001f;
                                                currentMapData = Math.Round(currentMapData * 100000) * 0.00001; // 5.1111

                                                double double_value = currentMapData;
                                                double double_result = ((double_value - Math.Floor(double_value)) * someothermul0) - Math.Floor((Math.Floor(Math.Floor((double_value - Math.Floor(double_value)) * someothermul0) * 0.1f) * 10));// == 0.345f







                                                //somevoxelvirtualdesktoppriminstance[indexofmainobject].arrayofindexzeromesh[indexofmeshzero].somechunk[indexofmeshinst].somechunkpos.X
                                                //Matrix worldmatrixofvoxelobject = somevoxelvirtualdesktop[0].worldmatofobj;
                                                //somevoxelvirtualdesktoppriminstance[indexofmainobject].arrayofindexzeromesh[indexofmeshzero].somechunk[indexofmeshinst].somechunkpos = 
                                                Vector3 somechunkbyteposition = new Vector3(somevoxelvirtualdesktop[0].worldmatofobj.M41, somevoxelvirtualdesktop[0].worldmatofobj.M42, somevoxelvirtualdesktop[0].worldmatofobj.M43);

                                                Matrix worldmatrixofvoxelobject = somevoxelvirtualdesktop[indexofmainobject].worldmatofobj;
                                                Quaternion somedirquat;
                                                Quaternion.RotationMatrix(ref worldmatrixofvoxelobject, out somedirquat);

                                                var dirInstanceRight = -sc_maths._newgetdirleft(somedirquat);
                                                var dirInstanceUp = sc_maths._newgetdirup(somedirquat);
                                                var dirInstanceForward = sc_maths._newgetdirforward(somedirquat);

                                                Vector3 somechunkbyteposition1 = new Vector3(somevoxelvirtualdesktop[indexofmainobject].worldmatofobj.M41, somevoxelvirtualdesktop[indexofmainobject].worldmatofobj.M42, somevoxelvirtualdesktop[indexofmainobject].worldmatofobj.M43);

                                                Matrix worldmatrixofvoxelobject1 = somevoxelvirtualdesktop[indexofmainobject].worldmatofobj; //Matrix.Identity;// 
                                                Quaternion.RotationMatrix(ref worldmatrixofvoxelobject1, out somedirquat);

                                                var dirInstanceRight1 = sc_maths._newgetdirleft(somedirquat);
                                                var dirInstanceUp1 = sc_maths._newgetdirup(somedirquat);
                                                var dirInstanceForward1 = sc_maths._newgetdirforward(somedirquat);

                                                float somemulsize = planeSize * 2;
                                                float somemulsize1 = planeSize;


                                                /*float somemulsizemainobjectx = 1;// / somevoxelvirtualdesktopw;// somevoxelvirtualdesktopglobals.numberOfObjectInHeight;// (planeSize * 10) * 0.5f;
                                                float somemulsizemainobjecty = 1;// / somevoxelvirtualdesktoph;// somevoxelvirtualdesktopglobals.numberOfInstancesPerObjectInHeight;// (planeSize * 10) * 0.5f;
                                                float somemulsizemainobjectz = 1;// / somevoxelvirtualdesktopd;// somevoxelvirtualdesktopglobals.numberOfInstancesPerObjectInDepth;// (planeSize * 10) * 0.5f;

                                                float somemulsizemainsubmeshx = 1;// / somevoxelvirtualdesktopglobals.numberOfObjectInWidth;// (planeSize * 10) * 0.5f;
                                                float somemulsizemainsubmeshy = 1;// / somevoxelvirtualdesktopglobals.numberOfObjectInHeight;// (planeSize * 10) * 0.5f;
                                                float somemulsizemainsubmeshz = 1;// / somevoxelvirtualdesktopglobals.numberOfObjectInDepth;// (planeSize * 10) * 0.5f;

                                                float somemulsizemainsubmeshinstx = 1;// / somevoxelvirtualdesktopglobals.numberOfInstancesPerObjectInWidth;// (planeSize * 10) * 0.5f;
                                                float somemulsizemainsubmeshinsty = 1;// / somevoxelvirtualdesktopglobals.numberOfInstancesPerObjectInHeight;// (planeSize * 10) * 0.5f;
                                                float somemulsizemainsubmeshinstz = 1;// / somevoxelvirtualdesktopglobals.numberOfInstancesPerObjectInDepth;// (planeSize * 10) * 0.5f;

                                                float somemulsizemainsubmeshinstbytex = 1;// / somevoxelvirtualdesktopglobals.tinyChunkWidth;// (planeSize * 10) * 0.5f;
                                                float somemulsizemainsubmeshinstbytey = 1;// / somevoxelvirtualdesktopglobals.tinyChunkHeight;// (planeSize * 10) * 0.5f;
                                                float somemulsizemainsubmeshinstbytez = 1;// / somevoxelvirtualdesktopglobals.tinyChunkDepth;// (planeSize * 10) * 0.5f;
                                                */
                                                float somemulsizemainobjectx = 1.0f / (float)somechunkkeyboardw;// / somechunkkeyboardw;// somevoxelvirtualdesktopglobals.numberOfObjectInHeight;// (planeSize * 10) * 0.5f;
                                                float somemulsizemainobjecty = 1.0f / (float)somechunkkeyboardh;// / somechunkkeyboardh;// somevoxelvirtualdesktopglobals.numberOfInstancesPerObjectInHeight;// (planeSize * 10) * 0.5f;
                                                float somemulsizemainobjectz = 1.0f / (float)somechunkkeyboardd;// / somechunkkeyboardd;// somevoxelvirtualdesktopglobals.numberOfInstancesPerObjectInDepth;// (planeSize * 10) * 0.5f;

                                                float somemulsizemainsubmeshx = 1.0f / (float)somevoxelvirtualdesktopglobals.numberOfObjectInWidth;// / somevoxelvirtualdesktopglobals.numberOfObjectInWidth;// (planeSize * 10) * 0.5f;
                                                float somemulsizemainsubmeshy = 1.0f / (float)somevoxelvirtualdesktopglobals.numberOfObjectInHeight;// / somevoxelvirtualdesktopglobals.numberOfObjectInHeight;// (planeSize * 10) * 0.5f;
                                                float somemulsizemainsubmeshz = 1.0f / (float)somevoxelvirtualdesktopglobals.numberOfObjectInDepth;// / somevoxelvirtualdesktopglobals.numberOfObjectInDepth;// (planeSize * 10) * 0.5f;

                                                float somemulsizemainsubmeshinstx = 1.0f / (float)somevoxelvirtualdesktopglobals.numberOfInstancesPerObjectInWidth;// / somevoxelvirtualdesktopglobals.numberOfInstancesPerObjectInWidth;// (planeSize * 10) * 0.5f;
                                                float somemulsizemainsubmeshinsty = 1.0f / (float)somevoxelvirtualdesktopglobals.numberOfInstancesPerObjectInHeight;// / somevoxelvirtualdesktopglobals.numberOfInstancesPerObjectInHeight;// (planeSize * 10) * 0.5f;
                                                float somemulsizemainsubmeshinstz = 1.0f / (float)somevoxelvirtualdesktopglobals.numberOfInstancesPerObjectInDepth;// / somevoxelvirtualdesktopglobals.numberOfInstancesPerObjectInDepth;// (planeSize * 10) * 0.5f;

                                                float somemulsizemainsubmeshinstbytex = 1.0f / (float)somevoxelvirtualdesktopglobals.tinyChunkWidth;// / somevoxelvirtualdesktopglobals.tinyChunkWidth;// (planeSize * 10) * 0.5f;
                                                float somemulsizemainsubmeshinstbytey = 1.0f / (float)somevoxelvirtualdesktopglobals.tinyChunkHeight;// / somevoxelvirtualdesktopglobals.tinyChunkHeight;// (planeSize * 10) * 0.5f;
                                                float somemulsizemainsubmeshinstbytez = 1.0f / (float)somevoxelvirtualdesktopglobals.tinyChunkDepth;// / somevoxelvirtualdesktopglobals.tinyChunkDepth;// (planeSize * 10) * 0.5f;


                                                somemulsize = (planeSize * 10) * 0.5f;
                                                somemulsize1 = planeSize;

                                                somechunkbyteposition += (dirInstanceRight * ((somevoxelvirtualdesktopw * somemulsizemainobjectx) * (somevoxelvirtualdesktopglobals.numberOfObjectInWidth * somemulsizemainsubmeshx) * (somevoxelvirtualdesktopglobals.numberOfInstancesPerObjectInWidth * somemulsizemainsubmeshinstx) * (somevoxelvirtualdesktopglobals.tinyChunkWidth * somemulsizemainsubmeshinstbytex)) * indexmainobjectx * somemulsize1);
                                                somechunkbyteposition += (dirInstanceRight * ((somevoxelvirtualdesktopglobals.numberOfObjectInWidth * somemulsizemainsubmeshx) * (somevoxelvirtualdesktopglobals.numberOfInstancesPerObjectInWidth * somemulsizemainsubmeshinstx) * (somevoxelvirtualdesktopglobals.tinyChunkWidth * somemulsizemainsubmeshinstbytex)) * indexmeshzerox * somemulsize1);
                                                somechunkbyteposition += (dirInstanceRight * ((somevoxelvirtualdesktopglobals.numberOfInstancesPerObjectInWidth * somemulsizemainsubmeshinstx) * (somevoxelvirtualdesktopglobals.tinyChunkWidth * somemulsizemainsubmeshinstbytex)) * indexofmeshinstx * somemulsize1);
                                                somechunkbyteposition += (dirInstanceRight * ((somevoxelvirtualdesktopglobals.tinyChunkWidth * somemulsizemainsubmeshinstbytex)) * indexbytex * somemulsize1);

                                                somechunkbyteposition += (dirInstanceUp * ((somevoxelvirtualdesktoph * somemulsizemainobjecty) * (somevoxelvirtualdesktopglobals.numberOfObjectInHeight * somemulsizemainsubmeshy) * (somevoxelvirtualdesktopglobals.numberOfInstancesPerObjectInHeight * somemulsizemainsubmeshinsty) * (somevoxelvirtualdesktopglobals.tinyChunkHeight * somemulsizemainsubmeshinstbytey)) * indexmainobjecty * somemulsize1);
                                                somechunkbyteposition += (dirInstanceUp * ((somevoxelvirtualdesktopglobals.numberOfObjectInHeight * somemulsizemainsubmeshy) * (somevoxelvirtualdesktopglobals.numberOfInstancesPerObjectInHeight * somemulsizemainsubmeshinsty) * (somevoxelvirtualdesktopglobals.tinyChunkHeight * somemulsizemainsubmeshinstbytey)) * indexmeshzeroy * somemulsize1);
                                                somechunkbyteposition += (dirInstanceUp * ((somevoxelvirtualdesktopglobals.numberOfInstancesPerObjectInHeight * somemulsizemainsubmeshinsty) * (somevoxelvirtualdesktopglobals.tinyChunkHeight * somemulsizemainsubmeshinstbytey)) * indexofmeshinsty * somemulsize1);
                                                somechunkbyteposition += (dirInstanceUp * ((somevoxelvirtualdesktopglobals.tinyChunkHeight * somemulsizemainsubmeshinstbytey)) * indexbytey * somemulsize1);

                                                somechunkbyteposition += (dirInstanceForward * ((somevoxelvirtualdesktopd * somemulsizemainobjectz) * (somevoxelvirtualdesktopglobals.numberOfObjectInDepth * somemulsizemainsubmeshz) * (somevoxelvirtualdesktopglobals.numberOfInstancesPerObjectInDepth * somemulsizemainsubmeshinstz) * (somevoxelvirtualdesktopglobals.tinyChunkDepth * somemulsizemainsubmeshinstbytez)) * indexmainobjectz * somemulsize1);
                                                somechunkbyteposition += (dirInstanceForward * ((somevoxelvirtualdesktopglobals.numberOfObjectInDepth * somemulsizemainsubmeshz) * (somevoxelvirtualdesktopglobals.numberOfInstancesPerObjectInDepth * somemulsizemainsubmeshinstz) * (somevoxelvirtualdesktopglobals.tinyChunkDepth * somemulsizemainsubmeshinstbytez)) * indexmeshzeroz * somemulsize1);
                                                somechunkbyteposition += (dirInstanceForward * ((somevoxelvirtualdesktopglobals.numberOfInstancesPerObjectInDepth * somemulsizemainsubmeshinstz) * (somevoxelvirtualdesktopglobals.tinyChunkDepth * somemulsizemainsubmeshinstbytez)) * indexofmeshinstz * somemulsize1);
                                                somechunkbyteposition += (dirInstanceForward * ((somevoxelvirtualdesktopglobals.tinyChunkDepth * somemulsizemainsubmeshinstbytez)) * indexbytez * somemulsize1);



                                                somemulsizemainobjectx = 1.0f / (float)somechunkkeyboardw;// / somechunkkeyboardw;// somevoxelvirtualdesktopglobals.numberOfObjectInHeight;// (planeSize * 10) * 0.5f;
                                                somemulsizemainobjecty = 1.0f / (float)somechunkkeyboardh;// / somechunkkeyboardh;// somevoxelvirtualdesktopglobals.numberOfInstancesPerObjectInHeight;// (planeSize * 10) * 0.5f;
                                                somemulsizemainobjectz = 1.0f / (float)somechunkkeyboardd;// / somechunkkeyboardd;// somevoxelvirtualdesktopglobals.numberOfInstancesPerObjectInDepth;// (planeSize * 10) * 0.5f;

                                                somemulsizemainsubmeshx = 1.0f / (float)somevoxelvirtualdesktopglobals.numberOfObjectInWidth;// / somevoxelvirtualdesktopglobals.numberOfObjectInWidth;// (planeSize * 10) * 0.5f;
                                                somemulsizemainsubmeshy = 1.0f / (float)somevoxelvirtualdesktopglobals.numberOfObjectInHeight;// / somevoxelvirtualdesktopglobals.numberOfObjectInHeight;// (planeSize * 10) * 0.5f;
                                                somemulsizemainsubmeshz = 1.0f / (float)somevoxelvirtualdesktopglobals.numberOfObjectInDepth;// / somevoxelvirtualdesktopglobals.numberOfObjectInDepth;// (planeSize * 10) * 0.5f;

                                                somemulsizemainsubmeshinstx = 1.0f / (float)somevoxelvirtualdesktopglobals.numberOfInstancesPerObjectInWidth;// / somevoxelvirtualdesktopglobals.numberOfInstancesPerObjectInWidth;// (planeSize * 10) * 0.5f;
                                                somemulsizemainsubmeshinsty = 1.0f / (float)somevoxelvirtualdesktopglobals.numberOfInstancesPerObjectInHeight;// / somevoxelvirtualdesktopglobals.numberOfInstancesPerObjectInHeight;// (planeSize * 10) * 0.5f;
                                                somemulsizemainsubmeshinstz = 1.0f / (float)somevoxelvirtualdesktopglobals.numberOfInstancesPerObjectInDepth;// / somevoxelvirtualdesktopglobals.numberOfInstancesPerObjectInDepth;// (planeSize * 10) * 0.5f;

                                                somemulsizemainsubmeshinstbytex = 1.0f / (float)somevoxelvirtualdesktopglobals.tinyChunkWidth;// / somevoxelvirtualdesktopglobals.tinyChunkWidth;// (planeSize * 10) * 0.5f;
                                                somemulsizemainsubmeshinstbytey = 1.0f / (float)somevoxelvirtualdesktopglobals.tinyChunkHeight;// / somevoxelvirtualdesktopglobals.tinyChunkHeight;// (planeSize * 10) * 0.5f;
                                                somemulsizemainsubmeshinstbytez = 1.0f / (float)somevoxelvirtualdesktopglobals.tinyChunkDepth;// / somevoxelvirtualdesktopglobals.tinyChunkDepth;// (planeSize * 10) * 0.5f;

                                                somemulsize1 = planeSize;


                                                somechunkbyteposition1 += (dirInstanceRight1 * ((somevoxelvirtualdesktopglobals.numberOfObjectInWidth) * (somevoxelvirtualdesktopglobals.numberOfInstancesPerObjectInWidth) * (somevoxelvirtualdesktopglobals.tinyChunkWidth)) * indexmainobjectx * somemulsize1);
                                                somechunkbyteposition1 += (dirInstanceRight1 * ((somevoxelvirtualdesktopglobals.numberOfInstancesPerObjectInWidth * somevoxelvirtualdesktopglobals.tinyChunkWidth)) * indexmeshzerox * somemulsize1);
                                                somechunkbyteposition1 += (dirInstanceRight1 * ((somevoxelvirtualdesktopglobals.tinyChunkWidth)) * indexofmeshinstx * somemulsize1);
                                                somechunkbyteposition1 += (dirInstanceRight1 * ((somevoxelvirtualdesktopglobals.tinyChunkWidth * somemulsizemainsubmeshinstbytex)) * indexbytex * somemulsize1);

                                                somechunkbyteposition1 += (dirInstanceUp1 * ((somevoxelvirtualdesktopglobals.numberOfObjectInHeight) * (somevoxelvirtualdesktopglobals.numberOfInstancesPerObjectInHeight) * (somevoxelvirtualdesktopglobals.tinyChunkHeight)) * indexmainobjecty * somemulsize1);
                                                somechunkbyteposition1 += (dirInstanceUp1 * ((somevoxelvirtualdesktopglobals.numberOfInstancesPerObjectInHeight * somevoxelvirtualdesktopglobals.tinyChunkHeight)) * indexmeshzeroy * somemulsize1);
                                                somechunkbyteposition1 += (dirInstanceUp1 * ((somevoxelvirtualdesktopglobals.tinyChunkHeight)) * indexofmeshinsty * somemulsize1);
                                                somechunkbyteposition1 += (dirInstanceUp1 * ((somevoxelvirtualdesktopglobals.tinyChunkHeight * somemulsizemainsubmeshinstbytey)) * indexbytey * somemulsize1);

                                                somechunkbyteposition1 += (dirInstanceForward1 * ((somevoxelvirtualdesktopglobals.numberOfObjectInDepth) * (somevoxelvirtualdesktopglobals.numberOfInstancesPerObjectInDepth) * (somevoxelvirtualdesktopglobals.tinyChunkDepth)) * indexmainobjectz * somemulsize1);
                                                somechunkbyteposition1 += (dirInstanceForward1 * ((somevoxelvirtualdesktopglobals.numberOfInstancesPerObjectInDepth * somevoxelvirtualdesktopglobals.tinyChunkDepth)) * indexmeshzeroz * somemulsize1);
                                                somechunkbyteposition1 += (dirInstanceForward1 * ((somevoxelvirtualdesktopglobals.tinyChunkDepth)) * indexofmeshinstz * somemulsize1);
                                                somechunkbyteposition1 += (dirInstanceForward1 * ((somevoxelvirtualdesktopglobals.tinyChunkDepth * somemulsizemainsubmeshinstbytez)) * indexbytez * somemulsize1);


                                                Vector3 mainmeshpos = new Vector3(somevoxelvirtualdesktop[0].worldmatofobj.M41, somevoxelvirtualdesktop[0].worldmatofobj.M42, somevoxelvirtualdesktop[0].worldmatofobj.M43);

                                                Vector3 tempvecpickaxehitpoint = pickaxetippoint;
                                                tempvecpickaxehitpoint.X += somevoxelvirtualdesktopglobals.planeSize * 0.5f;
                                                tempvecpickaxehitpoint.Y += somevoxelvirtualdesktopglobals.planeSize * 0.5f;
                                                tempvecpickaxehitpoint.Z += somevoxelvirtualdesktopglobals.planeSize * 0.5f;

                                                pickaxetippoint.X = (float)Math.Round(pickaxetippoint.X / somevoxelvirtualdesktopglobals.planeSize) * somevoxelvirtualdesktopglobals.planeSize;
                                                pickaxetippoint.Y = (float)Math.Round(pickaxetippoint.Y / somevoxelvirtualdesktopglobals.planeSize) * somevoxelvirtualdesktopglobals.planeSize;
                                                pickaxetippoint.Z = (float)Math.Round(pickaxetippoint.Z / somevoxelvirtualdesktopglobals.planeSize) * somevoxelvirtualdesktopglobals.planeSize;


                                                worldMatrix_instances_voxel_cube[0][0][2].M41 = somechunkbyteposition.X;// + mainmeshpos.X;// + mainmeshpos.X;
                                                worldMatrix_instances_voxel_cube[0][0][2].M42 = somechunkbyteposition.Y;//  + mainmeshpos.Y;// + mainmeshpos.Y;
                                                worldMatrix_instances_voxel_cube[0][0][2].M43 = somechunkbyteposition.Z;//  + mainmeshpos.Z;// + mainmeshpos.Z;


                                                worldMatrix_instances_voxel_cube[0][0][0].M41 = pickaxetippoint.X;
                                                worldMatrix_instances_voxel_cube[0][0][0].M42 = pickaxetippoint.Y;
                                                worldMatrix_instances_voxel_cube[0][0][0].M43 = pickaxetippoint.Z;






                                                //Vector3 somechunkbyteposition1 = new Vector3(somevoxelvirtualdesktop[0].worldmatofobj.M41, somevoxelvirtualdesktop[0].worldmatofobj.M42, somevoxelvirtualdesktop[0].worldmatofobj.M43);
                                                mainmeshpos = new Vector3(somevoxelvirtualdesktop[0].worldmatofobj.M41, somevoxelvirtualdesktop[0].worldmatofobj.M42, somevoxelvirtualdesktop[0].worldmatofobj.M43);




                                                //SET THE BYTE LOCATOR OBJECT TO THE LOCATION OF THE BYTE ON THE CHUNK IN ORDER TO HAVE A VISUAL ON WHERE THE BYTE LOCATOR IS IN CODE
                                                //SET THE BYTE LOCATOR OBJECT TO THE LOCATION OF THE BYTE ON THE CHUNK IN ORDER TO HAVE A VISUAL ON WHERE THE BYTE LOCATOR IS IN CODE
                                                //SET THE BYTE LOCATOR OBJECT TO THE LOCATION OF THE BYTE ON THE CHUNK IN ORDER TO HAVE A VISUAL ON WHERE THE BYTE LOCATOR IS IN CODE
                                                worldMatrix_instances_voxel_cube[0][0][4].M41 = somechunkbyteposition1.X;
                                                worldMatrix_instances_voxel_cube[0][0][4].M42 = somechunkbyteposition1.Y;
                                                worldMatrix_instances_voxel_cube[0][0][4].M43 = somechunkbyteposition1.Z;
                                                //SET THE BYTE LOCATOR OBJECT TO THE LOCATION OF THE BYTE ON THE CHUNK IN ORDER TO HAVE A VISUAL ON WHERE THE BYTE LOCATOR IS IN CODE
                                                //SET THE BYTE LOCATOR OBJECT TO THE LOCATION OF THE BYTE ON THE CHUNK IN ORDER TO HAVE A VISUAL ON WHERE THE BYTE LOCATOR IS IN CODE
                                                //SET THE BYTE LOCATOR OBJECT TO THE LOCATION OF THE BYTE ON THE CHUNK IN ORDER TO HAVE A VISUAL ON WHERE THE BYTE LOCATOR IS IN CODE

                                                pickaxetippoint.X = (float)Math.Round(pickaxetippoint.X / planeSize);
                                                worldMatrix_instances_voxel_cube[0][0][2].M41 = (float)Math.Round(worldMatrix_instances_voxel_cube[0][0][2].M41 / planeSize);

                                                pickaxetippoint.Y = (float)Math.Round(pickaxetippoint.Y / planeSize);
                                                worldMatrix_instances_voxel_cube[0][0][2].M42 = (float)Math.Round(worldMatrix_instances_voxel_cube[0][0][2].M42 / planeSize);

                                                pickaxetippoint.Z = (float)Math.Round(pickaxetippoint.Z / planeSize);
                                                worldMatrix_instances_voxel_cube[0][0][2].M43 = (float)Math.Round(worldMatrix_instances_voxel_cube[0][0][2].M43 / planeSize);

                                                Vector3 positionofhitbyte = new Vector3(worldMatrix_instances_voxel_cube[0][0][0].M41, worldMatrix_instances_voxel_cube[0][0][0].M42, worldMatrix_instances_voxel_cube[0][0][0].M43);

                                                if (consolewritecounter >= consolewritecountermax)
                                                {
                                                    if (consolewritecounterswtc == 0)
                                                    {

                                                        consolewritecounterswtc = 1;
                                                    }

                                                    /*for (int sc = 0; sc < 30; sc++) //Console.WindowWidth - 1
                                                    {
                                                        Console.SetCursorPosition(sc, 0);
                                                        Console.WriteLine(" ");
                                                        //Console.SetCursorPosition(sc, 1);
                                                        //Console.WriteLine(" ");
                                                        //Console.SetCursorPosition(sc, 1);
                                                        //Console.WriteLine(" ");
                                                        //Console.SetCursorPosition(sc, 3);
                                                        //Console.WriteLine(" ");
                                                        //Console.SetCursorPosition(sc, 4);
                                                        //Console.WriteLine(" ");
                                                    }*/

                                                    //Console.SetCursorPosition(0, 0);
                                                    //Console.WriteLine("x:" + +mainx + "/y:" + mainy + "/z:" + mainz);

                                                    //Console.SetCursorPosition(0, 1);
                                                    //Console.WriteLine("secx:" + +secx + "/secy:" + secy + "/secz:" + secz);

                                                    //Console.SetCursorPosition(0, 0);
                                                    //Console.WriteLine("somefx:" + +somefx + "/somefy:" + somefy + "/somefz:" + somefz);

                                                    //Console.SetCursorPosition(0, 0);
                                                    //Console.WriteLine("fobjmeshx:" + +fobjmeshx + "/fobjmeshy:" + fobjmeshy + "/fobjmeshz:" + fobjmeshz);

                                                    //Console.Title = "fobjmeshx:" + +fobjmeshx + "/fobjmeshy:" + fobjmeshy + "/fobjmeshz:" + fobjmeshz;
                                                    //Console.Title = "fobjmeshx:" + +fobjmeshx + "/fobjmeshy:" + fobjmeshy + "/fobjmeshz:" + fobjmeshz;
                                                    //Console.Title = "finstx:" + +finstx + "/finsty:" + finsty + "/finstz:" + finstz;
                                                    //Console.Title = "mainx:" + mainx + "/mainy:" + mainy + "/mainz:" + mainz;
                                                    //Console.Title = "someothermainx:" + someothermainx + "/someothermainy:" + someothermainy + "/someothermainz:" + someothermainz + "/fobjmeshx:" + +fobjmeshx + "/fobjmeshy:" + fobjmeshy + "/fobjmeshz:" + fobjmeshz;
                                                    //Console.Title = "/someothermainx:" + someothermainx + "/someothermainy:" + someothermainy + "/someothermainz:" + someothermainz +"/fobjmeshmainx:" + fobjmeshmainx + "/fobjmeshmainy:" + fobjmeshmainy + "/fobjmeshmainz:" + fobjmeshmainz + "/fobjmeshx:" + +fobjmeshx + "/fobjmeshy:" + fobjmeshy + "/fobjmeshz:" + fobjmeshz;

                                                    //Console.Title = "someinstx:" + (int)someinstx + "/someinsty:" + (int)someinsty + "/someinstz:" + (int)someinstz;

                                                    //Console.Title = "somefx:" + +somefx + "/somefy:" + somefy + "/somefz:" + somefz;

                                                    /*int indexbytex = remainderbytesx;
                                                    int indexbytey = remainderbytesy;
                                                    int indexbytez = remainderbytesz;
                                                    int indexofbyte = (indexbytex) + (someglobalschunkkeyboard.tinyChunkWidth) * ((indexbytey) + (someglobalschunkkeyboard.tinyChunkHeight) * (indexbytez));

                                                    int indexmeshinstx = remaindermeshinstx;
                                                    int indexmeshinsty = remaindermeshinsty;
                                                    int indexmeshinstz = remaindermeshinstz;
                                                    int indexofmeshinst = (indexmeshinstx) + (someglobalschunkkeyboard.numberOfInstancesPerObjectInWidth) * ((indexmeshinsty) + (someglobalschunkkeyboard.numberOfInstancesPerObjectInHeight) * (indexmeshinstz));

                                                    int indexmeshzerox = remaindermeshinstx;
                                                    int indexmeshzeroy = remaindermeshinsty;
                                                    int indexmeshzeroz = remaindermeshinstz;
                                                    int indexofmeshzero = (indexmeshzerox) + (someglobalschunkkeyboard.numberOfObjectInWidth) * ((indexmeshzeroy) + (someglobalschunkkeyboard.numberOfObjectInHeight) * (indexmeshzeroz));

                                                    int indexmainobjectx = remaindermeshinstx;
                                                    int indexmainobjecty = remaindermeshinsty;
                                                    int indexmainobjectz = remaindermeshinstz;
                                                    int indexofmainobject = (indexmainobjectx) + (somevoxelvirtualdesktopswidth) * ((indexmainobjecty) + (somevoxelvirtualdesktopsheight) * (indexmainobjectz));

                                                    //Console.Title = "indexbytex:" + (int)indexbytex + "/indexbytey:" + (int)indexbytey + "/indexbytez:" + (int)indexbytez;
                                                    //Console.Title = "indexofmeshinstx:" + (int)indexofmeshinstx + "/indexofmeshinsty:" + (int)indexofmeshinsty + "/indexofmeshinstz:" + (int)indexofmeshinstz;

                                                    ///Console.Title = "/bx:" + positionofhitbyte.X + "/by:" + positionofhitbyte.Y + "/bz:" + positionofhitbyte.Z + "/px:" + tempvecpickaxehitpoint.X + "/py:" + tempvecpickaxehitpoint.Y + "/pz:" + tempvecpickaxehitpoint.Z;
                                                    //Console.Title = "/bx:" + pickaxetippoint.X + "/by:" + pickaxetippoint.Y + "/bz:" + pickaxetippoint.Z + "/x:" + worldMatrix_instances_voxel_cube[0][0][2].M41 + "/y:" + worldMatrix_instances_voxel_cube[0][0][2].M42 + "/z:" + worldMatrix_instances_voxel_cube[0][0][2].M43;
                                                    // + somediff0x + "/y:" + somediff0y + "/z:" + somediff0z +  + somediff0x + "/y:" + somediff0y + "/z:" + somediff0z + 
                                                    //Console.Title = "/indexmeshzerox:" + (int)indexmeshzerox + "/indexmeshzeroy:" + (int)indexmeshzeroy + "/indexmeshzeroz:" + (int)indexmeshzeroz;

                                                    // "/x:" + somemainobjmeshpos.X + "/y:" + somemainobjmeshpos.Y + "/z:" + somemainobjmeshpos.Z + 
                                                    //Console.Title ="/x:" + mainmeshpos.X + "/y:" + mainmeshpos.Y + "/z:" + mainmeshpos.Z + "/bx:" + pickaxetippoint.X + "/by:" + pickaxetippoint.Y + "/bz:" + pickaxetippoint.Z + "/x:" + worldMatrix_instances_voxel_cube[0][0][0].M41 + "/y:" + worldMatrix_instances_voxel_cube[0][0][0].M42 + "/z:" + worldMatrix_instances_voxel_cube[0][0][0].M43 + "/x:" + worldMatrix_instances_voxel_cube[0][0][2].M41 + "/y:" + worldMatrix_instances_voxel_cube[0][0][2].M42 + "/z:" + worldMatrix_instances_voxel_cube[0][0][2].M43 + "/x:" + worldMatrix_instances_voxel_cube[0][0][4].M41 + "/y:" + worldMatrix_instances_voxel_cube[0][0][4].M42 + "/z:" + worldMatrix_instances_voxel_cube[0][0][4].M43 + "/x:" + (int)Math.Round(worldMatrix_instances_voxel_cube[0][0][0].M41 / planeSize) + "/y:" + (int)Math.Round(worldMatrix_instances_voxel_cube[0][0][0].M42 / planeSize) + "/z:" + (int)Math.Round(worldMatrix_instances_voxel_cube[0][0][0].M43 / planeSize) + "/x:" + (int)Math.Round(worldMatrix_instances_voxel_cube[0][0][4].M41 / planeSize) + "/y:" + (int)Math.Round(worldMatrix_instances_voxel_cube[0][0][4].M42 / planeSize) + "/z:" + (int)Math.Round(worldMatrix_instances_voxel_cube[0][0][4].M43 / planeSize);
                                                    consolewritecounter = 0;*/
                                                    Console.Title = "/x:" + mainmeshpos.X + "/y:" + mainmeshpos.Y + "/z:" + mainmeshpos.Z + "/bx:" + pickaxetippoint.X + "/by:" + pickaxetippoint.Y + "/bz:" + pickaxetippoint.Z + "/x:" + worldMatrix_instances_voxel_cube[0][0][0].M41 + "/y:" + worldMatrix_instances_voxel_cube[0][0][0].M42 + "/z:" + worldMatrix_instances_voxel_cube[0][0][0].M43 + "/x:" + worldMatrix_instances_voxel_cube[0][0][2].M41 + "/y:" + worldMatrix_instances_voxel_cube[0][0][2].M42 + "/z:" + worldMatrix_instances_voxel_cube[0][0][2].M43 + "/x:" + worldMatrix_instances_voxel_cube[0][0][4].M41 + "/y:" + worldMatrix_instances_voxel_cube[0][0][4].M42 + "/z:" + worldMatrix_instances_voxel_cube[0][0][4].M43;

                                                }
                                                consolewritecounter++;


                                                //pickaxetippoint





                                                //worldMatrix_instances_voxel_cube[0][0][2].M43 

                                                float someflooredvaluebytex = positionofhitbyte.X;// (float)(Math.Floor(positionofhitbyte.X / someglobalschunkkeyboard.planeSize) * someglobalschunkkeyboard.planeSize);
                                                float someflooredvaluebytey = positionofhitbyte.Y;// (float)(Math.Floor(positionofhitbyte.Y / someglobalschunkkeyboard.planeSize) * someglobalschunkkeyboard.planeSize);
                                                float someflooredvaluebytez = positionofhitbyte.Z;// (float)(Math.Floor(positionofhitbyte.Z / someglobalschunkkeyboard.planeSize) * someglobalschunkkeyboard.planeSize);

                                                //float locationbytex = worldmatrixofvoxelobject.M41 + (dirInstanceRight * indexofmainobject) + 

                                                //SECTION FOR 3D BYTE LOCATION WHEN AN INSTANCED BREAKABLE VOXEL OBJECT IS ROTATED
                                                //SECTION FOR 3D BYTE LOCATION WHEN AN INSTANCED BREAKABLE VOXEL OBJECT IS ROTATED
                                                //SECTION FOR 3D BYTE LOCATION WHEN AN INSTANCED BREAKABLE VOXEL OBJECT IS ROTATED

                                                int somebyte = somevoxelvirtualdesktop[indexofmainobject].arrayofindexzeromesh[indexofmeshzero].somechunk[indexofmeshinst].GetByte(indexbytex, indexbytey, indexbytez);
                                                //&& Math.Round(tempPoint.X / someglobalschunkkeyboard.planeSize) == someflooredvaluebytex && Math.Round(tempPoint.Y / someglobalschunkkeyboard.planeSize) == someflooredvaluebytey && Math.Round(tempPoint.Z / someglobalschunkkeyboard.planeSize) == someflooredvaluebytez

                                                //&& Math.Floor(pickaxetippoint.X / planeSize) == Math.Floor(worldMatrix_instances_voxel_cube[0][0][2].M41 / planeSize) && Math.Floor(pickaxetippoint.Y / planeSize) == Math.Floor(worldMatrix_instances_voxel_cube[0][0][2].M42 / planeSize) && Math.Floor(pickaxetippoint.Z / planeSize) == Math.Floor(worldMatrix_instances_voxel_cube[0][0][2].M43 / planeSize)

                                                //if (somebyte == 1 && worldMatrix_instances_voxel_cube[0][0][0].M41 == worldMatrix_instances_voxel_cube[0][0][4].M41 && worldMatrix_instances_voxel_cube[0][0][0].M42 == worldMatrix_instances_voxel_cube[0][0][4].M42 && worldMatrix_instances_voxel_cube[0][0][0].M43 == worldMatrix_instances_voxel_cube[0][0][4].M43)

                                                //if (somebyte == 1 && (int)Math.Round(worldMatrix_instances_voxel_cube[0][0][].M41 / planeSize) == (int)Math.Round(pickaxetippoint.X / planeSize) && (int)Math.Round(worldMatrix_instances_voxel_cube[0][0][0].M42 / planeSize) == (int)Math.Round(pickaxetippoint.Y / planeSize) && (int)Math.Round(worldMatrix_instances_voxel_cube[0][0][0].M43 / planeSize) == (int)Math.Round(pickaxetippoint.Z / planeSize))
                                                if (somebyte == 1 && (int)Math.Round(worldMatrix_instances_voxel_cube[0][0][0].M41 / planeSize) == (int)Math.Round(worldMatrix_instances_voxel_cube[0][0][4].M41 / planeSize) && (int)Math.Round(worldMatrix_instances_voxel_cube[0][0][0].M42 / planeSize) == (int)Math.Round(worldMatrix_instances_voxel_cube[0][0][4].M42 / planeSize) && (int)Math.Round(worldMatrix_instances_voxel_cube[0][0][0].M43 / planeSize) == (int)Math.Round(worldMatrix_instances_voxel_cube[0][0][4].M43 / planeSize))
                                                //if (somebyte == 1 && worldMatrix_instances_voxel_cube[0][0][0].M41 == worldMatrix_instances_voxel_cube[0][0][4].M41 && worldMatrix_instances_voxel_cube[0][0][0].M42 == worldMatrix_instances_voxel_cube[0][0][4].M42 && worldMatrix_instances_voxel_cube[0][0][0].M43 == worldMatrix_instances_voxel_cube[0][0][4].M43)
                                                //if (somebyte == 1 )
                                                {

                                                    //MainWindow.MessageBox((IntPtr)0, "/map:" + currentMapData + "/currentByteother:" + currentByteother + "/double_result:" + double_result, "sccs message 1", 0);
                                                    //MainWindow.MessageBox((IntPtr)0, "/map:" + currentMapData + "/someotherbyte:" + arrayOfDigits[someOtherIndex] + "/arrayOfDigits[someotherindex1]:" + arrayOfDigits[someotherindex1] + "/double_result:" + double_result, "sccs message 1", 0);
                                                    // MainWindow.MessageBox((IntPtr)0, "trying to break byte " + "/map4:" + currentMapData + "/bufferbyte:" + currentByte + "/classmemorybyte:" + somebyte + " ", "sccs message 1", 0);
                                                    int voxelchunkinvertoption = MainWindow.usetypeofvoxel;

                                                    //resetvoxelladdercounter

                                                    somevoxelvirtualdesktop[indexofmainobject].arrayofindexzeromesh[indexofmeshzero].somechunk[indexofmeshinst].SetByte(indexbytex, indexbytey, indexbytez, 0, Vector3.Zero);

                                                    somevoxelvirtualdesktop[indexofmainobject].arrayofindexzeromesh[indexofmeshzero].somechunk[indexofmeshinst].setnewmap(out m11, out m12, out m13, out m14, out m21, out m22, out m23, out m24, out m31, out m32, out m33, out m34, out m41, out m42, out m43, out m44, chosenmap, voxelchunkinvertoption
                                                        , out m11b, out m12b, out m13b, out m14b, out m21b, out m22b, out m23b, out m24b, out m31b, out m32b, out m33b, out m34b, out m41b, out m42b, out m43b, out m44b,
                                                        out m11c, out m12c, out m13c, out m14c, out m21c, out m22c, out m23c, out m24c, out m31c, out m32c, out m33c, out m34c, out m41c, out m42c, out m43c, out m44c,
                                                        out m11d, out m12d, out m13d, out m14d, out m21d, out m22d, out m23d, out m24d, out m31d, out m32d, out m33d, out m34d, out m41d, out m42d, out m43d, out m44d); //

                                                    /*somevoxelvirtualdesktop[indexofmainobject].arrayofindexzeromesh[indexofmeshzero].instancesmatrix[indexofmeshinst].instancematrix.M11 = (float)m11;
                                                    somevoxelvirtualdesktop[indexofmainobject].arrayofindexzeromesh[indexofmeshzero].instancesmatrix[indexofmeshinst].instancematrix.M12 = (float)m12;
                                                    somevoxelvirtualdesktop[indexofmainobject].arrayofindexzeromesh[indexofmeshzero].instancesmatrix[indexofmeshinst].instancematrix.M13 = (float)m13;
                                                    somevoxelvirtualdesktop[indexofmainobject].arrayofindexzeromesh[indexofmeshzero].instancesmatrix[indexofmeshinst].instancematrix.M14 = (float)m14;

                                                    somevoxelvirtualdesktop[indexofmainobject].arrayofindexzeromesh[indexofmeshzero].instancesmatrix[indexofmeshinst].instancematrix.M21 = (float)m21;
                                                    somevoxelvirtualdesktop[indexofmainobject].arrayofindexzeromesh[indexofmeshzero].instancesmatrix[indexofmeshinst].instancematrix.M22 = (float)m22;
                                                    somevoxelvirtualdesktop[indexofmainobject].arrayofindexzeromesh[indexofmeshzero].instancesmatrix[indexofmeshinst].instancematrix.M23 = (float)m23;
                                                    somevoxelvirtualdesktop[indexofmainobject].arrayofindexzeromesh[indexofmeshzero].instancesmatrix[indexofmeshinst].instancematrix.M24 = (float)m24;

                                                    somevoxelvirtualdesktop[indexofmainobject].arrayofindexzeromesh[indexofmeshzero].instancesmatrix[indexofmeshinst].instancematrix.M31 = (float)m31;
                                                    somevoxelvirtualdesktop[indexofmainobject].arrayofindexzeromesh[indexofmeshzero].instancesmatrix[indexofmeshinst].instancematrix.M32 = (float)m32;
                                                    somevoxelvirtualdesktop[indexofmainobject].arrayofindexzeromesh[indexofmeshzero].instancesmatrix[indexofmeshinst].instancematrix.M33 = (float)m33;
                                                    somevoxelvirtualdesktop[indexofmainobject].arrayofindexzeromesh[indexofmeshzero].instancesmatrix[indexofmeshinst].instancematrix.M34 = (float)m34;

                                                    somevoxelvirtualdesktop[indexofmainobject].arrayofindexzeromesh[indexofmeshzero].instancesmatrix[indexofmeshinst].instancematrix.M41 = (float)m41;
                                                    somevoxelvirtualdesktop[indexofmainobject].arrayofindexzeromesh[indexofmeshzero].instancesmatrix[indexofmeshinst].instancematrix.M42 = (float)m42;
                                                    somevoxelvirtualdesktop[indexofmainobject].arrayofindexzeromesh[indexofmeshzero].instancesmatrix[indexofmeshinst].instancematrix.M43 = (float)m43;
                                                    somevoxelvirtualdesktop[indexofmainobject].arrayofindexzeromesh[indexofmeshzero].instancesmatrix[indexofmeshinst].instancematrix.M44 = (float)m44;
                                                    */

                                                    /*currentIndex = indexofbyte;
                                                    if (currentIndex >= 0 && currentIndex <= 63)
                                                    {
                                                        if (currentIndex >= 0 && currentIndex <= 3)
                                                        {
                                                            somevoxelvirtualdesktop[indexofmainobject].arrayofindexzeromesh[indexofmeshzero].instancesmatrix[indexofmeshinst].instancematrix.M11 = (float)m11;
                                                        }
                                                        else if (currentIndex >= 4 && currentIndex <= 7)
                                                        {
                                                            somevoxelvirtualdesktop[indexofmainobject].arrayofindexzeromesh[indexofmeshzero].instancesmatrix[indexofmeshinst].instancematrix.M12 = (float)m12;
                                                        }
                                                        else if (currentIndex >= 8 && currentIndex <= 11)
                                                        {
                                                            somevoxelvirtualdesktop[indexofmainobject].arrayofindexzeromesh[indexofmeshzero].instancesmatrix[indexofmeshinst].instancematrix.M13 = (float)m13;
                                                        }
                                                        else if (currentIndex >= 12 && currentIndex <= 15)
                                                        {
                                                            somevoxelvirtualdesktop[indexofmainobject].arrayofindexzeromesh[indexofmeshzero].instancesmatrix[indexofmeshinst].instancematrix.M14 = (float)m14;
                                                        }
                                                        else if (currentIndex >= 16 && currentIndex <= 19)
                                                        {
                                                            somevoxelvirtualdesktop[indexofmainobject].arrayofindexzeromesh[indexofmeshzero].instancesmatrix[indexofmeshinst].instancematrix.M21 = (float)m21;
                                                        }
                                                        else if (currentIndex >= 20 && currentIndex <= 23)
                                                        {
                                                            somevoxelvirtualdesktop[indexofmainobject].arrayofindexzeromesh[indexofmeshzero].instancesmatrix[indexofmeshinst].instancematrix.M22 = (float)m22;
                                                        }
                                                        else if (currentIndex >= 24 && currentIndex <= 27)
                                                        {
                                                            somevoxelvirtualdesktop[indexofmainobject].arrayofindexzeromesh[indexofmeshzero].instancesmatrix[indexofmeshinst].instancematrix.M23 = (float)m23;
                                                        }
                                                        else if (currentIndex >= 28 && currentIndex <= 31)
                                                        {
                                                            somevoxelvirtualdesktop[indexofmainobject].arrayofindexzeromesh[indexofmeshzero].instancesmatrix[indexofmeshinst].instancematrix.M24 = (float)m24;
                                                        }
                                                        else if (currentIndex >= 32 && currentIndex <= 35)
                                                        {
                                                            somevoxelvirtualdesktop[indexofmainobject].arrayofindexzeromesh[indexofmeshzero].instancesmatrix[indexofmeshinst].instancematrix.M31 = (float)m31;
                                                        }
                                                        else if (currentIndex >= 36 && currentIndex <= 39)
                                                        {
                                                            somevoxelvirtualdesktop[indexofmainobject].arrayofindexzeromesh[indexofmeshzero].instancesmatrix[indexofmeshinst].instancematrix.M32 = (float)m32;
                                                        }
                                                        else if (currentIndex >= 40 && currentIndex <= 43)
                                                        {
                                                            somevoxelvirtualdesktop[indexofmainobject].arrayofindexzeromesh[indexofmeshzero].instancesmatrix[indexofmeshinst].instancematrix.M33 = (float)m33;
                                                        }
                                                        else if (currentIndex >= 44 && currentIndex <= 47)
                                                        {
                                                            somevoxelvirtualdesktop[indexofmainobject].arrayofindexzeromesh[indexofmeshzero].instancesmatrix[indexofmeshinst].instancematrix.M34 = (float)m34;
                                                        }
                                                        else if (currentIndex >= 48 && currentIndex <= 51)
                                                        {
                                                            somevoxelvirtualdesktop[indexofmainobject].arrayofindexzeromesh[indexofmeshzero].instancesmatrix[indexofmeshinst].instancematrix.M41 = (float)m41;
                                                        }
                                                        else if (currentIndex >= 52 && currentIndex <= 55)
                                                        {
                                                            somevoxelvirtualdesktop[indexofmainobject].arrayofindexzeromesh[indexofmeshzero].instancesmatrix[indexofmeshinst].instancematrix.M42 = (float)m42;
                                                        }
                                                        else if (currentIndex >= 56 && currentIndex <= 59)
                                                        {
                                                            somevoxelvirtualdesktop[indexofmainobject].arrayofindexzeromesh[indexofmeshzero].instancesmatrix[indexofmeshinst].instancematrix.M43 = (float)m43;
                                                        }
                                                        else if (currentIndex >= 60 && currentIndex <= 63)
                                                        {
                                                            somevoxelvirtualdesktop[indexofmainobject].arrayofindexzeromesh[indexofmeshzero].instancesmatrix[indexofmeshinst].instancematrix.M44 = (float)m44;
                                                        }
                                                    }*/


                                                    double selectablevectordouble = 0;
                                                    currentIndex = indexofbyte;
                                                    int maxv = somevoxelvirtualdesktopglobals.tinyChunkWidth * somevoxelvirtualdesktopglobals.tinyChunkHeight * somevoxelvirtualdesktopglobals.tinyChunkDepth;
                                                    int somemaxvecdigit = 16;
                                                    int somecountermul = 0;
                                                    int somec = 0;

                                                    for (int t = 0; t < currentIndex; t++)
                                                    {
                                                        if (somec == somemaxvecdigit)
                                                        {
                                                            somecountermul++;
                                                            somec = 0;
                                                        }
                                                        somec++;
                                                    }





                                                    //int somediv = index % 16;
                                                    /*
                                                    if (somebytecounter == 0)
                                                    {
                                                        byte1st = currentByte;
                                                    }
                                                    else if (somebytecounter == 1)
                                                    {
                                                        byte2nd = currentByte;
                                                    }
                                                    else if (somebytecounter == 2)
                                                    {
                                                        byte3rd = currentByte;
                                                    }*/




                                                    switch (somecountermul)
                                                    {
                                                        case 0:
                                                            somevoxelvirtualdesktop[indexofmainobject].arrayofindexzeromesh[indexofmeshzero].instancesmatrix[indexofmeshinst].instancematrix.M11 = (float)m11;
                                                            break;
                                                        case 1:
                                                            somevoxelvirtualdesktop[indexofmainobject].arrayofindexzeromesh[indexofmeshzero].instancesmatrix[indexofmeshinst].instancematrix.M12 = (float)m12;
                                                            break;
                                                        case 2:
                                                            somevoxelvirtualdesktop[indexofmainobject].arrayofindexzeromesh[indexofmeshzero].instancesmatrix[indexofmeshinst].instancematrix.M13 = (float)m13;
                                                            break;
                                                        case 3:
                                                            somevoxelvirtualdesktop[indexofmainobject].arrayofindexzeromesh[indexofmeshzero].instancesmatrix[indexofmeshinst].instancematrix.M14 = (float)m14;
                                                            break;
                                                        case 4:
                                                            somevoxelvirtualdesktop[indexofmainobject].arrayofindexzeromesh[indexofmeshzero].instancesmatrix[indexofmeshinst].instancematrix.M21 = (float)m21;
                                                            break;
                                                        case 5:
                                                            somevoxelvirtualdesktop[indexofmainobject].arrayofindexzeromesh[indexofmeshzero].instancesmatrix[indexofmeshinst].instancematrix.M22 = (float)m22;
                                                            break;
                                                        case 6:
                                                            somevoxelvirtualdesktop[indexofmainobject].arrayofindexzeromesh[indexofmeshzero].instancesmatrix[indexofmeshinst].instancematrix.M23 = (float)m23;
                                                            break;
                                                        case 7:
                                                            somevoxelvirtualdesktop[indexofmainobject].arrayofindexzeromesh[indexofmeshzero].instancesmatrix[indexofmeshinst].instancematrix.M24 = (float)m24;
                                                            break;
                                                        case 8:
                                                            somevoxelvirtualdesktop[indexofmainobject].arrayofindexzeromesh[indexofmeshzero].instancesmatrix[indexofmeshinst].instancematrix.M31 = (float)m31;
                                                            break;
                                                        case 9:
                                                            somevoxelvirtualdesktop[indexofmainobject].arrayofindexzeromesh[indexofmeshzero].instancesmatrix[indexofmeshinst].instancematrix.M32 = (float)m32;
                                                            break;
                                                        case 10:
                                                            somevoxelvirtualdesktop[indexofmainobject].arrayofindexzeromesh[indexofmeshzero].instancesmatrix[indexofmeshinst].instancematrix.M33 = (float)m33;
                                                            break;
                                                        case 11:
                                                            somevoxelvirtualdesktop[indexofmainobject].arrayofindexzeromesh[indexofmeshzero].instancesmatrix[indexofmeshinst].instancematrix.M34 = (float)m34;
                                                            break;
                                                        case 12:
                                                            somevoxelvirtualdesktop[indexofmainobject].arrayofindexzeromesh[indexofmeshzero].instancesmatrix[indexofmeshinst].instancematrix.M41 = (float)m41;
                                                            break;
                                                        case 13:
                                                            somevoxelvirtualdesktop[indexofmainobject].arrayofindexzeromesh[indexofmeshzero].instancesmatrix[indexofmeshinst].instancematrix.M42 = (float)m42;
                                                            break;
                                                        case 14:
                                                            somevoxelvirtualdesktop[indexofmainobject].arrayofindexzeromesh[indexofmeshzero].instancesmatrix[indexofmeshinst].instancematrix.M43 = (float)m43;
                                                            break;
                                                        case 15:
                                                            somevoxelvirtualdesktop[indexofmainobject].arrayofindexzeromesh[indexofmeshzero].instancesmatrix[indexofmeshinst].instancematrix.M44 = (float)m44;
                                                            break;




                                                        case 16:
                                                            somevoxelvirtualdesktop[indexofmainobject].arrayofindexzeromesh[indexofmeshzero].instancesmatrixb[indexofmeshinst].instancematrix.M11 = (float)m11b;
                                                            break;
                                                        case 17:
                                                            somevoxelvirtualdesktop[indexofmainobject].arrayofindexzeromesh[indexofmeshzero].instancesmatrixb[indexofmeshinst].instancematrix.M12 = (float)m12b;
                                                            break;
                                                        case 18:
                                                            somevoxelvirtualdesktop[indexofmainobject].arrayofindexzeromesh[indexofmeshzero].instancesmatrixb[indexofmeshinst].instancematrix.M13 = (float)m13b;
                                                            break;
                                                        case 19:
                                                            somevoxelvirtualdesktop[indexofmainobject].arrayofindexzeromesh[indexofmeshzero].instancesmatrixb[indexofmeshinst].instancematrix.M14 = (float)m14b;
                                                            break;
                                                        case 20:
                                                            somevoxelvirtualdesktop[indexofmainobject].arrayofindexzeromesh[indexofmeshzero].instancesmatrixb[indexofmeshinst].instancematrix.M21 = (float)m21b;
                                                            break;
                                                        case 21:
                                                            somevoxelvirtualdesktop[indexofmainobject].arrayofindexzeromesh[indexofmeshzero].instancesmatrixb[indexofmeshinst].instancematrix.M22 = (float)m22b;
                                                            break;
                                                        case 22:
                                                            somevoxelvirtualdesktop[indexofmainobject].arrayofindexzeromesh[indexofmeshzero].instancesmatrixb[indexofmeshinst].instancematrix.M23 = (float)m23b;
                                                            break;
                                                        case 23:
                                                            somevoxelvirtualdesktop[indexofmainobject].arrayofindexzeromesh[indexofmeshzero].instancesmatrixb[indexofmeshinst].instancematrix.M24 = (float)m24b;
                                                            break;
                                                        case 24:
                                                            somevoxelvirtualdesktop[indexofmainobject].arrayofindexzeromesh[indexofmeshzero].instancesmatrixb[indexofmeshinst].instancematrix.M31 = (float)m31b;
                                                            break;
                                                        case 25:
                                                            somevoxelvirtualdesktop[indexofmainobject].arrayofindexzeromesh[indexofmeshzero].instancesmatrixb[indexofmeshinst].instancematrix.M32 = (float)m32b;
                                                            break;
                                                        case 26:
                                                            somevoxelvirtualdesktop[indexofmainobject].arrayofindexzeromesh[indexofmeshzero].instancesmatrixb[indexofmeshinst].instancematrix.M33 = (float)m33b;
                                                            break;
                                                        case 27:
                                                            somevoxelvirtualdesktop[indexofmainobject].arrayofindexzeromesh[indexofmeshzero].instancesmatrixb[indexofmeshinst].instancematrix.M34 = (float)m34b;
                                                            break;
                                                        case 28:
                                                            somevoxelvirtualdesktop[indexofmainobject].arrayofindexzeromesh[indexofmeshzero].instancesmatrixb[indexofmeshinst].instancematrix.M41 = (float)m41b;
                                                            break;
                                                        case 29:
                                                            somevoxelvirtualdesktop[indexofmainobject].arrayofindexzeromesh[indexofmeshzero].instancesmatrixb[indexofmeshinst].instancematrix.M42 = (float)m42b;
                                                            break;
                                                        case 30:
                                                            somevoxelvirtualdesktop[indexofmainobject].arrayofindexzeromesh[indexofmeshzero].instancesmatrixb[indexofmeshinst].instancematrix.M43 = (float)m43b;
                                                            break;
                                                        case 31:
                                                            somevoxelvirtualdesktop[indexofmainobject].arrayofindexzeromesh[indexofmeshzero].instancesmatrixb[indexofmeshinst].instancematrix.M44 = (float)m44b;
                                                            break;



                                                        case 32:
                                                            somevoxelvirtualdesktop[indexofmainobject].arrayofindexzeromesh[indexofmeshzero].instancesmatrixc[indexofmeshinst].instancematrix.M11 = (float)m11c;
                                                            break;
                                                        case 33:
                                                            somevoxelvirtualdesktop[indexofmainobject].arrayofindexzeromesh[indexofmeshzero].instancesmatrixc[indexofmeshinst].instancematrix.M12 = (float)m12c;
                                                            break;
                                                        case 34:
                                                            somevoxelvirtualdesktop[indexofmainobject].arrayofindexzeromesh[indexofmeshzero].instancesmatrixc[indexofmeshinst].instancematrix.M13 = (float)m13c;
                                                            break;
                                                        case 35:
                                                            somevoxelvirtualdesktop[indexofmainobject].arrayofindexzeromesh[indexofmeshzero].instancesmatrixc[indexofmeshinst].instancematrix.M14 = (float)m14c;
                                                            break;
                                                        case 36:
                                                            somevoxelvirtualdesktop[indexofmainobject].arrayofindexzeromesh[indexofmeshzero].instancesmatrixc[indexofmeshinst].instancematrix.M21 = (float)m21c;
                                                            break;
                                                        case 37:
                                                            somevoxelvirtualdesktop[indexofmainobject].arrayofindexzeromesh[indexofmeshzero].instancesmatrixc[indexofmeshinst].instancematrix.M22 = (float)m22c;
                                                            break;
                                                        case 38:
                                                            somevoxelvirtualdesktop[indexofmainobject].arrayofindexzeromesh[indexofmeshzero].instancesmatrixc[indexofmeshinst].instancematrix.M23 = (float)m23c;
                                                            break;
                                                        case 39:
                                                            somevoxelvirtualdesktop[indexofmainobject].arrayofindexzeromesh[indexofmeshzero].instancesmatrixc[indexofmeshinst].instancematrix.M24 = (float)m24c;
                                                            break;
                                                        case 40:
                                                            somevoxelvirtualdesktop[indexofmainobject].arrayofindexzeromesh[indexofmeshzero].instancesmatrixc[indexofmeshinst].instancematrix.M31 = (float)m31c;
                                                            break;
                                                        case 41:
                                                            somevoxelvirtualdesktop[indexofmainobject].arrayofindexzeromesh[indexofmeshzero].instancesmatrixc[indexofmeshinst].instancematrix.M32 = (float)m32c;
                                                            break;
                                                        case 42:
                                                            somevoxelvirtualdesktop[indexofmainobject].arrayofindexzeromesh[indexofmeshzero].instancesmatrixc[indexofmeshinst].instancematrix.M33 = (float)m33c;
                                                            break;
                                                        case 43:
                                                            somevoxelvirtualdesktop[indexofmainobject].arrayofindexzeromesh[indexofmeshzero].instancesmatrixc[indexofmeshinst].instancematrix.M34 = (float)m34c;
                                                            break;
                                                        case 44:
                                                            somevoxelvirtualdesktop[indexofmainobject].arrayofindexzeromesh[indexofmeshzero].instancesmatrixc[indexofmeshinst].instancematrix.M41 = (float)m41c;
                                                            break;
                                                        case 45:
                                                            somevoxelvirtualdesktop[indexofmainobject].arrayofindexzeromesh[indexofmeshzero].instancesmatrixc[indexofmeshinst].instancematrix.M42 = (float)m42c;
                                                            break;
                                                        case 46:
                                                            somevoxelvirtualdesktop[indexofmainobject].arrayofindexzeromesh[indexofmeshzero].instancesmatrixc[indexofmeshinst].instancematrix.M43 = (float)m43c;
                                                            break;
                                                        case 47:
                                                            somevoxelvirtualdesktop[indexofmainobject].arrayofindexzeromesh[indexofmeshzero].instancesmatrixc[indexofmeshinst].instancematrix.M44 = (float)m44c;
                                                            break;




                                                        case 48:
                                                            somevoxelvirtualdesktop[indexofmainobject].arrayofindexzeromesh[indexofmeshzero].instancesmatrixd[indexofmeshinst].instancematrix.M11 = (float)m11d;
                                                            break;
                                                        case 49:
                                                            somevoxelvirtualdesktop[indexofmainobject].arrayofindexzeromesh[indexofmeshzero].instancesmatrixd[indexofmeshinst].instancematrix.M12 = (float)m12d;
                                                            break;
                                                        case 50:
                                                            somevoxelvirtualdesktop[indexofmainobject].arrayofindexzeromesh[indexofmeshzero].instancesmatrixd[indexofmeshinst].instancematrix.M13 = (float)m13d;
                                                            break;
                                                        case 51:
                                                            somevoxelvirtualdesktop[indexofmainobject].arrayofindexzeromesh[indexofmeshzero].instancesmatrixd[indexofmeshinst].instancematrix.M14 = (float)m14d;
                                                            break;
                                                        case 52:
                                                            somevoxelvirtualdesktop[indexofmainobject].arrayofindexzeromesh[indexofmeshzero].instancesmatrixd[indexofmeshinst].instancematrix.M21 = (float)m21d;
                                                            break;
                                                        case 53:
                                                            somevoxelvirtualdesktop[indexofmainobject].arrayofindexzeromesh[indexofmeshzero].instancesmatrixd[indexofmeshinst].instancematrix.M22 = (float)m22d;
                                                            break;
                                                        case 54:
                                                            somevoxelvirtualdesktop[indexofmainobject].arrayofindexzeromesh[indexofmeshzero].instancesmatrixd[indexofmeshinst].instancematrix.M23 = (float)m23d;
                                                            break;
                                                        case 55:
                                                            somevoxelvirtualdesktop[indexofmainobject].arrayofindexzeromesh[indexofmeshzero].instancesmatrixd[indexofmeshinst].instancematrix.M24 = (float)m24d;
                                                            break;
                                                        case 56:
                                                            somevoxelvirtualdesktop[indexofmainobject].arrayofindexzeromesh[indexofmeshzero].instancesmatrixd[indexofmeshinst].instancematrix.M31 = (float)m31d;
                                                            break;
                                                        case 57:
                                                            somevoxelvirtualdesktop[indexofmainobject].arrayofindexzeromesh[indexofmeshzero].instancesmatrixd[indexofmeshinst].instancematrix.M32 = (float)m32d;
                                                            break;
                                                        case 58:
                                                            somevoxelvirtualdesktop[indexofmainobject].arrayofindexzeromesh[indexofmeshzero].instancesmatrixd[indexofmeshinst].instancematrix.M33 = (float)m33d;
                                                            break;
                                                        case 59:
                                                            somevoxelvirtualdesktop[indexofmainobject].arrayofindexzeromesh[indexofmeshzero].instancesmatrixd[indexofmeshinst].instancematrix.M34 = (float)m34d;
                                                            break;
                                                        case 60:
                                                            somevoxelvirtualdesktop[indexofmainobject].arrayofindexzeromesh[indexofmeshzero].instancesmatrixd[indexofmeshinst].instancematrix.M41 = (float)m41d;
                                                            break;
                                                        case 61:
                                                            somevoxelvirtualdesktop[indexofmainobject].arrayofindexzeromesh[indexofmeshzero].instancesmatrixd[indexofmeshinst].instancematrix.M42 = (float)m42d;
                                                            break;
                                                        case 62:
                                                            somevoxelvirtualdesktop[indexofmainobject].arrayofindexzeromesh[indexofmeshzero].instancesmatrixd[indexofmeshinst].instancematrix.M43 = (float)m43d;
                                                            break;
                                                        case 63:
                                                            somevoxelvirtualdesktop[indexofmainobject].arrayofindexzeromesh[indexofmeshzero].instancesmatrixd[indexofmeshinst].instancematrix.M44 = (float)m44d;
                                                            break;
                                                    };


























                                                }
                                                else
                                                {
                                                    if (MainWindow.usetypeofvoxel == 3)
                                                    {
                                                        int voxelchunkinvertoption = MainWindow.usetypeofvoxel;

                                                        somevoxelvirtualdesktop[indexofmainobject].arrayofindexzeromesh[indexofmeshzero].somechunk[indexofmeshinst].SetByte(indexbytex, indexbytey, indexbytez, 1, Vector3.Zero);

                                                        somevoxelvirtualdesktop[indexofmainobject].arrayofindexzeromesh[indexofmeshzero].somechunk[indexofmeshinst].setnewmap(out m11, out m12, out m13, out m14, out m21, out m22, out m23, out m24, out m31, out m32, out m33, out m34, out m41, out m42, out m43, out m44, chosenmap, voxelchunkinvertoption
                                                            , out m11b, out m12b, out m13b, out m14b, out m21b, out m22b, out m23b, out m24b, out m31b, out m32b, out m33b, out m34b, out m41b, out m42b, out m43b, out m44b,
                            out m11c, out m12c, out m13c, out m14c, out m21c, out m22c, out m23c, out m24c, out m31c, out m32c, out m33c, out m34c, out m41c, out m42c, out m43c, out m44c,
                            out m11d, out m12d, out m13d, out m14d, out m21d, out m22d, out m23d, out m24d, out m31d, out m32d, out m33d, out m34d, out m41d, out m42d, out m43d, out m44d); //

                                                        /*if (currentIndex >= 0 && currentIndex <= 63)
                                                        {
                                                            if (currentIndex >= 0 && currentIndex <= 3)
                                                            {
                                                                somevoxelvirtualdesktop[indexofmainobject].arrayofindexzeromesh[indexofmeshzero].instancesmatrix[indexofmeshinst].instancematrix.M11 = (float)m11;
                                                            }
                                                            else if (currentIndex >= 4 && currentIndex <= 7)
                                                            {
                                                                somevoxelvirtualdesktop[indexofmainobject].arrayofindexzeromesh[indexofmeshzero].instancesmatrix[indexofmeshinst].instancematrix.M12 = (float)m12;
                                                            }
                                                            else if (currentIndex >= 8 && currentIndex <= 11)
                                                            {
                                                                somevoxelvirtualdesktop[indexofmainobject].arrayofindexzeromesh[indexofmeshzero].instancesmatrix[indexofmeshinst].instancematrix.M13 = (float)m13;
                                                            }
                                                            else if (currentIndex >= 12 && currentIndex <= 15)
                                                            {
                                                                somevoxelvirtualdesktop[indexofmainobject].arrayofindexzeromesh[indexofmeshzero].instancesmatrix[indexofmeshinst].instancematrix.M14 = (float)m14;
                                                            }
                                                            else if (currentIndex >= 16 && currentIndex <= 19)
                                                            {
                                                                somevoxelvirtualdesktop[indexofmainobject].arrayofindexzeromesh[indexofmeshzero].instancesmatrix[indexofmeshinst].instancematrix.M21 = (float)m21;
                                                            }
                                                            else if (currentIndex >= 20 && currentIndex <= 23)
                                                            {
                                                                somevoxelvirtualdesktop[indexofmainobject].arrayofindexzeromesh[indexofmeshzero].instancesmatrix[indexofmeshinst].instancematrix.M22 = (float)m22;
                                                            }
                                                            else if (currentIndex >= 24 && currentIndex <= 27)
                                                            {
                                                                somevoxelvirtualdesktop[indexofmainobject].arrayofindexzeromesh[indexofmeshzero].instancesmatrix[indexofmeshinst].instancematrix.M23 = (float)m23;
                                                            }
                                                            else if (currentIndex >= 28 && currentIndex <= 31)
                                                            {
                                                                somevoxelvirtualdesktop[indexofmainobject].arrayofindexzeromesh[indexofmeshzero].instancesmatrix[indexofmeshinst].instancematrix.M24 = (float)m24;
                                                            }
                                                            else if (currentIndex >= 32 && currentIndex <= 35)
                                                            {
                                                                somevoxelvirtualdesktop[indexofmainobject].arrayofindexzeromesh[indexofmeshzero].instancesmatrix[indexofmeshinst].instancematrix.M31 = (float)m31;
                                                            }
                                                            else if (currentIndex >= 36 && currentIndex <= 39)
                                                            {
                                                                somevoxelvirtualdesktop[indexofmainobject].arrayofindexzeromesh[indexofmeshzero].instancesmatrix[indexofmeshinst].instancematrix.M32 = (float)m32;
                                                            }
                                                            else if (currentIndex >= 40 && currentIndex <= 43)
                                                            {
                                                                somevoxelvirtualdesktop[indexofmainobject].arrayofindexzeromesh[indexofmeshzero].instancesmatrix[indexofmeshinst].instancematrix.M33 = (float)m33;
                                                            }
                                                            else if (currentIndex >= 44 && currentIndex <= 47)
                                                            {
                                                                somevoxelvirtualdesktop[indexofmainobject].arrayofindexzeromesh[indexofmeshzero].instancesmatrix[indexofmeshinst].instancematrix.M34 = (float)m34;
                                                            }
                                                            else if (currentIndex >= 48 && currentIndex <= 51)
                                                            {
                                                                somevoxelvirtualdesktop[indexofmainobject].arrayofindexzeromesh[indexofmeshzero].instancesmatrix[indexofmeshinst].instancematrix.M41 = (float)m41;
                                                            }
                                                            else if (currentIndex >= 52 && currentIndex <= 55)
                                                            {
                                                                somevoxelvirtualdesktop[indexofmainobject].arrayofindexzeromesh[indexofmeshzero].instancesmatrix[indexofmeshinst].instancematrix.M42 = (float)m42;
                                                            }
                                                            else if (currentIndex >= 56 && currentIndex <= 59)
                                                            {
                                                                somevoxelvirtualdesktop[indexofmainobject].arrayofindexzeromesh[indexofmeshzero].instancesmatrix[indexofmeshinst].instancematrix.M43 = (float)m43;
                                                            }
                                                            else if (currentIndex >= 60 && currentIndex <= 63)
                                                            {
                                                                somevoxelvirtualdesktop[indexofmainobject].arrayofindexzeromesh[indexofmeshzero].instancesmatrix[indexofmeshinst].instancematrix.M44 = (float)m44;
                                                            }
                                                        }*/





                                                        double selectablevectordouble = 0;
                                                        currentIndex = indexofbyte;
                                                        int maxv = somevoxelvirtualdesktopglobals.tinyChunkWidth * somevoxelvirtualdesktopglobals.tinyChunkHeight * somevoxelvirtualdesktopglobals.tinyChunkDepth;
                                                        int somemaxvecdigit = 16;
                                                        int somecountermul = 0;
                                                        int somec = 0;

                                                        for (int t = 0; t < currentIndex; t++)
                                                        {
                                                            if (somec == somemaxvecdigit)
                                                            {
                                                                somecountermul++;
                                                                somec = 0;
                                                            }
                                                            somec++;
                                                        }





                                                        //int somediv = index % 16;
                                                        /*
                                                        if (somebytecounter == 0)
                                                        {
                                                            byte1st = currentByte;
                                                        }
                                                        else if (somebytecounter == 1)
                                                        {
                                                            byte2nd = currentByte;
                                                        }
                                                        else if (somebytecounter == 2)
                                                        {
                                                            byte3rd = currentByte;
                                                        }*/




                                                        switch (somecountermul)
                                                        {
                                                            case 0:
                                                                somevoxelvirtualdesktop[indexofmainobject].arrayofindexzeromesh[indexofmeshzero].instancesmatrix[indexofmeshinst].instancematrix.M11 = (float)m11;
                                                                break;
                                                            case 1:
                                                                somevoxelvirtualdesktop[indexofmainobject].arrayofindexzeromesh[indexofmeshzero].instancesmatrix[indexofmeshinst].instancematrix.M12 = (float)m12;
                                                                break;
                                                            case 2:
                                                                somevoxelvirtualdesktop[indexofmainobject].arrayofindexzeromesh[indexofmeshzero].instancesmatrix[indexofmeshinst].instancematrix.M13 = (float)m13;
                                                                break;
                                                            case 3:
                                                                somevoxelvirtualdesktop[indexofmainobject].arrayofindexzeromesh[indexofmeshzero].instancesmatrix[indexofmeshinst].instancematrix.M14 = (float)m14;
                                                                break;
                                                            case 4:
                                                                somevoxelvirtualdesktop[indexofmainobject].arrayofindexzeromesh[indexofmeshzero].instancesmatrix[indexofmeshinst].instancematrix.M21 = (float)m21;
                                                                break;
                                                            case 5:
                                                                somevoxelvirtualdesktop[indexofmainobject].arrayofindexzeromesh[indexofmeshzero].instancesmatrix[indexofmeshinst].instancematrix.M22 = (float)m22;
                                                                break;
                                                            case 6:
                                                                somevoxelvirtualdesktop[indexofmainobject].arrayofindexzeromesh[indexofmeshzero].instancesmatrix[indexofmeshinst].instancematrix.M23 = (float)m23;
                                                                break;
                                                            case 7:
                                                                somevoxelvirtualdesktop[indexofmainobject].arrayofindexzeromesh[indexofmeshzero].instancesmatrix[indexofmeshinst].instancematrix.M24 = (float)m24;
                                                                break;
                                                            case 8:
                                                                somevoxelvirtualdesktop[indexofmainobject].arrayofindexzeromesh[indexofmeshzero].instancesmatrix[indexofmeshinst].instancematrix.M31 = (float)m31;
                                                                break;
                                                            case 9:
                                                                somevoxelvirtualdesktop[indexofmainobject].arrayofindexzeromesh[indexofmeshzero].instancesmatrix[indexofmeshinst].instancematrix.M32 = (float)m32;
                                                                break;
                                                            case 10:
                                                                somevoxelvirtualdesktop[indexofmainobject].arrayofindexzeromesh[indexofmeshzero].instancesmatrix[indexofmeshinst].instancematrix.M33 = (float)m33;
                                                                break;
                                                            case 11:
                                                                somevoxelvirtualdesktop[indexofmainobject].arrayofindexzeromesh[indexofmeshzero].instancesmatrix[indexofmeshinst].instancematrix.M34 = (float)m34;
                                                                break;
                                                            case 12:
                                                                somevoxelvirtualdesktop[indexofmainobject].arrayofindexzeromesh[indexofmeshzero].instancesmatrix[indexofmeshinst].instancematrix.M41 = (float)m41;
                                                                break;
                                                            case 13:
                                                                somevoxelvirtualdesktop[indexofmainobject].arrayofindexzeromesh[indexofmeshzero].instancesmatrix[indexofmeshinst].instancematrix.M42 = (float)m42;
                                                                break;
                                                            case 14:
                                                                somevoxelvirtualdesktop[indexofmainobject].arrayofindexzeromesh[indexofmeshzero].instancesmatrix[indexofmeshinst].instancematrix.M43 = (float)m43;
                                                                break;
                                                            case 15:
                                                                somevoxelvirtualdesktop[indexofmainobject].arrayofindexzeromesh[indexofmeshzero].instancesmatrix[indexofmeshinst].instancematrix.M44 = (float)m44;
                                                                break;




                                                            case 16:
                                                                somevoxelvirtualdesktop[indexofmainobject].arrayofindexzeromesh[indexofmeshzero].instancesmatrixb[indexofmeshinst].instancematrix.M11 = (float)m11b;
                                                                break;
                                                            case 17:
                                                                somevoxelvirtualdesktop[indexofmainobject].arrayofindexzeromesh[indexofmeshzero].instancesmatrixb[indexofmeshinst].instancematrix.M12 = (float)m12b;
                                                                break;
                                                            case 18:
                                                                somevoxelvirtualdesktop[indexofmainobject].arrayofindexzeromesh[indexofmeshzero].instancesmatrixb[indexofmeshinst].instancematrix.M13 = (float)m13b;
                                                                break;
                                                            case 19:
                                                                somevoxelvirtualdesktop[indexofmainobject].arrayofindexzeromesh[indexofmeshzero].instancesmatrixb[indexofmeshinst].instancematrix.M14 = (float)m14b;
                                                                break;
                                                            case 20:
                                                                somevoxelvirtualdesktop[indexofmainobject].arrayofindexzeromesh[indexofmeshzero].instancesmatrixb[indexofmeshinst].instancematrix.M21 = (float)m21b;
                                                                break;
                                                            case 21:
                                                                somevoxelvirtualdesktop[indexofmainobject].arrayofindexzeromesh[indexofmeshzero].instancesmatrixb[indexofmeshinst].instancematrix.M22 = (float)m22b;
                                                                break;
                                                            case 22:
                                                                somevoxelvirtualdesktop[indexofmainobject].arrayofindexzeromesh[indexofmeshzero].instancesmatrixb[indexofmeshinst].instancematrix.M23 = (float)m23b;
                                                                break;
                                                            case 23:
                                                                somevoxelvirtualdesktop[indexofmainobject].arrayofindexzeromesh[indexofmeshzero].instancesmatrixb[indexofmeshinst].instancematrix.M24 = (float)m24b;
                                                                break;
                                                            case 24:
                                                                somevoxelvirtualdesktop[indexofmainobject].arrayofindexzeromesh[indexofmeshzero].instancesmatrixb[indexofmeshinst].instancematrix.M31 = (float)m31b;
                                                                break;
                                                            case 25:
                                                                somevoxelvirtualdesktop[indexofmainobject].arrayofindexzeromesh[indexofmeshzero].instancesmatrixb[indexofmeshinst].instancematrix.M32 = (float)m32b;
                                                                break;
                                                            case 26:
                                                                somevoxelvirtualdesktop[indexofmainobject].arrayofindexzeromesh[indexofmeshzero].instancesmatrixb[indexofmeshinst].instancematrix.M33 = (float)m33b;
                                                                break;
                                                            case 27:
                                                                somevoxelvirtualdesktop[indexofmainobject].arrayofindexzeromesh[indexofmeshzero].instancesmatrixb[indexofmeshinst].instancematrix.M34 = (float)m34b;
                                                                break;
                                                            case 28:
                                                                somevoxelvirtualdesktop[indexofmainobject].arrayofindexzeromesh[indexofmeshzero].instancesmatrixb[indexofmeshinst].instancematrix.M41 = (float)m41b;
                                                                break;
                                                            case 29:
                                                                somevoxelvirtualdesktop[indexofmainobject].arrayofindexzeromesh[indexofmeshzero].instancesmatrixb[indexofmeshinst].instancematrix.M42 = (float)m42b;
                                                                break;
                                                            case 30:
                                                                somevoxelvirtualdesktop[indexofmainobject].arrayofindexzeromesh[indexofmeshzero].instancesmatrixb[indexofmeshinst].instancematrix.M43 = (float)m43b;
                                                                break;
                                                            case 31:
                                                                somevoxelvirtualdesktop[indexofmainobject].arrayofindexzeromesh[indexofmeshzero].instancesmatrixb[indexofmeshinst].instancematrix.M44 = (float)m44b;
                                                                break;



                                                            case 32:
                                                                somevoxelvirtualdesktop[indexofmainobject].arrayofindexzeromesh[indexofmeshzero].instancesmatrixc[indexofmeshinst].instancematrix.M11 = (float)m11c;
                                                                break;
                                                            case 33:
                                                                somevoxelvirtualdesktop[indexofmainobject].arrayofindexzeromesh[indexofmeshzero].instancesmatrixc[indexofmeshinst].instancematrix.M12 = (float)m12c;
                                                                break;
                                                            case 34:
                                                                somevoxelvirtualdesktop[indexofmainobject].arrayofindexzeromesh[indexofmeshzero].instancesmatrixc[indexofmeshinst].instancematrix.M13 = (float)m13c;
                                                                break;
                                                            case 35:
                                                                somevoxelvirtualdesktop[indexofmainobject].arrayofindexzeromesh[indexofmeshzero].instancesmatrixc[indexofmeshinst].instancematrix.M14 = (float)m14c;
                                                                break;
                                                            case 36:
                                                                somevoxelvirtualdesktop[indexofmainobject].arrayofindexzeromesh[indexofmeshzero].instancesmatrixc[indexofmeshinst].instancematrix.M21 = (float)m21c;
                                                                break;
                                                            case 37:
                                                                somevoxelvirtualdesktop[indexofmainobject].arrayofindexzeromesh[indexofmeshzero].instancesmatrixc[indexofmeshinst].instancematrix.M22 = (float)m22c;
                                                                break;
                                                            case 38:
                                                                somevoxelvirtualdesktop[indexofmainobject].arrayofindexzeromesh[indexofmeshzero].instancesmatrixc[indexofmeshinst].instancematrix.M23 = (float)m23c;
                                                                break;
                                                            case 39:
                                                                somevoxelvirtualdesktop[indexofmainobject].arrayofindexzeromesh[indexofmeshzero].instancesmatrixc[indexofmeshinst].instancematrix.M24 = (float)m24c;
                                                                break;
                                                            case 40:
                                                                somevoxelvirtualdesktop[indexofmainobject].arrayofindexzeromesh[indexofmeshzero].instancesmatrixc[indexofmeshinst].instancematrix.M31 = (float)m31c;
                                                                break;
                                                            case 41:
                                                                somevoxelvirtualdesktop[indexofmainobject].arrayofindexzeromesh[indexofmeshzero].instancesmatrixc[indexofmeshinst].instancematrix.M32 = (float)m32c;
                                                                break;
                                                            case 42:
                                                                somevoxelvirtualdesktop[indexofmainobject].arrayofindexzeromesh[indexofmeshzero].instancesmatrixc[indexofmeshinst].instancematrix.M33 = (float)m33c;
                                                                break;
                                                            case 43:
                                                                somevoxelvirtualdesktop[indexofmainobject].arrayofindexzeromesh[indexofmeshzero].instancesmatrixc[indexofmeshinst].instancematrix.M34 = (float)m34c;
                                                                break;
                                                            case 44:
                                                                somevoxelvirtualdesktop[indexofmainobject].arrayofindexzeromesh[indexofmeshzero].instancesmatrixc[indexofmeshinst].instancematrix.M41 = (float)m41c;
                                                                break;
                                                            case 45:
                                                                somevoxelvirtualdesktop[indexofmainobject].arrayofindexzeromesh[indexofmeshzero].instancesmatrixc[indexofmeshinst].instancematrix.M42 = (float)m42c;
                                                                break;
                                                            case 46:
                                                                somevoxelvirtualdesktop[indexofmainobject].arrayofindexzeromesh[indexofmeshzero].instancesmatrixc[indexofmeshinst].instancematrix.M43 = (float)m43c;
                                                                break;
                                                            case 47:
                                                                somevoxelvirtualdesktop[indexofmainobject].arrayofindexzeromesh[indexofmeshzero].instancesmatrixc[indexofmeshinst].instancematrix.M44 = (float)m44c;
                                                                break;




                                                            case 48:
                                                                somevoxelvirtualdesktop[indexofmainobject].arrayofindexzeromesh[indexofmeshzero].instancesmatrixd[indexofmeshinst].instancematrix.M11 = (float)m11d;
                                                                break;
                                                            case 49:
                                                                somevoxelvirtualdesktop[indexofmainobject].arrayofindexzeromesh[indexofmeshzero].instancesmatrixd[indexofmeshinst].instancematrix.M12 = (float)m12d;
                                                                break;
                                                            case 50:
                                                                somevoxelvirtualdesktop[indexofmainobject].arrayofindexzeromesh[indexofmeshzero].instancesmatrixd[indexofmeshinst].instancematrix.M13 = (float)m13d;
                                                                break;
                                                            case 51:
                                                                somevoxelvirtualdesktop[indexofmainobject].arrayofindexzeromesh[indexofmeshzero].instancesmatrixd[indexofmeshinst].instancematrix.M14 = (float)m14d;
                                                                break;
                                                            case 52:
                                                                somevoxelvirtualdesktop[indexofmainobject].arrayofindexzeromesh[indexofmeshzero].instancesmatrixd[indexofmeshinst].instancematrix.M21 = (float)m21d;
                                                                break;
                                                            case 53:
                                                                somevoxelvirtualdesktop[indexofmainobject].arrayofindexzeromesh[indexofmeshzero].instancesmatrixd[indexofmeshinst].instancematrix.M22 = (float)m22d;
                                                                break;
                                                            case 54:
                                                                somevoxelvirtualdesktop[indexofmainobject].arrayofindexzeromesh[indexofmeshzero].instancesmatrixd[indexofmeshinst].instancematrix.M23 = (float)m23d;
                                                                break;
                                                            case 55:
                                                                somevoxelvirtualdesktop[indexofmainobject].arrayofindexzeromesh[indexofmeshzero].instancesmatrixd[indexofmeshinst].instancematrix.M24 = (float)m24d;
                                                                break;
                                                            case 56:
                                                                somevoxelvirtualdesktop[indexofmainobject].arrayofindexzeromesh[indexofmeshzero].instancesmatrixd[indexofmeshinst].instancematrix.M31 = (float)m31d;
                                                                break;
                                                            case 57:
                                                                somevoxelvirtualdesktop[indexofmainobject].arrayofindexzeromesh[indexofmeshzero].instancesmatrixd[indexofmeshinst].instancematrix.M32 = (float)m32d;
                                                                break;
                                                            case 58:
                                                                somevoxelvirtualdesktop[indexofmainobject].arrayofindexzeromesh[indexofmeshzero].instancesmatrixd[indexofmeshinst].instancematrix.M33 = (float)m33d;
                                                                break;
                                                            case 59:
                                                                somevoxelvirtualdesktop[indexofmainobject].arrayofindexzeromesh[indexofmeshzero].instancesmatrixd[indexofmeshinst].instancematrix.M34 = (float)m34d;
                                                                break;
                                                            case 60:
                                                                somevoxelvirtualdesktop[indexofmainobject].arrayofindexzeromesh[indexofmeshzero].instancesmatrixd[indexofmeshinst].instancematrix.M41 = (float)m41d;
                                                                break;
                                                            case 61:
                                                                somevoxelvirtualdesktop[indexofmainobject].arrayofindexzeromesh[indexofmeshzero].instancesmatrixd[indexofmeshinst].instancematrix.M42 = (float)m42d;
                                                                break;
                                                            case 62:
                                                                somevoxelvirtualdesktop[indexofmainobject].arrayofindexzeromesh[indexofmeshzero].instancesmatrixd[indexofmeshinst].instancematrix.M43 = (float)m43d;
                                                                break;
                                                            case 63:
                                                                somevoxelvirtualdesktop[indexofmainobject].arrayofindexzeromesh[indexofmeshzero].instancesmatrixd[indexofmeshinst].instancematrix.M44 = (float)m44d;
                                                                break;
                                                        };







                                                    }
                                                }
                                            }
                                        }
                                    }
                                }
                            }
                        }

















                        pivotpositionpickaxe = new Vector3(ikarmvoxel[3]._player_r_hand_grab[0][0]._arrayOfInstances[insti].current_pos.M41, ikarmvoxel[3]._player_r_hand_grab[0][0]._arrayOfInstances[insti].current_pos.M42, ikarmvoxel[3]._player_r_hand_grab[0][0]._arrayOfInstances[insti].current_pos.M43);
                        temppickaxetiplocation = new Vector3(ikarmvoxel[3]._player_r_hand_grab[0][0]._chunk.listofpickaxetipbytes[0].X, ikarmvoxel[3]._player_r_hand_grab[0][0]._chunk.listofpickaxetipbytes[0].Y, ikarmvoxel[3]._player_r_hand_grab[0][0]._chunk.listofpickaxetipbytes[0].Z);
                        MOVINGPOINTER = new Vector3(ikvoxelbody[0]._player_torso[0][0]._arrayOfInstances[insti]._ORIGINPOSITION.M41, ikvoxelbody[0]._player_torso[0][0]._arrayOfInstances[insti]._ORIGINPOSITION.M42, ikvoxelbody[0]._player_torso[0][0]._arrayOfInstances[insti]._ORIGINPOSITION.M43);

                        rotposmatrix = ikarmvoxel[3]._player_r_hand_grab[0][0]._arrayOfInstances[insti].current_pos;// _player_rght_shldr[0][0]._ORIGINPOSITION;

                        //Quaternion somequat;
                        Quaternion.RotationMatrix(ref rotposmatrix, out somequat);

                        direction_feet_forward_ori = sc_maths._getDirection(Vector3.ForwardRH, somequat);
                        direction_feet_right_ori = sc_maths._getDirection(Vector3.Right, somequat);
                        direction_feet_up_ori = sc_maths._getDirection(Vector3.Up, somequat);

                        diffNormPosX = (MOVINGPOINTER.X) - ikarmvoxel[3]._player_r_hand_grab[0][0]._arrayOfInstances[insti].current_pos.M41;
                        diffNormPosY = (MOVINGPOINTER.Y) - ikarmvoxel[3]._player_r_hand_grab[0][0]._arrayOfInstances[insti].current_pos.M42;
                        diffNormPosZ = (MOVINGPOINTER.Z) - ikarmvoxel[3]._player_r_hand_grab[0][0]._arrayOfInstances[insti].current_pos.M43;

                        pickaxetippoint = MOVINGPOINTER;

                        //var tempPoint = pickaxetippoint + (direction_feet_right_ori * (diffNormPosX));
                        //tempPoint = tempPoint + (direction_feet_up_ori * (diffNormPosY));
                        //tempPoint = tempPoint + (direction_feet_forward_ori * (diffNormPosZ));

                        //var MOVINGPOINTER1 = tempPoint + new Vector3(ikarmvoxel[3]._player_r_hand_grab[0][0]._arrayOfInstances[insti].current_pos.M41, ikarmvoxel[3]._player_r_hand_grab[0][0]._arrayOfInstances[insti].current_pos.M42, ikarmvoxel[3]._player_r_hand_grab[0][0]._arrayOfInstances[insti].current_pos.M43);
                        MOVINGPOINTER1 = new Vector3(ikarmvoxel[3]._player_r_hand_grab[0][0]._arrayOfInstances[insti].current_pos.M41, ikarmvoxel[3]._player_r_hand_grab[0][0]._arrayOfInstances[insti].current_pos.M42, ikarmvoxel[3]._player_r_hand_grab[0][0]._arrayOfInstances[insti].current_pos.M43);

                        //float somezvalue = ikarmvoxel[3]._player_r_hand_grab[0][0]._total_torso_height;

                        pickaxetippoint = MOVINGPOINTER1 + (direction_feet_up_ori * (-temppickaxetiplocation.Y * ikarmvoxel[3].voxel_general_size));
                        pickaxetippoint = pickaxetippoint + (direction_feet_forward_ori * (-temppickaxetiplocation.Z * ikarmvoxel[3].voxel_general_size));




                        //SET THE BYTE LOCATOR OBJECT TO THE LOCATION OF THE BYTE ON THE CHUNK IN ORDER TO HAVE A VISUAL ON WHERE THE BYTE LOCATOR IS IN CODE
                        //SET THE BYTE LOCATOR OBJECT TO THE LOCATION OF THE BYTE ON THE CHUNK IN ORDER TO HAVE A VISUAL ON WHERE THE BYTE LOCATOR IS IN CODE
                        //SET THE BYTE LOCATOR OBJECT TO THE LOCATION OF THE BYTE ON THE CHUNK IN ORDER TO HAVE A VISUAL ON WHERE THE BYTE LOCATOR IS IN CODE
                        worldMatrix_instances_voxel_cube[0][0][5].M41 = pickaxetippoint.X;
                        worldMatrix_instances_voxel_cube[0][0][5].M42 = pickaxetippoint.Y;
                        worldMatrix_instances_voxel_cube[0][0][5].M43 = pickaxetippoint.Z;
                        //SET THE BYTE LOCATOR OBJECT TO THE LOCATION OF THE BYTE ON THE CHUNK IN ORDER TO HAVE A VISUAL ON WHERE THE BYTE LOCATOR IS IN CODE
                        //SET THE BYTE LOCATOR OBJECT TO THE LOCATION OF THE BYTE ON THE CHUNK IN ORDER TO HAVE A VISUAL ON WHERE THE BYTE LOCATOR IS IN CODE
                        //SET THE BYTE LOCATOR OBJECT TO THE LOCATION OF THE BYTE ON THE CHUNK IN ORDER TO HAVE A VISUAL ON WHERE THE BYTE LOCATOR IS IN CODE


                        planeSize = somechunkkeyboardglobals.planeSize;

                        //float somesizedfx = (float)(Math.Floor(pickaxetippoint.X / planeSize) * planeSize); // 35 + 1 = 36
                        //float somesizedfy = (float)(Math.Floor(pickaxetippoint.Y / planeSize) * planeSize); // 
                        //float somesizedfz = (float)(Math.Floor(pickaxetippoint.Z / planeSize) * planeSize); //

                        //ORIGINAL MADE BY STEVE CHASSÉ
                        //int somefx = (int)Math.Abs(Math.Floor(((ikarmvoxel[3]._player_rght_hnd[0][0]._arrayOfInstances[insti].current_pos.M41) - somechunkkeyboard[0].worldmatofobj.M41) / planeSize)); // 35 + 1 = 36
                        //int somefy = (int)Math.Abs(Math.Floor(((ikarmvoxel[3]._player_rght_hnd[0][0]._arrayOfInstances[insti].current_pos.M42) - somechunkkeyboard[0].worldmatofobj.M42) / planeSize)); // 
                        //int somefz = (int)Math.Abs(Math.Floor(((ikarmvoxel[3]._player_rght_hnd[0][0]._arrayOfInstances[insti].current_pos.M43) - somechunkkeyboard[0].worldmatofobj.M43) / planeSize)); //
                        //ORIGINAL MADE BY STEVE CHASSÉ



                        somefx = (int)Math.Abs(Math.Round(((pickaxetippoint.X) - somechunkkeyboard[0].worldmatofobj.M41) / planeSize)); // 35 + 1 = 36
                        somefy = (int)Math.Abs(Math.Round(((pickaxetippoint.Y) - somechunkkeyboard[0].worldmatofobj.M42) / planeSize)); // 
                        somefz = (int)Math.Abs(Math.Round(((pickaxetippoint.Z) - somechunkkeyboard[0].worldmatofobj.M43) / planeSize)); //

                        /*
                        somefx = (int)Math.Abs(Math.Round(((pickaxetippoint.X)) / planeSize)); // 35 + 1 = 36
                        somefy = (int)Math.Abs(Math.Round(((pickaxetippoint.Y)) / planeSize)); // 
                        somefz = (int)Math.Abs(Math.Round(((pickaxetippoint.Z)) / planeSize)); //
                        */
                        //if (somefx >= 0 && somefy >= 0 && somefz >= 0)
                        {
                            //BYTES INDEX FAST MODULO ALTERNATIVE FOUND ON A GOOGLE SEARCH WITH SOME BENCHMARKS AND IT SEEMED TO BE THAT LOOPING WAS FASTER THAN USING MODULO... DEPENDING MAYBE ON OTHER THINGS. ILL TEST LATER.
                            int theNumberx = somechunkkeyboardglobals.tinyChunkWidth;
                            int remainderbytesx = 0;
                            int totalTimesx = 0;

                            for (int ii = 0; ii <= somefx; ii++)
                            {
                                if (remainderbytesx == theNumberx)
                                {
                                    remainderbytesx = 0;
                                    totalTimesx++;
                                }
                                if (totalTimesx * theNumberx >= somefx) // >=?? why not only >
                                {
                                    break;
                                }
                                remainderbytesx++;
                            }

                            int theNumbery = somechunkkeyboardglobals.tinyChunkHeight;
                            int remainderbytesy = 0;
                            int totalTimesy = 0;

                            for (int ii = 0; ii <= somefy; ii++)
                            {
                                if (remainderbytesy == theNumbery)
                                {
                                    remainderbytesy = 0;
                                    totalTimesy++;
                                }
                                if (totalTimesy * theNumbery >= somefy) // >=?? why not only >
                                {
                                    break;
                                }
                                remainderbytesy++;
                            }

                            int theNumberz = somechunkkeyboardglobals.tinyChunkDepth;
                            int remainderbytesz = 0;
                            int totalTimesz = 0;

                            for (int ii = 0; ii <= somefz; ii++)
                            {
                                if (remainderbytesz == theNumberz)
                                {
                                    remainderbytesz = 0;
                                    totalTimesz++;
                                }
                                if (totalTimesz * theNumberz >= somefz) // >=?? why not only >
                                {
                                    break;
                                }
                                remainderbytesz++;
                            }
                            //BYTES INDEX 

                            //
                            int indexbytex = ((somefx - (totalTimesx * theNumberx)));
                            int indexbytey = ((somefy - (totalTimesy * theNumbery)));
                            int indexbytez = ((somefz - (totalTimesz * theNumberz)));
                            int indexofbyte = (indexbytex) + (somechunkkeyboardglobals.tinyChunkWidth) * ((indexbytey) + (somechunkkeyboardglobals.tinyChunkHeight) * (indexbytez));
                            //

                            //MESH INSTANCE INDEX FAST MODULO 
                            theNumberx = somechunkkeyboardglobals.tinyChunkWidth;
                            int remaindermeshinstx = 0;
                            totalTimesx = 0;

                            for (int ii = 0; ii <= somefx; ii++)
                            {
                                if (remaindermeshinstx == theNumberx)
                                {
                                    remaindermeshinstx = 0;
                                    totalTimesx++;
                                }
                                if (totalTimesx * theNumberx >= somefx) // >=?? why not only >
                                {
                                    break;
                                }
                                remaindermeshinstx++;
                            }

                            theNumbery = somechunkkeyboardglobals.tinyChunkHeight;
                            int remaindermeshinsty = 0;
                            totalTimesy = 0;

                            for (int ii = 0; ii <= somefy; ii++)
                            {
                                if (remaindermeshinsty == theNumbery)
                                {
                                    remaindermeshinsty = 0;
                                    totalTimesy++;
                                }
                                if (totalTimesy * theNumbery >= somefy) // >=?? why not only >
                                {
                                    break;
                                }
                                remaindermeshinsty++;
                            }

                            theNumberz = somechunkkeyboardglobals.tinyChunkDepth;  //somechunkkeyboardglobals.tinyChunkDepth;
                            int remaindermeshinstz = 0;
                            totalTimesz = 0;

                            for (int ii = 0; ii <= somefz; ii++) // 35
                            {
                                if (remaindermeshinstz == theNumberz) //16
                                {
                                    remaindermeshinstz = 0;
                                    totalTimesz++;
                                }
                                if (totalTimesz * theNumberz >= somefz) // >=?? why not only >
                                {
                                    break;
                                }
                                remaindermeshinstz++;
                            }
                            //MESH INSTANCE INDEX FAST MODULO 

                            //
                            int indexofmeshinstx = totalTimesx;// ((somefx - (totalTimesx * theNumberx))); // 35 - 30 = 5 
                            int indexofmeshinsty = totalTimesy;//  ((somefy - (totalTimesy * theNumbery))); 
                            int indexofmeshinstz = totalTimesz;// ((somefz - (totalTimesz * theNumberz)));
                                                               //int indexofmeshinstx = ((somefx - (totalTimesx * theNumberx))); // 35 - 30 = 5 
                                                               //int indexofmeshinsty = ((somefy - (totalTimesy * theNumbery)));
                                                               //int indexofmeshinstz = ((somefz - (totalTimesz * theNumberz)));


                            if (indexofmeshinstx >= somechunkkeyboardglobals.numberOfInstancesPerObjectInWidth)
                            {
                                indexofmeshinstx = indexofmeshinstx % somechunkkeyboardglobals.numberOfInstancesPerObjectInWidth;
                            }
                            if (indexofmeshinsty >= somechunkkeyboardglobals.numberOfInstancesPerObjectInHeight)
                            {
                                indexofmeshinsty = indexofmeshinsty % somechunkkeyboardglobals.numberOfInstancesPerObjectInHeight;
                            }
                            if (indexofmeshinstz >= somechunkkeyboardglobals.numberOfInstancesPerObjectInDepth)
                            {
                                indexofmeshinstz = indexofmeshinstz % somechunkkeyboardglobals.numberOfInstancesPerObjectInDepth;
                            }

                            int indexofmeshinst = (indexofmeshinstx) + (somechunkkeyboardglobals.numberOfInstancesPerObjectInWidth) * ((indexofmeshinsty) + (somechunkkeyboardglobals.numberOfInstancesPerObjectInHeight) * (indexofmeshinstz));
                            //


                            //MESH ZERO INDEX FAST MODULO 
                            theNumberx = somechunkkeyboardglobals.tinyChunkDepth * somechunkkeyboardglobals.numberOfInstancesPerObjectInDepth;
                            int remaindermeshzerox = 0;
                            totalTimesx = 0;

                            for (int ii = 0; ii <= somefx; ii++)
                            {
                                if (remaindermeshzerox == theNumberx)
                                {
                                    remaindermeshzerox = 0;
                                    totalTimesx++;
                                }
                                if (totalTimesx * theNumberx >= somefx) // >=?? why not only >
                                {
                                    break;
                                }
                                remaindermeshzerox++;
                            }

                            theNumbery = somechunkkeyboardglobals.tinyChunkDepth * somechunkkeyboardglobals.numberOfInstancesPerObjectInDepth;
                            int remaindermeshzeroy = 0;
                            totalTimesy = 0;

                            for (int ii = 0; ii <= somefy; ii++)
                            {
                                if (remaindermeshzeroy == theNumbery)
                                {
                                    remaindermeshzeroy = 0;
                                    totalTimesy++;
                                }
                                if (totalTimesy * theNumbery >= somefy) // >=?? why not only >
                                {
                                    break;
                                }
                                remaindermeshzeroy++;
                            }

                            theNumberz = somechunkkeyboardglobals.tinyChunkDepth * somechunkkeyboardglobals.numberOfInstancesPerObjectInDepth;  //somechunkkeyboardglobals.tinyChunkDepth;
                            int remaindermeshzeroz = 0;
                            totalTimesz = 0;

                            for (int ii = 0; ii <= somefz; ii++)
                            {
                                if (remaindermeshzeroz == theNumberz)
                                {
                                    remaindermeshzeroz = 0;
                                    totalTimesz++;
                                }
                                if (totalTimesz * theNumberz >= somefz) // >=?? why not only >
                                {
                                    break;
                                }
                                remaindermeshzeroz++;
                            }
                            //MESH ZERO INDEX FAST MODULO 


                            if (totalTimesx >= somechunkkeyboardglobals.numberOfObjectInWidth)
                            {
                                totalTimesx = totalTimesx % somechunkkeyboardglobals.numberOfObjectInWidth;
                            }
                            if (totalTimesy >= somechunkkeyboardglobals.numberOfObjectInHeight)
                            {
                                totalTimesy = totalTimesy % somechunkkeyboardglobals.numberOfObjectInHeight;
                            }
                            if (totalTimesz >= somechunkkeyboardglobals.numberOfObjectInDepth)
                            {
                                totalTimesz = totalTimesz % somechunkkeyboardglobals.numberOfObjectInDepth;
                            }



                            //
                            int indexmeshzerox = totalTimesx;//((somefx - (totalTimesx * theNumberx)));
                            int indexmeshzeroy = totalTimesy;//((somefy - (totalTimesy * theNumbery)));
                            int indexmeshzeroz = totalTimesz;//((somefz - (totalTimesz * theNumberz)));
                            int indexofmeshzero = (indexmeshzerox) + (somechunkkeyboardglobals.numberOfObjectInWidth) * ((indexmeshzeroy) + (somechunkkeyboardglobals.numberOfObjectInHeight) * (indexmeshzeroz));
                            //


                            //MAIN OBJECT INDEX FAST MODULO 
                            theNumberx = somechunkkeyboardglobals.tinyChunkWidth * somechunkkeyboardglobals.numberOfInstancesPerObjectInWidth * somechunkkeyboardglobals.numberOfObjectInWidth;
                            int remaindermainobjectx = 0;
                            totalTimesx = 0;

                            for (int ii = 0; ii <= somefx; ii++)
                            {
                                if (remaindermainobjectx == theNumberx)
                                {
                                    remaindermainobjectx = 0;
                                    totalTimesx++;
                                }
                                if (totalTimesx * theNumberx >= somefx) // >=?? why not only >
                                {
                                    break;
                                }
                                remaindermainobjectx++;
                            }

                            theNumbery = somechunkkeyboardglobals.tinyChunkHeight * somechunkkeyboardglobals.numberOfInstancesPerObjectInHeight * somechunkkeyboardglobals.numberOfObjectInHeight;
                            int remaindermainobjecty = 0;
                            totalTimesy = 0;

                            for (int ii = 0; ii <= somefy; ii++)
                            {
                                if (remaindermainobjecty == theNumbery)
                                {
                                    remaindermainobjecty = 0;
                                    totalTimesy++;
                                }
                                if (totalTimesy * theNumbery >= somefy) // >=?? why not only >
                                {
                                    break;
                                }
                                remaindermainobjecty++;
                            }

                            theNumberz = somechunkkeyboardglobals.tinyChunkDepth * somechunkkeyboardglobals.numberOfInstancesPerObjectInDepth * somechunkkeyboardglobals.numberOfObjectInDepth;  //somechunkkeyboardglobals.tinyChunkDepth;
                            int remaindermainobjectz = 0;
                            totalTimesz = 0;

                            for (int ii = 0; ii <= somefz; ii++)
                            {
                                if (remaindermainobjectz == theNumberz)
                                {
                                    remaindermainobjectz = 0;
                                    totalTimesz++;
                                }
                                if (totalTimesz * theNumberz >= somefz) // >=?? why not only >
                                {
                                    break;
                                }
                                remaindermainobjectz++;
                            }
                            //MAIN OBJECT INDEX FAST MODULO 


                            if (totalTimesx >= somechunkkeyboardw)
                            {
                                totalTimesx = totalTimesx % somechunkkeyboardw;
                            }
                            if (totalTimesy >= somechunkkeyboardh)
                            {
                                totalTimesy = totalTimesy % somechunkkeyboardh;
                            }
                            if (totalTimesz >= somechunkkeyboardd)
                            {
                                totalTimesz = totalTimesz % somechunkkeyboardd;
                            }

                            //
                            //int indexmainobjectx = totalTimesx; //((somefx - (totalTimesx * theNumberx)));
                            //int indexmainobjecty = totalTimesy; //((somefy - (totalTimesy * theNumbery)));
                            //int indexmainobjectz = totalTimesz; //((somefz - (totalTimesz * theNumberz)));
                            //int indexmainobjectx = ((somefx - (totalTimesx * theNumberx)));
                            //int indexmainobjecty = ((somefy - (totalTimesy * theNumbery)));
                            //int indexmainobjectz = ((somefz - (totalTimesz * theNumberz)));
                            int indexmainobjectx = totalTimesx;// ((somefx - (totalTimesx * theNumberx)));
                            int indexmainobjecty = totalTimesy;// ((somefy - (totalTimesy * theNumbery)));
                            int indexmainobjectz = totalTimesz;// ((somefz - (totalTimesz * theNumberz)));

                            int indexofmainobject = (indexmainobjectx) + (somechunkkeyboardw) * ((indexmainobjecty) + (somechunkkeyboardh) * (indexmainobjectz));
                            //

                            //int diffx = (int)(Math.Floor(SC_Update._rightTouchMatrix.M41 - somechunkkeyboard[indexofmainobject].arrayofindexzeromesh[indexofmeshzero].somechunk[indexofmeshinst].somechunkpos.X));
                            //int diffy = (int)(Math.Floor(SC_Update._rightTouchMatrix.M42 - somechunkkeyboard[indexofmainobject].arrayofindexzeromesh[indexofmeshzero].somechunk[indexofmeshinst].somechunkpos.Y));
                            //int diffz = (int)(Math.Floor(SC_Update._rightTouchMatrix.M43 - somechunkkeyboard[indexofmainobject].arrayofindexzeromesh[indexofmeshzero].somechunk[indexofmeshinst].somechunkpos.Z));

                            //CONSOLE DEBUG
                            //CONSOLE DEBUG
                            //CONSOLE DEBUG

                            if (consolewritecounter >= consolewritecountermax)
                            {
                                if (consolewritecounterswtc == 0)
                                {

                                    consolewritecounterswtc = 1;
                                }

                                /*for (int sc = 0; sc < 30; sc++) //Console.WindowWidth - 1
                                {
                                    Console.SetCursorPosition(sc, 0);
                                    Console.WriteLine(" ");
                                    //Console.SetCursorPosition(sc, 1);
                                    //Console.WriteLine(" ");
                                    //Console.SetCursorPosition(sc, 1);
                                    //Console.WriteLine(" ");
                                    //Console.SetCursorPosition(sc, 3);
                                    //Console.WriteLine(" ");
                                    //Console.SetCursorPosition(sc, 4);
                                    //Console.WriteLine(" ");
                                }*/

                                //Console.SetCursorPosition(0, 0);
                                //Console.WriteLine("x:" + +mainx + "/y:" + mainy + "/z:" + mainz);

                                //Console.SetCursorPosition(0, 1);
                                //Console.WriteLine("secx:" + +secx + "/secy:" + secy + "/secz:" + secz);

                                //Console.SetCursorPosition(0, 0);
                                //Console.WriteLine("somefx:" + +somefx + "/somefy:" + somefy + "/somefz:" + somefz);

                                //Console.SetCursorPosition(0, 0);
                                //Console.WriteLine("fobjmeshx:" + +fobjmeshx + "/fobjmeshy:" + fobjmeshy + "/fobjmeshz:" + fobjmeshz);

                                //Console.Title = "fobjmeshx:" + +fobjmeshx + "/fobjmeshy:" + fobjmeshy + "/fobjmeshz:" + fobjmeshz;
                                //Console.Title = "fobjmeshx:" + +fobjmeshx + "/fobjmeshy:" + fobjmeshy + "/fobjmeshz:" + fobjmeshz;
                                //Console.Title = "finstx:" + +finstx + "/finsty:" + finsty + "/finstz:" + finstz;
                                //Console.Title = "mainx:" + mainx + "/mainy:" + mainy + "/mainz:" + mainz;
                                //Console.Title = "someothermainx:" + someothermainx + "/someothermainy:" + someothermainy + "/someothermainz:" + someothermainz + "/fobjmeshx:" + +fobjmeshx + "/fobjmeshy:" + fobjmeshy + "/fobjmeshz:" + fobjmeshz;
                                //Console.Title = "/someothermainx:" + someothermainx + "/someothermainy:" + someothermainy + "/someothermainz:" + someothermainz +"/fobjmeshmainx:" + fobjmeshmainx + "/fobjmeshmainy:" + fobjmeshmainy + "/fobjmeshmainz:" + fobjmeshmainz + "/fobjmeshx:" + +fobjmeshx + "/fobjmeshy:" + fobjmeshy + "/fobjmeshz:" + fobjmeshz;

                                //Console.Title = "someinstx:" + (int)someinstx + "/someinsty:" + (int)someinsty + "/someinstz:" + (int)someinstz;

                                //Console.Title = "somefx:" + +somefx + "/somefy:" + somefy + "/somefz:" + somefz;


                                //Console.Title = "indexbytex:" + (int)indexbytex + "/indexbytey:" + (int)indexbytey + "/indexbytez:" + (int)indexbytez;
                                //Console.Title = "indexofmeshinstx:" + (int)indexofmeshinstx + "/indexofmeshinsty:" + (int)indexofmeshinsty + "/indexofmeshinstz:" + (int)indexofmeshinstz;


                                //Console.Title = "/tx:" + totalTimesx + "/ty:" + totalTimesy + "/tz:" + totalTimesz + "/rx:" + remaindermainobjectx + "/ry:" + remaindermainobjecty + "/rz:" + remaindermainobjectz + "/mx:" + indexmainobjectx + "/my:" + indexmainobjecty + "/mz:" + indexmainobjectz + "/msx:" + (int)indexmeshzerox + "/msy:" + (int)indexmeshzeroy + "/msz:" + (int)indexmeshzeroz + "/msix:" + (int)indexofmeshinstx + "/msiy:" + (int)indexofmeshinsty + "/msiz:" + (int)indexofmeshinstz + "/indexbytex:" + (int)indexbytex + "/indexbytey:" + (int)indexbytey + "/indexbytez:" + (int)indexbytez;


                                //Console.Title = "/indexmeshzerox:" + (int)indexmeshzerox + "/indexmeshzeroy:" + (int)indexmeshzeroy + "/indexmeshzeroz:" + (int)indexmeshzeroz;


                                consolewritecounter = 0;
                            }
                            consolewritecounter++;

                            //CONSOLE DEBUG
                            //CONSOLE DEBUG
                            //CONSOLE DEBUG

                            //indexofmainobject = someothermainindex;

                            if (indexofmainobject >= 0 && indexofmainobject < somechunkkeyboardw * somechunkkeyboardh * somechunkkeyboardd)
                            {
                                if (indexofmeshzero >= 0 && indexofmeshzero < somechunkkeyboardglobals.numberOfObjectInWidth * somechunkkeyboardglobals.numberOfObjectInHeight * somechunkkeyboardglobals.numberOfObjectInDepth)
                                {
                                    if (indexofmeshinst >= 0 && indexofmeshinst < somechunkkeyboardglobals.numberOfInstancesPerObjectInWidth * somechunkkeyboardglobals.numberOfInstancesPerObjectInHeight * somechunkkeyboardglobals.numberOfInstancesPerObjectInDepth)
                                    {
                                        someinstancebytesindex = indexofbyte;

                                        if (someinstancebytesindex >= 0 && someinstancebytesindex < somechunkkeyboardglobals.tinyChunkWidth * somechunkkeyboardglobals.tinyChunkHeight * somechunkkeyboardglobals.tinyChunkDepth)
                                        {
                                            int currentIndex = someinstancebytesindex;
                                            int someOtherIndex = currentIndex;

                                            double currentMapData = -1;

                                            int chosenmap = 0;

                                            int somemul = 0;

                                            if (currentIndex >= 0 && currentIndex <= 63)
                                            {
                                                if (currentIndex >= 0 && currentIndex <= 3)
                                                {
                                                    currentMapData = (double)somechunkkeyboard[indexofmainobject].arrayofindexzeromesh[indexofmeshzero].instancesmatrix[indexofmeshinst].instancematrix.M11;//input.one;                                                                                                                                                                                                 //// MainWindow.MessageBox((IntPtr)0, "sccs:" + "map:" + (double)somechunkkeyboard[indexofmainobject].arrayofindexzeromesh[indexofmeshzero].instancesmatrix[indexofmeshinst].instancematrix.M11 , "sccs message 0", 0);

                                                    if (currentIndex >= 0 && currentIndex <= 1)
                                                    {
                                                        int somemax = 1;
                                                        someOtherIndex = 1 + ((somemax - someOtherIndex) * 2);
                                                    }
                                                    else if (currentIndex >= 2 && currentIndex <= 3)
                                                    {
                                                        int somemax = 3;
                                                        someOtherIndex = 0 + ((somemax - someOtherIndex) * 2);
                                                    }
                                                    chosenmap = 0;
                                                }
                                                else if (currentIndex >= 4 && currentIndex <= 7)
                                                {
                                                    currentMapData = (double)somechunkkeyboard[indexofmainobject].arrayofindexzeromesh[indexofmeshzero].instancesmatrix[indexofmeshinst].instancematrix.M12;//input.oneTwo;
                                                                                                                                                                                                            //// MainWindow.MessageBox((IntPtr)0, "sccs:" + "map:" + (double)somechunkkeyboard[indexofmainobject].arrayofindexzeromesh[indexofmeshzero].instancesmatrix[indexofmeshinst].instancematrix.M12 , "sccs message 0", 0);

                                                    if (currentIndex >= 4 && currentIndex <= 5)
                                                    {
                                                        int somemax = 5;
                                                        someOtherIndex = 1 + ((somemax - someOtherIndex) * 2);
                                                    }
                                                    else if (currentIndex >= 6 && currentIndex <= 7)
                                                    {
                                                        int somemax = 7;
                                                        someOtherIndex = 0 + ((somemax - someOtherIndex) * 2);
                                                    }
                                                    chosenmap = 1;
                                                }
                                                else if (currentIndex >= 8 && currentIndex <= 11)
                                                {
                                                    currentMapData = (double)somechunkkeyboard[indexofmainobject].arrayofindexzeromesh[indexofmeshzero].instancesmatrix[indexofmeshinst].instancematrix.M13;
                                                    //// MainWindow.MessageBox((IntPtr)0, "sccs:" + "map:" + (double)somechunkkeyboard[indexofmainobject].arrayofindexzeromesh[indexofmeshzero].instancesmatrix[indexofmeshinst].instancematrix.M13 , "sccs message 0", 0);

                                                    if (currentIndex >= 8 && currentIndex <= 9)
                                                    {
                                                        int somemax = 9;
                                                        someOtherIndex = 1 + ((somemax - someOtherIndex) * 2);
                                                    }
                                                    else if (currentIndex >= 10 && currentIndex <= 11)
                                                    {
                                                        int somemax = 11;
                                                        someOtherIndex = 0 + ((somemax - someOtherIndex) * 2);
                                                    }
                                                    chosenmap = 2;
                                                }

                                                else if (currentIndex >= 12 && currentIndex <= 15)
                                                {
                                                    currentMapData = (double)somechunkkeyboard[indexofmainobject].arrayofindexzeromesh[indexofmeshzero].instancesmatrix[indexofmeshinst].instancematrix.M14;//input.twoTwo;
                                                                                                                                                                                                            //// MainWindow.MessageBox((IntPtr)0, "sccs:" + "map:" + (double)somechunkkeyboard[indexofmainobject].arrayofindexzeromesh[indexofmeshzero].instancesmatrix[indexofmeshinst].instancematrix.M14 , "sccs message 0", 0);

                                                    if (currentIndex >= 12 && currentIndex <= 13)
                                                    {
                                                        int somemax = 13;
                                                        someOtherIndex = 1 + ((somemax - someOtherIndex) * 2);
                                                    }
                                                    else if (currentIndex >= 14 && currentIndex <= 15)
                                                    {
                                                        int somemax = 15;
                                                        someOtherIndex = 0 + ((somemax - someOtherIndex) * 2);
                                                    }
                                                    chosenmap = 3;
                                                }
                                                else if (currentIndex >= 16 && currentIndex <= 19)
                                                {
                                                    currentMapData = (double)somechunkkeyboard[indexofmainobject].arrayofindexzeromesh[indexofmeshzero].instancesmatrix[indexofmeshinst].instancematrix.M21;//input.three;
                                                                                                                                                                                                            //// MainWindow.MessageBox((IntPtr)0, "sccs:" + "map:" + (double)somechunkkeyboard[indexofmainobject].arrayofindexzeromesh[indexofmeshzero].instancesmatrix[indexofmeshinst].instancematrix.M21 , "sccs message 0", 0);

                                                    if (currentIndex >= 16 && currentIndex <= 17)
                                                    {
                                                        int somemax = 17;
                                                        someOtherIndex = 1 + ((somemax - someOtherIndex) * 2);
                                                    }
                                                    else if (currentIndex >= 18 && currentIndex <= 19)
                                                    {
                                                        int somemax = 19;
                                                        someOtherIndex = 0 + ((somemax - someOtherIndex) * 2);
                                                    }
                                                    chosenmap = 4;
                                                }
                                                else if (currentIndex >= 20 && currentIndex <= 23)
                                                {
                                                    currentMapData = (double)somechunkkeyboard[indexofmainobject].arrayofindexzeromesh[indexofmeshzero].instancesmatrix[indexofmeshinst].instancematrix.M22; //input.mapmatrix1.y;//input.threeTwo;
                                                                                                                                                                                                             //// MainWindow.MessageBox((IntPtr)0, "sccs:" + "map:" + (double)somechunkkeyboard[indexofmainobject].arrayofindexzeromesh[indexofmeshzero].instancesmatrix[indexofmeshinst].instancematrix.M22 , "sccs message 0", 0);

                                                    if (currentIndex >= 20 && currentIndex <= 21)
                                                    {
                                                        int somemax = 21;
                                                        someOtherIndex = 1 + ((somemax - someOtherIndex) * 2);
                                                    }
                                                    else if (currentIndex >= 22 && currentIndex <= 23)
                                                    {
                                                        int somemax = 23;
                                                        someOtherIndex = 0 + ((somemax - someOtherIndex) * 2);
                                                    }
                                                    chosenmap = 5;
                                                }
                                                else if (currentIndex >= 24 && currentIndex <= 27)
                                                {
                                                    currentMapData = (double)somechunkkeyboard[indexofmainobject].arrayofindexzeromesh[indexofmeshzero].instancesmatrix[indexofmeshinst].instancematrix.M23; //input.mapmatrix1.z;//input.four;
                                                                                                                                                                                                             //// MainWindow.MessageBox((IntPtr)0, "sccs:" + "map:" + (double)somechunkkeyboard[indexofmainobject].arrayofindexzeromesh[indexofmeshzero].instancesmatrix[indexofmeshinst].instancematrix.M23 , "sccs message 0", 0);

                                                    if (currentIndex >= 24 && currentIndex <= 25)
                                                    {
                                                        int somemax = 25;
                                                        someOtherIndex = 1 + ((somemax - someOtherIndex) * 2);
                                                    }
                                                    else if (currentIndex >= 26 && currentIndex <= 27)
                                                    {
                                                        int somemax = 27;
                                                        someOtherIndex = 0 + ((somemax - someOtherIndex) * 2);
                                                    }
                                                    chosenmap = 6;
                                                }
                                                else if (currentIndex >= 28 && currentIndex <= 31)
                                                {
                                                    currentMapData = (double)somechunkkeyboard[indexofmainobject].arrayofindexzeromesh[indexofmeshzero].instancesmatrix[indexofmeshinst].instancematrix.M24; // input.mapmatrix1.w;//input.fourTwo;
                                                                                                                                                                                                             //// MainWindow.MessageBox((IntPtr)0, "sccs:" + "map:" + (double)somechunkkeyboard[indexofmainobject].arrayofindexzeromesh[indexofmeshzero].instancesmatrix[indexofmeshinst].instancematrix.M24 , "sccs message 0", 0);

                                                    if (currentIndex >= 28 && currentIndex <= 29)
                                                    {
                                                        int somemax = 29;
                                                        someOtherIndex = 1 + ((somemax - someOtherIndex) * 2);
                                                    }
                                                    else if (currentIndex >= 30 && currentIndex <= 31)
                                                    {
                                                        int somemax = 31;
                                                        someOtherIndex = 0 + ((somemax - someOtherIndex) * 2);
                                                    }
                                                    chosenmap = 7;
                                                }
                                                else if (currentIndex >= 32 && currentIndex <= 35)
                                                {
                                                    currentMapData = (double)somechunkkeyboard[indexofmainobject].arrayofindexzeromesh[indexofmeshzero].instancesmatrix[indexofmeshinst].instancematrix.M31; // input.mapmatrix1.w;//input.fourTwo;
                                                                                                                                                                                                             //// MainWindow.MessageBox((IntPtr)0, "sccs:" + "map:" + (double)somechunkkeyboard[indexofmainobject].arrayofindexzeromesh[indexofmeshzero].instancesmatrix[indexofmeshinst].instancematrix.M31, "sccs message 0", 0);

                                                    if (currentIndex >= 32 && currentIndex <= 33)
                                                    {
                                                        int somemax = 33;
                                                        someOtherIndex = 1 + ((somemax - someOtherIndex) * 2);
                                                    }
                                                    else if (currentIndex >= 34 && currentIndex <= 35)
                                                    {
                                                        int somemax = 35;
                                                        someOtherIndex = 0 + ((somemax - someOtherIndex) * 2);
                                                    }
                                                    chosenmap = 8;
                                                }
                                                else if (currentIndex >= 36 && currentIndex <= 39)
                                                {
                                                    currentMapData = (double)somechunkkeyboard[indexofmainobject].arrayofindexzeromesh[indexofmeshzero].instancesmatrix[indexofmeshinst].instancematrix.M32; // input.mapmatrix1.w;//input.fourTwo;
                                                                                                                                                                                                             //// MainWindow.MessageBox((IntPtr)0, "sccs:" + "map:" + (double)somechunkkeyboard[indexofmainobject].arrayofindexzeromesh[indexofmeshzero].instancesmatrix[indexofmeshinst].instancematrix.M32, "sccs message 0", 0);

                                                    if (currentIndex >= 36 && currentIndex <= 37)
                                                    {
                                                        int somemax = 37;
                                                        someOtherIndex = 1 + ((somemax - someOtherIndex) * 2);
                                                    }
                                                    else if (currentIndex >= 38 && currentIndex <= 39)
                                                    {
                                                        int somemax = 39;
                                                        someOtherIndex = 0 + ((somemax - someOtherIndex) * 2);
                                                    }
                                                    chosenmap = 9;
                                                }
                                                else if (currentIndex >= 40 && currentIndex <= 43)
                                                {
                                                    currentMapData = (double)somechunkkeyboard[indexofmainobject].arrayofindexzeromesh[indexofmeshzero].instancesmatrix[indexofmeshinst].instancematrix.M33; // input.mapmatrix1.w;//input.fourTwo;
                                                                                                                                                                                                             //// MainWindow.MessageBox((IntPtr)0, "sccs:" + "map:" + (double)somechunkkeyboard[indexofmainobject].arrayofindexzeromesh[indexofmeshzero].instancesmatrix[indexofmeshinst].instancematrix.M33, "sccs message 0", 0);

                                                    if (currentIndex >= 40 && currentIndex <= 41)
                                                    {
                                                        int somemax = 41;
                                                        someOtherIndex = 1 + ((somemax - someOtherIndex) * 2);
                                                    }
                                                    else if (currentIndex >= 42 && currentIndex <= 43)
                                                    {
                                                        int somemax = 43;
                                                        someOtherIndex = 0 + ((somemax - someOtherIndex) * 2);
                                                    }
                                                    chosenmap = 10;
                                                }
                                                else if (currentIndex >= 44 && currentIndex <= 47)
                                                {
                                                    currentMapData = (double)somechunkkeyboard[indexofmainobject].arrayofindexzeromesh[indexofmeshzero].instancesmatrix[indexofmeshinst].instancematrix.M34; // input.mapmatrix1.w;//input.fourTwo;
                                                                                                                                                                                                             //// MainWindow.MessageBox((IntPtr)0, "sccs:" + "map:" + (double)somechunkkeyboard[indexofmainobject].arrayofindexzeromesh[indexofmeshzero].instancesmatrix[indexofmeshinst].instancematrix.M34, "sccs message 0", 0);

                                                    if (currentIndex >= 44 && currentIndex <= 45)
                                                    {
                                                        int somemax = 45;
                                                        someOtherIndex = 1 + ((somemax - someOtherIndex) * 2);
                                                    }
                                                    else if (currentIndex >= 46 && currentIndex <= 47)
                                                    {
                                                        int somemax = 47;
                                                        someOtherIndex = 0 + ((somemax - someOtherIndex) * 2);
                                                    }
                                                    chosenmap = 11;
                                                }
                                                else if (currentIndex >= 48 && currentIndex <= 51)
                                                {
                                                    currentMapData = (double)somechunkkeyboard[indexofmainobject].arrayofindexzeromesh[indexofmeshzero].instancesmatrix[indexofmeshinst].instancematrix.M41; // input.mapmatrix1.w;//input.fourTwo;
                                                                                                                                                                                                             //// MainWindow.MessageBox((IntPtr)0, "sccs:" + "map:" + (double)somechunkkeyboard[indexofmainobject].arrayofindexzeromesh[indexofmeshzero].instancesmatrix[indexofmeshinst].instancematrix.M41, "sccs message 0", 0);

                                                    if (currentIndex >= 48 && currentIndex <= 49)
                                                    {
                                                        int somemax = 49;
                                                        someOtherIndex = 1 + ((somemax - someOtherIndex) * 2);
                                                    }
                                                    else if (currentIndex >= 50 && currentIndex <= 51)
                                                    {
                                                        int somemax = 51;
                                                        someOtherIndex = 0 + ((somemax - someOtherIndex) * 2);
                                                    }
                                                    chosenmap = 12;
                                                }
                                                else if (currentIndex >= 52 && currentIndex <= 55)
                                                {
                                                    currentMapData = (double)somechunkkeyboard[indexofmainobject].arrayofindexzeromesh[indexofmeshzero].instancesmatrix[indexofmeshinst].instancematrix.M42; // input.mapmatrix1.w;//input.fourTwo;
                                                                                                                                                                                                             //// MainWindow.MessageBox((IntPtr)0, "sccs:" + "map:" + (double)somechunkkeyboard[indexofmainobject].arrayofindexzeromesh[indexofmeshzero].instancesmatrix[indexofmeshinst].instancematrix.M42, "sccs message 0", 0);

                                                    if (currentIndex >= 52 && currentIndex <= 53)
                                                    {
                                                        int somemax = 53;
                                                        someOtherIndex = 1 + ((somemax - someOtherIndex) * 2);
                                                    }
                                                    else if (currentIndex >= 54 && currentIndex <= 55)
                                                    {
                                                        int somemax = 55;
                                                        someOtherIndex = 0 + ((somemax - someOtherIndex) * 2);
                                                    }
                                                    chosenmap = 13;
                                                }
                                                else if (currentIndex >= 56 && currentIndex <= 59)
                                                {
                                                    currentMapData = (double)somechunkkeyboard[indexofmainobject].arrayofindexzeromesh[indexofmeshzero].instancesmatrix[indexofmeshinst].instancematrix.M43; // input.mapmatrix1.w;//input.fourTwo;
                                                                                                                                                                                                             //// MainWindow.MessageBox((IntPtr)0, "sccs:" + "map:" + (double)somechunkkeyboard[indexofmainobject].arrayofindexzeromesh[indexofmeshzero].instancesmatrix[indexofmeshinst].instancematrix.M43 , "sccs message 0", 0);

                                                    if (currentIndex >= 56 && currentIndex <= 57)
                                                    {
                                                        int somemax = 57;
                                                        someOtherIndex = 1 + ((somemax - someOtherIndex) * 2);
                                                    }
                                                    else if (currentIndex >= 58 && currentIndex <= 59)
                                                    {
                                                        int somemax = 59;
                                                        someOtherIndex = 0 + ((somemax - someOtherIndex) * 2);
                                                    }
                                                    chosenmap = 14;
                                                }
                                                else if (currentIndex >= 60 && currentIndex <= 63)
                                                {
                                                    currentMapData = (double)somechunkkeyboard[indexofmainobject].arrayofindexzeromesh[indexofmeshzero].instancesmatrix[indexofmeshinst].instancematrix.M44; // input.mapmatrix1.w;//input.fourTwo;
                                                                                                                                                                                                             //// MainWindow.MessageBox((IntPtr)0, "sccs:" + "map:" + (double)somechunkkeyboard[indexofmainobject].arrayofindexzeromesh[indexofmeshzero].instancesmatrix[indexofmeshinst].instancematrix.M44 , "sccs message 0", 0);

                                                    if (currentIndex >= 60 && currentIndex <= 61)
                                                    {
                                                        int somemax = 61;
                                                        someOtherIndex = 1 + ((somemax - someOtherIndex) * 2);
                                                    }
                                                    else if (currentIndex >= 62 && currentIndex <= 63)
                                                    {
                                                        int somemax = 63;
                                                        someOtherIndex = 0 + ((somemax - someOtherIndex) * 2);
                                                    }
                                                    chosenmap = 15;
                                                }


                                                //someOtherIndex = 2;

                                                double someothermul0 = 10.0;
                                                double someothermul1 = 1.0;

                                                if (someOtherIndex == 0)
                                                {
                                                    someothermul0 = 100.0;
                                                    someothermul1 = 0.1;
                                                }
                                                else if (someOtherIndex == 1)
                                                {
                                                    someothermul0 = 1000.0;
                                                    someothermul1 = 0.01;
                                                }
                                                else if (someOtherIndex == 2)
                                                {
                                                    someothermul0 = 10000.0;
                                                    someothermul1 = 0.001;
                                                }
                                                else if (someOtherIndex == 3)
                                                {
                                                    someothermul0 = 100000.0;
                                                    someothermul1 = 0.0001;
                                                }

                                                double[] arrayOfDigits = new double[4];// = {0,0,0,0,0,0,0,0,0};

                                                //double someorimap = 51234;
                                                double somemap = currentMapData;// 51234; //currentMapData

                                                double tempsomemap;
                                                double someotherbyte;

                                                for (int i = 0; i < 4; i++) //111111111 // 6th digit //someOtherIndex
                                                {
                                                    tempsomemap = somemap;
                                                    somemap = (somemap * 0.1);
                                                    //MainWindow.MessageBox((IntPtr)0, "/somemap:" + somemap, "sccs message 1", 0);
                                                    var somevalue = Math.Floor((double)(int)((somemap - (int)somemap) * someothermul0)) * someothermul1;
                                                    somevalue = somevalue - (Math.Floor(somevalue * 0.1) * 10);

                                                    arrayOfDigits[i] = somevalue;

                                                    //MainWindow.MessageBox((IntPtr)0, "/arrayOfDigits[i]:" + arrayOfDigits[i] + "/somevalue:" + somevalue, "sccs message 1", 0);
                                                }




                                                double[] arrayOfDigits1 = new double[5];// = {0,0,0,0,0,0,0,0,0};

                                                //double someorimap = 51234;
                                                double somemap1 = currentMapData;// 51234; //currentMapData

                                                double tempsomemap1;
                                                double someotherbyte1;

                                                for (int i = 0; i < 5; i++) //111111111 // 6th digit //someOtherIndex
                                                {
                                                    tempsomemap1 = somemap1;
                                                    somemap1 = (somemap1 * 0.1);
                                                    //MainWindow.MessageBox((IntPtr)0, "/somemap:" + somemap, "sccs message 1", 0);
                                                    var somevalue1 = Math.Floor((double)(int)((somemap1 - (int)somemap1) * 100000.0)) * 0.0001;
                                                    somevalue1 = somevalue1 - (Math.Floor(somevalue1 * 0.1) * 10);

                                                    arrayOfDigits1[i] = somevalue1;

                                                    //MainWindow.MessageBox((IntPtr)0, "/arrayOfDigits[i]:" + arrayOfDigits[i] + "/somevalue:" + somevalue, "sccs message 1", 0);
                                                }

                                                //MainWindow.MessageBox((IntPtr)0, "/arrayOfDigits1[i]:" + arrayOfDigits1[arrayOfDigits1.Length-1], "sccs message 1", 0);

                                                var someotherindex1 = 3 - someOtherIndex;

                                                if (someOtherIndex == 0)
                                                {
                                                    someothermul0 = 10.0;
                                                    someothermul1 = 1.0;
                                                }
                                                else if (someOtherIndex == 1)
                                                {
                                                    someothermul0 = 100.0;
                                                    someothermul1 = 0.1;
                                                }
                                                else if (someOtherIndex == 2)
                                                {
                                                    someothermul0 = 1000.0;
                                                    someothermul1 = 0.01;
                                                }
                                                else if (someOtherIndex == 3)
                                                {
                                                    someothermul0 = 10000.0;
                                                    someothermul1 = 0.001;
                                                }

                                                //currentMapData = 51234.0;
                                                currentMapData *= 0.0001f;
                                                currentMapData = Math.Round(currentMapData * 100000) * 0.00001; // 5.1111

                                                double double_value = currentMapData;
                                                double double_result = ((double_value - Math.Floor(double_value)) * someothermul0) - Math.Floor((Math.Floor(Math.Floor((double_value - Math.Floor(double_value)) * someothermul0) * 0.1f) * 10));// == 0.345f







                                                //somechunkkeyboardpriminstance[indexofmainobject].arrayofindexzeromesh[indexofmeshzero].somechunk[indexofmeshinst].somechunkpos.X
                                                //Matrix worldmatrixofvoxelobject = somechunkkeyboard[0].worldmatofobj;
                                                //somechunkkeyboardpriminstance[indexofmainobject].arrayofindexzeromesh[indexofmeshzero].somechunk[indexofmeshinst].somechunkpos = 
                                                Vector3 somechunkbyteposition = new Vector3(somechunkkeyboard[0].worldmatofobj.M41, somechunkkeyboard[0].worldmatofobj.M42, somechunkkeyboard[0].worldmatofobj.M43);

                                                Matrix worldmatrixofvoxelobject = somechunkkeyboard[indexofmainobject].worldmatofobj;
                                                Quaternion somedirquat;
                                                Quaternion.RotationMatrix(ref worldmatrixofvoxelobject, out somedirquat);

                                                var dirInstanceRight = -sc_maths._newgetdirleft(somedirquat);
                                                var dirInstanceUp = sc_maths._newgetdirup(somedirquat);
                                                var dirInstanceForward = sc_maths._newgetdirforward(somedirquat);

                                                Vector3 somechunkbyteposition1 = new Vector3(somechunkkeyboard[0].worldmatofobj.M41, somechunkkeyboard[0].worldmatofobj.M42, somechunkkeyboard[0].worldmatofobj.M43);

                                                Matrix worldmatrixofvoxelobject1 = somechunkkeyboard[indexofmainobject].worldmatofobj; //Matrix.Identity;// 
                                                Quaternion.RotationMatrix(ref worldmatrixofvoxelobject1, out somedirquat);

                                                var dirInstanceRight1 = sc_maths._newgetdirleft(somedirquat);
                                                var dirInstanceUp1 = sc_maths._newgetdirup(somedirquat);
                                                var dirInstanceForward1 = sc_maths._newgetdirforward(somedirquat);

                                                float somemulsize;// = planeSize * 2;
                                                float somemulsize1;// = planeSize;


                                                float somemulsizemainobjectx = 1.0f / (float)somechunkkeyboardw;// / somechunkkeyboardw;// somechunkkeyboardglobals.numberOfObjectInHeight;// (planeSize * 10) * 0.5f;
                                                float somemulsizemainobjecty = 1.0f / (float)somechunkkeyboardh;// / somechunkkeyboardh;// somechunkkeyboardglobals.numberOfInstancesPerObjectInHeight;// (planeSize * 10) * 0.5f;
                                                float somemulsizemainobjectz = 1.0f / (float)somechunkkeyboardd;// / somechunkkeyboardd;// somechunkkeyboardglobals.numberOfInstancesPerObjectInDepth;// (planeSize * 10) * 0.5f;

                                                float somemulsizemainsubmeshx = 1.0f / (float)somechunkkeyboardglobals.numberOfObjectInWidth;// / somechunkkeyboardglobals.numberOfObjectInWidth;// (planeSize * 10) * 0.5f;
                                                float somemulsizemainsubmeshy = 1.0f / (float)somechunkkeyboardglobals.numberOfObjectInHeight;// / somechunkkeyboardglobals.numberOfObjectInHeight;// (planeSize * 10) * 0.5f;
                                                float somemulsizemainsubmeshz = 1.0f / (float)somechunkkeyboardglobals.numberOfObjectInDepth;// / somechunkkeyboardglobals.numberOfObjectInDepth;// (planeSize * 10) * 0.5f;

                                                float somemulsizemainsubmeshinstx = 1.0f / (float)somechunkkeyboardglobals.numberOfInstancesPerObjectInWidth;// / somechunkkeyboardglobals.numberOfInstancesPerObjectInWidth;// (planeSize * 10) * 0.5f;
                                                float somemulsizemainsubmeshinsty = 1.0f / (float)somechunkkeyboardglobals.numberOfInstancesPerObjectInHeight;// / somechunkkeyboardglobals.numberOfInstancesPerObjectInHeight;// (planeSize * 10) * 0.5f;
                                                float somemulsizemainsubmeshinstz = 1.0f / (float)somechunkkeyboardglobals.numberOfInstancesPerObjectInDepth;// / somechunkkeyboardglobals.numberOfInstancesPerObjectInDepth;// (planeSize * 10) * 0.5f;

                                                float somemulsizemainsubmeshinstbytex = 1.0f / (float)somechunkkeyboardglobals.tinyChunkWidth;// / somechunkkeyboardglobals.tinyChunkWidth;// (planeSize * 10) * 0.5f;
                                                float somemulsizemainsubmeshinstbytey = 1.0f / (float)somechunkkeyboardglobals.tinyChunkHeight;// / somechunkkeyboardglobals.tinyChunkHeight;// (planeSize * 10) * 0.5f;
                                                float somemulsizemainsubmeshinstbytez = 1.0f / (float)somechunkkeyboardglobals.tinyChunkDepth;// / somechunkkeyboardglobals.tinyChunkDepth;// (planeSize * 10) * 0.5f;


                                                somemulsize = (planeSize * 10) * 0.5f;
                                                somemulsize1 = planeSize;

                                                somechunkbyteposition += (dirInstanceRight * ((somechunkkeyboardw * somemulsizemainobjectx) * (somechunkkeyboardglobals.numberOfObjectInWidth * somemulsizemainsubmeshx) * (somechunkkeyboardglobals.numberOfInstancesPerObjectInWidth * somemulsizemainsubmeshinstx) * (somechunkkeyboardglobals.tinyChunkWidth * somemulsizemainsubmeshinstbytex)) * indexmainobjectx * somemulsize1);
                                                somechunkbyteposition += (dirInstanceRight * ((somechunkkeyboardglobals.numberOfObjectInWidth * somemulsizemainsubmeshx) * (somechunkkeyboardglobals.numberOfInstancesPerObjectInWidth * somemulsizemainsubmeshinstx) * (somechunkkeyboardglobals.tinyChunkWidth * somemulsizemainsubmeshinstbytex)) * indexmeshzerox * somemulsize1);
                                                somechunkbyteposition += (dirInstanceRight * ((somechunkkeyboardglobals.numberOfInstancesPerObjectInWidth * somemulsizemainsubmeshinstx) * (somechunkkeyboardglobals.tinyChunkWidth * somemulsizemainsubmeshinstbytex)) * indexofmeshinstx * somemulsize1);
                                                somechunkbyteposition += (dirInstanceRight * ((somechunkkeyboardglobals.tinyChunkWidth * somemulsizemainsubmeshinstbytex)) * indexbytex * somemulsize1);

                                                somechunkbyteposition += (dirInstanceUp * ((somechunkkeyboardh * somemulsizemainobjecty) * (somechunkkeyboardglobals.numberOfObjectInHeight * somemulsizemainsubmeshy) * (somechunkkeyboardglobals.numberOfInstancesPerObjectInHeight * somemulsizemainsubmeshinsty) * (somechunkkeyboardglobals.tinyChunkHeight * somemulsizemainsubmeshinstbytey)) * indexmainobjecty * somemulsize1);
                                                somechunkbyteposition += (dirInstanceUp * ((somechunkkeyboardglobals.numberOfObjectInHeight * somemulsizemainsubmeshy) * (somechunkkeyboardglobals.numberOfInstancesPerObjectInHeight * somemulsizemainsubmeshinsty) * (somechunkkeyboardglobals.tinyChunkHeight * somemulsizemainsubmeshinstbytey)) * indexmeshzeroy * somemulsize1);
                                                somechunkbyteposition += (dirInstanceUp * ((somechunkkeyboardglobals.numberOfInstancesPerObjectInHeight * somemulsizemainsubmeshinsty) * (somechunkkeyboardglobals.tinyChunkHeight * somemulsizemainsubmeshinstbytey)) * indexofmeshinsty * somemulsize1);
                                                somechunkbyteposition += (dirInstanceUp * ((somechunkkeyboardglobals.tinyChunkHeight * somemulsizemainsubmeshinstbytey)) * indexbytey * somemulsize1);

                                                somechunkbyteposition += (dirInstanceForward * ((somechunkkeyboardd * somemulsizemainobjectz) * (somechunkkeyboardglobals.numberOfObjectInDepth * somemulsizemainsubmeshz) * (somechunkkeyboardglobals.numberOfInstancesPerObjectInDepth * somemulsizemainsubmeshinstz) * (somechunkkeyboardglobals.tinyChunkDepth * somemulsizemainsubmeshinstbytez)) * indexmainobjectz * somemulsize1);
                                                somechunkbyteposition += (dirInstanceForward * ((somechunkkeyboardglobals.numberOfObjectInDepth * somemulsizemainsubmeshz) * (somechunkkeyboardglobals.numberOfInstancesPerObjectInDepth * somemulsizemainsubmeshinstz) * (somechunkkeyboardglobals.tinyChunkDepth * somemulsizemainsubmeshinstbytez)) * indexmeshzeroz * somemulsize1);
                                                somechunkbyteposition += (dirInstanceForward * ((somechunkkeyboardglobals.numberOfInstancesPerObjectInDepth * somemulsizemainsubmeshinstz) * (somechunkkeyboardglobals.tinyChunkDepth * somemulsizemainsubmeshinstbytez)) * indexofmeshinstz * somemulsize1);
                                                somechunkbyteposition += (dirInstanceForward * ((somechunkkeyboardglobals.tinyChunkDepth * somemulsizemainsubmeshinstbytez)) * indexbytez * somemulsize1);


                                                somemulsizemainobjectx = 1.0f / (float)somechunkkeyboardw;// / somechunkkeyboardw;// somechunkkeyboardglobals.numberOfObjectInHeight;// (planeSize * 10) * 0.5f;
                                                somemulsizemainobjecty = 1.0f / (float)somechunkkeyboardh;// / somechunkkeyboardh;// somechunkkeyboardglobals.numberOfInstancesPerObjectInHeight;// (planeSize * 10) * 0.5f;
                                                somemulsizemainobjectz = 1.0f / (float)somechunkkeyboardd;// / somechunkkeyboardd;// somechunkkeyboardglobals.numberOfInstancesPerObjectInDepth;// (planeSize * 10) * 0.5f;

                                                somemulsizemainsubmeshx = 1.0f / (float)somechunkkeyboardglobals.numberOfObjectInWidth;// / somechunkkeyboardglobals.numberOfObjectInWidth;// (planeSize * 10) * 0.5f;
                                                somemulsizemainsubmeshy = 1.0f / (float)somechunkkeyboardglobals.numberOfObjectInHeight;// / somechunkkeyboardglobals.numberOfObjectInHeight;// (planeSize * 10) * 0.5f;
                                                somemulsizemainsubmeshz = 1.0f / (float)somechunkkeyboardglobals.numberOfObjectInDepth;// / somechunkkeyboardglobals.numberOfObjectInDepth;// (planeSize * 10) * 0.5f;

                                                somemulsizemainsubmeshinstx = 1.0f / (float)somechunkkeyboardglobals.numberOfInstancesPerObjectInWidth;// / somechunkkeyboardglobals.numberOfInstancesPerObjectInWidth;// (planeSize * 10) * 0.5f;
                                                somemulsizemainsubmeshinsty = 1.0f / (float)somechunkkeyboardglobals.numberOfInstancesPerObjectInHeight;// / somechunkkeyboardglobals.numberOfInstancesPerObjectInHeight;// (planeSize * 10) * 0.5f;
                                                somemulsizemainsubmeshinstz = 1.0f / (float)somechunkkeyboardglobals.numberOfInstancesPerObjectInDepth;// / somechunkkeyboardglobals.numberOfInstancesPerObjectInDepth;// (planeSize * 10) * 0.5f;

                                                somemulsizemainsubmeshinstbytex = 1.0f / (float)somechunkkeyboardglobals.tinyChunkWidth;// / somechunkkeyboardglobals.tinyChunkWidth;// (planeSize * 10) * 0.5f;
                                                somemulsizemainsubmeshinstbytey = 1.0f / (float)somechunkkeyboardglobals.tinyChunkHeight;// / somechunkkeyboardglobals.tinyChunkHeight;// (planeSize * 10) * 0.5f;
                                                somemulsizemainsubmeshinstbytez = 1.0f / (float)somechunkkeyboardglobals.tinyChunkDepth;// / somechunkkeyboardglobals.tinyChunkDepth;// (planeSize * 10) * 0.5f;

                                                somemulsize1 = planeSize;

                                                somechunkbyteposition1 += (dirInstanceRight1 * ((somechunkkeyboardglobals.numberOfObjectInWidth) * (somechunkkeyboardglobals.numberOfInstancesPerObjectInWidth) * (somechunkkeyboardglobals.tinyChunkWidth)) * indexmainobjectx * somemulsize1);
                                                somechunkbyteposition1 += (dirInstanceRight1 * ((somechunkkeyboardglobals.numberOfInstancesPerObjectInWidth * somechunkkeyboardglobals.tinyChunkWidth)) * indexmeshzerox * somemulsize1);
                                                somechunkbyteposition1 += (dirInstanceRight1 * ((somechunkkeyboardglobals.tinyChunkWidth)) * indexofmeshinstx * somemulsize1);
                                                somechunkbyteposition1 += (dirInstanceRight1 * ((somechunkkeyboardglobals.tinyChunkWidth * somemulsizemainsubmeshinstbytex)) * indexbytex * somemulsize1);

                                                somechunkbyteposition1 += (dirInstanceUp1 * ((somechunkkeyboardglobals.numberOfObjectInHeight) * (somechunkkeyboardglobals.numberOfInstancesPerObjectInHeight) * (somechunkkeyboardglobals.tinyChunkHeight)) * indexmainobjecty * somemulsize1);
                                                somechunkbyteposition1 += (dirInstanceUp1 * ((somechunkkeyboardglobals.numberOfInstancesPerObjectInHeight * somechunkkeyboardglobals.tinyChunkHeight)) * indexmeshzeroy * somemulsize1);
                                                somechunkbyteposition1 += (dirInstanceUp1 * ((somechunkkeyboardglobals.tinyChunkHeight)) * indexofmeshinsty * somemulsize1);
                                                somechunkbyteposition1 += (dirInstanceUp1 * ((somechunkkeyboardglobals.tinyChunkHeight * somemulsizemainsubmeshinstbytey)) * indexbytey * somemulsize1);

                                                somechunkbyteposition1 += (dirInstanceForward1 * ((somechunkkeyboardglobals.numberOfObjectInDepth) * (somechunkkeyboardglobals.numberOfInstancesPerObjectInDepth) * (somechunkkeyboardglobals.tinyChunkDepth)) * indexmainobjectz * somemulsize1);
                                                somechunkbyteposition1 += (dirInstanceForward1 * ((somechunkkeyboardglobals.numberOfInstancesPerObjectInDepth * somechunkkeyboardglobals.tinyChunkDepth)) * indexmeshzeroz * somemulsize1);
                                                somechunkbyteposition1 += (dirInstanceForward1 * ((somechunkkeyboardglobals.tinyChunkDepth)) * indexofmeshinstz * somemulsize1);
                                                somechunkbyteposition1 += (dirInstanceForward1 * ((somechunkkeyboardglobals.tinyChunkDepth * somemulsizemainsubmeshinstbytez)) * indexbytez * somemulsize1);


                                                //Vector3 mainmeshpos = new Vector3(somechunkkeyboard[0].worldmatofobj.M41, somechunkkeyboard[0].worldmatofobj.M42, somechunkkeyboard[0].worldmatofobj.M43);

                                                //Vector3 tempvecpickaxehitpoint = pickaxetippoint;
                                                //tempvecpickaxehitpoint.X += somechunkkeyboardglobals.planeSize * 0.5f;
                                                //tempvecpickaxehitpoint.Y += somechunkkeyboardglobals.planeSize * 0.5f;
                                                //tempvecpickaxehitpoint.Z += somechunkkeyboardglobals.planeSize * 0.5f;

                                                pickaxetippoint.X = (float)Math.Round(pickaxetippoint.X / somechunkkeyboardglobals.planeSize) * somechunkkeyboardglobals.planeSize;
                                                pickaxetippoint.Y = (float)Math.Round(pickaxetippoint.Y / somechunkkeyboardglobals.planeSize) * somechunkkeyboardglobals.planeSize;
                                                pickaxetippoint.Z = (float)Math.Round(pickaxetippoint.Z / somechunkkeyboardglobals.planeSize) * somechunkkeyboardglobals.planeSize;

                                                worldMatrix_instances_voxel_cube[0][0][6].M41 = somechunkbyteposition.X;// + mainmeshpos.X;// + mainmeshpos.X; //2
                                                worldMatrix_instances_voxel_cube[0][0][6].M42 = somechunkbyteposition.Y;//  + mainmeshpos.Y;// + mainmeshpos.Y;
                                                worldMatrix_instances_voxel_cube[0][0][6].M43 = somechunkbyteposition.Z;//  + mainmeshpos.Z;// + mainmeshpos.Z;

                                                worldMatrix_instances_voxel_cube[0][0][7].M41 = pickaxetippoint.X; // 0
                                                worldMatrix_instances_voxel_cube[0][0][7].M42 = pickaxetippoint.Y;
                                                worldMatrix_instances_voxel_cube[0][0][7].M43 = pickaxetippoint.Z;

                                                //Vector3 somechunkbyteposition1 = new Vector3(somechunkkeyboard[0].worldmatofobj.M41, somechunkkeyboard[0].worldmatofobj.M42, somechunkkeyboard[0].worldmatofobj.M43);
                                                //mainmeshpos = new Vector3(somechunkkeyboard[0].worldmatofobj.M41, somechunkkeyboard[0].worldmatofobj.M42, somechunkkeyboard[0].worldmatofobj.M43);

                                                //SET THE BYTE LOCATOR OBJECT TO THE LOCATION OF THE BYTE ON THE CHUNK IN ORDER TO HAVE A VISUAL ON WHERE THE BYTE LOCATOR IS IN CODE
                                                //SET THE BYTE LOCATOR OBJECT TO THE LOCATION OF THE BYTE ON THE CHUNK IN ORDER TO HAVE A VISUAL ON WHERE THE BYTE LOCATOR IS IN CODE
                                                //SET THE BYTE LOCATOR OBJECT TO THE LOCATION OF THE BYTE ON THE CHUNK IN ORDER TO HAVE A VISUAL ON WHERE THE BYTE LOCATOR IS IN CODE

                                                worldMatrix_instances_voxel_cube[0][0][8].M41 = somechunkbyteposition1.X; // - (((somechunkkeyboardglobals.numberOfObjectInWidth) * (somechunkkeyboardglobals.numberOfInstancesPerObjectInWidth) * (somechunkkeyboardglobals.tinyChunkWidth)) * indexmainobjectx * somemulsize1 * 0.5f); //4
                                                worldMatrix_instances_voxel_cube[0][0][8].M42 = somechunkbyteposition1.Y;
                                                worldMatrix_instances_voxel_cube[0][0][8].M43 = somechunkbyteposition1.Z;

                                                //SET THE BYTE LOCATOR OBJECT TO THE LOCATION OF THE BYTE ON THE CHUNK IN ORDER TO HAVE A VISUAL ON WHERE THE BYTE LOCATOR IS IN CODE
                                                //SET THE BYTE LOCATOR OBJECT TO THE LOCATION OF THE BYTE ON THE CHUNK IN ORDER TO HAVE A VISUAL ON WHERE THE BYTE LOCATOR IS IN CODE
                                                //SET THE BYTE LOCATOR OBJECT TO THE LOCATION OF THE BYTE ON THE CHUNK IN ORDER TO HAVE A VISUAL ON WHERE THE BYTE LOCATOR IS IN CODE

                                                pickaxetippoint.X = (float)Math.Round(pickaxetippoint.X / planeSize);
                                                worldMatrix_instances_voxel_cube[0][0][6].M41 = (float)Math.Round(worldMatrix_instances_voxel_cube[0][0][6].M41 / planeSize);

                                                pickaxetippoint.Y = (float)Math.Round(pickaxetippoint.Y / planeSize);
                                                worldMatrix_instances_voxel_cube[0][0][6].M42 = (float)Math.Round(worldMatrix_instances_voxel_cube[0][0][6].M42 / planeSize);

                                                pickaxetippoint.Z = (float)Math.Round(pickaxetippoint.Z / planeSize);
                                                worldMatrix_instances_voxel_cube[0][0][6].M43 = (float)Math.Round(worldMatrix_instances_voxel_cube[0][0][6].M43 / planeSize);

                                                //Vector3 positionofhitbyte = new Vector3(worldMatrix_instances_voxel_cube[0][0][5].M41, worldMatrix_instances_voxel_cube[0][0][5].M42, worldMatrix_instances_voxel_cube[0][0][5].M43);

                                                if (consolewritecounter >= consolewritecountermax)
                                                {
                                                    if (consolewritecounterswtc == 0)
                                                    {

                                                        consolewritecounterswtc = 1;
                                                    }

                                                    /*for (int sc = 0; sc < 30; sc++) //Console.WindowWidth - 1
                                                    {
                                                        Console.SetCursorPosition(sc, 0);
                                                        Console.WriteLine(" ");
                                                        //Console.SetCursorPosition(sc, 1);
                                                        //Console.WriteLine(" ");
                                                        //Console.SetCursorPosition(sc, 1);
                                                        //Console.WriteLine(" ");
                                                        //Console.SetCursorPosition(sc, 3);
                                                        //Console.WriteLine(" ");
                                                        //Console.SetCursorPosition(sc, 4);
                                                        //Console.WriteLine(" ");
                                                    }*/

                                                    //Console.SetCursorPosition(0, 0);
                                                    //Console.WriteLine("x:" + +mainx + "/y:" + mainy + "/z:" + mainz);

                                                    //Console.SetCursorPosition(0, 1);
                                                    //Console.WriteLine("secx:" + +secx + "/secy:" + secy + "/secz:" + secz);

                                                    //Console.SetCursorPosition(0, 0);
                                                    //Console.WriteLine("somefx:" + +somefx + "/somefy:" + somefy + "/somefz:" + somefz);

                                                    //Console.SetCursorPosition(0, 0);
                                                    //Console.WriteLine("fobjmeshx:" + +fobjmeshx + "/fobjmeshy:" + fobjmeshy + "/fobjmeshz:" + fobjmeshz);

                                                    //Console.Title = "fobjmeshx:" + +fobjmeshx + "/fobjmeshy:" + fobjmeshy + "/fobjmeshz:" + fobjmeshz;
                                                    //Console.Title = "fobjmeshx:" + +fobjmeshx + "/fobjmeshy:" + fobjmeshy + "/fobjmeshz:" + fobjmeshz;
                                                    //Console.Title = "finstx:" + +finstx + "/finsty:" + finsty + "/finstz:" + finstz;
                                                    //Console.Title = "mainx:" + mainx + "/mainy:" + mainy + "/mainz:" + mainz;
                                                    //Console.Title = "someothermainx:" + someothermainx + "/someothermainy:" + someothermainy + "/someothermainz:" + someothermainz + "/fobjmeshx:" + +fobjmeshx + "/fobjmeshy:" + fobjmeshy + "/fobjmeshz:" + fobjmeshz;
                                                    //Console.Title = "/someothermainx:" + someothermainx + "/someothermainy:" + someothermainy + "/someothermainz:" + someothermainz +"/fobjmeshmainx:" + fobjmeshmainx + "/fobjmeshmainy:" + fobjmeshmainy + "/fobjmeshmainz:" + fobjmeshmainz + "/fobjmeshx:" + +fobjmeshx + "/fobjmeshy:" + fobjmeshy + "/fobjmeshz:" + fobjmeshz;

                                                    //Console.Title = "someinstx:" + (int)someinstx + "/someinsty:" + (int)someinsty + "/someinstz:" + (int)someinstz;

                                                    //Console.Title = "somefx:" + +somefx + "/somefy:" + somefy + "/somefz:" + somefz;

                                                    /*int indexbytex = remainderbytesx;
                                                    int indexbytey = remainderbytesy;
                                                    int indexbytez = remainderbytesz;
                                                    int indexofbyte = (indexbytex) + (someglobalschunkkeyboard.tinyChunkWidth) * ((indexbytey) + (someglobalschunkkeyboard.tinyChunkHeight) * (indexbytez));

                                                    int indexmeshinstx = remaindermeshinstx;
                                                    int indexmeshinsty = remaindermeshinsty;
                                                    int indexmeshinstz = remaindermeshinstz;
                                                    int indexofmeshinst = (indexmeshinstx) + (someglobalschunkkeyboard.numberOfInstancesPerObjectInWidth) * ((indexmeshinsty) + (someglobalschunkkeyboard.numberOfInstancesPerObjectInHeight) * (indexmeshinstz));

                                                    int indexmeshzerox = remaindermeshinstx;
                                                    int indexmeshzeroy = remaindermeshinsty;
                                                    int indexmeshzeroz = remaindermeshinstz;
                                                    int indexofmeshzero = (indexmeshzerox) + (someglobalschunkkeyboard.numberOfObjectInWidth) * ((indexmeshzeroy) + (someglobalschunkkeyboard.numberOfObjectInHeight) * (indexmeshzeroz));

                                                    int indexmainobjectx = remaindermeshinstx;
                                                    int indexmainobjecty = remaindermeshinsty;
                                                    int indexmainobjectz = remaindermeshinstz;
                                                    int indexofmainobject = (indexmainobjectx) + (somechunkkeyboardswidth) * ((indexmainobjecty) + (somechunkkeyboardsheight) * (indexmainobjectz));*/

                                                    //Console.Title = "indexbytex:" + (int)indexbytex + "/indexbytey:" + (int)indexbytey + "/indexbytez:" + (int)indexbytez;
                                                    //Console.Title = "indexofmeshinstx:" + (int)indexofmeshinstx + "/indexofmeshinsty:" + (int)indexofmeshinsty + "/indexofmeshinstz:" + (int)indexofmeshinstz;

                                                    ///Console.Title = "/bx:" + positionofhitbyte.X + "/by:" + positionofhitbyte.Y + "/bz:" + positionofhitbyte.Z + "/px:" + tempvecpickaxehitpoint.X + "/py:" + tempvecpickaxehitpoint.Y + "/pz:" + tempvecpickaxehitpoint.Z;
                                                    //Console.Title = "/bx:" + pickaxetippoint.X + "/by:" + pickaxetippoint.Y + "/bz:" + pickaxetippoint.Z + "/x:" + worldMatrix_instances_voxel_cube[0][0][2].M41 + "/y:" + worldMatrix_instances_voxel_cube[0][0][2].M42 + "/z:" + worldMatrix_instances_voxel_cube[0][0][2].M43;
                                                    //Console.Title = "/x:" + somemainobjmeshpos.X + "/y:" + somemainobjmeshpos.Y + "/z:" + somemainobjmeshpos.Z + "/x:" + mainmeshpos.X + "/y:" + mainmeshpos.Y + "/z:" + mainmeshpos.Z + "/bx:" + pickaxetippoint.X + "/by:" + pickaxetippoint.Y + "/bz:" + pickaxetippoint.Z + "/x:" + worldMatrix_instances_voxel_cube[0][0][0].M41 + "/y:" + worldMatrix_instances_voxel_cube[0][0][0].M42 + "/z:" + worldMatrix_instances_voxel_cube[0][0][0].M43 + "/x:" + worldMatrix_instances_voxel_cube[0][0][2].M41 + "/y:" + worldMatrix_instances_voxel_cube[0][0][2].M42 + "/z:" + worldMatrix_instances_voxel_cube[0][0][2].M43 + "/x:" + worldMatrix_instances_voxel_cube[0][0][4].M41 + "/y:" + worldMatrix_instances_voxel_cube[0][0][4].M42 + "/z:" + worldMatrix_instances_voxel_cube[0][0][4].M43;
                                                    // + somediff0x + "/y:" + somediff0y + "/z:" + somediff0z +  + somediff0x + "/y:" + somediff0y + "/z:" + somediff0z + 
                                                    //Console.Title = "/indexmeshzerox:" + (int)indexmeshzerox + "/indexmeshzeroy:" + (int)indexmeshzeroy + "/indexmeshzeroz:" + (int)indexmeshzeroz;

                                                    // "/x:" + somemainobjmeshpos.X + "/y:" + somemainobjmeshpos.Y + "/z:" + somemainobjmeshpos.Z + 
                                                    //Console.Title ="/x:" + mainmeshpos.X + "/y:" + mainmeshpos.Y + "/z:" + mainmeshpos.Z + "/bx:" + pickaxetippoint.X + "/by:" + pickaxetippoint.Y + "/bz:" + pickaxetippoint.Z + "/x:" + worldMatrix_instances_voxel_cube[0][0][0].M41 + "/y:" + worldMatrix_instances_voxel_cube[0][0][0].M42 + "/z:" + worldMatrix_instances_voxel_cube[0][0][0].M43 + "/x:" + worldMatrix_instances_voxel_cube[0][0][2].M41 + "/y:" + worldMatrix_instances_voxel_cube[0][0][2].M42 + "/z:" + worldMatrix_instances_voxel_cube[0][0][2].M43 + "/x:" + worldMatrix_instances_voxel_cube[0][0][4].M41 + "/y:" + worldMatrix_instances_voxel_cube[0][0][4].M42 + "/z:" + worldMatrix_instances_voxel_cube[0][0][4].M43 + "/x:" + (int)Math.Round(worldMatrix_instances_voxel_cube[0][0][0].M41 / planeSize) + "/y:" + (int)Math.Round(worldMatrix_instances_voxel_cube[0][0][0].M42 / planeSize) + "/z:" + (int)Math.Round(worldMatrix_instances_voxel_cube[0][0][0].M43 / planeSize) + "/x:" + (int)Math.Round(worldMatrix_instances_voxel_cube[0][0][4].M41 / planeSize) + "/y:" + (int)Math.Round(worldMatrix_instances_voxel_cube[0][0][4].M42 / planeSize) + "/z:" + (int)Math.Round(worldMatrix_instances_voxel_cube[0][0][4].M43 / planeSize);
                                                    consolewritecounter = 0;
                                                }
                                                consolewritecounter++;


                                                //pickaxetippoint





                                                //worldMatrix_instances_voxel_cube[0][0][2].M43 

                                                //float someflooredvaluebytex = positionofhitbyte.X;// (float)(Math.Floor(positionofhitbyte.X / someglobalschunkkeyboard.planeSize) * someglobalschunkkeyboard.planeSize);
                                                //float someflooredvaluebytey = positionofhitbyte.Y;// (float)(Math.Floor(positionofhitbyte.Y / someglobalschunkkeyboard.planeSize) * someglobalschunkkeyboard.planeSize);
                                                //float someflooredvaluebytez = positionofhitbyte.Z;// (float)(Math.Floor(positionofhitbyte.Z / someglobalschunkkeyboard.planeSize) * someglobalschunkkeyboard.planeSize);

                                                //float locationbytex = worldmatrixofvoxelobject.M41 + (dirInstanceRight * indexofmainobject) + 

                                                //SECTION FOR 3D BYTE LOCATION WHEN AN INSTANCED BREAKABLE VOXEL OBJECT IS ROTATED
                                                //SECTION FOR 3D BYTE LOCATION WHEN AN INSTANCED BREAKABLE VOXEL OBJECT IS ROTATED
                                                //SECTION FOR 3D BYTE LOCATION WHEN AN INSTANCED BREAKABLE VOXEL OBJECT IS ROTATED

                                                int somebyte = somechunkkeyboard[indexofmainobject].arrayofindexzeromesh[indexofmeshzero].somechunk[indexofmeshinst].GetByte(indexbytex, indexbytey, indexbytez);
                                                //&& Math.Round(tempPoint.X / someglobalschunkkeyboard.planeSize) == someflooredvaluebytex && Math.Round(tempPoint.Y / someglobalschunkkeyboard.planeSize) == someflooredvaluebytey && Math.Round(tempPoint.Z / someglobalschunkkeyboard.planeSize) == someflooredvaluebytez

                                                //&& Math.Floor(pickaxetippoint.X / planeSize) == Math.Floor(worldMatrix_instances_voxel_cube[0][0][2].M41 / planeSize) && Math.Floor(pickaxetippoint.Y / planeSize) == Math.Floor(worldMatrix_instances_voxel_cube[0][0][2].M42 / planeSize) && Math.Floor(pickaxetippoint.Z / planeSize) == Math.Floor(worldMatrix_instances_voxel_cube[0][0][2].M43 / planeSize)

                                                //if (somebyte == 1 && worldMatrix_instances_voxel_cube[0][0][0].M41 == worldMatrix_instances_voxel_cube[0][0][4].M41 && worldMatrix_instances_voxel_cube[0][0][0].M42 == worldMatrix_instances_voxel_cube[0][0][4].M42 && worldMatrix_instances_voxel_cube[0][0][0].M43 == worldMatrix_instances_voxel_cube[0][0][4].M43)

                                                //if (somebyte == 1 && (int)Math.Round(worldMatrix_instances_voxel_cube[0][0][].M41 / planeSize) == (int)Math.Round(pickaxetippoint.X / planeSize) && (int)Math.Round(worldMatrix_instances_voxel_cube[0][0][0].M42 / planeSize) == (int)Math.Round(pickaxetippoint.Y / planeSize) && (int)Math.Round(worldMatrix_instances_voxel_cube[0][0][0].M43 / planeSize) == (int)Math.Round(pickaxetippoint.Z / planeSize))
                                                if (somebyte == 1 && (int)Math.Round(worldMatrix_instances_voxel_cube[0][0][7].M41 / planeSize) == (int)Math.Round(worldMatrix_instances_voxel_cube[0][0][8].M41 / planeSize) && (int)Math.Round(worldMatrix_instances_voxel_cube[0][0][7].M42 / planeSize) == (int)Math.Round(worldMatrix_instances_voxel_cube[0][0][8].M42 / planeSize) && (int)Math.Round(worldMatrix_instances_voxel_cube[0][0][7].M43 / planeSize) == (int)Math.Round(worldMatrix_instances_voxel_cube[0][0][8].M43 / planeSize))
                                                //if (somebyte == 1 && worldMatrix_instances_voxel_cube[0][0][0].M41 == worldMatrix_instances_voxel_cube[0][0][4].M41 && worldMatrix_instances_voxel_cube[0][0][0].M42 == worldMatrix_instances_voxel_cube[0][0][4].M42 && worldMatrix_instances_voxel_cube[0][0][0].M43 == worldMatrix_instances_voxel_cube[0][0][4].M43)
                                                //if (somebyte == 1 )
                                                {












                                                    //if (MainWindow._keyboard_input._KeyboardState.PressedKeys.Contains(SharpDX.DirectInput.Key.LeftControl))
                                                    //{
                                                    //
                                                    //}

                                                    //ROW 0
                                                    //ROW 0
                                                    //ROW 0
                                                    if (indexofmeshinst == 0)
                                                    {
                                                        if (keyboardclickstopwatch.Elapsed.Ticks >= 20)
                                                        {
                                                            //MainWindow.MessageBox((IntPtr)0, "", "sccs", 0);
                                                            MainWindow.keyboardsim.KeyDown(WindowsInput.Native.VirtualKeyCode.LCONTROL);
                                                            MainWindow.keyboardsim.KeyUp(WindowsInput.Native.VirtualKeyCode.LCONTROL);

                                                            keyboardclickstopwatch.Restart();
                                                        }
                                                    }

                                                    if (indexofmeshinst == 1)
                                                    {
                                                        if (keyboardclickstopwatch.Elapsed.Ticks >= 20)
                                                        {
                                                            //MainWindow.MessageBox((IntPtr)0, "", "sccs", 0);
                                                            MainWindow.keyboardsim.KeyDown(WindowsInput.Native.VirtualKeyCode.LWIN);
                                                            MainWindow.keyboardsim.KeyUp(WindowsInput.Native.VirtualKeyCode.LWIN);

                                                            keyboardclickstopwatch.Restart();
                                                        }
                                                    }


                                                    if (indexofmeshinst == 2)
                                                    {
                                                        if (keyboardclickstopwatch.Elapsed.Ticks >= 20)
                                                        {
                                                            //MainWindow.MessageBox((IntPtr)0, "", "sccs", 0);
                                                            MainWindow.keyboardsim.KeyDown(WindowsInput.Native.VirtualKeyCode.LMENU);
                                                            MainWindow.keyboardsim.KeyUp(WindowsInput.Native.VirtualKeyCode.LMENU);

                                                            keyboardclickstopwatch.Restart();
                                                        }
                                                    }


                                                    if (indexofmeshinst == 3)
                                                    {
                                                        if (keyboardclickstopwatch.Elapsed.Ticks >= 20)
                                                        {
                                                            //MainWindow.MessageBox((IntPtr)0, "", "sccs", 0);
                                                            MainWindow.keyboardsim.KeyDown(WindowsInput.Native.VirtualKeyCode.SPACE);
                                                            MainWindow.keyboardsim.KeyUp(WindowsInput.Native.VirtualKeyCode.SPACE);

                                                            keyboardclickstopwatch.Restart();
                                                        }
                                                    }
                                                    if (indexofmeshinst == 4)
                                                    {
                                                        if (keyboardclickstopwatch.Elapsed.Ticks >= 20)
                                                        {
                                                            //MainWindow.MessageBox((IntPtr)0, "", "sccs", 0);
                                                            MainWindow.keyboardsim.KeyDown(WindowsInput.Native.VirtualKeyCode.SPACE);
                                                            MainWindow.keyboardsim.KeyUp(WindowsInput.Native.VirtualKeyCode.SPACE);

                                                            keyboardclickstopwatch.Restart();
                                                        }
                                                    }
                                                    if (indexofmeshinst == 5)
                                                    {
                                                        if (keyboardclickstopwatch.Elapsed.Ticks >= 20)
                                                        {
                                                            //MainWindow.MessageBox((IntPtr)0, "", "sccs", 0);
                                                            MainWindow.keyboardsim.KeyDown(WindowsInput.Native.VirtualKeyCode.SPACE);
                                                            MainWindow.keyboardsim.KeyUp(WindowsInput.Native.VirtualKeyCode.SPACE);

                                                            keyboardclickstopwatch.Restart();
                                                        }
                                                    }


                                                    if (indexofmeshinst == 6)
                                                    {
                                                        if (keyboardclickstopwatch.Elapsed.Ticks >= 20)
                                                        {
                                                            //MainWindow.MessageBox((IntPtr)0, "", "sccs", 0);
                                                            MainWindow.keyboardsim.KeyDown(WindowsInput.Native.VirtualKeyCode.SPACE);
                                                            MainWindow.keyboardsim.KeyUp(WindowsInput.Native.VirtualKeyCode.SPACE);

                                                            keyboardclickstopwatch.Restart();
                                                        }
                                                    }


                                                    if (indexofmeshinst == 7)
                                                    {
                                                        if (keyboardclickstopwatch.Elapsed.Ticks >= 20)
                                                        {
                                                            //MainWindow.MessageBox((IntPtr)0, "", "sccs", 0);
                                                            MainWindow.keyboardsim.KeyDown(WindowsInput.Native.VirtualKeyCode.SPACE);
                                                            MainWindow.keyboardsim.KeyUp(WindowsInput.Native.VirtualKeyCode.SPACE);

                                                            keyboardclickstopwatch.Restart();
                                                        }
                                                    }


                                                    if (indexofmeshinst == 8)
                                                    {
                                                        if (keyboardclickstopwatch.Elapsed.Ticks >= 20)
                                                        {
                                                            //MainWindow.MessageBox((IntPtr)0, "", "sccs", 0);
                                                            MainWindow.keyboardsim.KeyDown(WindowsInput.Native.VirtualKeyCode.SPACE);
                                                            MainWindow.keyboardsim.KeyUp(WindowsInput.Native.VirtualKeyCode.SPACE);

                                                            keyboardclickstopwatch.Restart();
                                                        }
                                                    }

                                                    if (indexofmeshinst == 9)
                                                    {
                                                        if (keyboardclickstopwatch.Elapsed.Ticks >= 20)
                                                        {
                                                            //MainWindow.MessageBox((IntPtr)0, "", "sccs", 0);
                                                            MainWindow.keyboardsim.KeyDown(WindowsInput.Native.VirtualKeyCode.SPACE);
                                                            MainWindow.keyboardsim.KeyUp(WindowsInput.Native.VirtualKeyCode.SPACE);

                                                            keyboardclickstopwatch.Restart();
                                                        }
                                                    }

                                                    if (indexofmeshinst == 10)
                                                    {
                                                        if (keyboardclickstopwatch.Elapsed.Ticks >= 20)
                                                        {
                                                            //MainWindow.MessageBox((IntPtr)0, "", "sccs", 0);
                                                            MainWindow.keyboardsim.KeyDown(WindowsInput.Native.VirtualKeyCode.RMENU);
                                                            MainWindow.keyboardsim.KeyUp(WindowsInput.Native.VirtualKeyCode.RMENU);

                                                            keyboardclickstopwatch.Restart();
                                                        }
                                                    }


                                                    //if (indexofmeshinst == 11)
                                                    //{
                                                    //    if (keyboardclickstopwatch.Elapsed.Ticks >= 20)
                                                    //    {
                                                    ///        //MainWindow.MessageBox((IntPtr)0, "", "sccs", 0);
                                                    //        MainWindow.keyboardsim.KeyDown(WindowsInput.Native.VirtualKeyCode.FN);
                                                    //        MainWindow.keyboardsim.KeyUp(WindowsInput.Native.VirtualKeyCode.FN);
                                                    //
                                                    //        keyboardclickstopwatch.Restart();
                                                    //    }
                                                    //}


                                                    if (indexofmeshinst == 12)
                                                    {
                                                        if (keyboardclickstopwatch.Elapsed.Ticks >= 20)
                                                        {
                                                            //MainWindow.MessageBox((IntPtr)0, "", "sccs", 0);
                                                            MainWindow.keyboardsim.KeyDown(WindowsInput.Native.VirtualKeyCode.RWIN);
                                                            MainWindow.keyboardsim.KeyUp(WindowsInput.Native.VirtualKeyCode.RWIN);

                                                            keyboardclickstopwatch.Restart();
                                                        }
                                                    }

                                                    if (indexofmeshinst == 13)
                                                    {
                                                        if (keyboardclickstopwatch.Elapsed.Ticks >= 20)
                                                        {
                                                            //MainWindow.MessageBox((IntPtr)0, "", "sccs", 0);
                                                            MainWindow.keyboardsim.KeyDown(WindowsInput.Native.VirtualKeyCode.RCONTROL);
                                                            MainWindow.keyboardsim.KeyUp(WindowsInput.Native.VirtualKeyCode.RCONTROL);

                                                            keyboardclickstopwatch.Restart();
                                                        }
                                                    }

                                                    if (indexofmeshinst == 14)
                                                    {
                                                        if (keyboardclickstopwatch.Elapsed.Ticks >= 20)
                                                        {
                                                            //MainWindow.MessageBox((IntPtr)0, "", "sccs", 0);
                                                            MainWindow.keyboardsim.KeyDown(WindowsInput.Native.VirtualKeyCode.LEFT);
                                                            MainWindow.keyboardsim.KeyUp(WindowsInput.Native.VirtualKeyCode.LEFT);

                                                            keyboardclickstopwatch.Restart();
                                                        }
                                                    }



                                                    if (indexofmeshinst == 15)
                                                    {
                                                        if (keyboardclickstopwatch.Elapsed.Ticks >= 20)
                                                        {
                                                            //MainWindow.MessageBox((IntPtr)0, "", "sccs", 0);
                                                            MainWindow.keyboardsim.KeyDown(WindowsInput.Native.VirtualKeyCode.DOWN);
                                                            MainWindow.keyboardsim.KeyUp(WindowsInput.Native.VirtualKeyCode.DOWN);

                                                            keyboardclickstopwatch.Restart();
                                                        }
                                                    }

                                                    if (indexofmeshinst == 16)
                                                    {
                                                        if (keyboardclickstopwatch.Elapsed.Ticks >= 20)
                                                        {
                                                            //MainWindow.MessageBox((IntPtr)0, "", "sccs", 0);
                                                            MainWindow.keyboardsim.KeyDown(WindowsInput.Native.VirtualKeyCode.RIGHT);
                                                            MainWindow.keyboardsim.KeyUp(WindowsInput.Native.VirtualKeyCode.RIGHT);

                                                            keyboardclickstopwatch.Restart();
                                                        }
                                                    }

                                                    if (indexofmeshinst == 17)
                                                    {
                                                        if (keyboardclickstopwatch.Elapsed.Ticks >= 20)
                                                        {
                                                            //MainWindow.MessageBox((IntPtr)0, "", "sccs", 0);
                                                            MainWindow.keyboardsim.KeyDown(WindowsInput.Native.VirtualKeyCode.VK_0);
                                                            MainWindow.keyboardsim.KeyUp(WindowsInput.Native.VirtualKeyCode.VK_0);

                                                            keyboardclickstopwatch.Restart();
                                                        }
                                                    }
                                                    if (indexofmeshinst == 18)
                                                    {
                                                        if (keyboardclickstopwatch.Elapsed.Ticks >= 20)
                                                        {
                                                            //MainWindow.MessageBox((IntPtr)0, "", "sccs", 0);
                                                            MainWindow.keyboardsim.KeyDown(WindowsInput.Native.VirtualKeyCode.VK_0);
                                                            MainWindow.keyboardsim.KeyUp(WindowsInput.Native.VirtualKeyCode.VK_0);

                                                            keyboardclickstopwatch.Restart();
                                                        }
                                                    }

                                                    if (indexofmeshinst == 19)
                                                    {
                                                        if (keyboardclickstopwatch.Elapsed.Ticks >= 20)
                                                        {
                                                            //MainWindow.MessageBox((IntPtr)0, "", "sccs", 0);
                                                            MainWindow.keyboardsim.KeyDown(WindowsInput.Native.VirtualKeyCode.OEM_PERIOD);
                                                            MainWindow.keyboardsim.KeyUp(WindowsInput.Native.VirtualKeyCode.OEM_PERIOD);

                                                            keyboardclickstopwatch.Restart();
                                                        }
                                                    }

                                                    if (indexofmeshinst == 20)
                                                    {
                                                        if (keyboardclickstopwatch.Elapsed.Ticks >= 20)
                                                        {
                                                            //MainWindow.MessageBox((IntPtr)0, "", "sccs", 0);
                                                            MainWindow.keyboardsim.KeyDown(WindowsInput.Native.VirtualKeyCode.RETURN);
                                                            MainWindow.keyboardsim.KeyUp(WindowsInput.Native.VirtualKeyCode.RETURN);

                                                            keyboardclickstopwatch.Restart();
                                                        }
                                                    }
                                                    //ROW 0
                                                    //ROW 0
                                                    //ROW 0






                                                    //ROW 1
                                                    //ROW 1
                                                    //ROW 1

                                                    if (indexofmeshinst == 21)
                                                    {
                                                        if (keyboardclickstopwatch.Elapsed.Ticks >= 20)
                                                        {
                                                            //MainWindow.MessageBox((IntPtr)0, "", "sccs", 0);
                                                            MainWindow.keyboardsim.KeyDown(WindowsInput.Native.VirtualKeyCode.LSHIFT);
                                                            MainWindow.keyboardsim.KeyUp(WindowsInput.Native.VirtualKeyCode.LSHIFT);

                                                            keyboardclickstopwatch.Restart();
                                                        }
                                                    }

                                                    if (indexofmeshinst == 22)
                                                    {
                                                        if (keyboardclickstopwatch.Elapsed.Ticks >= 20)
                                                        {
                                                            //MainWindow.MessageBox((IntPtr)0, "", "sccs", 0);
                                                            MainWindow.keyboardsim.KeyDown(WindowsInput.Native.VirtualKeyCode.LSHIFT);
                                                            MainWindow.keyboardsim.KeyUp(WindowsInput.Native.VirtualKeyCode.LSHIFT);

                                                            keyboardclickstopwatch.Restart();
                                                        }
                                                    }


                                                    if (indexofmeshinst == 23)
                                                    {
                                                        if (keyboardclickstopwatch.Elapsed.Ticks >= 20)
                                                        {
                                                            //MainWindow.MessageBox((IntPtr)0, "", "sccs", 0);
                                                            MainWindow.keyboardsim.KeyDown(WindowsInput.Native.VirtualKeyCode.VK_Z);
                                                            MainWindow.keyboardsim.KeyUp(WindowsInput.Native.VirtualKeyCode.VK_Z);

                                                            keyboardclickstopwatch.Restart();
                                                        }
                                                    }


                                                    if (indexofmeshinst == 24)
                                                    {
                                                        if (keyboardclickstopwatch.Elapsed.Ticks >= 20)
                                                        {
                                                            //MainWindow.MessageBox((IntPtr)0, "", "sccs", 0);
                                                            MainWindow.keyboardsim.KeyDown(WindowsInput.Native.VirtualKeyCode.VK_X);
                                                            MainWindow.keyboardsim.KeyUp(WindowsInput.Native.VirtualKeyCode.VK_X);

                                                            keyboardclickstopwatch.Restart();
                                                        }
                                                    }




                                                    if (indexofmeshinst == 25)
                                                    {
                                                        if (keyboardclickstopwatch.Elapsed.Ticks >= 20)
                                                        {
                                                            //MainWindow.MessageBox((IntPtr)0, "", "sccs", 0);
                                                            MainWindow.keyboardsim.KeyDown(WindowsInput.Native.VirtualKeyCode.VK_C);
                                                            MainWindow.keyboardsim.KeyUp(WindowsInput.Native.VirtualKeyCode.VK_C);

                                                            keyboardclickstopwatch.Restart();
                                                        }
                                                    }



                                                    if (indexofmeshinst == 26)
                                                    {
                                                        if (keyboardclickstopwatch.Elapsed.Ticks >= 20)
                                                        {
                                                            //MainWindow.MessageBox((IntPtr)0, "", "sccs", 0);
                                                            MainWindow.keyboardsim.KeyDown(WindowsInput.Native.VirtualKeyCode.VK_V);
                                                            MainWindow.keyboardsim.KeyUp(WindowsInput.Native.VirtualKeyCode.VK_V);

                                                            keyboardclickstopwatch.Restart();
                                                        }
                                                    }

                                                    if (indexofmeshinst == 27)
                                                    {
                                                        if (keyboardclickstopwatch.Elapsed.Ticks >= 20)
                                                        {
                                                            //MainWindow.MessageBox((IntPtr)0, "", "sccs", 0);
                                                            MainWindow.keyboardsim.KeyDown(WindowsInput.Native.VirtualKeyCode.VK_B);
                                                            MainWindow.keyboardsim.KeyUp(WindowsInput.Native.VirtualKeyCode.VK_B);

                                                            keyboardclickstopwatch.Restart();
                                                        }
                                                    }


                                                    if (indexofmeshinst == 28)
                                                    {
                                                        if (keyboardclickstopwatch.Elapsed.Ticks >= 20)
                                                        {
                                                            //MainWindow.MessageBox((IntPtr)0, "", "sccs", 0);
                                                            MainWindow.keyboardsim.KeyDown(WindowsInput.Native.VirtualKeyCode.VK_N);
                                                            MainWindow.keyboardsim.KeyUp(WindowsInput.Native.VirtualKeyCode.VK_N);

                                                            keyboardclickstopwatch.Restart();
                                                        }
                                                    }

                                                    if (indexofmeshinst == 29)
                                                    {
                                                        if (keyboardclickstopwatch.Elapsed.Ticks >= 20)
                                                        {
                                                            //MainWindow.MessageBox((IntPtr)0, "", "sccs", 0);
                                                            MainWindow.keyboardsim.KeyDown(WindowsInput.Native.VirtualKeyCode.VK_M);
                                                            MainWindow.keyboardsim.KeyUp(WindowsInput.Native.VirtualKeyCode.VK_M);

                                                            keyboardclickstopwatch.Restart();
                                                        }
                                                    }


                                                    if (indexofmeshinst == 30)
                                                    {
                                                        if (keyboardclickstopwatch.Elapsed.Ticks >= 20)
                                                        {
                                                            //MainWindow.MessageBox((IntPtr)0, "", "sccs", 0);
                                                            MainWindow.keyboardsim.KeyDown(WindowsInput.Native.VirtualKeyCode.OEM_COMMA);
                                                            MainWindow.keyboardsim.KeyUp(WindowsInput.Native.VirtualKeyCode.OEM_COMMA);

                                                            keyboardclickstopwatch.Restart();
                                                        }
                                                    }




                                                    if (indexofmeshinst == 31)
                                                    {
                                                        if (keyboardclickstopwatch.Elapsed.Ticks >= 20)
                                                        {
                                                            //MainWindow.MessageBox((IntPtr)0, "", "sccs", 0);
                                                            MainWindow.keyboardsim.KeyDown(WindowsInput.Native.VirtualKeyCode.OEM_PERIOD);
                                                            MainWindow.keyboardsim.KeyUp(WindowsInput.Native.VirtualKeyCode.OEM_PERIOD);

                                                            keyboardclickstopwatch.Restart();
                                                        }
                                                    }


                                                    if (indexofmeshinst == 32)
                                                    {
                                                        if (keyboardclickstopwatch.Elapsed.Ticks >= 20)
                                                        {
                                                            //MainWindow.MessageBox((IntPtr)0, "", "sccs", 0);
                                                            MainWindow.keyboardsim.KeyDown(WindowsInput.Native.VirtualKeyCode.OEM_2);
                                                            MainWindow.keyboardsim.KeyUp(WindowsInput.Native.VirtualKeyCode.OEM_2);

                                                            keyboardclickstopwatch.Restart();
                                                        }
                                                    }

                                                    if (indexofmeshinst == 33)
                                                    {
                                                        if (keyboardclickstopwatch.Elapsed.Ticks >= 20)
                                                        {
                                                            //MainWindow.MessageBox((IntPtr)0, "", "sccs", 0);
                                                            MainWindow.keyboardsim.KeyDown(WindowsInput.Native.VirtualKeyCode.RSHIFT);
                                                            MainWindow.keyboardsim.KeyUp(WindowsInput.Native.VirtualKeyCode.RSHIFT);

                                                            keyboardclickstopwatch.Restart();
                                                        }
                                                    }

                                                    if (indexofmeshinst == 34)
                                                    {
                                                        if (keyboardclickstopwatch.Elapsed.Ticks >= 20)
                                                        {
                                                            //MainWindow.MessageBox((IntPtr)0, "", "sccs", 0);
                                                            MainWindow.keyboardsim.KeyDown(WindowsInput.Native.VirtualKeyCode.RSHIFT);
                                                            MainWindow.keyboardsim.KeyUp(WindowsInput.Native.VirtualKeyCode.RSHIFT);

                                                            keyboardclickstopwatch.Restart();
                                                        }
                                                    }



                                                    if (indexofmeshinst == 35)
                                                    {
                                                        if (keyboardclickstopwatch.Elapsed.Ticks >= 20)
                                                        {
                                                            //unassigned

                                                            keyboardclickstopwatch.Restart();
                                                        }
                                                    }



                                                    if (indexofmeshinst == 36)
                                                    {
                                                        if (keyboardclickstopwatch.Elapsed.Ticks >= 20)
                                                        {
                                                            MainWindow.keyboardsim.KeyDown(WindowsInput.Native.VirtualKeyCode.UP);
                                                            MainWindow.keyboardsim.KeyUp(WindowsInput.Native.VirtualKeyCode.UP);

                                                            keyboardclickstopwatch.Restart();
                                                        }
                                                    }


                                                    if (indexofmeshinst == 37)
                                                    {
                                                        if (keyboardclickstopwatch.Elapsed.Ticks >= 20)
                                                        {
                                                            //unassigned

                                                            keyboardclickstopwatch.Restart();
                                                        }
                                                    }

                                                    if (indexofmeshinst == 38)
                                                    {
                                                        if (keyboardclickstopwatch.Elapsed.Ticks >= 20)
                                                        {
                                                            MainWindow.keyboardsim.KeyDown(WindowsInput.Native.VirtualKeyCode.NUMPAD1);
                                                            MainWindow.keyboardsim.KeyUp(WindowsInput.Native.VirtualKeyCode.NUMPAD1);

                                                            keyboardclickstopwatch.Restart();
                                                        }
                                                    }

                                                    if (indexofmeshinst == 39)
                                                    {
                                                        if (keyboardclickstopwatch.Elapsed.Ticks >= 20)
                                                        {
                                                            MainWindow.keyboardsim.KeyDown(WindowsInput.Native.VirtualKeyCode.NUMPAD2);
                                                            MainWindow.keyboardsim.KeyUp(WindowsInput.Native.VirtualKeyCode.NUMPAD2);

                                                            keyboardclickstopwatch.Restart();
                                                        }
                                                    }

                                                    if (indexofmeshinst == 40)
                                                    {
                                                        if (keyboardclickstopwatch.Elapsed.Ticks >= 20)
                                                        {
                                                            MainWindow.keyboardsim.KeyDown(WindowsInput.Native.VirtualKeyCode.NUMPAD3);
                                                            MainWindow.keyboardsim.KeyUp(WindowsInput.Native.VirtualKeyCode.NUMPAD3);

                                                            keyboardclickstopwatch.Restart();
                                                        }
                                                    }

                                                    if (indexofmeshinst == 41)
                                                    {
                                                        if (keyboardclickstopwatch.Elapsed.Ticks >= 20)
                                                        {
                                                            MainWindow.keyboardsim.KeyDown(WindowsInput.Native.VirtualKeyCode.RETURN);
                                                            MainWindow.keyboardsim.KeyUp(WindowsInput.Native.VirtualKeyCode.RETURN);

                                                            keyboardclickstopwatch.Restart();
                                                        }
                                                    }
                                                    //ROW 1
                                                    //ROW 1
                                                    //ROW 1





                                                    //ROW 2
                                                    //ROW 2
                                                    //ROW 2
                                                    if (indexofmeshinst == 42)
                                                    {
                                                        if (keyboardclickstopwatch.Elapsed.Ticks >= 20)
                                                        {
                                                            MainWindow.keyboardsim.KeyDown(WindowsInput.Native.VirtualKeyCode.CAPITAL);
                                                            MainWindow.keyboardsim.KeyUp(WindowsInput.Native.VirtualKeyCode.CAPITAL);

                                                            keyboardclickstopwatch.Restart();
                                                        }
                                                    }


                                                    if (indexofmeshinst == 43)
                                                    {
                                                        if (keyboardclickstopwatch.Elapsed.Ticks >= 20)
                                                        {
                                                            MainWindow.keyboardsim.KeyDown(WindowsInput.Native.VirtualKeyCode.VK_A);
                                                            MainWindow.keyboardsim.KeyUp(WindowsInput.Native.VirtualKeyCode.VK_A);

                                                            keyboardclickstopwatch.Restart();
                                                        }
                                                    }


                                                    if (indexofmeshinst == 44)
                                                    {
                                                        if (keyboardclickstopwatch.Elapsed.Ticks >= 20)
                                                        {
                                                            MainWindow.keyboardsim.KeyDown(WindowsInput.Native.VirtualKeyCode.VK_S);
                                                            MainWindow.keyboardsim.KeyUp(WindowsInput.Native.VirtualKeyCode.VK_S);

                                                            keyboardclickstopwatch.Restart();
                                                        }
                                                    }

                                                    if (indexofmeshinst == 45)
                                                    {
                                                        if (keyboardclickstopwatch.Elapsed.Ticks >= 20)
                                                        {
                                                            MainWindow.keyboardsim.KeyDown(WindowsInput.Native.VirtualKeyCode.VK_D);
                                                            MainWindow.keyboardsim.KeyUp(WindowsInput.Native.VirtualKeyCode.VK_D);

                                                            keyboardclickstopwatch.Restart();
                                                        }
                                                    }

                                                    if (indexofmeshinst == 46)
                                                    {
                                                        if (keyboardclickstopwatch.Elapsed.Ticks >= 20)
                                                        {
                                                            MainWindow.keyboardsim.KeyDown(WindowsInput.Native.VirtualKeyCode.VK_F);
                                                            MainWindow.keyboardsim.KeyUp(WindowsInput.Native.VirtualKeyCode.VK_F);

                                                            keyboardclickstopwatch.Restart();
                                                        }
                                                    }


                                                    if (indexofmeshinst == 47)
                                                    {
                                                        if (keyboardclickstopwatch.Elapsed.Ticks >= 20)
                                                        {
                                                            MainWindow.keyboardsim.KeyDown(WindowsInput.Native.VirtualKeyCode.VK_G);
                                                            MainWindow.keyboardsim.KeyUp(WindowsInput.Native.VirtualKeyCode.VK_G);

                                                            keyboardclickstopwatch.Restart();
                                                        }
                                                    }

                                                    if (indexofmeshinst == 48)
                                                    {
                                                        if (keyboardclickstopwatch.Elapsed.Ticks >= 20)
                                                        {
                                                            MainWindow.keyboardsim.KeyDown(WindowsInput.Native.VirtualKeyCode.VK_H);
                                                            MainWindow.keyboardsim.KeyUp(WindowsInput.Native.VirtualKeyCode.VK_H);

                                                            keyboardclickstopwatch.Restart();
                                                        }
                                                    }


                                                    if (indexofmeshinst == 49)
                                                    {
                                                        if (keyboardclickstopwatch.Elapsed.Ticks >= 20)
                                                        {
                                                            MainWindow.keyboardsim.KeyDown(WindowsInput.Native.VirtualKeyCode.VK_J);
                                                            MainWindow.keyboardsim.KeyUp(WindowsInput.Native.VirtualKeyCode.VK_J);

                                                            keyboardclickstopwatch.Restart();
                                                        }
                                                    }

                                                    if (indexofmeshinst == 50)
                                                    {
                                                        if (keyboardclickstopwatch.Elapsed.Ticks >= 20)
                                                        {
                                                            MainWindow.keyboardsim.KeyDown(WindowsInput.Native.VirtualKeyCode.VK_K);
                                                            MainWindow.keyboardsim.KeyUp(WindowsInput.Native.VirtualKeyCode.VK_K);

                                                            keyboardclickstopwatch.Restart();
                                                        }
                                                    }

                                                    if (indexofmeshinst == 51)
                                                    {
                                                        if (keyboardclickstopwatch.Elapsed.Ticks >= 20)
                                                        {
                                                            MainWindow.keyboardsim.KeyDown(WindowsInput.Native.VirtualKeyCode.VK_L);
                                                            MainWindow.keyboardsim.KeyUp(WindowsInput.Native.VirtualKeyCode.VK_L);

                                                            keyboardclickstopwatch.Restart();
                                                        }
                                                    }

                                                    if (indexofmeshinst == 52)
                                                    {
                                                        if (keyboardclickstopwatch.Elapsed.Ticks >= 20)
                                                        {
                                                            MainWindow.keyboardsim.KeyDown(WindowsInput.Native.VirtualKeyCode.OEM_1);
                                                            MainWindow.keyboardsim.KeyUp(WindowsInput.Native.VirtualKeyCode.OEM_1);

                                                            keyboardclickstopwatch.Restart();
                                                        }
                                                    }

                                                    if (indexofmeshinst == 53)
                                                    {
                                                        if (keyboardclickstopwatch.Elapsed.Ticks >= 20)
                                                        {
                                                            MainWindow.keyboardsim.KeyDown(WindowsInput.Native.VirtualKeyCode.OEM_7);
                                                            MainWindow.keyboardsim.KeyUp(WindowsInput.Native.VirtualKeyCode.OEM_7);

                                                            keyboardclickstopwatch.Restart();
                                                        }
                                                    }
                                                    if (indexofmeshinst == 54)
                                                    {
                                                        if (keyboardclickstopwatch.Elapsed.Ticks >= 20)
                                                        {
                                                            MainWindow.keyboardsim.KeyDown(WindowsInput.Native.VirtualKeyCode.RETURN);
                                                            MainWindow.keyboardsim.KeyUp(WindowsInput.Native.VirtualKeyCode.RETURN);

                                                            keyboardclickstopwatch.Restart();
                                                        }
                                                    }

                                                    if (indexofmeshinst == 55)
                                                    {
                                                        if (keyboardclickstopwatch.Elapsed.Ticks >= 20)
                                                        {
                                                            MainWindow.keyboardsim.KeyDown(WindowsInput.Native.VirtualKeyCode.RETURN);
                                                            MainWindow.keyboardsim.KeyUp(WindowsInput.Native.VirtualKeyCode.RETURN);

                                                            keyboardclickstopwatch.Restart();
                                                        }
                                                    }


                                                    if (indexofmeshinst == 56)
                                                    {
                                                        if (keyboardclickstopwatch.Elapsed.Ticks >= 20)
                                                        {
                                                            //unassigned

                                                            keyboardclickstopwatch.Restart();
                                                        }
                                                    }

                                                    if (indexofmeshinst == 57)
                                                    {
                                                        if (keyboardclickstopwatch.Elapsed.Ticks >= 20)
                                                        {
                                                            //unassigned

                                                            keyboardclickstopwatch.Restart();
                                                        }
                                                    }

                                                    if (indexofmeshinst == 58)
                                                    {
                                                        if (keyboardclickstopwatch.Elapsed.Ticks >= 20)
                                                        {
                                                            //unassigned

                                                            keyboardclickstopwatch.Restart();
                                                        }
                                                    }



                                                    if (indexofmeshinst == 59)
                                                    {
                                                        if (keyboardclickstopwatch.Elapsed.Ticks >= 20)
                                                        {
                                                            MainWindow.keyboardsim.KeyDown(WindowsInput.Native.VirtualKeyCode.VK_4);
                                                            MainWindow.keyboardsim.KeyUp(WindowsInput.Native.VirtualKeyCode.VK_4);

                                                            keyboardclickstopwatch.Restart();
                                                        }
                                                    }


                                                    if (indexofmeshinst == 60)
                                                    {
                                                        if (keyboardclickstopwatch.Elapsed.Ticks >= 20)
                                                        {
                                                            MainWindow.keyboardsim.KeyDown(WindowsInput.Native.VirtualKeyCode.VK_5);
                                                            MainWindow.keyboardsim.KeyUp(WindowsInput.Native.VirtualKeyCode.VK_5);

                                                            keyboardclickstopwatch.Restart();
                                                        }
                                                    }

                                                    if (indexofmeshinst == 61)
                                                    {
                                                        if (keyboardclickstopwatch.Elapsed.Ticks >= 20)
                                                        {
                                                            MainWindow.keyboardsim.KeyDown(WindowsInput.Native.VirtualKeyCode.VK_6);
                                                            MainWindow.keyboardsim.KeyUp(WindowsInput.Native.VirtualKeyCode.VK_6);

                                                            keyboardclickstopwatch.Restart();
                                                        }
                                                    }
                                                    if (indexofmeshinst == 62)
                                                    {
                                                        if (keyboardclickstopwatch.Elapsed.Ticks >= 20)
                                                        {
                                                            MainWindow.keyboardsim.KeyDown(WindowsInput.Native.VirtualKeyCode.ADD);
                                                            MainWindow.keyboardsim.KeyUp(WindowsInput.Native.VirtualKeyCode.ADD);

                                                            keyboardclickstopwatch.Restart();
                                                        }
                                                    }
                                                    //ROW 2
                                                    //ROW 2
                                                    //ROW 2





                                                    //ROW 3
                                                    //ROW 3
                                                    //ROW 3
                                                    if (indexofmeshinst == 63)
                                                    {
                                                        if (keyboardclickstopwatch.Elapsed.Ticks >= 20)
                                                        {
                                                            MainWindow.keyboardsim.KeyDown(WindowsInput.Native.VirtualKeyCode.TAB);
                                                            MainWindow.keyboardsim.KeyUp(WindowsInput.Native.VirtualKeyCode.TAB);

                                                            keyboardclickstopwatch.Restart();
                                                        }
                                                    }

                                                    if (indexofmeshinst == 64)
                                                    {
                                                        if (keyboardclickstopwatch.Elapsed.Ticks >= 20)
                                                        {
                                                            MainWindow.keyboardsim.KeyDown(WindowsInput.Native.VirtualKeyCode.VK_Q);
                                                            MainWindow.keyboardsim.KeyUp(WindowsInput.Native.VirtualKeyCode.VK_Q);

                                                            keyboardclickstopwatch.Restart();
                                                        }
                                                    }

                                                    if (indexofmeshinst == 65)
                                                    {
                                                        if (keyboardclickstopwatch.Elapsed.Ticks >= 20)
                                                        {
                                                            MainWindow.keyboardsim.KeyDown(WindowsInput.Native.VirtualKeyCode.VK_W);
                                                            MainWindow.keyboardsim.KeyUp(WindowsInput.Native.VirtualKeyCode.VK_W);

                                                            keyboardclickstopwatch.Restart();
                                                        }
                                                    }


                                                    if (indexofmeshinst == 66)
                                                    {
                                                        if (keyboardclickstopwatch.Elapsed.Ticks >= 20)
                                                        {
                                                            MainWindow.keyboardsim.KeyDown(WindowsInput.Native.VirtualKeyCode.VK_E);
                                                            MainWindow.keyboardsim.KeyUp(WindowsInput.Native.VirtualKeyCode.VK_E);

                                                            keyboardclickstopwatch.Restart();
                                                        }
                                                    }


                                                    if (indexofmeshinst == 67)
                                                    {
                                                        if (keyboardclickstopwatch.Elapsed.Ticks >= 20)
                                                        {
                                                            MainWindow.keyboardsim.KeyDown(WindowsInput.Native.VirtualKeyCode.VK_R);
                                                            MainWindow.keyboardsim.KeyUp(WindowsInput.Native.VirtualKeyCode.VK_R);

                                                            keyboardclickstopwatch.Restart();
                                                        }
                                                    }

                                                    if (indexofmeshinst == 68)
                                                    {
                                                        if (keyboardclickstopwatch.Elapsed.Ticks >= 20)
                                                        {
                                                            MainWindow.keyboardsim.KeyDown(WindowsInput.Native.VirtualKeyCode.VK_T);
                                                            MainWindow.keyboardsim.KeyUp(WindowsInput.Native.VirtualKeyCode.VK_T);

                                                            keyboardclickstopwatch.Restart();
                                                        }
                                                    }
                                                    if (indexofmeshinst == 69)
                                                    {
                                                        if (keyboardclickstopwatch.Elapsed.Ticks >= 20)
                                                        {
                                                            MainWindow.keyboardsim.KeyDown(WindowsInput.Native.VirtualKeyCode.VK_Y);
                                                            MainWindow.keyboardsim.KeyUp(WindowsInput.Native.VirtualKeyCode.VK_Y);

                                                            keyboardclickstopwatch.Restart();
                                                        }
                                                    }
                                                    if (indexofmeshinst == 70)
                                                    {
                                                        if (keyboardclickstopwatch.Elapsed.Ticks >= 20)
                                                        {
                                                            MainWindow.keyboardsim.KeyDown(WindowsInput.Native.VirtualKeyCode.VK_U);
                                                            MainWindow.keyboardsim.KeyUp(WindowsInput.Native.VirtualKeyCode.VK_U);

                                                            keyboardclickstopwatch.Restart();
                                                        }
                                                    }

                                                    if (indexofmeshinst == 71)
                                                    {
                                                        if (keyboardclickstopwatch.Elapsed.Ticks >= 20)
                                                        {
                                                            MainWindow.keyboardsim.KeyDown(WindowsInput.Native.VirtualKeyCode.VK_I);
                                                            MainWindow.keyboardsim.KeyUp(WindowsInput.Native.VirtualKeyCode.VK_I);

                                                            keyboardclickstopwatch.Restart();
                                                        }
                                                    }


                                                    if (indexofmeshinst == 72)
                                                    {
                                                        if (keyboardclickstopwatch.Elapsed.Ticks >= 20)
                                                        {
                                                            MainWindow.keyboardsim.KeyDown(WindowsInput.Native.VirtualKeyCode.VK_O);
                                                            MainWindow.keyboardsim.KeyUp(WindowsInput.Native.VirtualKeyCode.VK_O);

                                                            keyboardclickstopwatch.Restart();
                                                        }
                                                    }

                                                    if (indexofmeshinst == 73)
                                                    {
                                                        if (keyboardclickstopwatch.Elapsed.Ticks >= 20)
                                                        {
                                                            MainWindow.keyboardsim.KeyDown(WindowsInput.Native.VirtualKeyCode.VK_P);
                                                            MainWindow.keyboardsim.KeyUp(WindowsInput.Native.VirtualKeyCode.VK_P);

                                                            keyboardclickstopwatch.Restart();
                                                        }
                                                    }

                                                    if (indexofmeshinst == 74)
                                                    {
                                                        if (keyboardclickstopwatch.Elapsed.Ticks >= 20)
                                                        {
                                                            MainWindow.keyboardsim.KeyDown(WindowsInput.Native.VirtualKeyCode.OEM_4);
                                                            MainWindow.keyboardsim.KeyUp(WindowsInput.Native.VirtualKeyCode.OEM_4);

                                                            keyboardclickstopwatch.Restart();
                                                        }
                                                    }

                                                    if (indexofmeshinst == 75)
                                                    {
                                                        if (keyboardclickstopwatch.Elapsed.Ticks >= 20)
                                                        {
                                                            MainWindow.keyboardsim.KeyDown(WindowsInput.Native.VirtualKeyCode.OEM_6);
                                                            MainWindow.keyboardsim.KeyUp(WindowsInput.Native.VirtualKeyCode.OEM_6);

                                                            keyboardclickstopwatch.Restart();
                                                        }
                                                    }

                                                    if (indexofmeshinst == 76)
                                                    {
                                                        if (keyboardclickstopwatch.Elapsed.Ticks >= 20)
                                                        {
                                                            MainWindow.keyboardsim.KeyDown(WindowsInput.Native.VirtualKeyCode.OEM_5);
                                                            MainWindow.keyboardsim.KeyUp(WindowsInput.Native.VirtualKeyCode.OEM_5);

                                                            keyboardclickstopwatch.Restart();
                                                        }
                                                    }
                                                    if (indexofmeshinst == 77)
                                                    {
                                                        if (keyboardclickstopwatch.Elapsed.Ticks >= 20)
                                                        {
                                                            MainWindow.keyboardsim.KeyDown(WindowsInput.Native.VirtualKeyCode.DELETE);
                                                            MainWindow.keyboardsim.KeyUp(WindowsInput.Native.VirtualKeyCode.DELETE);

                                                            keyboardclickstopwatch.Restart();
                                                        }
                                                    }

                                                    if (indexofmeshinst == 78)
                                                    {
                                                        if (keyboardclickstopwatch.Elapsed.Ticks >= 20)
                                                        {
                                                            MainWindow.keyboardsim.KeyDown(WindowsInput.Native.VirtualKeyCode.END);
                                                            MainWindow.keyboardsim.KeyUp(WindowsInput.Native.VirtualKeyCode.END);

                                                            keyboardclickstopwatch.Restart();
                                                        }
                                                    }

                                                    if (indexofmeshinst == 79)
                                                    {
                                                        if (keyboardclickstopwatch.Elapsed.Ticks >= 20)
                                                        {
                                                            MainWindow.keyboardsim.KeyDown(WindowsInput.Native.VirtualKeyCode.NEXT);
                                                            MainWindow.keyboardsim.KeyUp(WindowsInput.Native.VirtualKeyCode.NEXT);

                                                            keyboardclickstopwatch.Restart();
                                                        }
                                                    }

                                                    if (indexofmeshinst == 80)
                                                    {
                                                        if (keyboardclickstopwatch.Elapsed.Ticks >= 20)
                                                        {
                                                            MainWindow.keyboardsim.KeyDown(WindowsInput.Native.VirtualKeyCode.VK_7);
                                                            MainWindow.keyboardsim.KeyUp(WindowsInput.Native.VirtualKeyCode.VK_7);

                                                            keyboardclickstopwatch.Restart();
                                                        }
                                                    }

                                                    if (indexofmeshinst == 81)
                                                    {
                                                        if (keyboardclickstopwatch.Elapsed.Ticks >= 20)
                                                        {
                                                            MainWindow.keyboardsim.KeyDown(WindowsInput.Native.VirtualKeyCode.VK_8);
                                                            MainWindow.keyboardsim.KeyUp(WindowsInput.Native.VirtualKeyCode.VK_8);

                                                            keyboardclickstopwatch.Restart();
                                                        }
                                                    }

                                                    if (indexofmeshinst == 82)
                                                    {
                                                        if (keyboardclickstopwatch.Elapsed.Ticks >= 20)
                                                        {
                                                            MainWindow.keyboardsim.KeyDown(WindowsInput.Native.VirtualKeyCode.VK_9);
                                                            MainWindow.keyboardsim.KeyUp(WindowsInput.Native.VirtualKeyCode.VK_9);

                                                            keyboardclickstopwatch.Restart();
                                                        }
                                                    }

                                                    if (indexofmeshinst == 83)
                                                    {
                                                        if (keyboardclickstopwatch.Elapsed.Ticks >= 20)
                                                        {
                                                            MainWindow.keyboardsim.KeyDown(WindowsInput.Native.VirtualKeyCode.ADD);
                                                            MainWindow.keyboardsim.KeyUp(WindowsInput.Native.VirtualKeyCode.ADD);

                                                            keyboardclickstopwatch.Restart();
                                                        }
                                                    }
                                                    //ROW 3
                                                    //ROW 3
                                                    //ROW 3








                                                    //ROW 4
                                                    //ROW 4
                                                    //ROW 4
                                                    if (indexofmeshinst == 84)
                                                    {
                                                        if (keyboardclickstopwatch.Elapsed.Ticks >= 20)
                                                        {
                                                            MainWindow.keyboardsim.KeyDown(WindowsInput.Native.VirtualKeyCode.OEM_3);
                                                            MainWindow.keyboardsim.KeyUp(WindowsInput.Native.VirtualKeyCode.OEM_3);

                                                            keyboardclickstopwatch.Restart();
                                                        }
                                                    }

                                                    if (indexofmeshinst == 85)
                                                    {
                                                        if (keyboardclickstopwatch.Elapsed.Ticks >= 20)
                                                        {
                                                            MainWindow.keyboardsim.KeyDown(WindowsInput.Native.VirtualKeyCode.VK_1);
                                                            MainWindow.keyboardsim.KeyUp(WindowsInput.Native.VirtualKeyCode.VK_1);

                                                            keyboardclickstopwatch.Restart();
                                                        }
                                                    }
                                                    if (indexofmeshinst == 86)
                                                    {
                                                        if (keyboardclickstopwatch.Elapsed.Ticks >= 20)
                                                        {
                                                            MainWindow.keyboardsim.KeyDown(WindowsInput.Native.VirtualKeyCode.VK_2);
                                                            MainWindow.keyboardsim.KeyUp(WindowsInput.Native.VirtualKeyCode.VK_2);

                                                            keyboardclickstopwatch.Restart();
                                                        }
                                                    }

                                                    if (indexofmeshinst == 87)
                                                    {
                                                        if (keyboardclickstopwatch.Elapsed.Ticks >= 20)
                                                        {
                                                            MainWindow.keyboardsim.KeyDown(WindowsInput.Native.VirtualKeyCode.VK_3);
                                                            MainWindow.keyboardsim.KeyUp(WindowsInput.Native.VirtualKeyCode.VK_3);

                                                            keyboardclickstopwatch.Restart();
                                                        }
                                                    }
                                                    if (indexofmeshinst == 88)
                                                    {
                                                        if (keyboardclickstopwatch.Elapsed.Ticks >= 20)
                                                        {
                                                            MainWindow.keyboardsim.KeyDown(WindowsInput.Native.VirtualKeyCode.VK_4);
                                                            MainWindow.keyboardsim.KeyUp(WindowsInput.Native.VirtualKeyCode.VK_4);

                                                            keyboardclickstopwatch.Restart();
                                                        }
                                                    }

                                                    if (indexofmeshinst == 89)
                                                    {
                                                        if (keyboardclickstopwatch.Elapsed.Ticks >= 20)
                                                        {
                                                            MainWindow.keyboardsim.KeyDown(WindowsInput.Native.VirtualKeyCode.VK_5);
                                                            MainWindow.keyboardsim.KeyUp(WindowsInput.Native.VirtualKeyCode.VK_5);

                                                            keyboardclickstopwatch.Restart();
                                                        }
                                                    }

                                                    if (indexofmeshinst == 90)
                                                    {
                                                        if (keyboardclickstopwatch.Elapsed.Ticks >= 20)
                                                        {
                                                            MainWindow.keyboardsim.KeyDown(WindowsInput.Native.VirtualKeyCode.VK_6);
                                                            MainWindow.keyboardsim.KeyUp(WindowsInput.Native.VirtualKeyCode.VK_6);

                                                            keyboardclickstopwatch.Restart();
                                                        }
                                                    }

                                                    if (indexofmeshinst == 91)
                                                    {
                                                        if (keyboardclickstopwatch.Elapsed.Ticks >= 20)
                                                        {
                                                            MainWindow.keyboardsim.KeyDown(WindowsInput.Native.VirtualKeyCode.VK_7);
                                                            MainWindow.keyboardsim.KeyUp(WindowsInput.Native.VirtualKeyCode.VK_7);

                                                            keyboardclickstopwatch.Restart();
                                                        }
                                                    }
                                                    if (indexofmeshinst == 92)
                                                    {
                                                        if (keyboardclickstopwatch.Elapsed.Ticks >= 20)
                                                        {
                                                            MainWindow.keyboardsim.KeyDown(WindowsInput.Native.VirtualKeyCode.VK_8);
                                                            MainWindow.keyboardsim.KeyUp(WindowsInput.Native.VirtualKeyCode.VK_8);

                                                            keyboardclickstopwatch.Restart();
                                                        }
                                                    }

                                                    if (indexofmeshinst == 93)
                                                    {
                                                        if (keyboardclickstopwatch.Elapsed.Ticks >= 20)
                                                        {
                                                            MainWindow.keyboardsim.KeyDown(WindowsInput.Native.VirtualKeyCode.VK_9);
                                                            MainWindow.keyboardsim.KeyUp(WindowsInput.Native.VirtualKeyCode.VK_9);

                                                            keyboardclickstopwatch.Restart();
                                                        }
                                                    }

                                                    if (indexofmeshinst == 94)
                                                    {
                                                        if (keyboardclickstopwatch.Elapsed.Ticks >= 20)
                                                        {
                                                            MainWindow.keyboardsim.KeyDown(WindowsInput.Native.VirtualKeyCode.VK_0);
                                                            MainWindow.keyboardsim.KeyUp(WindowsInput.Native.VirtualKeyCode.VK_0);

                                                            keyboardclickstopwatch.Restart();
                                                        }
                                                    }

                                                    if (indexofmeshinst == 95)
                                                    {
                                                        if (keyboardclickstopwatch.Elapsed.Ticks >= 20)
                                                        {
                                                            MainWindow.keyboardsim.KeyDown(WindowsInput.Native.VirtualKeyCode.OEM_MINUS);
                                                            MainWindow.keyboardsim.KeyUp(WindowsInput.Native.VirtualKeyCode.OEM_MINUS);

                                                            keyboardclickstopwatch.Restart();
                                                        }
                                                    }

                                                    if (indexofmeshinst == 96)
                                                    {
                                                        if (keyboardclickstopwatch.Elapsed.Ticks >= 20)
                                                        {
                                                            MainWindow.keyboardsim.KeyDown(WindowsInput.Native.VirtualKeyCode.OEM_PLUS);
                                                            MainWindow.keyboardsim.KeyUp(WindowsInput.Native.VirtualKeyCode.OEM_PLUS);

                                                            keyboardclickstopwatch.Restart();
                                                        }
                                                    }

                                                    if (indexofmeshinst == 97)
                                                    {
                                                        if (keyboardclickstopwatch.Elapsed.Ticks >= 20)
                                                        {
                                                            MainWindow.keyboardsim.KeyDown(WindowsInput.Native.VirtualKeyCode.BACK);
                                                            MainWindow.keyboardsim.KeyUp(WindowsInput.Native.VirtualKeyCode.BACK);

                                                            keyboardclickstopwatch.Restart();
                                                        }
                                                    }


                                                    if (indexofmeshinst == 98)
                                                    {
                                                        if (keyboardclickstopwatch.Elapsed.Ticks >= 20)
                                                        {
                                                            MainWindow.keyboardsim.KeyDown(WindowsInput.Native.VirtualKeyCode.INSERT);
                                                            MainWindow.keyboardsim.KeyUp(WindowsInput.Native.VirtualKeyCode.INSERT);

                                                            keyboardclickstopwatch.Restart();
                                                        }
                                                    }

                                                    if (indexofmeshinst == 99)
                                                    {
                                                        if (keyboardclickstopwatch.Elapsed.Ticks >= 20)
                                                        {
                                                            MainWindow.keyboardsim.KeyDown(WindowsInput.Native.VirtualKeyCode.HOME);
                                                            MainWindow.keyboardsim.KeyUp(WindowsInput.Native.VirtualKeyCode.HOME);

                                                            keyboardclickstopwatch.Restart();
                                                        }
                                                    }

                                                    if (indexofmeshinst == 100)
                                                    {
                                                        if (keyboardclickstopwatch.Elapsed.Ticks >= 20)
                                                        {
                                                            MainWindow.keyboardsim.KeyDown(WindowsInput.Native.VirtualKeyCode.PRIOR);
                                                            MainWindow.keyboardsim.KeyUp(WindowsInput.Native.VirtualKeyCode.PRIOR);

                                                            keyboardclickstopwatch.Restart();
                                                        }
                                                    }

                                                    if (indexofmeshinst == 101)
                                                    {
                                                        if (keyboardclickstopwatch.Elapsed.Ticks >= 20)
                                                        {
                                                            MainWindow.keyboardsim.KeyDown(WindowsInput.Native.VirtualKeyCode.NUMLOCK);
                                                            MainWindow.keyboardsim.KeyUp(WindowsInput.Native.VirtualKeyCode.NUMLOCK);

                                                            keyboardclickstopwatch.Restart();
                                                        }
                                                    }

                                                    if (indexofmeshinst == 102)
                                                    {
                                                        if (keyboardclickstopwatch.Elapsed.Ticks >= 20)
                                                        {
                                                            MainWindow.keyboardsim.KeyDown(WindowsInput.Native.VirtualKeyCode.OEM_102);
                                                            MainWindow.keyboardsim.KeyUp(WindowsInput.Native.VirtualKeyCode.OEM_102);

                                                            keyboardclickstopwatch.Restart();
                                                        }
                                                    }

                                                    if (indexofmeshinst == 103)
                                                    {
                                                        if (keyboardclickstopwatch.Elapsed.Ticks >= 20)
                                                        {
                                                            MainWindow.keyboardsim.KeyDown(WindowsInput.Native.VirtualKeyCode.MULTIPLY);
                                                            MainWindow.keyboardsim.KeyUp(WindowsInput.Native.VirtualKeyCode.MULTIPLY);

                                                            keyboardclickstopwatch.Restart();
                                                        }
                                                    }
                                                    if (indexofmeshinst == 104)
                                                    {
                                                        if (keyboardclickstopwatch.Elapsed.Ticks >= 20)
                                                        {
                                                            MainWindow.keyboardsim.KeyDown(WindowsInput.Native.VirtualKeyCode.SUBTRACT);
                                                            MainWindow.keyboardsim.KeyUp(WindowsInput.Native.VirtualKeyCode.SUBTRACT);

                                                            keyboardclickstopwatch.Restart();
                                                        }
                                                    }
                                                    //ROW 4
                                                    //ROW 4
                                                    //ROW 4







                                                    //ROW 5
                                                    //ROW 5
                                                    //ROW 5

                                                    if (indexofmeshinst == 105)
                                                    {
                                                        if (keyboardclickstopwatch.Elapsed.Ticks >= 20)
                                                        {
                                                            MainWindow.keyboardsim.KeyDown(WindowsInput.Native.VirtualKeyCode.ESCAPE);
                                                            MainWindow.keyboardsim.KeyUp(WindowsInput.Native.VirtualKeyCode.ESCAPE);

                                                            keyboardclickstopwatch.Restart();
                                                        }
                                                    }

                                                    if (indexofmeshinst == 106)
                                                    {
                                                        if (keyboardclickstopwatch.Elapsed.Ticks >= 20)
                                                        {
                                                            //unassigned

                                                            keyboardclickstopwatch.Restart();
                                                        }
                                                    }

                                                    if (indexofmeshinst == 107)
                                                    {
                                                        if (keyboardclickstopwatch.Elapsed.Ticks >= 20)
                                                        {
                                                            MainWindow.keyboardsim.KeyDown(WindowsInput.Native.VirtualKeyCode.F1);
                                                            MainWindow.keyboardsim.KeyUp(WindowsInput.Native.VirtualKeyCode.F1);


                                                            keyboardclickstopwatch.Restart();
                                                        }
                                                    }



                                                    if (indexofmeshinst == 108)
                                                    {
                                                        if (keyboardclickstopwatch.Elapsed.Ticks >= 20)
                                                        {
                                                            MainWindow.keyboardsim.KeyDown(WindowsInput.Native.VirtualKeyCode.F2);
                                                            MainWindow.keyboardsim.KeyUp(WindowsInput.Native.VirtualKeyCode.F2);


                                                            keyboardclickstopwatch.Restart();
                                                        }
                                                    }

                                                    if (indexofmeshinst == 109)
                                                    {
                                                        if (keyboardclickstopwatch.Elapsed.Ticks >= 20)
                                                        {
                                                            MainWindow.keyboardsim.KeyDown(WindowsInput.Native.VirtualKeyCode.F3);
                                                            MainWindow.keyboardsim.KeyUp(WindowsInput.Native.VirtualKeyCode.F3);

                                                            keyboardclickstopwatch.Restart();
                                                        }
                                                    }
                                                    if (indexofmeshinst == 110)
                                                    {
                                                        if (keyboardclickstopwatch.Elapsed.Ticks >= 20)
                                                        {
                                                            MainWindow.keyboardsim.KeyDown(WindowsInput.Native.VirtualKeyCode.F4);
                                                            MainWindow.keyboardsim.KeyUp(WindowsInput.Native.VirtualKeyCode.F4);

                                                            keyboardclickstopwatch.Restart();
                                                        }
                                                    }
                                                    if (indexofmeshinst == 111)
                                                    {
                                                        if (keyboardclickstopwatch.Elapsed.Ticks >= 20)
                                                        {
                                                            //unassigned

                                                            keyboardclickstopwatch.Restart();
                                                        }
                                                    }
                                                    if (indexofmeshinst == 112)
                                                    {
                                                        if (keyboardclickstopwatch.Elapsed.Ticks >= 20)
                                                        {
                                                            MainWindow.keyboardsim.KeyDown(WindowsInput.Native.VirtualKeyCode.F5);
                                                            MainWindow.keyboardsim.KeyUp(WindowsInput.Native.VirtualKeyCode.F5);

                                                            keyboardclickstopwatch.Restart();
                                                        }
                                                    }
                                                    if (indexofmeshinst == 113)
                                                    {
                                                        if (keyboardclickstopwatch.Elapsed.Ticks >= 20)
                                                        {
                                                            MainWindow.keyboardsim.KeyDown(WindowsInput.Native.VirtualKeyCode.F6);
                                                            MainWindow.keyboardsim.KeyUp(WindowsInput.Native.VirtualKeyCode.F6);

                                                            keyboardclickstopwatch.Restart();
                                                        }
                                                    }
                                                    if (indexofmeshinst == 114)
                                                    {
                                                        if (keyboardclickstopwatch.Elapsed.Ticks >= 20)
                                                        {
                                                            MainWindow.keyboardsim.KeyDown(WindowsInput.Native.VirtualKeyCode.F7);
                                                            MainWindow.keyboardsim.KeyUp(WindowsInput.Native.VirtualKeyCode.F7);

                                                            keyboardclickstopwatch.Restart();
                                                        }
                                                    }
                                                    if (indexofmeshinst == 115)
                                                    {
                                                        if (keyboardclickstopwatch.Elapsed.Ticks >= 20)
                                                        {
                                                            MainWindow.keyboardsim.KeyDown(WindowsInput.Native.VirtualKeyCode.F8);
                                                            MainWindow.keyboardsim.KeyUp(WindowsInput.Native.VirtualKeyCode.F8);

                                                            keyboardclickstopwatch.Restart();
                                                        }
                                                    }
                                                    if (indexofmeshinst == 116)
                                                    {
                                                        if (keyboardclickstopwatch.Elapsed.Ticks >= 20)
                                                        {
                                                            //unassigned

                                                            keyboardclickstopwatch.Restart();
                                                        }
                                                    }
                                                    if (indexofmeshinst == 117)
                                                    {
                                                        if (keyboardclickstopwatch.Elapsed.Ticks >= 20)
                                                        {
                                                            MainWindow.keyboardsim.KeyDown(WindowsInput.Native.VirtualKeyCode.F9);
                                                            MainWindow.keyboardsim.KeyUp(WindowsInput.Native.VirtualKeyCode.F9);

                                                            keyboardclickstopwatch.Restart();
                                                        }
                                                    }
                                                    if (indexofmeshinst == 118)
                                                    {
                                                        if (keyboardclickstopwatch.Elapsed.Ticks >= 20)
                                                        {
                                                            MainWindow.keyboardsim.KeyDown(WindowsInput.Native.VirtualKeyCode.F10);
                                                            MainWindow.keyboardsim.KeyUp(WindowsInput.Native.VirtualKeyCode.F10);

                                                            keyboardclickstopwatch.Restart();
                                                        }
                                                    }
                                                    if (indexofmeshinst == 119)
                                                    {
                                                        if (keyboardclickstopwatch.Elapsed.Ticks >= 20)
                                                        {
                                                            MainWindow.keyboardsim.KeyDown(WindowsInput.Native.VirtualKeyCode.F11);
                                                            MainWindow.keyboardsim.KeyUp(WindowsInput.Native.VirtualKeyCode.F11);

                                                            keyboardclickstopwatch.Restart();
                                                        }
                                                    }
                                                    if (indexofmeshinst == 120)
                                                    {
                                                        if (keyboardclickstopwatch.Elapsed.Ticks >= 20)
                                                        {
                                                            MainWindow.keyboardsim.KeyDown(WindowsInput.Native.VirtualKeyCode.F12);
                                                            MainWindow.keyboardsim.KeyUp(WindowsInput.Native.VirtualKeyCode.F12);

                                                            keyboardclickstopwatch.Restart();
                                                        }
                                                    }
                                                    if (indexofmeshinst == 121)
                                                    {
                                                        if (keyboardclickstopwatch.Elapsed.Ticks >= 20)
                                                        {
                                                            //unassigned

                                                            keyboardclickstopwatch.Restart();
                                                        }
                                                    }
                                                    if (indexofmeshinst == 122)
                                                    {
                                                        if (keyboardclickstopwatch.Elapsed.Ticks >= 20)
                                                        {
                                                            MainWindow.keyboardsim.KeyDown(WindowsInput.Native.VirtualKeyCode.PRINT);
                                                            MainWindow.keyboardsim.KeyUp(WindowsInput.Native.VirtualKeyCode.PRINT);

                                                            keyboardclickstopwatch.Restart();
                                                        }
                                                    }
                                                    if (indexofmeshinst == 123)
                                                    {
                                                        if (keyboardclickstopwatch.Elapsed.Ticks >= 20)
                                                        {
                                                            MainWindow.keyboardsim.KeyDown(WindowsInput.Native.VirtualKeyCode.SCROLL);
                                                            MainWindow.keyboardsim.KeyUp(WindowsInput.Native.VirtualKeyCode.SCROLL);

                                                            keyboardclickstopwatch.Restart();
                                                        }
                                                    }
                                                    if (indexofmeshinst == 124)
                                                    {
                                                        if (keyboardclickstopwatch.Elapsed.Ticks >= 20)
                                                        {
                                                            MainWindow.keyboardsim.KeyDown(WindowsInput.Native.VirtualKeyCode.PAUSE);
                                                            MainWindow.keyboardsim.KeyUp(WindowsInput.Native.VirtualKeyCode.PAUSE);

                                                            keyboardclickstopwatch.Restart();
                                                        }
                                                    }


                                                    //ROW 5
                                                    //ROW 5
                                                    //ROW 5
                                                    //if (somechunkkeyboardpriminstance[someindexchunkkeyboardpriminstance].arrayofindexzeromesh[someindexm].instances[someindexinst].instancePos.X)
                                                    //{
                                                    //
                                                    //}
                                                    //vrkeyboardkeypress(someindexchunkkeyboardpriminstance, someindexm, someindexinst, xii, yii, zii);




























                                                    //MainWindow.MessageBox((IntPtr)0, "/map:" + currentMapData + "/currentByteother:" + currentByteother + "/double_result:" + double_result, "sccs message 1", 0);
                                                    //MainWindow.MessageBox((IntPtr)0, "/map:" + currentMapData + "/someotherbyte:" + arrayOfDigits[someOtherIndex] + "/arrayOfDigits[someotherindex1]:" + arrayOfDigits[someotherindex1] + "/double_result:" + double_result, "sccs message 1", 0);
                                                    // MainWindow.MessageBox((IntPtr)0, "trying to break byte " + "/map4:" + currentMapData + "/bufferbyte:" + currentByte + "/classmemorybyte:" + somebyte + " ", "sccs message 1", 0);
                                                    int voxelchunkinvertoption = MainWindow.usetypeofvoxel;

                                                    //resetvoxelladdercounter

                                                    somechunkkeyboard[indexofmainobject].arrayofindexzeromesh[indexofmeshzero].somechunk[indexofmeshinst].SetByte(indexbytex, indexbytey, indexbytez, 0, Vector3.Zero);

                                                    somechunkkeyboard[indexofmainobject].arrayofindexzeromesh[indexofmeshzero].somechunk[indexofmeshinst].setnewmap(out m11, out m12, out m13, out m14, out m21, out m22, out m23, out m24, out m31, out m32, out m33, out m34, out m41, out m42, out m43, out m44, chosenmap, voxelchunkinvertoption
                                                        , out m11b, out m12b, out m13b, out m14b, out m21b, out m22b, out m23b, out m24b, out m31b, out m32b, out m33b, out m34b, out m41b, out m42b, out m43b, out m44b,
                            out m11c, out m12c, out m13c, out m14c, out m21c, out m22c, out m23c, out m24c, out m31c, out m32c, out m33c, out m34c, out m41c, out m42c, out m43c, out m44c,
                            out m11d, out m12d, out m13d, out m14d, out m21d, out m22d, out m23d, out m24d, out m31d, out m32d, out m33d, out m34d, out m41d, out m42d, out m43d, out m44d); //

                                                    /*somechunkkeyboard[indexofmainobject].arrayofindexzeromesh[indexofmeshzero].instancesmatrix[indexofmeshinst].instancematrix.M11 = (float)m11;
                                                    somechunkkeyboard[indexofmainobject].arrayofindexzeromesh[indexofmeshzero].instancesmatrix[indexofmeshinst].instancematrix.M12 = (float)m12;
                                                    somechunkkeyboard[indexofmainobject].arrayofindexzeromesh[indexofmeshzero].instancesmatrix[indexofmeshinst].instancematrix.M13 = (float)m13;
                                                    somechunkkeyboard[indexofmainobject].arrayofindexzeromesh[indexofmeshzero].instancesmatrix[indexofmeshinst].instancematrix.M14 = (float)m14;

                                                    somechunkkeyboard[indexofmainobject].arrayofindexzeromesh[indexofmeshzero].instancesmatrix[indexofmeshinst].instancematrix.M21 = (float)m21;
                                                    somechunkkeyboard[indexofmainobject].arrayofindexzeromesh[indexofmeshzero].instancesmatrix[indexofmeshinst].instancematrix.M22 = (float)m22;
                                                    somechunkkeyboard[indexofmainobject].arrayofindexzeromesh[indexofmeshzero].instancesmatrix[indexofmeshinst].instancematrix.M23 = (float)m23;
                                                    somechunkkeyboard[indexofmainobject].arrayofindexzeromesh[indexofmeshzero].instancesmatrix[indexofmeshinst].instancematrix.M24 = (float)m24;

                                                    somechunkkeyboard[indexofmainobject].arrayofindexzeromesh[indexofmeshzero].instancesmatrix[indexofmeshinst].instancematrix.M31 = (float)m31;
                                                    somechunkkeyboard[indexofmainobject].arrayofindexzeromesh[indexofmeshzero].instancesmatrix[indexofmeshinst].instancematrix.M32 = (float)m32;
                                                    somechunkkeyboard[indexofmainobject].arrayofindexzeromesh[indexofmeshzero].instancesmatrix[indexofmeshinst].instancematrix.M33 = (float)m33;
                                                    somechunkkeyboard[indexofmainobject].arrayofindexzeromesh[indexofmeshzero].instancesmatrix[indexofmeshinst].instancematrix.M34 = (float)m34;

                                                    somechunkkeyboard[indexofmainobject].arrayofindexzeromesh[indexofmeshzero].instancesmatrix[indexofmeshinst].instancematrix.M41 = (float)m41;
                                                    somechunkkeyboard[indexofmainobject].arrayofindexzeromesh[indexofmeshzero].instancesmatrix[indexofmeshinst].instancematrix.M42 = (float)m42;
                                                    somechunkkeyboard[indexofmainobject].arrayofindexzeromesh[indexofmeshzero].instancesmatrix[indexofmeshinst].instancematrix.M43 = (float)m43;
                                                    somechunkkeyboard[indexofmainobject].arrayofindexzeromesh[indexofmeshzero].instancesmatrix[indexofmeshinst].instancematrix.M44 = (float)m44;
                                                    */

                                                    currentIndex = indexofbyte;
                                                    if (currentIndex >= 0 && currentIndex <= 63)
                                                    {
                                                        if (currentIndex >= 0 && currentIndex <= 3)
                                                        {
                                                            somechunkkeyboard[indexofmainobject].arrayofindexzeromesh[indexofmeshzero].instancesmatrix[indexofmeshinst].instancematrix.M11 = (float)m11;
                                                        }
                                                        else if (currentIndex >= 4 && currentIndex <= 7)
                                                        {
                                                            somechunkkeyboard[indexofmainobject].arrayofindexzeromesh[indexofmeshzero].instancesmatrix[indexofmeshinst].instancematrix.M12 = (float)m12;
                                                        }
                                                        else if (currentIndex >= 8 && currentIndex <= 11)
                                                        {
                                                            somechunkkeyboard[indexofmainobject].arrayofindexzeromesh[indexofmeshzero].instancesmatrix[indexofmeshinst].instancematrix.M13 = (float)m13;
                                                        }
                                                        else if (currentIndex >= 12 && currentIndex <= 15)
                                                        {
                                                            somechunkkeyboard[indexofmainobject].arrayofindexzeromesh[indexofmeshzero].instancesmatrix[indexofmeshinst].instancematrix.M14 = (float)m14;
                                                        }
                                                        else if (currentIndex >= 16 && currentIndex <= 19)
                                                        {
                                                            somechunkkeyboard[indexofmainobject].arrayofindexzeromesh[indexofmeshzero].instancesmatrix[indexofmeshinst].instancematrix.M21 = (float)m21;
                                                        }
                                                        else if (currentIndex >= 20 && currentIndex <= 23)
                                                        {
                                                            somechunkkeyboard[indexofmainobject].arrayofindexzeromesh[indexofmeshzero].instancesmatrix[indexofmeshinst].instancematrix.M22 = (float)m22;
                                                        }
                                                        else if (currentIndex >= 24 && currentIndex <= 27)
                                                        {
                                                            somechunkkeyboard[indexofmainobject].arrayofindexzeromesh[indexofmeshzero].instancesmatrix[indexofmeshinst].instancematrix.M23 = (float)m23;
                                                        }
                                                        else if (currentIndex >= 28 && currentIndex <= 31)
                                                        {
                                                            somechunkkeyboard[indexofmainobject].arrayofindexzeromesh[indexofmeshzero].instancesmatrix[indexofmeshinst].instancematrix.M24 = (float)m24;
                                                        }
                                                        else if (currentIndex >= 32 && currentIndex <= 35)
                                                        {
                                                            somechunkkeyboard[indexofmainobject].arrayofindexzeromesh[indexofmeshzero].instancesmatrix[indexofmeshinst].instancematrix.M31 = (float)m31;
                                                        }
                                                        else if (currentIndex >= 36 && currentIndex <= 39)
                                                        {
                                                            somechunkkeyboard[indexofmainobject].arrayofindexzeromesh[indexofmeshzero].instancesmatrix[indexofmeshinst].instancematrix.M32 = (float)m32;
                                                        }
                                                        else if (currentIndex >= 40 && currentIndex <= 43)
                                                        {
                                                            somechunkkeyboard[indexofmainobject].arrayofindexzeromesh[indexofmeshzero].instancesmatrix[indexofmeshinst].instancematrix.M33 = (float)m33;
                                                        }
                                                        else if (currentIndex >= 44 && currentIndex <= 47)
                                                        {
                                                            somechunkkeyboard[indexofmainobject].arrayofindexzeromesh[indexofmeshzero].instancesmatrix[indexofmeshinst].instancematrix.M34 = (float)m34;
                                                        }
                                                        else if (currentIndex >= 48 && currentIndex <= 51)
                                                        {
                                                            somechunkkeyboard[indexofmainobject].arrayofindexzeromesh[indexofmeshzero].instancesmatrix[indexofmeshinst].instancematrix.M41 = (float)m41;
                                                        }
                                                        else if (currentIndex >= 52 && currentIndex <= 55)
                                                        {
                                                            somechunkkeyboard[indexofmainobject].arrayofindexzeromesh[indexofmeshzero].instancesmatrix[indexofmeshinst].instancematrix.M42 = (float)m42;
                                                        }
                                                        else if (currentIndex >= 56 && currentIndex <= 59)
                                                        {
                                                            somechunkkeyboard[indexofmainobject].arrayofindexzeromesh[indexofmeshzero].instancesmatrix[indexofmeshinst].instancematrix.M43 = (float)m43;
                                                        }
                                                        else if (currentIndex >= 60 && currentIndex <= 63)
                                                        {
                                                            somechunkkeyboard[indexofmainobject].arrayofindexzeromesh[indexofmeshzero].instancesmatrix[indexofmeshinst].instancematrix.M44 = (float)m44;
                                                        }
                                                    }
                                                }
                                                else
                                                {
                                                    if (MainWindow.usetypeofvoxel == 3)
                                                    {
                                                        int voxelchunkinvertoption = MainWindow.usetypeofvoxel;

                                                        somechunkkeyboard[indexofmainobject].arrayofindexzeromesh[indexofmeshzero].somechunk[indexofmeshinst].SetByte(indexbytex, indexbytey, indexbytez, 1, Vector3.Zero);

                                                        somechunkkeyboard[indexofmainobject].arrayofindexzeromesh[indexofmeshzero].somechunk[indexofmeshinst].setnewmap(out m11, out m12, out m13, out m14, out m21, out m22, out m23, out m24, out m31, out m32, out m33, out m34, out m41, out m42, out m43, out m44, chosenmap, voxelchunkinvertoption
                                                            , out m11b, out m12b, out m13b, out m14b, out m21b, out m22b, out m23b, out m24b, out m31b, out m32b, out m33b, out m34b, out m41b, out m42b, out m43b, out m44b,
                            out m11c, out m12c, out m13c, out m14c, out m21c, out m22c, out m23c, out m24c, out m31c, out m32c, out m33c, out m34c, out m41c, out m42c, out m43c, out m44c,
                            out m11d, out m12d, out m13d, out m14d, out m21d, out m22d, out m23d, out m24d, out m31d, out m32d, out m33d, out m34d, out m41d, out m42d, out m43d, out m44d); //

                                                        if (currentIndex >= 0 && currentIndex <= 63)
                                                        {
                                                            if (currentIndex >= 0 && currentIndex <= 3)
                                                            {
                                                                somechunkkeyboard[indexofmainobject].arrayofindexzeromesh[indexofmeshzero].instancesmatrix[indexofmeshinst].instancematrix.M11 = (float)m11;
                                                            }
                                                            else if (currentIndex >= 4 && currentIndex <= 7)
                                                            {
                                                                somechunkkeyboard[indexofmainobject].arrayofindexzeromesh[indexofmeshzero].instancesmatrix[indexofmeshinst].instancematrix.M12 = (float)m12;
                                                            }
                                                            else if (currentIndex >= 8 && currentIndex <= 11)
                                                            {
                                                                somechunkkeyboard[indexofmainobject].arrayofindexzeromesh[indexofmeshzero].instancesmatrix[indexofmeshinst].instancematrix.M13 = (float)m13;
                                                            }
                                                            else if (currentIndex >= 12 && currentIndex <= 15)
                                                            {
                                                                somechunkkeyboard[indexofmainobject].arrayofindexzeromesh[indexofmeshzero].instancesmatrix[indexofmeshinst].instancematrix.M14 = (float)m14;
                                                            }
                                                            else if (currentIndex >= 16 && currentIndex <= 19)
                                                            {
                                                                somechunkkeyboard[indexofmainobject].arrayofindexzeromesh[indexofmeshzero].instancesmatrix[indexofmeshinst].instancematrix.M21 = (float)m21;
                                                            }
                                                            else if (currentIndex >= 20 && currentIndex <= 23)
                                                            {
                                                                somechunkkeyboard[indexofmainobject].arrayofindexzeromesh[indexofmeshzero].instancesmatrix[indexofmeshinst].instancematrix.M22 = (float)m22;
                                                            }
                                                            else if (currentIndex >= 24 && currentIndex <= 27)
                                                            {
                                                                somechunkkeyboard[indexofmainobject].arrayofindexzeromesh[indexofmeshzero].instancesmatrix[indexofmeshinst].instancematrix.M23 = (float)m23;
                                                            }
                                                            else if (currentIndex >= 28 && currentIndex <= 31)
                                                            {
                                                                somechunkkeyboard[indexofmainobject].arrayofindexzeromesh[indexofmeshzero].instancesmatrix[indexofmeshinst].instancematrix.M24 = (float)m24;
                                                            }
                                                            else if (currentIndex >= 32 && currentIndex <= 35)
                                                            {
                                                                somechunkkeyboard[indexofmainobject].arrayofindexzeromesh[indexofmeshzero].instancesmatrix[indexofmeshinst].instancematrix.M31 = (float)m31;
                                                            }
                                                            else if (currentIndex >= 36 && currentIndex <= 39)
                                                            {
                                                                somechunkkeyboard[indexofmainobject].arrayofindexzeromesh[indexofmeshzero].instancesmatrix[indexofmeshinst].instancematrix.M32 = (float)m32;
                                                            }
                                                            else if (currentIndex >= 40 && currentIndex <= 43)
                                                            {
                                                                somechunkkeyboard[indexofmainobject].arrayofindexzeromesh[indexofmeshzero].instancesmatrix[indexofmeshinst].instancematrix.M33 = (float)m33;
                                                            }
                                                            else if (currentIndex >= 44 && currentIndex <= 47)
                                                            {
                                                                somechunkkeyboard[indexofmainobject].arrayofindexzeromesh[indexofmeshzero].instancesmatrix[indexofmeshinst].instancematrix.M34 = (float)m34;
                                                            }
                                                            else if (currentIndex >= 48 && currentIndex <= 51)
                                                            {
                                                                somechunkkeyboard[indexofmainobject].arrayofindexzeromesh[indexofmeshzero].instancesmatrix[indexofmeshinst].instancematrix.M41 = (float)m41;
                                                            }
                                                            else if (currentIndex >= 52 && currentIndex <= 55)
                                                            {
                                                                somechunkkeyboard[indexofmainobject].arrayofindexzeromesh[indexofmeshzero].instancesmatrix[indexofmeshinst].instancematrix.M42 = (float)m42;
                                                            }
                                                            else if (currentIndex >= 56 && currentIndex <= 59)
                                                            {
                                                                somechunkkeyboard[indexofmainobject].arrayofindexzeromesh[indexofmeshzero].instancesmatrix[indexofmeshinst].instancematrix.M43 = (float)m43;
                                                            }
                                                            else if (currentIndex >= 60 && currentIndex <= 63)
                                                            {
                                                                somechunkkeyboard[indexofmainobject].arrayofindexzeromesh[indexofmeshzero].instancesmatrix[indexofmeshinst].instancematrix.M44 = (float)m44;
                                                            }
                                                        }
                                                    }
                                                }
                                            }
                                        }
                                    }
                                }
                            }
                        }
                    }























                }
                else if (playerusebrush == 1)
                {



                    //int somefx = (int)Math.Abs(Math.Floor(ikarmvoxel[3]._player_rght_hnd[0][0]._arrayOfInstances[0].current_pos.M41 / planeSize)); // 
                    //int somefy = (int)Math.Abs(Math.Floor(ikarmvoxel[3]._player_rght_hnd[0][0]._arrayOfInstances[0].current_pos.M42 / planeSize)); // 
                    //int somefz = (int)Math.Abs(Math.Floor(ikarmvoxel[3]._player_rght_hnd[0][0]._arrayOfInstances[0].current_pos.M43 / planeSize)); //

                    //27 bytes brush
                    for (int brx = -brushsizelx; brx <= brushsizerx; brx++)
                    {
                        for (int bry = -brushsizely; bry <= brushsizery; bry++)
                        {
                            for (int brz = -brushsizelz; brz <= brushsizerz; brz++)
                            {
                                /*int minx = 9;
                                int miny = 9;
                                int minz = 9;

                                int diagmaxx = 9;
                                int diagmaxy = 9;
                                int diagmaxz = 9;

                                int diagminx = 9;
                                int diagminy = 9;
                                int diagminz = 9;

                                int chunkwidthl = 4;
                                int chunkwidthr = 3;

                                int chunkheightl = 4;
                                int chunkheightr = 4;

                                int chunkdepthl = 4;
                                int chunkdepthr = 3;
                                int distance = 25;*/

                                int minx = 3;
                                int miny = 3;
                                int minz = 3;

                                int diagmaxx = 3;
                                int diagmaxy = 3;
                                int diagmaxz = 3;

                                int diagminx = 3;
                                int diagminy = 3;
                                int diagminz = 3;

                                int chunkwidthl = 4;
                                int chunkwidthr = 3;

                                int chunkheightl = 65;
                                int chunkheightr = 64;

                                int chunkdepthl = 40;
                                int chunkdepthr = 39;

                                int maxDistance = 95;

                                Vector3 pivotpositionpickaxe = new Vector3(ikarmvoxel[3]._player_r_hand_grab[0][0]._arrayOfInstances[0].current_pos.M41, ikarmvoxel[3]._player_r_hand_grab[0][0]._arrayOfInstances[0].current_pos.M42, ikarmvoxel[3]._player_r_hand_grab[0][0]._arrayOfInstances[0].current_pos.M43);
                                Vector3 temppickaxetiplocation = new Vector3(ikarmvoxel[3]._player_r_hand_grab[0][0]._chunk.listofpickaxetipbytes[0].X, ikarmvoxel[3]._player_r_hand_grab[0][0]._chunk.listofpickaxetipbytes[0].Y, ikarmvoxel[3]._player_r_hand_grab[0][0]._chunk.listofpickaxetipbytes[0].Z);

                                /*float somedistancetopickaxetip = sc_maths.sc_check_distance_node_3d(ikarmvoxel[3]._player_r_hand_grab[0][0]._chunk.listofpickaxetipbytes[0], positionofhitbyte, minx, miny, minz, diagmaxx, diagmaxy, diagmaxz, diagminx, diagminy, diagminz);
                                float maxx = 2;
                                float maxy = 8;
                                float maxz = 2;


                                if (somedistancetopickaxetip >= chunkheightl)// * maxDistance) && y >= -chunkheightl && y < -chunkheightl + maxy)//x >= -maxx && x < maxx && z >= -maxz && z < maxz) // 0.35f
                                {


                                }*/



                                var MOVINGPOINTER = new Vector3(ikvoxelbody[0]._player_torso[0][0]._arrayOfInstances[0]._ORIGINPOSITION.M41, ikvoxelbody[0]._player_torso[0][0]._arrayOfInstances[0]._ORIGINPOSITION.M42, ikvoxelbody[0]._player_torso[0][0]._arrayOfInstances[0]._ORIGINPOSITION.M43);

                                var rotposmatrix = ikarmvoxel[3]._player_r_hand_grab[0][0]._arrayOfInstances[0].current_pos;// _player_rght_shldr[0][0]._ORIGINPOSITION;

                                Quaternion somequat;
                                Quaternion.RotationMatrix(ref rotposmatrix, out somequat);
                                var direction_feet_forward_ori = sc_maths._getDirection(Vector3.ForwardRH, somequat);
                                var direction_feet_right_ori = sc_maths._getDirection(Vector3.Right, somequat);
                                var direction_feet_up_ori = sc_maths._getDirection(Vector3.Up, somequat);
                                var diffNormPosX = (MOVINGPOINTER.X) - ikarmvoxel[3]._player_r_hand_grab[0][0]._arrayOfInstances[0]._ORIGINPOSITION.M41;
                                var diffNormPosY = (MOVINGPOINTER.Y) - ikarmvoxel[3]._player_r_hand_grab[0][0]._arrayOfInstances[0]._ORIGINPOSITION.M42;
                                var diffNormPosZ = (MOVINGPOINTER.Z) - ikarmvoxel[3]._player_r_hand_grab[0][0]._arrayOfInstances[0]._ORIGINPOSITION.M43;
                                var pickaxetippoint = MOVINGPOINTER;

                                //var tempPoint = pickaxetippoint + (direction_feet_right_ori * (diffNormPosX));
                                //tempPoint = tempPoint + (direction_feet_up_ori * (diffNormPosY));
                                //tempPoint = tempPoint + (direction_feet_forward_ori * (diffNormPosZ));

                                //var MOVINGPOINTER1 = tempPoint + new Vector3(ikarmvoxel[3]._player_r_hand_grab[0][0]._arrayOfInstances[0].current_pos.M41, ikarmvoxel[3]._player_r_hand_grab[0][0]._arrayOfInstances[0].current_pos.M42, ikarmvoxel[3]._player_r_hand_grab[0][0]._arrayOfInstances[0].current_pos.M43);
                                var MOVINGPOINTER1 = new Vector3(ikarmvoxel[3]._player_r_hand_grab[0][0]._arrayOfInstances[0].current_pos.M41, ikarmvoxel[3]._player_r_hand_grab[0][0]._arrayOfInstances[0].current_pos.M42, ikarmvoxel[3]._player_r_hand_grab[0][0]._arrayOfInstances[0].current_pos.M43);


                                //float somezvalue = ikarmvoxel[3]._player_r_hand_grab[0][0]._total_torso_height;

                                pickaxetippoint = MOVINGPOINTER1 + (direction_feet_up_ori * (-temppickaxetiplocation.Y * ikarmvoxel[3].voxel_general_size));
                                pickaxetippoint = pickaxetippoint + (direction_feet_forward_ori * (-temppickaxetiplocation.Z * ikarmvoxel[3].voxel_general_size));

                                //SET THE BYTE LOCATOR OBJECT TO THE LOCATION OF THE BYTE ON THE CHUNK IN ORDER TO HAVE A VISUAL ON WHERE THE BYTE LOCATOR IS IN CODE
                                //SET THE BYTE LOCATOR OBJECT TO THE LOCATION OF THE BYTE ON THE CHUNK IN ORDER TO HAVE A VISUAL ON WHERE THE BYTE LOCATOR IS IN CODE
                                //SET THE BYTE LOCATOR OBJECT TO THE LOCATION OF THE BYTE ON THE CHUNK IN ORDER TO HAVE A VISUAL ON WHERE THE BYTE LOCATOR IS IN CODE
                                worldMatrix_instances_voxel_cube[0][0][1].M41 = pickaxetippoint.X;
                                worldMatrix_instances_voxel_cube[0][0][1].M42 = pickaxetippoint.Y;
                                worldMatrix_instances_voxel_cube[0][0][1].M43 = pickaxetippoint.Z;
                                //SET THE BYTE LOCATOR OBJECT TO THE LOCATION OF THE BYTE ON THE CHUNK IN ORDER TO HAVE A VISUAL ON WHERE THE BYTE LOCATOR IS IN CODE
                                //SET THE BYTE LOCATOR OBJECT TO THE LOCATION OF THE BYTE ON THE CHUNK IN ORDER TO HAVE A VISUAL ON WHERE THE BYTE LOCATOR IS IN CODE
                                //SET THE BYTE LOCATOR OBJECT TO THE LOCATION OF THE BYTE ON THE CHUNK IN ORDER TO HAVE A VISUAL ON WHERE THE BYTE LOCATOR IS IN CODE


                                /*// tempPoint = tempPoint + (direction_feet_up_ori * (diffNormPosY));
                                //tempPoint = tempPoint + (direction_feet_forward_ori * (diffNormPosZ));

                                //tempPoint = tempPoint + OFFSETPOS;

                                float someflooredvaluex = (float)(Math.Floor(tempPoint.X / someglobalschunkmesh.planeSize) * someglobalschunkmesh.planeSize);
                                float someflooredvaluey = (float)(Math.Floor(tempPoint.Y / someglobalschunkmesh.planeSize) * someglobalschunkmesh.planeSize);
                                float someflooredvaluez = (float)(Math.Floor(tempPoint.Z / someglobalschunkmesh.planeSize) * someglobalschunkmesh.planeSize);
                                */



                                //int brushsizex = 1;
                                //int brushsizey = 1;
                                //int brushsizez = 1;

                                float planeSize = somechunkkeyboardglobals.planeSize;

                                float somesizedfx = (float)(Math.Floor(pickaxetippoint.X / planeSize) * planeSize); // 35 + 1 = 36
                                float somesizedfy = (float)(Math.Floor(pickaxetippoint.Y / planeSize) * planeSize); // 
                                float somesizedfz = (float)(Math.Floor(pickaxetippoint.Z / planeSize) * planeSize); //

                                //ORIGINAL MADE BY STEVE CHASSÉ
                                //int somefx = (int)Math.Abs(Math.Floor(((ikarmvoxel[3]._player_rght_hnd[0][0]._arrayOfInstances[0].current_pos.M41) - somechunkmesh[0].worldmatofobj.M41) / planeSize)); // 35 + 1 = 36
                                //int somefy = (int)Math.Abs(Math.Floor(((ikarmvoxel[3]._player_rght_hnd[0][0]._arrayOfInstances[0].current_pos.M42) - somechunkmesh[0].worldmatofobj.M42) / planeSize)); // 
                                //int somefz = (int)Math.Abs(Math.Floor(((ikarmvoxel[3]._player_rght_hnd[0][0]._arrayOfInstances[0].current_pos.M43) - somechunkmesh[0].worldmatofobj.M43) / planeSize)); //
                                //ORIGINAL MADE BY STEVE CHASSÉ

                                int somefx = (int)Math.Abs(Math.Floor(((pickaxetippoint.X) - somechunkmesh[0].worldmatofobj.M41) / planeSize)); // 35 + 1 = 36
                                int somefy = (int)Math.Abs(Math.Floor(((pickaxetippoint.Y) - somechunkmesh[0].worldmatofobj.M42) / planeSize)); // 
                                int somefz = (int)Math.Abs(Math.Floor(((pickaxetippoint.Z) - somechunkmesh[0].worldmatofobj.M43) / planeSize)); //


                                //if (somefx >= 0 && somefy >= 0 && somefz >= 0)
                                {
                                    //BYTES INDEX FAST MODULO ALTERNATIVE FOUND ON A GOOGLE SEARCH WITH SOME BENCHMARKS AND IT SEEMED TO BE THAT LOOPING WAS FASTER THAN USING MODULO... DEPENDING MAYBE ON OTHER THINGS. ILL TEST LATER.
                                    int theNumberx = someglobalschunkmesh.tinyChunkWidth;
                                    int remainderbytesx = 0;
                                    int totalTimesx = 0;

                                    for (int ii = 0; ii <= somefx; ii++)
                                    {
                                        if (remainderbytesx == theNumberx)
                                        {
                                            remainderbytesx = 0;
                                            totalTimesx++;
                                        }
                                        if (totalTimesx * theNumberx >= somefx) // >=?? why not only >
                                        {
                                            break;
                                        }
                                        remainderbytesx++;
                                    }

                                    int theNumbery = someglobalschunkmesh.tinyChunkHeight;
                                    int remainderbytesy = 0;
                                    int totalTimesy = 0;

                                    for (int ii = 0; ii <= somefy; ii++)
                                    {
                                        if (remainderbytesy == theNumbery)
                                        {
                                            remainderbytesy = 0;
                                            totalTimesy++;
                                        }
                                        if (totalTimesy * theNumbery >= somefy) // >=?? why not only >
                                        {
                                            break;
                                        }
                                        remainderbytesy++;
                                    }

                                    int theNumberz = someglobalschunkmesh.tinyChunkDepth;
                                    int remainderbytesz = 0;
                                    int totalTimesz = 0;

                                    for (int ii = 0; ii <= somefz; ii++)
                                    {
                                        if (remainderbytesz == theNumberz)
                                        {
                                            remainderbytesz = 0;
                                            totalTimesz++;
                                        }
                                        if (totalTimesz * theNumberz >= somefz) // >=?? why not only >
                                        {
                                            break;
                                        }
                                        remainderbytesz++;
                                    }
                                    //BYTES INDEX 


                                    //
                                    int indexofbytex = ((somefx - (totalTimesx * theNumberx))); //36 / 4 = 9 <=> 36 - (9 * 4) = 0.
                                    int indexofbytey = ((somefy - (totalTimesy * theNumbery)));
                                    int indexofbytez = ((somefz - (totalTimesz * theNumberz)));

                                    indexofbytex += brx;
                                    indexofbytey += bry;
                                    indexofbytez += brz;

                                    int indexofbyte = (indexofbytex) + (someglobalschunkmesh.tinyChunkWidth) * ((indexofbytey) + (someglobalschunkmesh.tinyChunkHeight) * (indexofbytez));

                                    //Vector3 brushpos = new Vector3(brx, bry, brz);

                                    //int brushposx = (int)Math.Abs(Math.Floor((brushpos.X) / planeSize)); // 
                                    //int brushposy = (int)Math.Abs(Math.Floor((brushpos.Y) / planeSize)); // 
                                    //int brushposz = (int)Math.Abs(Math.Floor((brushpos.Z) / planeSize)); //                       

                                    //MESH INSTANCE INDEX FAST MODULO 
                                    theNumberx = someglobalschunkmesh.tinyChunkWidth;
                                    int remaindermeshinstx = 0;
                                    totalTimesx = 0;

                                    for (int ii = 0; ii <= somefx; ii++)
                                    {
                                        if (remaindermeshinstx == theNumberx)
                                        {
                                            remaindermeshinstx = 0;
                                            totalTimesx++;
                                        }
                                        if (totalTimesx * theNumberx >= somefx) // >=?? why not only >
                                        {
                                            break;
                                        }
                                        remaindermeshinstx++;
                                    }

                                    theNumbery = someglobalschunkmesh.tinyChunkHeight;
                                    int remaindermeshinsty = 0;
                                    totalTimesy = 0;

                                    for (int ii = 0; ii <= somefy; ii++)
                                    {
                                        if (remaindermeshinsty == theNumbery)
                                        {
                                            remaindermeshinsty = 0;
                                            totalTimesy++;
                                        }
                                        if (totalTimesy * theNumbery >= somefy) // >=?? why not only >
                                        {
                                            break;
                                        }
                                        remaindermeshinsty++;
                                    }

                                    theNumberz = someglobalschunkmesh.tinyChunkDepth;  //someglobalschunkmesh.tinyChunkDepth;
                                    int remaindermeshinstz = 0;
                                    totalTimesz = 0;

                                    for (int ii = 0; ii <= somefz; ii++) // 35
                                    {
                                        if (remaindermeshinstz == theNumberz) //16
                                        {
                                            remaindermeshinstz = 0;
                                            totalTimesz++;
                                        }
                                        if (totalTimesz * theNumberz >= somefz) // >=?? why not only >
                                        {
                                            break;
                                        }
                                        remaindermeshinstz++;
                                    }
                                    //MESH INSTANCE INDEX FAST MODULO 

                                    //
                                    int indexofmeshinstx = totalTimesx;// ((somefx - (totalTimesx * theNumberx))); // 35 - 30 = 5 
                                    int indexofmeshinsty = totalTimesy;//  ((somefy - (totalTimesy * theNumbery))); 
                                    int indexofmeshinstz = totalTimesz;// ((somefz - (totalTimesz * theNumberz)));


                                    if (indexofmeshinstx >= someglobalschunkmesh.numberOfInstancesPerObjectInWidth)
                                    {
                                        indexofmeshinstx = indexofmeshinstx % someglobalschunkmesh.numberOfInstancesPerObjectInWidth;
                                    }
                                    if (indexofmeshinsty >= someglobalschunkmesh.numberOfInstancesPerObjectInHeight)
                                    {
                                        indexofmeshinsty = indexofmeshinsty % someglobalschunkmesh.numberOfInstancesPerObjectInHeight;
                                    }
                                    if (indexofmeshinstz >= someglobalschunkmesh.numberOfInstancesPerObjectInDepth)
                                    {
                                        indexofmeshinstz = indexofmeshinstz % someglobalschunkmesh.numberOfInstancesPerObjectInDepth;
                                    }

                                    int indexofmeshinst = (indexofmeshinstx) + (someglobalschunkmesh.numberOfInstancesPerObjectInWidth) * ((indexofmeshinsty) + (someglobalschunkmesh.numberOfInstancesPerObjectInHeight) * (indexofmeshinstz));
                                    //


                                    //MESH ZERO INDEX FAST MODULO 
                                    theNumberx = someglobalschunkmesh.tinyChunkDepth * someglobalschunkmesh.numberOfInstancesPerObjectInDepth;
                                    int remaindermeshzerox = 0;
                                    totalTimesx = 0;

                                    for (int ii = 0; ii <= somefx; ii++)
                                    {
                                        if (remaindermeshzerox == theNumberx)
                                        {
                                            remaindermeshzerox = 0;
                                            totalTimesx++;
                                        }
                                        if (totalTimesx * theNumberx >= somefx) // >=?? why not only >
                                        {
                                            break;
                                        }
                                        remaindermeshzerox++;
                                    }

                                    theNumbery = someglobalschunkmesh.tinyChunkDepth * someglobalschunkmesh.numberOfInstancesPerObjectInDepth;
                                    int remaindermeshzeroy = 0;
                                    totalTimesy = 0;

                                    for (int ii = 0; ii <= somefy; ii++)
                                    {
                                        if (remaindermeshzeroy == theNumbery)
                                        {
                                            remaindermeshzeroy = 0;
                                            totalTimesy++;
                                        }
                                        if (totalTimesy * theNumbery >= somefy) // >=?? why not only >
                                        {
                                            break;
                                        }
                                        remaindermeshzeroy++;
                                    }

                                    theNumberz = someglobalschunkmesh.tinyChunkDepth * someglobalschunkmesh.numberOfInstancesPerObjectInDepth;  //someglobalschunkmesh.tinyChunkDepth;
                                    int remaindermeshzeroz = 0;
                                    totalTimesz = 0;

                                    for (int ii = 0; ii <= somefz; ii++)
                                    {
                                        if (remaindermeshzeroz == theNumberz)
                                        {
                                            remaindermeshzeroz = 0;
                                            totalTimesz++;
                                        }
                                        if (totalTimesz * theNumberz >= somefz) // >=?? why not only >
                                        {
                                            break;
                                        }
                                        remaindermeshzeroz++;
                                    }
                                    //MESH ZERO INDEX FAST MODULO 


                                    if (totalTimesx >= someglobalschunkmesh.numberOfObjectInWidth)
                                    {
                                        totalTimesx = totalTimesx % someglobalschunkmesh.numberOfObjectInWidth;
                                    }
                                    if (totalTimesy >= someglobalschunkmesh.numberOfObjectInHeight)
                                    {
                                        totalTimesy = totalTimesy % someglobalschunkmesh.numberOfObjectInHeight;
                                    }
                                    if (totalTimesz >= someglobalschunkmesh.numberOfObjectInDepth)
                                    {
                                        totalTimesz = totalTimesz % someglobalschunkmesh.numberOfObjectInDepth;
                                    }



                                    //
                                    int indexofmeshzerox = totalTimesx;//((somefx - (totalTimesx * theNumberx)));
                                    int indexofmeshzeroy = totalTimesy;//((somefy - (totalTimesy * theNumbery)));
                                    int indexofmeshzeroz = totalTimesz;//((somefz - (totalTimesz * theNumberz)));
                                    int indexofmeshzero = (indexofmeshzerox) + (someglobalschunkmesh.numberOfObjectInWidth) * ((indexofmeshzeroy) + (someglobalschunkmesh.numberOfObjectInHeight) * (indexofmeshzeroz));
                                    //


                                    //MAIN OBJECT INDEX FAST MODULO 
                                    theNumberx = someglobalschunkmesh.tinyChunkWidth * someglobalschunkmesh.numberOfInstancesPerObjectInWidth * someglobalschunkmesh.numberOfObjectInWidth;
                                    int remaindermainobjectx = 0;
                                    totalTimesx = 0;

                                    for (int ii = 0; ii <= somefx; ii++)
                                    {
                                        if (remaindermainobjectx == theNumberx)
                                        {
                                            remaindermainobjectx = 0;
                                            totalTimesx++;
                                        }
                                        if (totalTimesx * theNumberx >= somefx) // >=?? why not only >
                                        {
                                            break;
                                        }
                                        remaindermainobjectx++;
                                    }

                                    theNumbery = someglobalschunkmesh.tinyChunkHeight * someglobalschunkmesh.numberOfInstancesPerObjectInHeight * someglobalschunkmesh.numberOfObjectInHeight;
                                    int remaindermainobjecty = 0;
                                    totalTimesy = 0;

                                    for (int ii = 0; ii <= somefy; ii++)
                                    {
                                        if (remaindermainobjecty == theNumbery)
                                        {
                                            remaindermainobjecty = 0;
                                            totalTimesy++;
                                        }
                                        if (totalTimesy * theNumbery >= somefy) // >=?? why not only >
                                        {
                                            break;
                                        }
                                        remaindermainobjecty++;
                                    }

                                    theNumberz = someglobalschunkmesh.tinyChunkDepth * someglobalschunkmesh.numberOfInstancesPerObjectInDepth * someglobalschunkmesh.numberOfObjectInDepth;  //someglobalschunkmesh.tinyChunkDepth;
                                    int remaindermainobjectz = 0;
                                    totalTimesz = 0;

                                    for (int ii = 0; ii <= somefz; ii++)
                                    {
                                        if (remaindermainobjectz == theNumberz)
                                        {
                                            remaindermainobjectz = 0;
                                            totalTimesz++;
                                        }
                                        if (totalTimesz * theNumberz >= somefz) // >=?? why not only >
                                        {
                                            break;
                                        }
                                        remaindermainobjectz++;
                                    }
                                    //MAIN OBJECT INDEX FAST MODULO 


                                    if (totalTimesx >= somechunkmeshswidth)
                                    {
                                        totalTimesx = totalTimesx % somechunkmeshswidth;
                                    }
                                    if (totalTimesy >= somechunkmeshsheight)
                                    {
                                        totalTimesy = totalTimesy % somechunkmeshsheight;
                                    }
                                    if (totalTimesz >= somechunkmeshsdepth)
                                    {
                                        totalTimesz = totalTimesz % somechunkmeshsdepth;
                                    }

                                    //
                                    int indexofmainobjectx = totalTimesx; //((somefx - (totalTimesx * theNumberx)));
                                    int indexofmainobjecty = totalTimesy; //((somefy - (totalTimesy * theNumbery)));
                                    int indexofmainobjectz = totalTimesz; //((somefz - (totalTimesz * theNumberz)));
                                    int indexofmainobject = (indexofmainobjectx) + (somechunkmeshswidth) * ((indexofmainobjecty) + (somechunkmeshsheight) * (indexofmainobjectz));
                                    //

                                    //int diffx = (int)(Math.Floor(SC_Update._rightTouchMatrix.M41 - somechunkmesh[indexofmainobject].arrayofindexzeromesh[indexofmeshzero].somechunk[indexofmeshinst].somechunkpos.X));
                                    //int diffy = (int)(Math.Floor(SC_Update._rightTouchMatrix.M42 - somechunkmesh[indexofmainobject].arrayofindexzeromesh[indexofmeshzero].somechunk[indexofmeshinst].somechunkpos.Y));
                                    //int diffz = (int)(Math.Floor(SC_Update._rightTouchMatrix.M43 - somechunkmesh[indexofmainobject].arrayofindexzeromesh[indexofmeshzero].somechunk[indexofmeshinst].somechunkpos.Z));

                                    //CONSOLE DEBUG
                                    //CONSOLE DEBUG
                                    //CONSOLE DEBUG
                                    /*
                                    if (consolewritecounter >= consolewritecountermax)
                                    {
                                        if (consolewritecounterswtc == 0)
                                        {

                                            consolewritecounterswtc = 1;
                                        }

                                        /*for (int sc = 0; sc < 30; sc++) //Console.WindowWidth - 1
                                        {
                                            Console.SetCursorPosition(sc, 0);
                                            Console.WriteLine(" ");
                                            //Console.SetCursorPosition(sc, 1);
                                            //Console.WriteLine(" ");
                                            //Console.SetCursorPosition(sc, 1);
                                            //Console.WriteLine(" ");
                                            //Console.SetCursorPosition(sc, 3);
                                            //Console.WriteLine(" ");
                                            //Console.SetCursorPosition(sc, 4);
                                            //Console.WriteLine(" ");
                                        }*/

                                    //Console.SetCursorPosition(0, 0);
                                    //Console.WriteLine("x:" + +mainx + "/y:" + mainy + "/z:" + mainz);

                                    //Console.SetCursorPosition(0, 1);
                                    //Console.WriteLine("secx:" + +secx + "/secy:" + secy + "/secz:" + secz);

                                    //Console.SetCursorPosition(0, 0);
                                    //Console.WriteLine("somefx:" + +somefx + "/somefy:" + somefy + "/somefz:" + somefz);

                                    //Console.SetCursorPosition(0, 0);
                                    //Console.WriteLine("fobjmeshx:" + +fobjmeshx + "/fobjmeshy:" + fobjmeshy + "/fobjmeshz:" + fobjmeshz);

                                    //Console.Title = "fobjmeshx:" + +fobjmeshx + "/fobjmeshy:" + fobjmeshy + "/fobjmeshz:" + fobjmeshz;
                                    //Console.Title = "fobjmeshx:" + +fobjmeshx + "/fobjmeshy:" + fobjmeshy + "/fobjmeshz:" + fobjmeshz;
                                    //Console.Title = "finstx:" + +finstx + "/finsty:" + finsty + "/finstz:" + finstz;
                                    //Console.Title = "mainx:" + mainx + "/mainy:" + mainy + "/mainz:" + mainz;
                                    //Console.Title = "someothermainx:" + someothermainx + "/someothermainy:" + someothermainy + "/someothermainz:" + someothermainz + "/fobjmeshx:" + +fobjmeshx + "/fobjmeshy:" + fobjmeshy + "/fobjmeshz:" + fobjmeshz;
                                    //Console.Title = "/someothermainx:" + someothermainx + "/someothermainy:" + someothermainy + "/someothermainz:" + someothermainz +"/fobjmeshmainx:" + fobjmeshmainx + "/fobjmeshmainy:" + fobjmeshmainy + "/fobjmeshmainz:" + fobjmeshmainz + "/fobjmeshx:" + +fobjmeshx + "/fobjmeshy:" + fobjmeshy + "/fobjmeshz:" + fobjmeshz;

                                    //Console.Title = "someinstx:" + (int)someinstx + "/someinsty:" + (int)someinsty + "/someinstz:" + (int)someinstz;

                                    //Console.Title = "somefx:" + +somefx + "/somefy:" + somefy + "/somefz:" + somefz;


                                    /*int indexbytex = remainderbytesx;
                                    int indexbytey = remainderbytesy;
                                    int indexbytez = remainderbytesz;
                                    int indexofbyte = (indexbytex) + (someglobalschunkmesh.tinyChunkWidth) * ((indexbytey) + (someglobalschunkmesh.tinyChunkHeight) * (indexbytez));

                                    int indexmeshinstx = remaindermeshinstx;
                                    int indexmeshinsty = remaindermeshinsty;
                                    int indexmeshinstz = remaindermeshinstz;
                                    int indexofmeshinst = (indexmeshinstx) + (someglobalschunkmesh.numberOfInstancesPerObjectInWidth) * ((indexmeshinsty) + (someglobalschunkmesh.numberOfInstancesPerObjectInHeight) * (indexmeshinstz));

                                    int indexmeshzerox = remaindermeshinstx;
                                    int indexmeshzeroy = remaindermeshinsty;
                                    int indexmeshzeroz = remaindermeshinstz;
                                    int indexofmeshzero = (indexmeshzerox) + (someglobalschunkmesh.numberOfObjectInWidth) * ((indexmeshzeroy) + (someglobalschunkmesh.numberOfObjectInHeight) * (indexmeshzeroz));

                                    int indexmainobjectx = remaindermeshinstx;
                                    int indexmainobjecty = remaindermeshinsty;
                                    int indexmainobjectz = remaindermeshinstz;
                                    int indexofmainobject = (indexmainobjectx) + (somechunkmeshswidth) * ((indexmainobjecty) + (somechunkmeshsheight) * (indexmainobjectz));

                                    //Console.Title = "indexbytex:" + (int)indexbytex + "/indexbytey:" + (int)indexbytey + "/indexbytez:" + (int)indexbytez;
                                    //Console.Title = "indexofmeshinstx:" + (int)indexofmeshinstx + "/indexofmeshinsty:" + (int)indexofmeshinsty + "/indexofmeshinstz:" + (int)indexofmeshinstz;


                                    Console.Title = "/indexmeshzerox:" + (int)indexofmeshzerox + "/indexmeshzeroy:" + (int)indexofmeshzeroy + "/indexmeshzeroz:" + (int)indexofmeshzeroz + "/indexofmeshinstx:" + (int)indexofmeshinstx + "/indexofmeshinsty:" + (int)indexofmeshinsty + "/indexofmeshinstz:" + (int)indexofmeshinstz;


                                    //Console.Title = "/indexmeshzerox:" + (int)indexmeshzerox + "/indexmeshzeroy:" + (int)indexmeshzeroy + "/indexmeshzeroz:" + (int)indexmeshzeroz;


                                    consolewritecounter = 0;
                                }
                                consolewritecounter++;*/



                                    /*indexofmainobject
                                    indexofmeshzero
                                    indexofbyte
                                    indexofmeshinst*/



                                    //CONSOLE DEBUG
                                    //CONSOLE DEBUG
                                    //CONSOLE DEBUG

                                    //indexofmainobject = someothermainindex;




                                    if (indexofmainobject >= 0 && indexofmainobject < somechunkmeshswidth * somechunkmeshsheight * somechunkmeshsdepth)
                                    {
                                        if (indexofmeshzero >= 0 && indexofmeshzero < someglobalschunkmesh.numberOfObjectInWidth * someglobalschunkmesh.numberOfObjectInHeight * someglobalschunkmesh.numberOfObjectInDepth)
                                        {
                                            if (indexofmeshinst >= 0 && indexofmeshinst < someglobalschunkmesh.numberOfInstancesPerObjectInWidth * someglobalschunkmesh.numberOfInstancesPerObjectInHeight * someglobalschunkmesh.numberOfInstancesPerObjectInDepth)
                                            {
                                                //int widthofchunkbyte = someglobalschunkmesh.tinyChunkWidth;
                                                //int heightofchunkbyte = someglobalschunkmesh.tinyChunkHeight;
                                                //int depthofchunkbyte = someglobalschunkmesh.tinyChunkDepth;

                                                //int diffx = (int)(Math.Floor(SC_Update._rightTouchMatrix.M41 - somechunkmesh[indexofmainobject].arrayofindexzeromesh[indexofmeshzero].somechunk[indexofmeshinst].somechunkpos.X));
                                                //int diffy = (int)(Math.Floor(SC_Update._rightTouchMatrix.M42 - somechunkmesh[indexofmainobject].arrayofindexzeromesh[indexofmeshzero].somechunk[indexofmeshinst].somechunkpos.Y));
                                                //int diffz = (int)(Math.Floor(SC_Update._rightTouchMatrix.M43 - somechunkmesh[indexofmainobject].arrayofindexzeromesh[indexofmeshzero].somechunk[indexofmeshinst].somechunkpos.Z));
                                                //int diffindex = (diffx) + (someglobalschunkmesh.tinyChunkWidth) * ((diffy) + (someglobalschunkmesh.tinyChunkHeight) * (diffz));





                                                /*planeSize = someglobalschunkmesh.planeSize;

                                                somefx = (int)Math.Abs((Math.Floor(ikarmvoxel[3]._player_rght_hnd[0][0]._arrayOfInstances[0].current_pos.M41 - somechunkmesh[0].somechunkpriminstancepos.X) / planeSize)); // 
                                                somefy = (int)Math.Abs((Math.Floor(ikarmvoxel[3]._player_rght_hnd[0][0]._arrayOfInstances[0].current_pos.M42 - somechunkmesh[0].somechunkpriminstancepos.Y) / planeSize)); // 
                                                somefz = (int)Math.Abs((Math.Floor(ikarmvoxel[3]._player_rght_hnd[0][0]._arrayOfInstances[0].current_pos.M43 - somechunkmesh[0].somechunkpriminstancepos.Z) / planeSize)); //

                                                //BYTES INDEX FAST MODULO ALTERNATIVE FOUND ON A GOOGLE SEARCH WITH SOME BENCHMARKS AND IT SEEMED TO BE THAT LOOPING WAS FASTER THAN USING MODULO... DEPENDING MAYBE ON OTHER THINGS. ILL TEST LATER.
                                                theNumberx = someglobalschunkmesh.tinyChunkWidth;
                                                remainderbytesx = 0;
                                                totalTimesx = 0;

                                                for (int ii = 0; ii <= somefx; ii++)
                                                {
                                                    if (remainderbytesx == theNumberx)
                                                    {
                                                        remainderbytesx = 0;
                                                        totalTimesx++;
                                                    }
                                                    if (totalTimesx * theNumberx >= somefx) // >=?? why not only >
                                                    {
                                                        break;
                                                    }
                                                    remainderbytesx++;
                                                }

                                                theNumbery = someglobalschunkmesh.tinyChunkHeight;
                                                remainderbytesy = 0;
                                                totalTimesy = 0;

                                                for (int ii = 0; ii <= somefy; ii++)
                                                {
                                                    if (remainderbytesy == theNumbery)
                                                    {
                                                        remainderbytesy = 0;
                                                        totalTimesy++;
                                                    }
                                                    if (totalTimesy * theNumbery >= somefy) // >=?? why not only >
                                                    {
                                                        break;
                                                    }
                                                    remainderbytesy++;
                                                }

                                                theNumberz = someglobalschunkmesh.tinyChunkDepth;
                                                remainderbytesz = 0;
                                                totalTimesz = 0;

                                                for (int ii = 0; ii <= somefz; ii++)
                                                {
                                                    if (remainderbytesz == theNumberz)
                                                    {
                                                        remainderbytesz = 0;
                                                        totalTimesz++;
                                                    }
                                                    if (totalTimesz * theNumberz >= somefz) // >=?? why not only >
                                                    {
                                                        break;
                                                    }
                                                    remainderbytesz++;
                                                }
                                                //BYTES INDEX 

                                                //
                                                indexbytex = ((somefx - (totalTimesx * theNumberx)));
                                                indexbytey = ((somefy - (totalTimesy * theNumbery)));
                                                indexbytez = ((somefz - (totalTimesz * theNumberz)));
                                                indexofbyte = (indexbytex) + (someglobalschunkmesh.tinyChunkWidth) * ((indexbytey) + (someglobalschunkmesh.tinyChunkHeight) * (indexbytez));
                                                //*/

                                                someinstancebytesindex = indexofbyte;

                                                if (someinstancebytesindex >= 0 && someinstancebytesindex < someglobalschunkmesh.tinyChunkWidth * someglobalschunkmesh.tinyChunkHeight * someglobalschunkmesh.tinyChunkDepth)
                                                {
                                                    int currentIndex = someinstancebytesindex;
                                                    int someOtherIndex = currentIndex;

                                                    double currentMapData = -1;

                                                    int chosenmap = 0;

                                                    int somemul = 0;

                                                    if (currentIndex >= 0 && currentIndex <= 63)
                                                    {
                                                        if (currentIndex >= 0 && currentIndex <= 3)
                                                        {
                                                            currentMapData = (double)somechunkmesh[indexofmainobject].arrayofindexzeromesh[indexofmeshzero].instancesmatrix[indexofmeshinst].instancematrix.M11;//input.one;                                                                                                                                                                                                 //// MainWindow.MessageBox((IntPtr)0, "sccs:" + "map:" + (double)somechunkmesh[indexofmainobject].arrayofindexzeromesh[indexofmeshzero].instancesmatrix[indexofmeshinst].instancematrix.M11 , "sccs message 0", 0);

                                                            if (currentIndex >= 0 && currentIndex <= 1)
                                                            {
                                                                int somemax = 1;
                                                                someOtherIndex = 1 + ((somemax - someOtherIndex) * 2);
                                                            }
                                                            else if (currentIndex >= 2 && currentIndex <= 3)
                                                            {
                                                                int somemax = 3;
                                                                someOtherIndex = 0 + ((somemax - someOtherIndex) * 2);
                                                            }
                                                            chosenmap = 0;
                                                        }
                                                        else if (currentIndex >= 4 && currentIndex <= 7)
                                                        {
                                                            currentMapData = (double)somechunkmesh[indexofmainobject].arrayofindexzeromesh[indexofmeshzero].instancesmatrix[indexofmeshinst].instancematrix.M12;//input.oneTwo;
                                                                                                                                                                                                                //// MainWindow.MessageBox((IntPtr)0, "sccs:" + "map:" + (double)somechunkmesh[indexofmainobject].arrayofindexzeromesh[indexofmeshzero].instancesmatrix[indexofmeshinst].instancematrix.M12 , "sccs message 0", 0);

                                                            if (currentIndex >= 4 && currentIndex <= 5)
                                                            {
                                                                int somemax = 5;
                                                                someOtherIndex = 1 + ((somemax - someOtherIndex) * 2);
                                                            }
                                                            else if (currentIndex >= 6 && currentIndex <= 7)
                                                            {
                                                                int somemax = 7;
                                                                someOtherIndex = 0 + ((somemax - someOtherIndex) * 2);
                                                            }
                                                            chosenmap = 1;
                                                        }
                                                        else if (currentIndex >= 8 && currentIndex <= 11)
                                                        {
                                                            currentMapData = (double)somechunkmesh[indexofmainobject].arrayofindexzeromesh[indexofmeshzero].instancesmatrix[indexofmeshinst].instancematrix.M13;
                                                            //// MainWindow.MessageBox((IntPtr)0, "sccs:" + "map:" + (double)somechunkmesh[indexofmainobject].arrayofindexzeromesh[indexofmeshzero].instancesmatrix[indexofmeshinst].instancematrix.M13 , "sccs message 0", 0);

                                                            if (currentIndex >= 8 && currentIndex <= 9)
                                                            {
                                                                int somemax = 9;
                                                                someOtherIndex = 1 + ((somemax - someOtherIndex) * 2);
                                                            }
                                                            else if (currentIndex >= 10 && currentIndex <= 11)
                                                            {
                                                                int somemax = 11;
                                                                someOtherIndex = 0 + ((somemax - someOtherIndex) * 2);
                                                            }
                                                            chosenmap = 2;
                                                        }

                                                        else if (currentIndex >= 12 && currentIndex <= 15)
                                                        {
                                                            currentMapData = (double)somechunkmesh[indexofmainobject].arrayofindexzeromesh[indexofmeshzero].instancesmatrix[indexofmeshinst].instancematrix.M14;//input.twoTwo;
                                                                                                                                                                                                                //// MainWindow.MessageBox((IntPtr)0, "sccs:" + "map:" + (double)somechunkmesh[indexofmainobject].arrayofindexzeromesh[indexofmeshzero].instancesmatrix[indexofmeshinst].instancematrix.M14 , "sccs message 0", 0);

                                                            if (currentIndex >= 12 && currentIndex <= 13)
                                                            {
                                                                int somemax = 13;
                                                                someOtherIndex = 1 + ((somemax - someOtherIndex) * 2);
                                                            }
                                                            else if (currentIndex >= 14 && currentIndex <= 15)
                                                            {
                                                                int somemax = 15;
                                                                someOtherIndex = 0 + ((somemax - someOtherIndex) * 2);
                                                            }
                                                            chosenmap = 3;
                                                        }
                                                        else if (currentIndex >= 16 && currentIndex <= 19)
                                                        {
                                                            currentMapData = (double)somechunkmesh[indexofmainobject].arrayofindexzeromesh[indexofmeshzero].instancesmatrix[indexofmeshinst].instancematrix.M21;//input.three;
                                                                                                                                                                                                                //// MainWindow.MessageBox((IntPtr)0, "sccs:" + "map:" + (double)somechunkmesh[indexofmainobject].arrayofindexzeromesh[indexofmeshzero].instancesmatrix[indexofmeshinst].instancematrix.M21 , "sccs message 0", 0);

                                                            if (currentIndex >= 16 && currentIndex <= 17)
                                                            {
                                                                int somemax = 17;
                                                                someOtherIndex = 1 + ((somemax - someOtherIndex) * 2);
                                                            }
                                                            else if (currentIndex >= 18 && currentIndex <= 19)
                                                            {
                                                                int somemax = 19;
                                                                someOtherIndex = 0 + ((somemax - someOtherIndex) * 2);
                                                            }
                                                            chosenmap = 4;
                                                        }
                                                        else if (currentIndex >= 20 && currentIndex <= 23)
                                                        {
                                                            currentMapData = (double)somechunkmesh[indexofmainobject].arrayofindexzeromesh[indexofmeshzero].instancesmatrix[indexofmeshinst].instancematrix.M22; //input.mapmatrix1.y;//input.threeTwo;
                                                                                                                                                                                                                 //// MainWindow.MessageBox((IntPtr)0, "sccs:" + "map:" + (double)somechunkmesh[indexofmainobject].arrayofindexzeromesh[indexofmeshzero].instancesmatrix[indexofmeshinst].instancematrix.M22 , "sccs message 0", 0);

                                                            if (currentIndex >= 20 && currentIndex <= 21)
                                                            {
                                                                int somemax = 21;
                                                                someOtherIndex = 1 + ((somemax - someOtherIndex) * 2);
                                                            }
                                                            else if (currentIndex >= 22 && currentIndex <= 23)
                                                            {
                                                                int somemax = 23;
                                                                someOtherIndex = 0 + ((somemax - someOtherIndex) * 2);
                                                            }
                                                            chosenmap = 5;
                                                        }
                                                        else if (currentIndex >= 24 && currentIndex <= 27)
                                                        {
                                                            currentMapData = (double)somechunkmesh[indexofmainobject].arrayofindexzeromesh[indexofmeshzero].instancesmatrix[indexofmeshinst].instancematrix.M23; //input.mapmatrix1.z;//input.four;
                                                                                                                                                                                                                 //// MainWindow.MessageBox((IntPtr)0, "sccs:" + "map:" + (double)somechunkmesh[indexofmainobject].arrayofindexzeromesh[indexofmeshzero].instancesmatrix[indexofmeshinst].instancematrix.M23 , "sccs message 0", 0);

                                                            if (currentIndex >= 24 && currentIndex <= 25)
                                                            {
                                                                int somemax = 25;
                                                                someOtherIndex = 1 + ((somemax - someOtherIndex) * 2);
                                                            }
                                                            else if (currentIndex >= 26 && currentIndex <= 27)
                                                            {
                                                                int somemax = 27;
                                                                someOtherIndex = 0 + ((somemax - someOtherIndex) * 2);
                                                            }
                                                            chosenmap = 6;
                                                        }
                                                        else if (currentIndex >= 28 && currentIndex <= 31)
                                                        {
                                                            currentMapData = (double)somechunkmesh[indexofmainobject].arrayofindexzeromesh[indexofmeshzero].instancesmatrix[indexofmeshinst].instancematrix.M24; // input.mapmatrix1.w;//input.fourTwo;
                                                                                                                                                                                                                 //// MainWindow.MessageBox((IntPtr)0, "sccs:" + "map:" + (double)somechunkmesh[indexofmainobject].arrayofindexzeromesh[indexofmeshzero].instancesmatrix[indexofmeshinst].instancematrix.M24 , "sccs message 0", 0);

                                                            if (currentIndex >= 28 && currentIndex <= 29)
                                                            {
                                                                int somemax = 29;
                                                                someOtherIndex = 1 + ((somemax - someOtherIndex) * 2);
                                                            }
                                                            else if (currentIndex >= 30 && currentIndex <= 31)
                                                            {
                                                                int somemax = 31;
                                                                someOtherIndex = 0 + ((somemax - someOtherIndex) * 2);
                                                            }
                                                            chosenmap = 7;
                                                        }
                                                        else if (currentIndex >= 32 && currentIndex <= 35)
                                                        {
                                                            currentMapData = (double)somechunkmesh[indexofmainobject].arrayofindexzeromesh[indexofmeshzero].instancesmatrix[indexofmeshinst].instancematrix.M31; // input.mapmatrix1.w;//input.fourTwo;
                                                                                                                                                                                                                 //// MainWindow.MessageBox((IntPtr)0, "sccs:" + "map:" + (double)somechunkmesh[indexofmainobject].arrayofindexzeromesh[indexofmeshzero].instancesmatrix[indexofmeshinst].instancematrix.M31, "sccs message 0", 0);

                                                            if (currentIndex >= 32 && currentIndex <= 33)
                                                            {
                                                                int somemax = 33;
                                                                someOtherIndex = 1 + ((somemax - someOtherIndex) * 2);
                                                            }
                                                            else if (currentIndex >= 34 && currentIndex <= 35)
                                                            {
                                                                int somemax = 35;
                                                                someOtherIndex = 0 + ((somemax - someOtherIndex) * 2);
                                                            }
                                                            chosenmap = 8;
                                                        }
                                                        else if (currentIndex >= 36 && currentIndex <= 39)
                                                        {
                                                            currentMapData = (double)somechunkmesh[indexofmainobject].arrayofindexzeromesh[indexofmeshzero].instancesmatrix[indexofmeshinst].instancematrix.M32; // input.mapmatrix1.w;//input.fourTwo;
                                                                                                                                                                                                                 //// MainWindow.MessageBox((IntPtr)0, "sccs:" + "map:" + (double)somechunkmesh[indexofmainobject].arrayofindexzeromesh[indexofmeshzero].instancesmatrix[indexofmeshinst].instancematrix.M32, "sccs message 0", 0);

                                                            if (currentIndex >= 36 && currentIndex <= 37)
                                                            {
                                                                int somemax = 37;
                                                                someOtherIndex = 1 + ((somemax - someOtherIndex) * 2);
                                                            }
                                                            else if (currentIndex >= 38 && currentIndex <= 39)
                                                            {
                                                                int somemax = 39;
                                                                someOtherIndex = 0 + ((somemax - someOtherIndex) * 2);
                                                            }
                                                            chosenmap = 9;
                                                        }
                                                        else if (currentIndex >= 40 && currentIndex <= 43)
                                                        {
                                                            currentMapData = (double)somechunkmesh[indexofmainobject].arrayofindexzeromesh[indexofmeshzero].instancesmatrix[indexofmeshinst].instancematrix.M33; // input.mapmatrix1.w;//input.fourTwo;
                                                                                                                                                                                                                 //// MainWindow.MessageBox((IntPtr)0, "sccs:" + "map:" + (double)somechunkmesh[indexofmainobject].arrayofindexzeromesh[indexofmeshzero].instancesmatrix[indexofmeshinst].instancematrix.M33, "sccs message 0", 0);

                                                            if (currentIndex >= 40 && currentIndex <= 41)
                                                            {
                                                                int somemax = 41;
                                                                someOtherIndex = 1 + ((somemax - someOtherIndex) * 2);
                                                            }
                                                            else if (currentIndex >= 42 && currentIndex <= 43)
                                                            {
                                                                int somemax = 43;
                                                                someOtherIndex = 0 + ((somemax - someOtherIndex) * 2);
                                                            }
                                                            chosenmap = 10;
                                                        }
                                                        else if (currentIndex >= 44 && currentIndex <= 47)
                                                        {
                                                            currentMapData = (double)somechunkmesh[indexofmainobject].arrayofindexzeromesh[indexofmeshzero].instancesmatrix[indexofmeshinst].instancematrix.M34; // input.mapmatrix1.w;//input.fourTwo;
                                                                                                                                                                                                                 //// MainWindow.MessageBox((IntPtr)0, "sccs:" + "map:" + (double)somechunkmesh[indexofmainobject].arrayofindexzeromesh[indexofmeshzero].instancesmatrix[indexofmeshinst].instancematrix.M34, "sccs message 0", 0);

                                                            if (currentIndex >= 44 && currentIndex <= 45)
                                                            {
                                                                int somemax = 45;
                                                                someOtherIndex = 1 + ((somemax - someOtherIndex) * 2);
                                                            }
                                                            else if (currentIndex >= 46 && currentIndex <= 47)
                                                            {
                                                                int somemax = 47;
                                                                someOtherIndex = 0 + ((somemax - someOtherIndex) * 2);
                                                            }
                                                            chosenmap = 11;
                                                        }
                                                        else if (currentIndex >= 48 && currentIndex <= 51)
                                                        {
                                                            currentMapData = (double)somechunkmesh[indexofmainobject].arrayofindexzeromesh[indexofmeshzero].instancesmatrix[indexofmeshinst].instancematrix.M41; // input.mapmatrix1.w;//input.fourTwo;
                                                                                                                                                                                                                 //// MainWindow.MessageBox((IntPtr)0, "sccs:" + "map:" + (double)somechunkmesh[indexofmainobject].arrayofindexzeromesh[indexofmeshzero].instancesmatrix[indexofmeshinst].instancematrix.M41, "sccs message 0", 0);

                                                            if (currentIndex >= 48 && currentIndex <= 49)
                                                            {
                                                                int somemax = 49;
                                                                someOtherIndex = 1 + ((somemax - someOtherIndex) * 2);
                                                            }
                                                            else if (currentIndex >= 50 && currentIndex <= 51)
                                                            {
                                                                int somemax = 51;
                                                                someOtherIndex = 0 + ((somemax - someOtherIndex) * 2);
                                                            }
                                                            chosenmap = 12;
                                                        }
                                                        else if (currentIndex >= 52 && currentIndex <= 55)
                                                        {
                                                            currentMapData = (double)somechunkmesh[indexofmainobject].arrayofindexzeromesh[indexofmeshzero].instancesmatrix[indexofmeshinst].instancematrix.M42; // input.mapmatrix1.w;//input.fourTwo;
                                                                                                                                                                                                                 //// MainWindow.MessageBox((IntPtr)0, "sccs:" + "map:" + (double)somechunkmesh[indexofmainobject].arrayofindexzeromesh[indexofmeshzero].instancesmatrix[indexofmeshinst].instancematrix.M42, "sccs message 0", 0);

                                                            if (currentIndex >= 52 && currentIndex <= 53)
                                                            {
                                                                int somemax = 53;
                                                                someOtherIndex = 1 + ((somemax - someOtherIndex) * 2);
                                                            }
                                                            else if (currentIndex >= 54 && currentIndex <= 55)
                                                            {
                                                                int somemax = 55;
                                                                someOtherIndex = 0 + ((somemax - someOtherIndex) * 2);
                                                            }
                                                            chosenmap = 13;
                                                        }
                                                        else if (currentIndex >= 56 && currentIndex <= 59)
                                                        {
                                                            currentMapData = (double)somechunkmesh[indexofmainobject].arrayofindexzeromesh[indexofmeshzero].instancesmatrix[indexofmeshinst].instancematrix.M43; // input.mapmatrix1.w;//input.fourTwo;
                                                                                                                                                                                                                 //// MainWindow.MessageBox((IntPtr)0, "sccs:" + "map:" + (double)somechunkmesh[indexofmainobject].arrayofindexzeromesh[indexofmeshzero].instancesmatrix[indexofmeshinst].instancematrix.M43 , "sccs message 0", 0);

                                                            if (currentIndex >= 56 && currentIndex <= 57)
                                                            {
                                                                int somemax = 57;
                                                                someOtherIndex = 1 + ((somemax - someOtherIndex) * 2);
                                                            }
                                                            else if (currentIndex >= 58 && currentIndex <= 59)
                                                            {
                                                                int somemax = 59;
                                                                someOtherIndex = 0 + ((somemax - someOtherIndex) * 2);
                                                            }
                                                            chosenmap = 14;
                                                        }
                                                        else if (currentIndex >= 60 && currentIndex <= 63)
                                                        {
                                                            currentMapData = (double)somechunkmesh[indexofmainobject].arrayofindexzeromesh[indexofmeshzero].instancesmatrix[indexofmeshinst].instancematrix.M44; // input.mapmatrix1.w;//input.fourTwo;
                                                                                                                                                                                                                 //// MainWindow.MessageBox((IntPtr)0, "sccs:" + "map:" + (double)somechunkmesh[indexofmainobject].arrayofindexzeromesh[indexofmeshzero].instancesmatrix[indexofmeshinst].instancematrix.M44 , "sccs message 0", 0);

                                                            if (currentIndex >= 60 && currentIndex <= 61)
                                                            {
                                                                int somemax = 61;
                                                                someOtherIndex = 1 + ((somemax - someOtherIndex) * 2);
                                                            }
                                                            else if (currentIndex >= 62 && currentIndex <= 63)
                                                            {
                                                                int somemax = 63;
                                                                someOtherIndex = 0 + ((somemax - someOtherIndex) * 2);
                                                            }
                                                            chosenmap = 15;
                                                        }


                                                        //someOtherIndex = 2;

                                                        double someothermul0 = 10.0;
                                                        double someothermul1 = 1.0;

                                                        if (someOtherIndex == 0)
                                                        {
                                                            someothermul0 = 100.0;
                                                            someothermul1 = 0.1;
                                                        }
                                                        else if (someOtherIndex == 1)
                                                        {
                                                            someothermul0 = 1000.0;
                                                            someothermul1 = 0.01;
                                                        }
                                                        else if (someOtherIndex == 2)
                                                        {
                                                            someothermul0 = 10000.0;
                                                            someothermul1 = 0.001;
                                                        }
                                                        else if (someOtherIndex == 3)
                                                        {
                                                            someothermul0 = 100000.0;
                                                            someothermul1 = 0.0001;
                                                        }

                                                        double[] arrayOfDigits = new double[4];// = {0,0,0,0,0,0,0,0,0};

                                                        //double someorimap = 51234;
                                                        double somemap = currentMapData;// 51234; //currentMapData

                                                        double tempsomemap;
                                                        double someotherbyte;

                                                        for (int i = 0; i < 4; i++) //111111111 // 6th digit //someOtherIndex
                                                        {
                                                            tempsomemap = somemap;
                                                            somemap = (somemap * 0.1);
                                                            //MainWindow.MessageBox((IntPtr)0, "/somemap:" + somemap, "sccs message 1", 0);
                                                            var somevalue = Math.Floor((double)(int)((somemap - (int)somemap) * someothermul0)) * someothermul1;
                                                            somevalue = somevalue - (Math.Floor(somevalue * 0.1) * 10);

                                                            arrayOfDigits[i] = somevalue;

                                                            //MainWindow.MessageBox((IntPtr)0, "/arrayOfDigits[i]:" + arrayOfDigits[i] + "/somevalue:" + somevalue, "sccs message 1", 0);
                                                        }




                                                        double[] arrayOfDigits1 = new double[5];// = {0,0,0,0,0,0,0,0,0};

                                                        //double someorimap = 51234;
                                                        double somemap1 = currentMapData;// 51234; //currentMapData

                                                        double tempsomemap1;
                                                        double someotherbyte1;

                                                        for (int i = 0; i < 5; i++) //111111111 // 6th digit //someOtherIndex
                                                        {
                                                            tempsomemap1 = somemap1;
                                                            somemap1 = (somemap1 * 0.1);
                                                            //MainWindow.MessageBox((IntPtr)0, "/somemap:" + somemap, "sccs message 1", 0);
                                                            var somevalue1 = Math.Floor((double)(int)((somemap1 - (int)somemap1) * 100000.0)) * 0.0001;
                                                            somevalue1 = somevalue1 - (Math.Floor(somevalue1 * 0.1) * 10);

                                                            arrayOfDigits1[i] = somevalue1;

                                                            //MainWindow.MessageBox((IntPtr)0, "/arrayOfDigits[i]:" + arrayOfDigits[i] + "/somevalue:" + somevalue, "sccs message 1", 0);
                                                        }

                                                        //MainWindow.MessageBox((IntPtr)0, "/arrayOfDigits1[i]:" + arrayOfDigits1[arrayOfDigits1.Length-1], "sccs message 1", 0);

                                                        var someotherindex1 = 3 - someOtherIndex;

                                                        if (someOtherIndex == 0)
                                                        {
                                                            someothermul0 = 10.0;
                                                            someothermul1 = 1.0;
                                                        }
                                                        else if (someOtherIndex == 1)
                                                        {
                                                            someothermul0 = 100.0;
                                                            someothermul1 = 0.1;
                                                        }
                                                        else if (someOtherIndex == 2)
                                                        {
                                                            someothermul0 = 1000.0;
                                                            someothermul1 = 0.01;
                                                        }
                                                        else if (someOtherIndex == 3)
                                                        {
                                                            someothermul0 = 10000.0;
                                                            someothermul1 = 0.001;
                                                        }

                                                        //currentMapData = 51234.0;
                                                        currentMapData *= 0.0001f;
                                                        currentMapData = Math.Round(currentMapData * 100000) * 0.00001; // 5.1111

                                                        double double_value = currentMapData;
                                                        double double_result = ((double_value - Math.Floor(double_value)) * someothermul0) - Math.Floor((Math.Floor(Math.Floor((double_value - Math.Floor(double_value)) * someothermul0) * 0.1f) * 10));// == 0.345f








                                                        //SECTION FOR 3D BYTE LOCATION WHEN AN INSTANCED BREAKABLE VOXEL OBJECT IS ROTATED
                                                        //SECTION FOR 3D BYTE LOCATION WHEN AN INSTANCED BREAKABLE VOXEL OBJECT IS ROTATED
                                                        //SECTION FOR 3D BYTE LOCATION WHEN AN INSTANCED BREAKABLE VOXEL OBJECT IS ROTATED

                                                        //somechunkmesh[indexofmainobject].arrayofindexzeromesh[indexofmeshzero].somechunk[indexofmeshinst].somechunkpos.X
                                                        Matrix worldmatrixofvoxelobject = somechunkmesh[indexofmainobject].worldmatofobj;
                                                        //somechunkmesh[indexofmainobject].arrayofindexzeromesh[indexofmeshzero].somechunk[indexofmeshinst].somechunkpos = 
                                                        Vector3 somechunkbyteposition = new Vector3(worldmatrixofvoxelobject.M41, worldmatrixofvoxelobject.M42, worldmatrixofvoxelobject.M43);
                                                        Vector3 somechunkbytepositioninteger = new Vector3(worldmatrixofvoxelobject.M41, worldmatrixofvoxelobject.M42, worldmatrixofvoxelobject.M43);

                                                        Quaternion somedirquat;
                                                        Quaternion.RotationMatrix(ref worldmatrixofvoxelobject, out somedirquat);

                                                        var dirInstanceRight = -sc_maths._newgetdirleft(somedirquat);
                                                        var dirInstanceUp = sc_maths._newgetdirup(somedirquat);
                                                        var dirInstanceForward = sc_maths._newgetdirforward(somedirquat);

                                                        float somemulsize = (0.05f * 10) * 0.5f;
                                                        float somemulsize1 = planeSize;

                                                        somechunkbyteposition = new Vector3(0, 0, 0);
                                                        somechunkbytepositioninteger = new Vector3(0, 0, 0);



                                                        /*
                                                        var MOVINGPOINTER = new Vector3(ikvoxelbody[0]._player_torso[0][0]._arrayOfInstances[0]._ORIGINPOSITION.M41, ikvoxelbody[0]._player_torso[0][0]._arrayOfInstances[0]._ORIGINPOSITION.M42, ikvoxelbody[0]._player_torso[0][0]._arrayOfInstances[0]._ORIGINPOSITION.M43);

                                                        var rotposmatrix = ikarmvoxel[3]._player_r_hand_grab[0][0]._arrayOfInstances[0].current_pos;// _player_rght_shldr[0][0]._ORIGINPOSITION;

                                                        Quaternion somequat;
                                                        Quaternion.RotationMatrix(ref rotposmatrix, out somequat);
                                                        var direction_feet_forward_ori = sc_maths._getDirection(Vector3.ForwardRH, somequat);
                                                        var direction_feet_right_ori = sc_maths._getDirection(Vector3.Right, somequat);
                                                        var direction_feet_up_ori = sc_maths._getDirection(Vector3.Up, somequat);
                                                        var diffNormPosX = (MOVINGPOINTER.X) - ikarmvoxel[3]._player_r_hand_grab[0][0]._arrayOfInstances[0]._ORIGINPOSITION.M41;
                                                        var diffNormPosY = (MOVINGPOINTER.Y) - ikarmvoxel[3]._player_r_hand_grab[0][0]._arrayOfInstances[0]._ORIGINPOSITION.M42;
                                                        var diffNormPosZ = (MOVINGPOINTER.Z) - ikarmvoxel[3]._player_r_hand_grab[0][0]._arrayOfInstances[0]._ORIGINPOSITION.M43;
                                                        var pickaxetippoint = MOVINGPOINTER;*/




                                                        /*somechunkbyteposition += (dirInstanceRight * (somechunkmeshswidth * somemulsize) * indexofmainobjectx) * somemulsize1;
                                                        somechunkbyteposition += (dirInstanceRight * (someglobalschunkmesh.numberOfObjectInWidth * somemulsize) * indexofmeshzerox) * somemulsize1;
                                                        somechunkbyteposition += (dirInstanceRight * (someglobalschunkmesh.numberOfInstancesPerObjectInWidth * somemulsize) * indexofmeshinstx) * somemulsize1;
                                                        //somechunkbyteposition += (dirInstanceRight * (someglobalschunkmesh.tinyChunkWidth * somemulsize) * indexofbytex) * somemulsize1;

                                                        somechunkbyteposition += (dirInstanceUp * (somechunkmeshsheight * somemulsize) * indexofmainobjecty) * somemulsize1;
                                                        somechunkbyteposition += (dirInstanceUp * (someglobalschunkmesh.numberOfObjectInHeight * somemulsize) * indexofmeshzeroy) * somemulsize1;
                                                        somechunkbyteposition += (dirInstanceUp * (someglobalschunkmesh.numberOfInstancesPerObjectInHeight * somemulsize) * indexofmeshinsty) * somemulsize1;
                                                        //somechunkbyteposition += (dirInstanceUp * (someglobalschunkmesh.tinyChunkHeight * somemulsize) * indexofbytey * somemulsize1);

                                                        somechunkbyteposition += (dirInstanceForward * (somechunkmeshsdepth * somemulsize) * indexofmainobjectz) * somemulsize1;
                                                        somechunkbyteposition += (dirInstanceForward * (someglobalschunkmesh.numberOfObjectInDepth * somemulsize) * indexofmeshzeroz) * somemulsize1;
                                                        somechunkbyteposition += (dirInstanceForward * (someglobalschunkmesh.numberOfInstancesPerObjectInDepth * somemulsize) * indexofmeshinstz) * somemulsize1;
                                                        //somechunkbyteposition += (dirInstanceForward * (someglobalschunkmesh.tinyChunkDepth * somemulsize) * indexofbytez) * somemulsize1;
                                                        */

                                                        pickaxetippoint.X = (float)Math.Floor(pickaxetippoint.X / someglobalschunkmesh.planeSize) * someglobalschunkmesh.planeSize;
                                                        pickaxetippoint.Y = (float)Math.Floor(pickaxetippoint.Y / someglobalschunkmesh.planeSize) * someglobalschunkmesh.planeSize;
                                                        pickaxetippoint.Z = (float)Math.Floor(pickaxetippoint.Z / someglobalschunkmesh.planeSize) * someglobalschunkmesh.planeSize;

                                                        Vector3 tempvecpickaxehitpoint = pickaxetippoint;
                                                        tempvecpickaxehitpoint.X += someglobalschunkmesh.planeSize * 0.5f;
                                                        tempvecpickaxehitpoint.Y += someglobalschunkmesh.planeSize * 0.5f;
                                                        tempvecpickaxehitpoint.Z += someglobalschunkmesh.planeSize * 0.5f;

                                                        //somechunkbyteposition.X = tempvecpickaxehitpoint.X;
                                                        //somechunkbyteposition.Y = tempvecpickaxehitpoint.Y;
                                                        //somechunkbyteposition.Z = tempvecpickaxehitpoint.Z;

                                                        somechunkbyteposition += (dirInstanceRight * (somechunkmeshswidth * someglobalschunkmesh.numberOfObjectInWidth * someglobalschunkmesh.numberOfInstancesPerObjectInWidth * someglobalschunkmesh.tinyChunkWidth * somemulsize) * indexofmainobjectx) * somemulsize1;
                                                        somechunkbyteposition += (dirInstanceRight * (someglobalschunkmesh.numberOfObjectInWidth * someglobalschunkmesh.numberOfInstancesPerObjectInWidth * someglobalschunkmesh.tinyChunkWidth * somemulsize) * indexofmeshzerox) * somemulsize1;
                                                        somechunkbyteposition += (dirInstanceRight * (someglobalschunkmesh.numberOfInstancesPerObjectInWidth * someglobalschunkmesh.tinyChunkWidth * somemulsize) * indexofmeshinstx) * somemulsize1;
                                                        somechunkbyteposition += (dirInstanceRight * (someglobalschunkmesh.tinyChunkWidth * somemulsize) * indexofbytex) * somemulsize1;
                                                        //somechunkbyteposition += (dirInstanceRight * (someglobalschunkmesh.tinyChunkWidth * somemulsize) * indexofbytex) * somemulsize1;

                                                        somechunkbyteposition += (dirInstanceUp * (somechunkmeshsheight * someglobalschunkmesh.numberOfObjectInHeight * someglobalschunkmesh.numberOfInstancesPerObjectInHeight * someglobalschunkmesh.tinyChunkHeight * somemulsize) * indexofmainobjecty) * somemulsize1;
                                                        somechunkbyteposition += (dirInstanceUp * (someglobalschunkmesh.numberOfObjectInHeight * someglobalschunkmesh.numberOfInstancesPerObjectInHeight * someglobalschunkmesh.tinyChunkHeight * somemulsize) * indexofmeshzeroy) * somemulsize1;
                                                        somechunkbyteposition += (dirInstanceUp * (someglobalschunkmesh.numberOfInstancesPerObjectInHeight * someglobalschunkmesh.tinyChunkHeight * somemulsize) * indexofmeshinsty) * somemulsize1;
                                                        somechunkbyteposition += (dirInstanceUp * (someglobalschunkmesh.tinyChunkHeight * somemulsize) * (indexofbytey)) * somemulsize1;
                                                        //somechunkbyteposition += (dirInstanceUp * (someglobalschunkmesh.tinyChunkHeight * somemulsize) * indexofbytey * somemulsize1);

                                                        somechunkbyteposition += (dirInstanceForward * (somechunkmeshsdepth * someglobalschunkmesh.numberOfObjectInDepth * someglobalschunkmesh.numberOfInstancesPerObjectInDepth * someglobalschunkmesh.tinyChunkDepth * somemulsize) * indexofmainobjectz) * somemulsize1;
                                                        somechunkbyteposition += (dirInstanceForward * (someglobalschunkmesh.numberOfObjectInDepth * someglobalschunkmesh.numberOfInstancesPerObjectInDepth * someglobalschunkmesh.tinyChunkDepth * somemulsize) * indexofmeshzeroz) * somemulsize1;
                                                        somechunkbyteposition += (dirInstanceForward * (someglobalschunkmesh.numberOfInstancesPerObjectInDepth * someglobalschunkmesh.tinyChunkDepth * somemulsize) * indexofmeshinstz) * somemulsize1;
                                                        somechunkbyteposition += (dirInstanceForward * (someglobalschunkmesh.tinyChunkDepth * somemulsize) * indexofbytez) * somemulsize1;












                                                        /*
                                                        somechunkbyteposition += (direction_feet_right_ori * (somechunkmeshswidth * someglobalschunkmesh.numberOfObjectInWidth * someglobalschunkmesh.numberOfInstancesPerObjectInWidth * someglobalschunkmesh.tinyChunkWidth * somemulsize) * indexofmainobjectx) * somemulsize1;
                                                        somechunkbyteposition += (direction_feet_right_ori * (someglobalschunkmesh.numberOfObjectInWidth * someglobalschunkmesh.numberOfInstancesPerObjectInWidth * someglobalschunkmesh.tinyChunkWidth * somemulsize) * indexofmeshzerox) * somemulsize1;
                                                        somechunkbyteposition += (direction_feet_right_ori * (someglobalschunkmesh.numberOfInstancesPerObjectInWidth * someglobalschunkmesh.tinyChunkWidth * somemulsize) * indexofmeshinstx) * somemulsize1;
                                                        somechunkbyteposition += (direction_feet_right_ori * (someglobalschunkmesh.tinyChunkWidth * somemulsize) * indexofbytex) * somemulsize1;
                                                        //somechunkbyteposition += (dirInstanceRight * (someglobalschunkmesh.tinyChunkWidth * somemulsize) * indexofbytex) * somemulsize1;

                                                        somechunkbyteposition += (direction_feet_up_ori * (somechunkmeshsheight * someglobalschunkmesh.numberOfObjectInHeight * someglobalschunkmesh.numberOfInstancesPerObjectInHeight * someglobalschunkmesh.tinyChunkHeight * somemulsize) * indexofmainobjecty) * somemulsize1;
                                                        somechunkbyteposition += (direction_feet_up_ori * (someglobalschunkmesh.numberOfObjectInHeight * someglobalschunkmesh.numberOfInstancesPerObjectInHeight * someglobalschunkmesh.tinyChunkHeight * somemulsize) * indexofmeshzeroy) * somemulsize1;
                                                        somechunkbyteposition += (direction_feet_up_ori * (someglobalschunkmesh.numberOfInstancesPerObjectInHeight * someglobalschunkmesh.tinyChunkHeight * somemulsize) * indexofmeshinsty) * somemulsize1;
                                                        somechunkbyteposition += (direction_feet_up_ori * (someglobalschunkmesh.tinyChunkHeight * somemulsize) * (indexofbytey)) * somemulsize1;
                                                        //somechunkbyteposition += (dirInstanceUp * (someglobalschunkmesh.tinyChunkHeight * somemulsize) * indexofbytey * somemulsize1);

                                                        somechunkbyteposition += (direction_feet_forward_ori * (somechunkmeshsdepth * someglobalschunkmesh.numberOfObjectInDepth * someglobalschunkmesh.numberOfInstancesPerObjectInDepth * someglobalschunkmesh.tinyChunkDepth * somemulsize) * indexofmainobjectz) * somemulsize1;
                                                        somechunkbyteposition += (direction_feet_forward_ori * (someglobalschunkmesh.numberOfObjectInDepth * someglobalschunkmesh.numberOfInstancesPerObjectInDepth * someglobalschunkmesh.tinyChunkDepth * somemulsize) * indexofmeshzeroz) * somemulsize1;
                                                        somechunkbyteposition += (direction_feet_forward_ori * (someglobalschunkmesh.numberOfInstancesPerObjectInDepth * someglobalschunkmesh.tinyChunkDepth * somemulsize) * indexofmeshinstz) * somemulsize1;
                                                        somechunkbyteposition += (direction_feet_forward_ori * (someglobalschunkmesh.tinyChunkDepth * somemulsize) * indexofbytez) * somemulsize1;
                                                        */









                                                        somemulsize = 1.0f;
                                                        somemulsize1 = 1.0f;

                                                        somechunkbytepositioninteger += (dirInstanceRight * (somechunkmeshswidth * someglobalschunkmesh.numberOfObjectInWidth * someglobalschunkmesh.numberOfInstancesPerObjectInWidth * someglobalschunkmesh.tinyChunkWidth * somemulsize) * indexofmainobjectx) * somemulsize1;
                                                        somechunkbytepositioninteger += (dirInstanceRight * (someglobalschunkmesh.numberOfObjectInWidth * someglobalschunkmesh.numberOfInstancesPerObjectInWidth * someglobalschunkmesh.tinyChunkWidth * somemulsize) * indexofmeshzerox) * somemulsize1;
                                                        somechunkbytepositioninteger += (dirInstanceRight * (someglobalschunkmesh.numberOfInstancesPerObjectInWidth * someglobalschunkmesh.tinyChunkWidth * somemulsize) * indexofmeshinstx) * somemulsize1;
                                                        somechunkbytepositioninteger += (dirInstanceRight * (someglobalschunkmesh.tinyChunkWidth * somemulsize) * indexofbytex) * somemulsize1;
                                                        //somechunkbytepositioninteger += (dirInstanceRight * (someglobalschunkmesh.tinyChunkWidth * somemulsize) * indexofbytex) * somemulsize1;

                                                        somechunkbytepositioninteger += (dirInstanceUp * (somechunkmeshsheight * someglobalschunkmesh.numberOfObjectInHeight * someglobalschunkmesh.numberOfInstancesPerObjectInHeight * someglobalschunkmesh.tinyChunkHeight * somemulsize) * indexofmainobjecty) * somemulsize1;
                                                        somechunkbytepositioninteger += (dirInstanceUp * (someglobalschunkmesh.numberOfObjectInHeight * someglobalschunkmesh.numberOfInstancesPerObjectInHeight * someglobalschunkmesh.tinyChunkHeight * somemulsize) * indexofmeshzeroy) * somemulsize1;
                                                        somechunkbytepositioninteger += (dirInstanceUp * (someglobalschunkmesh.numberOfInstancesPerObjectInHeight * someglobalschunkmesh.tinyChunkHeight * somemulsize) * indexofmeshinsty) * somemulsize1;
                                                        somechunkbytepositioninteger += (dirInstanceUp * (someglobalschunkmesh.tinyChunkHeight * somemulsize) * indexofbytey) * somemulsize1;
                                                        //somechunkbytepositioninteger += (dirInstanceUp * (someglobalschunkmesh.tinyChunkHeight * somemulsize) * indexofbytey * somemulsize1);

                                                        somechunkbytepositioninteger += (dirInstanceForward * (somechunkmeshsdepth * someglobalschunkmesh.numberOfObjectInDepth * someglobalschunkmesh.numberOfInstancesPerObjectInDepth * someglobalschunkmesh.tinyChunkDepth * somemulsize) * indexofmainobjectz) * somemulsize1;
                                                        somechunkbytepositioninteger += (dirInstanceForward * (someglobalschunkmesh.numberOfObjectInDepth * someglobalschunkmesh.numberOfInstancesPerObjectInDepth * someglobalschunkmesh.tinyChunkDepth * somemulsize) * indexofmeshzeroz) * somemulsize1;
                                                        somechunkbytepositioninteger += (dirInstanceForward * (someglobalschunkmesh.numberOfInstancesPerObjectInDepth * someglobalschunkmesh.tinyChunkDepth * somemulsize) * indexofmeshinstz) * somemulsize1;
                                                        somechunkbytepositioninteger += (dirInstanceForward * (someglobalschunkmesh.tinyChunkDepth * somemulsize) * indexofbytez) * somemulsize1;









                                                        //somechunkbyteposition += (dirInstanceForward * (someglobalschunkmesh.tinyChunkDepth * somemulsize) * indexofbytez) * somemulsize1;

                                                        //somechunkbyteposition *= 0.5f;

                                                        //somechunkbyteposition += (dirInstanceRight * indexofmainobjectx * planeSize) + (dirInstanceRight * indexofmainobjectx * planeSize)  + (dirInstanceRight * indexofmainobjectx * planeSize) + (dirInstanceRight * indexofmainobjectx * planeSize);

                                                        //somechunkbyteposition += (dirInstanceRight * indexofmainobjectx * indexofmeshzerox * indexofmeshinstx * indexofbytex * planeSize);
                                                        //somechunkbyteposition += (dirInstanceUp * indexofmainobjecty * indexofmeshzeroy * indexofmeshinsty * indexofbytey * planeSize);
                                                        //somechunkbyteposition += (dirInstanceForward * indexofmainobjectz  * indexofmeshzeroz * indexofmeshinstz * indexofbytez * planeSize);

                                                        //somechunkbyteposition








                                                        /*
                                                        //SET THE BYTE LOCATOR OBJECT TO THE LOCATION OF THE BYTE ON THE CHUNK IN ORDER TO HAVE A VISUAL ON WHERE THE BYTE LOCATOR IS IN CODE
                                                        //SET THE BYTE LOCATOR OBJECT TO THE LOCATION OF THE BYTE ON THE CHUNK IN ORDER TO HAVE A VISUAL ON WHERE THE BYTE LOCATOR IS IN CODE
                                                        //SET THE BYTE LOCATOR OBJECT TO THE LOCATION OF THE BYTE ON THE CHUNK IN ORDER TO HAVE A VISUAL ON WHERE THE BYTE LOCATOR IS IN CODE
                                                        worldMatrix_instances_voxel_cube[0][0][0].M41 = somechunkbyteposition.X + somechunkmesh[indexofmainobject].worldmatofobj.M41;
                                                        worldMatrix_instances_voxel_cube[0][0][0].M42 = somechunkbyteposition.Y + somechunkmesh[indexofmainobject].worldmatofobj.M42;
                                                        worldMatrix_instances_voxel_cube[0][0][0].M43 = somechunkbyteposition.Z + somechunkmesh[indexofmainobject].worldmatofobj.M43;
                                                        //SET THE BYTE LOCATOR OBJECT TO THE LOCATION OF THE BYTE ON THE CHUNK IN ORDER TO HAVE A VISUAL ON WHERE THE BYTE LOCATOR IS IN CODE
                                                        //SET THE BYTE LOCATOR OBJECT TO THE LOCATION OF THE BYTE ON THE CHUNK IN ORDER TO HAVE A VISUAL ON WHERE THE BYTE LOCATOR IS IN CODE
                                                        //SET THE BYTE LOCATOR OBJECT TO THE LOCATION OF THE BYTE ON THE CHUNK IN ORDER TO HAVE A VISUAL ON WHERE THE BYTE LOCATOR IS IN CODE

                                                        worldMatrix_instances_voxel_cube[0][0][0].M41 += someglobalschunkmesh.planeSize * 0.5f;
                                                        worldMatrix_instances_voxel_cube[0][0][0].M42 += someglobalschunkmesh.planeSize * 0.5f;
                                                        worldMatrix_instances_voxel_cube[0][0][0].M43 += someglobalschunkmesh.planeSize * 0.5f;
                                                        */



                                                        Vector3 positionofhitbyte = new Vector3(worldMatrix_instances_voxel_cube[0][0][0].M41, worldMatrix_instances_voxel_cube[0][0][0].M42, worldMatrix_instances_voxel_cube[0][0][0].M43);
                                                        //Vector3 positionofhitbyte = (somechunkbytepositioninteger * someglobalschunkmesh.planeSize) - new Vector3(somechunkmesh[indexofmainobject].worldmatofobj.M41, somechunkmesh[indexofmainobject].worldmatofobj.M42, somechunkmesh[indexofmainobject].worldmatofobj.M43);






                                                        //positionofhitbyte.X = (float)Math.Round(positionofhitbyte.X / someglobalschunkmesh.planeSize) * someglobalschunkmesh.planeSize;
                                                        //positionofhitbyte.Y = (float)Math.Round(positionofhitbyte.Y / someglobalschunkmesh.planeSize) * someglobalschunkmesh.planeSize;
                                                        //positionofhitbyte.Z = (float)Math.Round(positionofhitbyte.Z / someglobalschunkmesh.planeSize) * someglobalschunkmesh.planeSize;




                                                        //somechunkmesh[indexofmainobject].arrayofindexzeromesh[indexofmeshzero].somechunk[indexofmeshinst].somechunkpos.X
                                                        /*Matrix worldmatrixofvoxelobject0 = ikarmvoxel[3]._player_r_hand_grab[0][0]._arrayOfInstances[0].current_pos;
                                                        //somechunkmesh[indexofmainobject].arrayofindexzeromesh[indexofmeshzero].somechunk[indexofmeshinst].somechunkpos = 
                                                        //Vector3 somechunkbyteposition0 = new Vector3(worldmatrixofvoxelobject.M41, worldmatrixofvoxelobject.M42, worldmatrixofvoxelobject.M43);

                                                        Quaternion somedirquat0;
                                                        Quaternion.RotationMatrix(ref worldmatrixofvoxelobject0, out somedirquat0);

                                                        var dirInstanceRight0 = -sc_maths._newgetdirleft(somedirquat0);
                                                        var dirInstanceUp0 = sc_maths._newgetdirup(somedirquat0);
                                                        var dirInstanceForward0 = sc_maths._newgetdirforward(somedirquat0);


                                                        Vector3 pivotpositionpickaxeorigin = new Vector3(ikarmvoxel[3]._player_r_hand_grab[0][0]._arrayOfInstances[0]._ORIGINPOSITION.M41, ikarmvoxel[3]._player_r_hand_grab[0][0]._arrayOfInstances[0]._ORIGINPOSITION.M42, ikarmvoxel[3]._player_r_hand_grab[0][0]._arrayOfInstances[0]._ORIGINPOSITION.M43);
                                                        */
                                                        //temppickaxetiplocation = pivotpositionpickaxeorigin;// Vector3.Zero;
                                                        /*temppickaxetiplocation = temppickaxetiplocation + (dirInstanceRight0 * temppickaxetiplocation.X * ikarmvoxel[3].voxel_general_size);
                                                        temppickaxetiplocation = temppickaxetiplocation + (dirInstanceUp0 * temppickaxetiplocation.Y * ikarmvoxel[3].voxel_general_size);
                                                        temppickaxetiplocation = temppickaxetiplocation + (dirInstanceForward0 * temppickaxetiplocation.Z * ikarmvoxel[3].voxel_general_size);
                                                        */
                                                        //worldMatrix_instances_voxel_cube[0][0][0].M41 = temppickaxetiplocation.X + positionofhitbyte.X;// somechunkbyteposition.X + positionofhitbyte.X;
                                                        //worldMatrix_instances_voxel_cube[0][0][0].M42 = temppickaxetiplocation.Y + positionofhitbyte.Y;//somechunkbyteposition.Y + positionofhitbyte.Y;
                                                        //worldMatrix_instances_voxel_cube[0][0][0].M43 = temppickaxetiplocation.Z + positionofhitbyte.Z;//somechunkbyteposition.Z + positionofhitbyte.Z;



                                                        /*worldMatrix_instances_voxel_cube[0][0][0].M41 = (pivotpositionpickaxe.X + (temppickaxetiplocation.X));// somechunkbyteposition.X + positionofhitbyte.X;
                                                        worldMatrix_instances_voxel_cube[0][0][0].M42 = (pivotpositionpickaxe.Y + (-temppickaxetiplocation.Y));//somechunkbyteposition.Y + positionofhitbyte.Y;
                                                        worldMatrix_instances_voxel_cube[0][0][0].M43 = (pivotpositionpickaxe.Z + (temppickaxetiplocation.Z));//somechunkbyteposition.Z + positionofhitbyte.Z;
                                                        */


                                                        //worldMatrix_instances_voxel_cube[0][0][0].M41 = positionofhitbyte.X;// somechunkbyteposition.X + positionofhitbyte.X;
                                                        //worldMatrix_instances_voxel_cube[0][0][0].M42 = positionofhitbyte.Y;//somechunkbyteposition.Y + positionofhitbyte.Y;
                                                        //worldMatrix_instances_voxel_cube[0][0][0].M43 = positionofhitbyte.Z;//somechunkbyteposition.Z + positionofhitbyte.Z;


                                                        /*worldMatrix_instances_voxel_cube[0][0][0].M41 = (pivotpositionpickaxe.X + (temppickaxetiplocation.X * 0.01f));// somechunkbyteposition.X + positionofhitbyte.X;
                                                        worldMatrix_instances_voxel_cube[0][0][0].M42 = (pivotpositionpickaxe.Y + (temppickaxetiplocation.Y * 0.01f));//somechunkbyteposition.Y + positionofhitbyte.Y;
                                                        worldMatrix_instances_voxel_cube[0][0][0].M43 = (pivotpositionpickaxe.Z + (temppickaxetiplocation.Z * 0.01f));//somechunkbyteposition.Z + positionofhitbyte.Z;
                                                        */









                                                        /*if (y >= -chunkheightl && y < -chunkheightl + maxy) // 0.35f // distance < ((ChunkHeight_R) * maxDistance) && 
                                                        {
                                                            if (_index >= 0 && _index < _max)
                                                            {
                                                                map[_index] = 1;
                                                            }
                                                        }*/




                                                        //pickaxetippoint.X *= someglobalschunkmesh.planeSize;
                                                        //pickaxetippoint.Y *= someglobalschunkmesh.planeSize;
                                                        //pickaxetippoint.Z *= someglobalschunkmesh.planeSize;


                                                        //Vector3 somemainobjmeshpos = new Vector3(somevoxelvirtualdesktop[0].worldmatofobj.M41, somevoxelvirtualdesktop[0].worldmatofobj.M42, somevoxelvirtualdesktop[0].worldmatofobj.M43);


                                                        if (consolewritecounter >= consolewritecountermax)
                                                        {
                                                            if (consolewritecounterswtc == 0)
                                                            {

                                                                consolewritecounterswtc = 1;
                                                            }

                                                            /*for (int sc = 0; sc < 30; sc++) //Console.WindowWidth - 1
                                                            {
                                                                Console.SetCursorPosition(sc, 0);
                                                                Console.WriteLine(" ");
                                                                //Console.SetCursorPosition(sc, 1);
                                                                //Console.WriteLine(" ");
                                                                //Console.SetCursorPosition(sc, 1);
                                                                //Console.WriteLine(" ");
                                                                //Console.SetCursorPosition(sc, 3);
                                                                //Console.WriteLine(" ");
                                                                //Console.SetCursorPosition(sc, 4);
                                                                //Console.WriteLine(" ");
                                                            }*/

                                                            //Console.SetCursorPosition(0, 0);
                                                            //Console.WriteLine("x:" + +mainx + "/y:" + mainy + "/z:" + mainz);

                                                            //Console.SetCursorPosition(0, 1);
                                                            //Console.WriteLine("secx:" + +secx + "/secy:" + secy + "/secz:" + secz);

                                                            //Console.SetCursorPosition(0, 0);
                                                            //Console.WriteLine("somefx:" + +somefx + "/somefy:" + somefy + "/somefz:" + somefz);

                                                            //Console.SetCursorPosition(0, 0);
                                                            //Console.WriteLine("fobjmeshx:" + +fobjmeshx + "/fobjmeshy:" + fobjmeshy + "/fobjmeshz:" + fobjmeshz);

                                                            //Console.Title = "fobjmeshx:" + +fobjmeshx + "/fobjmeshy:" + fobjmeshy + "/fobjmeshz:" + fobjmeshz;
                                                            //Console.Title = "fobjmeshx:" + +fobjmeshx + "/fobjmeshy:" + fobjmeshy + "/fobjmeshz:" + fobjmeshz;
                                                            //Console.Title = "finstx:" + +finstx + "/finsty:" + finsty + "/finstz:" + finstz;
                                                            //Console.Title = "mainx:" + mainx + "/mainy:" + mainy + "/mainz:" + mainz;
                                                            //Console.Title = "someothermainx:" + someothermainx + "/someothermainy:" + someothermainy + "/someothermainz:" + someothermainz + "/fobjmeshx:" + +fobjmeshx + "/fobjmeshy:" + fobjmeshy + "/fobjmeshz:" + fobjmeshz;
                                                            //Console.Title = "/someothermainx:" + someothermainx + "/someothermainy:" + someothermainy + "/someothermainz:" + someothermainz +"/fobjmeshmainx:" + fobjmeshmainx + "/fobjmeshmainy:" + fobjmeshmainy + "/fobjmeshmainz:" + fobjmeshmainz + "/fobjmeshx:" + +fobjmeshx + "/fobjmeshy:" + fobjmeshy + "/fobjmeshz:" + fobjmeshz;

                                                            //Console.Title = "someinstx:" + (int)someinstx + "/someinsty:" + (int)someinsty + "/someinstz:" + (int)someinstz;

                                                            //Console.Title = "somefx:" + +somefx + "/somefy:" + somefy + "/somefz:" + somefz;


                                                            /*int indexbytex = remainderbytesx;
                                                            int indexbytey = remainderbytesy;
                                                            int indexbytez = remainderbytesz;
                                                            int indexofbyte = (indexbytex) + (someglobalschunkmesh.tinyChunkWidth) * ((indexbytey) + (someglobalschunkmesh.tinyChunkHeight) * (indexbytez));

                                                            int indexmeshinstx = remaindermeshinstx;
                                                            int indexmeshinsty = remaindermeshinsty;
                                                            int indexmeshinstz = remaindermeshinstz;
                                                            int indexofmeshinst = (indexmeshinstx) + (someglobalschunkmesh.numberOfInstancesPerObjectInWidth) * ((indexmeshinsty) + (someglobalschunkmesh.numberOfInstancesPerObjectInHeight) * (indexmeshinstz));

                                                            int indexmeshzerox = remaindermeshinstx;
                                                            int indexmeshzeroy = remaindermeshinsty;
                                                            int indexmeshzeroz = remaindermeshinstz;
                                                            int indexofmeshzero = (indexmeshzerox) + (someglobalschunkmesh.numberOfObjectInWidth) * ((indexmeshzeroy) + (someglobalschunkmesh.numberOfObjectInHeight) * (indexmeshzeroz));

                                                            int indexmainobjectx = remaindermeshinstx;
                                                            int indexmainobjecty = remaindermeshinsty;
                                                            int indexmainobjectz = remaindermeshinstz;
                                                            int indexofmainobject = (indexmainobjectx) + (somechunkmeshswidth) * ((indexmainobjecty) + (somechunkmeshsheight) * (indexmainobjectz));*/

                                                            //Console.Title = "indexbytex:" + (int)indexbytex + "/indexbytey:" + (int)indexbytey + "/indexbytez:" + (int)indexbytez;
                                                            //Console.Title = "indexofmeshinstx:" + (int)indexofmeshinstx + "/indexofmeshinsty:" + (int)indexofmeshinsty + "/indexofmeshinstz:" + (int)indexofmeshinstz;



                                                            //Console.Title = "/bx:" + positionofhitbyte.X + "/by:" + positionofhitbyte.Y + "/bz:" + positionofhitbyte.Z + "/px:" + tempvecpickaxehitpoint.X + "/py:" + tempvecpickaxehitpoint.Y + "/pz:" + tempvecpickaxehitpoint.Z;


                                                            //Console.Title = "/indexmeshzerox:" + (int)indexmeshzerox + "/indexmeshzeroy:" + (int)indexmeshzeroy + "/indexmeshzeroz:" + (int)indexmeshzeroz;


                                                            consolewritecounter = 0;
                                                        }
                                                        consolewritecounter++;






                                                        float someflooredvaluebytex = positionofhitbyte.X;// (float)(Math.Floor(positionofhitbyte.X / someglobalschunkmesh.planeSize) * someglobalschunkmesh.planeSize);
                                                        float someflooredvaluebytey = positionofhitbyte.Y;// (float)(Math.Floor(positionofhitbyte.Y / someglobalschunkmesh.planeSize) * someglobalschunkmesh.planeSize);
                                                        float someflooredvaluebytez = positionofhitbyte.Z;// (float)(Math.Floor(positionofhitbyte.Z / someglobalschunkmesh.planeSize) * someglobalschunkmesh.planeSize);




                                                        //float locationbytex = worldmatrixofvoxelobject.M41 + (dirInstanceRight * indexofmainobject) + 

                                                        //SECTION FOR 3D BYTE LOCATION WHEN AN INSTANCED BREAKABLE VOXEL OBJECT IS ROTATED
                                                        //SECTION FOR 3D BYTE LOCATION WHEN AN INSTANCED BREAKABLE VOXEL OBJECT IS ROTATED
                                                        //SECTION FOR 3D BYTE LOCATION WHEN AN INSTANCED BREAKABLE VOXEL OBJECT IS ROTATED


                                                        int somebyte = somechunkmesh[indexofmainobject].arrayofindexzeromesh[indexofmeshzero].somechunk[indexofmeshinst].GetByte(indexofbytex, indexofbytey, indexofbytez);
                                                        //&& Math.Round(tempPoint.X / someglobalschunkmesh.planeSize) == someflooredvaluebytex && Math.Round(tempPoint.Y / someglobalschunkmesh.planeSize) == someflooredvaluebytey && Math.Round(tempPoint.Z / someglobalschunkmesh.planeSize) == someflooredvaluebytez

                                                        if (somebyte == 1) // 1
                                                        {
                                                            //MainWindow.MessageBox((IntPtr)0, "/map:" + currentMapData + "/currentByteother:" + currentByteother + "/double_result:" + double_result, "sccs message 1", 0);
                                                            //MainWindow.MessageBox((IntPtr)0, "/map:" + currentMapData + "/someotherbyte:" + arrayOfDigits[someOtherIndex] + "/arrayOfDigits[someotherindex1]:" + arrayOfDigits[someotherindex1] + "/double_result:" + double_result, "sccs message 1", 0);
                                                            // MainWindow.MessageBox((IntPtr)0, "trying to break byte " + "/map4:" + currentMapData + "/bufferbyte:" + currentByte + "/classmemorybyte:" + somebyte + " ", "sccs message 1", 0);
                                                            int voxelchunkinvertoption = MainWindow.usetypeofvoxel;

                                                            //resetvoxelladdercounter

                                                            somechunkmesh[indexofmainobject].arrayofindexzeromesh[indexofmeshzero].somechunk[indexofmeshinst].SetByte(indexofbytex, indexofbytey, indexofbytez, 0, Vector3.Zero);

                                                            somechunkmesh[indexofmainobject].arrayofindexzeromesh[indexofmeshzero].somechunk[indexofmeshinst].setnewmap(out m11, out m12, out m13, out m14, out m21, out m22, out m23, out m24, out m31, out m32, out m33, out m34, out m41, out m42, out m43, out m44, chosenmap, voxelchunkinvertoption
                                                                , out m11b, out m12b, out m13b, out m14b, out m21b, out m22b, out m23b, out m24b, out m31b, out m32b, out m33b, out m34b, out m41b, out m42b, out m43b, out m44b,
                            out m11c, out m12c, out m13c, out m14c, out m21c, out m22c, out m23c, out m24c, out m31c, out m32c, out m33c, out m34c, out m41c, out m42c, out m43c, out m44c,
                            out m11d, out m12d, out m13d, out m14d, out m21d, out m22d, out m23d, out m24d, out m31d, out m32d, out m33d, out m34d, out m41d, out m42d, out m43d, out m44d); //

                                                            /*somechunkmesh[indexofmainobject].arrayofindexzeromesh[indexofmeshzero].instancesmatrix[indexofmeshinst].instancematrix.M11 = (float)m11;
                                                            somechunkmesh[indexofmainobject].arrayofindexzeromesh[indexofmeshzero].instancesmatrix[indexofmeshinst].instancematrix.M12 = (float)m12;
                                                            somechunkmesh[indexofmainobject].arrayofindexzeromesh[indexofmeshzero].instancesmatrix[indexofmeshinst].instancematrix.M13 = (float)m13;
                                                            somechunkmesh[indexofmainobject].arrayofindexzeromesh[indexofmeshzero].instancesmatrix[indexofmeshinst].instancematrix.M14 = (float)m14;

                                                            somechunkmesh[indexofmainobject].arrayofindexzeromesh[indexofmeshzero].instancesmatrix[indexofmeshinst].instancematrix.M21 = (float)m21;
                                                            somechunkmesh[indexofmainobject].arrayofindexzeromesh[indexofmeshzero].instancesmatrix[indexofmeshinst].instancematrix.M22 = (float)m22;
                                                            somechunkmesh[indexofmainobject].arrayofindexzeromesh[indexofmeshzero].instancesmatrix[indexofmeshinst].instancematrix.M23 = (float)m23;
                                                            somechunkmesh[indexofmainobject].arrayofindexzeromesh[indexofmeshzero].instancesmatrix[indexofmeshinst].instancematrix.M24 = (float)m24;

                                                            somechunkmesh[indexofmainobject].arrayofindexzeromesh[indexofmeshzero].instancesmatrix[indexofmeshinst].instancematrix.M31 = (float)m31;
                                                            somechunkmesh[indexofmainobject].arrayofindexzeromesh[indexofmeshzero].instancesmatrix[indexofmeshinst].instancematrix.M32 = (float)m32;
                                                            somechunkmesh[indexofmainobject].arrayofindexzeromesh[indexofmeshzero].instancesmatrix[indexofmeshinst].instancematrix.M33 = (float)m33;
                                                            somechunkmesh[indexofmainobject].arrayofindexzeromesh[indexofmeshzero].instancesmatrix[indexofmeshinst].instancematrix.M34 = (float)m34;

                                                            somechunkmesh[indexofmainobject].arrayofindexzeromesh[indexofmeshzero].instancesmatrix[indexofmeshinst].instancematrix.M41 = (float)m41;
                                                            somechunkmesh[indexofmainobject].arrayofindexzeromesh[indexofmeshzero].instancesmatrix[indexofmeshinst].instancematrix.M42 = (float)m42;
                                                            somechunkmesh[indexofmainobject].arrayofindexzeromesh[indexofmeshzero].instancesmatrix[indexofmeshinst].instancematrix.M43 = (float)m43;
                                                            somechunkmesh[indexofmainobject].arrayofindexzeromesh[indexofmeshzero].instancesmatrix[indexofmeshinst].instancematrix.M44 = (float)m44;
                                                            */

                                                            if (currentIndex >= 0 && currentIndex <= 63)
                                                            {
                                                                if (currentIndex >= 0 && currentIndex <= 3)
                                                                {
                                                                    somechunkmesh[indexofmainobject].arrayofindexzeromesh[indexofmeshzero].instancesmatrix[indexofmeshinst].instancematrix.M11 = (float)m11;
                                                                }
                                                                else if (currentIndex >= 4 && currentIndex <= 7)
                                                                {
                                                                    somechunkmesh[indexofmainobject].arrayofindexzeromesh[indexofmeshzero].instancesmatrix[indexofmeshinst].instancematrix.M12 = (float)m12;
                                                                }
                                                                else if (currentIndex >= 8 && currentIndex <= 11)
                                                                {
                                                                    somechunkmesh[indexofmainobject].arrayofindexzeromesh[indexofmeshzero].instancesmatrix[indexofmeshinst].instancematrix.M13 = (float)m13;
                                                                }
                                                                else if (currentIndex >= 12 && currentIndex <= 15)
                                                                {
                                                                    somechunkmesh[indexofmainobject].arrayofindexzeromesh[indexofmeshzero].instancesmatrix[indexofmeshinst].instancematrix.M14 = (float)m14;
                                                                }
                                                                else if (currentIndex >= 16 && currentIndex <= 19)
                                                                {
                                                                    somechunkmesh[indexofmainobject].arrayofindexzeromesh[indexofmeshzero].instancesmatrix[indexofmeshinst].instancematrix.M21 = (float)m21;
                                                                }
                                                                else if (currentIndex >= 20 && currentIndex <= 23)
                                                                {
                                                                    somechunkmesh[indexofmainobject].arrayofindexzeromesh[indexofmeshzero].instancesmatrix[indexofmeshinst].instancematrix.M22 = (float)m22;
                                                                }
                                                                else if (currentIndex >= 24 && currentIndex <= 27)
                                                                {
                                                                    somechunkmesh[indexofmainobject].arrayofindexzeromesh[indexofmeshzero].instancesmatrix[indexofmeshinst].instancematrix.M23 = (float)m23;
                                                                }
                                                                else if (currentIndex >= 28 && currentIndex <= 31)
                                                                {
                                                                    somechunkmesh[indexofmainobject].arrayofindexzeromesh[indexofmeshzero].instancesmatrix[indexofmeshinst].instancematrix.M24 = (float)m24;
                                                                }
                                                                else if (currentIndex >= 32 && currentIndex <= 35)
                                                                {
                                                                    somechunkmesh[indexofmainobject].arrayofindexzeromesh[indexofmeshzero].instancesmatrix[indexofmeshinst].instancematrix.M31 = (float)m31;
                                                                }
                                                                else if (currentIndex >= 36 && currentIndex <= 39)
                                                                {
                                                                    somechunkmesh[indexofmainobject].arrayofindexzeromesh[indexofmeshzero].instancesmatrix[indexofmeshinst].instancematrix.M32 = (float)m32;
                                                                }
                                                                else if (currentIndex >= 40 && currentIndex <= 43)
                                                                {
                                                                    somechunkmesh[indexofmainobject].arrayofindexzeromesh[indexofmeshzero].instancesmatrix[indexofmeshinst].instancematrix.M33 = (float)m33;
                                                                }
                                                                else if (currentIndex >= 44 && currentIndex <= 47)
                                                                {
                                                                    somechunkmesh[indexofmainobject].arrayofindexzeromesh[indexofmeshzero].instancesmatrix[indexofmeshinst].instancematrix.M34 = (float)m34;
                                                                }
                                                                else if (currentIndex >= 48 && currentIndex <= 51)
                                                                {
                                                                    somechunkmesh[indexofmainobject].arrayofindexzeromesh[indexofmeshzero].instancesmatrix[indexofmeshinst].instancematrix.M41 = (float)m41;
                                                                }
                                                                else if (currentIndex >= 52 && currentIndex <= 55)
                                                                {
                                                                    somechunkmesh[indexofmainobject].arrayofindexzeromesh[indexofmeshzero].instancesmatrix[indexofmeshinst].instancematrix.M42 = (float)m42;
                                                                }
                                                                else if (currentIndex >= 56 && currentIndex <= 59)
                                                                {
                                                                    somechunkmesh[indexofmainobject].arrayofindexzeromesh[indexofmeshzero].instancesmatrix[indexofmeshinst].instancematrix.M43 = (float)m43;
                                                                }
                                                                else if (currentIndex >= 60 && currentIndex <= 63)
                                                                {
                                                                    somechunkmesh[indexofmainobject].arrayofindexzeromesh[indexofmeshzero].instancesmatrix[indexofmeshinst].instancematrix.M44 = (float)m44;
                                                                }
                                                            }
                                                        }
                                                        else
                                                        {
                                                            if (MainWindow.usetypeofvoxel == 3)
                                                            {
                                                                int voxelchunkinvertoption = MainWindow.usetypeofvoxel;

                                                                somechunkmesh[indexofmainobject].arrayofindexzeromesh[indexofmeshzero].somechunk[indexofmeshinst].SetByte(indexofbytex, indexofbytey, indexofbytez, 1, Vector3.Zero);

                                                                somechunkmesh[indexofmainobject].arrayofindexzeromesh[indexofmeshzero].somechunk[indexofmeshinst].setnewmap(out m11, out m12, out m13, out m14, out m21, out m22, out m23, out m24, out m31, out m32, out m33, out m34, out m41, out m42, out m43, out m44, chosenmap, voxelchunkinvertoption
                                                                    , out m11b, out m12b, out m13b, out m14b, out m21b, out m22b, out m23b, out m24b, out m31b, out m32b, out m33b, out m34b, out m41b, out m42b, out m43b, out m44b,
                                                                        out m11c, out m12c, out m13c, out m14c, out m21c, out m22c, out m23c, out m24c, out m31c, out m32c, out m33c, out m34c, out m41c, out m42c, out m43c, out m44c,
                                                                        out m11d, out m12d, out m13d, out m14d, out m21d, out m22d, out m23d, out m24d, out m31d, out m32d, out m33d, out m34d, out m41d, out m42d, out m43d, out m44d); //

                                                                if (currentIndex >= 0 && currentIndex <= 63)
                                                                {
                                                                    if (currentIndex >= 0 && currentIndex <= 3)
                                                                    {
                                                                        somechunkmesh[indexofmainobject].arrayofindexzeromesh[indexofmeshzero].instancesmatrix[indexofmeshinst].instancematrix.M11 = (float)m11;
                                                                    }
                                                                    else if (currentIndex >= 4 && currentIndex <= 7)
                                                                    {
                                                                        somechunkmesh[indexofmainobject].arrayofindexzeromesh[indexofmeshzero].instancesmatrix[indexofmeshinst].instancematrix.M12 = (float)m12;
                                                                    }
                                                                    else if (currentIndex >= 8 && currentIndex <= 11)
                                                                    {
                                                                        somechunkmesh[indexofmainobject].arrayofindexzeromesh[indexofmeshzero].instancesmatrix[indexofmeshinst].instancematrix.M13 = (float)m13;
                                                                    }
                                                                    else if (currentIndex >= 12 && currentIndex <= 15)
                                                                    {
                                                                        somechunkmesh[indexofmainobject].arrayofindexzeromesh[indexofmeshzero].instancesmatrix[indexofmeshinst].instancematrix.M14 = (float)m14;
                                                                    }
                                                                    else if (currentIndex >= 16 && currentIndex <= 19)
                                                                    {
                                                                        somechunkmesh[indexofmainobject].arrayofindexzeromesh[indexofmeshzero].instancesmatrix[indexofmeshinst].instancematrix.M21 = (float)m21;
                                                                    }
                                                                    else if (currentIndex >= 20 && currentIndex <= 23)
                                                                    {
                                                                        somechunkmesh[indexofmainobject].arrayofindexzeromesh[indexofmeshzero].instancesmatrix[indexofmeshinst].instancematrix.M22 = (float)m22;
                                                                    }
                                                                    else if (currentIndex >= 24 && currentIndex <= 27)
                                                                    {
                                                                        somechunkmesh[indexofmainobject].arrayofindexzeromesh[indexofmeshzero].instancesmatrix[indexofmeshinst].instancematrix.M23 = (float)m23;
                                                                    }
                                                                    else if (currentIndex >= 28 && currentIndex <= 31)
                                                                    {
                                                                        somechunkmesh[indexofmainobject].arrayofindexzeromesh[indexofmeshzero].instancesmatrix[indexofmeshinst].instancematrix.M24 = (float)m24;
                                                                    }
                                                                    else if (currentIndex >= 32 && currentIndex <= 35)
                                                                    {
                                                                        somechunkmesh[indexofmainobject].arrayofindexzeromesh[indexofmeshzero].instancesmatrix[indexofmeshinst].instancematrix.M31 = (float)m31;
                                                                    }
                                                                    else if (currentIndex >= 36 && currentIndex <= 39)
                                                                    {
                                                                        somechunkmesh[indexofmainobject].arrayofindexzeromesh[indexofmeshzero].instancesmatrix[indexofmeshinst].instancematrix.M32 = (float)m32;
                                                                    }
                                                                    else if (currentIndex >= 40 && currentIndex <= 43)
                                                                    {
                                                                        somechunkmesh[indexofmainobject].arrayofindexzeromesh[indexofmeshzero].instancesmatrix[indexofmeshinst].instancematrix.M33 = (float)m33;
                                                                    }
                                                                    else if (currentIndex >= 44 && currentIndex <= 47)
                                                                    {
                                                                        somechunkmesh[indexofmainobject].arrayofindexzeromesh[indexofmeshzero].instancesmatrix[indexofmeshinst].instancematrix.M34 = (float)m34;
                                                                    }
                                                                    else if (currentIndex >= 48 && currentIndex <= 51)
                                                                    {
                                                                        somechunkmesh[indexofmainobject].arrayofindexzeromesh[indexofmeshzero].instancesmatrix[indexofmeshinst].instancematrix.M41 = (float)m41;
                                                                    }
                                                                    else if (currentIndex >= 52 && currentIndex <= 55)
                                                                    {
                                                                        somechunkmesh[indexofmainobject].arrayofindexzeromesh[indexofmeshzero].instancesmatrix[indexofmeshinst].instancematrix.M42 = (float)m42;
                                                                    }
                                                                    else if (currentIndex >= 56 && currentIndex <= 59)
                                                                    {
                                                                        somechunkmesh[indexofmainobject].arrayofindexzeromesh[indexofmeshzero].instancesmatrix[indexofmeshinst].instancematrix.M43 = (float)m43;
                                                                    }
                                                                    else if (currentIndex >= 60 && currentIndex <= 63)
                                                                    {
                                                                        somechunkmesh[indexofmainobject].arrayofindexzeromesh[indexofmeshzero].instancesmatrix[indexofmeshinst].instancematrix.M44 = (float)m44;
                                                                    }
                                                                }
                                                            }
                                                        }
                                                    }
                                                }
                                            }
                                        }
                                    }
                                }

                            }
                        }
                    }
                }



















                //CONSOLE DEBUG
                //CONSOLE DEBUG
                //CONSOLE DEBUG
                /*
                if (consolewritecounter >= consolewritecountermax)
                {
                    if (consolewritecounterswtc == 0)
                    {

                        consolewritecounterswtc = 1;
                    }

                    /*for (int sc = 0; sc < 30; sc++) //Console.WindowWidth - 1
                    {
                        Console.SetCursorPosition(sc, 0);
                        Console.WriteLine(" ");
                        //Console.SetCursorPosition(sc, 1);
                        //Console.WriteLine(" ");
                        //Console.SetCursorPosition(sc, 1);
                        //Console.WriteLine(" ");
                        //Console.SetCursorPosition(sc, 3);
                        //Console.WriteLine(" ");
                        //Console.SetCursorPosition(sc, 4);
                        //Console.WriteLine(" ");
                    }

                    //Console.SetCursorPosition(0, 0);
                    //Console.WriteLine("x:" + +mainx + "/y:" + mainy + "/z:" + mainz);

                    //Console.SetCursorPosition(0, 1);
                    //Console.WriteLine("secx:" + +secx + "/secy:" + secy + "/secz:" + secz);

                    //Console.SetCursorPosition(0, 0);
                    //Console.WriteLine("somefx:" + +somefx + "/somefy:" + somefy + "/somefz:" + somefz);

                    //Console.SetCursorPosition(0, 0);
                    //Console.WriteLine("fobjmeshx:" + +fobjmeshx + "/fobjmeshy:" + fobjmeshy + "/fobjmeshz:" + fobjmeshz);

                    //Console.Title = "fobjmeshx:" + +fobjmeshx + "/fobjmeshy:" + fobjmeshy + "/fobjmeshz:" + fobjmeshz;
                    //Console.Title = "fobjmeshx:" + +fobjmeshx + "/fobjmeshy:" + fobjmeshy + "/fobjmeshz:" + fobjmeshz;
                    //Console.Title = "finstx:" + +finstx + "/finsty:" + finsty + "/finstz:" + finstz;
                    //Console.Title = "mainx:" + mainx + "/mainy:" + mainy + "/mainz:" + mainz;
                    //Console.Title = "someothermainx:" + someothermainx + "/someothermainy:" + someothermainy + "/someothermainz:" + someothermainz + "/fobjmeshx:" + +fobjmeshx + "/fobjmeshy:" + fobjmeshy + "/fobjmeshz:" + fobjmeshz;
                    //Console.Title = "/someothermainx:" + someothermainx + "/someothermainy:" + someothermainy + "/someothermainz:" + someothermainz +"/fobjmeshmainx:" + fobjmeshmainx + "/fobjmeshmainy:" + fobjmeshmainy + "/fobjmeshmainz:" + fobjmeshmainz + "/fobjmeshx:" + +fobjmeshx + "/fobjmeshy:" + fobjmeshy + "/fobjmeshz:" + fobjmeshz;

                    //Console.Title = "someinstx:" + (int)someinstx + "/someinsty:" + (int)someinsty + "/someinstz:" + (int)someinstz;

                    //Console.Title = "somefx:" + +somefx + "/somefy:" + somefy + "/somefz:" + somefz;


                    /*int indexbytex = remainderbytesx;
                    int indexbytey = remainderbytesy;
                    int indexbytez = remainderbytesz;
                    int indexofbyte = (indexbytex) + (someglobalschunkmesh.tinyChunkWidth) * ((indexbytey) + (someglobalschunkmesh.tinyChunkHeight) * (indexbytez));

                    int indexmeshinstx = remaindermeshinstx;
                    int indexmeshinsty = remaindermeshinsty;
                    int indexmeshinstz = remaindermeshinstz;
                    int indexofmeshinst = (indexmeshinstx) + (someglobalschunkmesh.numberOfInstancesPerObjectInWidth) * ((indexmeshinsty) + (someglobalschunkmesh.numberOfInstancesPerObjectInHeight) * (indexmeshinstz));

                    int indexmeshzerox = remaindermeshinstx;
                    int indexmeshzeroy = remaindermeshinsty;
                    int indexmeshzeroz = remaindermeshinstz;
                    int indexofmeshzero = (indexmeshzerox) + (someglobalschunkmesh.numberOfObjectInWidth) * ((indexmeshzeroy) + (someglobalschunkmesh.numberOfObjectInHeight) * (indexmeshzeroz));

                    int indexmainobjectx = remaindermeshinstx;
                    int indexmainobjecty = remaindermeshinsty;
                    int indexmainobjectz = remaindermeshinstz;
                    int indexofmainobject = (indexmainobjectx) + (somechunkmeshswidth) * ((indexmainobjecty) + (somechunkmeshsheight) * (indexmainobjectz));

                    //Console.Title = "indexbytex:" + (int)indexbytex + "/indexbytey:" + (int)indexbytey + "/indexbytez:" + (int)indexbytez;
                    //Console.Title = "indexofmeshinstx:" + (int)indexofmeshinstx + "/indexofmeshinsty:" + (int)indexofmeshinsty + "/indexofmeshinstz:" + (int)indexofmeshinstz;


                    Console.Title = "/indexmeshzerox:" + (int)indexmeshzerox + "/indexmeshzeroy:" + (int)indexmeshzeroy + "/indexmeshzeroz:" + (int)indexmeshzeroz + "/indexofmeshinstx:" + (int)indexofmeshinstx + "/indexofmeshinsty:" + (int)indexofmeshinsty + "/indexofmeshinstz:" + (int)indexofmeshinstz;


                    //Console.Title = "/indexmeshzerox:" + (int)indexmeshzerox + "/indexmeshzeroy:" + (int)indexmeshzeroy + "/indexmeshzeroz:" + (int)indexmeshzeroz;


                    consolewritecounter = 0;
                }
                consolewritecounter++;*/






























                /*
                float planeSize = someglobalschunkmesh.planeSize;
                realplanetwidth = 4;
                float fractionOf = realplanetwidth / planeSize;
                int mainx = (int)Math.Floor(((SC_Update._rightTouchMatrix.M41 / planeSize)) / fractionOf); //4.654321/0.2 = 23.271605 => 23.271605/fractionOf = floor(2.3f)
                int mainy = (int)Math.Floor(((SC_Update._rightTouchMatrix.M42 / planeSize)) / fractionOf); // tiny*big*area => 4*4*2 = 32 width of the set of voxel mesh.
                int mainz = (int)Math.Floor(((SC_Update._rightTouchMatrix.M43 / planeSize)) / fractionOf);

                planeSize = someglobalschunkmesh.planeSize;
                realplanetwidth = 4;
                fractionOf = planeSize / (someglobalschunkmesh.numberOfObjectInWidth * someglobalschunkmesh.numberOfInstancesPerObjectInWidth);
                int secx = (int)Math.Floor(((SC_Update._rightTouchMatrix.M41 / planeSize)) / fractionOf); //4.654321/0.2 = 23.271605 => 23.271605/fractionOf = floor(2.3f)
                int secy = (int)Math.Floor(((SC_Update._rightTouchMatrix.M42 / planeSize)) / fractionOf); // tiny*big*area => 4*4*2 = 32 width of the set of voxel mesh.
                int secz = (int)Math.Floor(((SC_Update._rightTouchMatrix.M43 / planeSize)) / fractionOf);



                int someobjmeshmax = someglobalschunkmesh.numberOfObjectInWidth;
                float someobjmeshmaxfrac = someglobalschunkmesh.numberOfObjectInWidth * planeSize;

                int somemaxx = someglobalschunkmesh.numberOfObjectInWidth * someglobalschunkmesh.numberOfInstancesPerObjectInWidth;
                float somefrac = (someglobalschunkmesh.numberOfObjectInWidth * someglobalschunkmesh.numberOfInstancesPerObjectInWidth) * planeSize;

                float somefx = (float)((int)Math.Floor(SC_Update._rightTouchMatrix.M41 / planeSize) * planeSize); // 
                float somefy = (float)((int)Math.Floor(SC_Update._rightTouchMatrix.M42 / planeSize) * planeSize); // 
                float somefz = (float)((int)Math.Floor(SC_Update._rightTouchMatrix.M43 / planeSize) * planeSize);

                somefx /= somefrac; // 1.5 / 1.6 = 0.9375
                somefy /= somefrac; // 3.5 / 1.6 = 2.1875
                somefz /= somefrac;

                somefx /= (float)(1.0f / (float)somemaxx); //0.9375 / (1/16)
                somefy /= (float)(1.0f / (float)somemaxx); //2.1875 // 35
                somefz /= (float)(1.0f / (float)somemaxx);

                int finstx = (int)somefx / someglobalschunkmesh.numberOfInstancesPerObjectInWidth;
                int finsty = (int)somefy / someglobalschunkmesh.numberOfInstancesPerObjectInWidth;
                int finstz = (int)somefz / someglobalschunkmesh.numberOfInstancesPerObjectInWidth;

                int fobjmeshx = (int)finstx / someglobalschunkmesh.numberOfObjectInWidth;
                int fobjmeshy = (int)finsty / someglobalschunkmesh.numberOfObjectInWidth;
                int fobjmeshz = (int)finstz / someglobalschunkmesh.numberOfObjectInWidth;

                fobjmeshx = (int)finstx / someglobalschunkmesh.numberOfInstancesPerObjectInWidth;
                fobjmeshy = (int)finsty / someglobalschunkmesh.numberOfInstancesPerObjectInWidth;
                fobjmeshz = (int)finstz / someglobalschunkmesh.numberOfInstancesPerObjectInWidth;

                int indexofmainobjectmeshinstance = (mainx) + (somechunkmeshswidth) * ((mainy) + (somechunkmeshswidth) * (mainz));
                int indexofsecobjectmeshinstance = ((int)fobjmeshx) + (someglobalschunkmesh.numberOfObjectInWidth) * (((int)fobjmeshy) + (someglobalschunkmesh.numberOfObjectInWidth) * ((int)fobjmeshz));
                int indexoftierobjectinstance = (finstx) + (someglobalschunkmesh.numberOfInstancesPerObjectInWidth) * ((finsty) + (someglobalschunkmesh.numberOfInstancesPerObjectInWidth) * (finstz));
                int indexofbyte = ((int)somefx) + (someglobalschunkmesh.tinyChunkWidth) * (((int)somefy) + (someglobalschunkmesh.tinyChunkWidth) * ((int)somefz));

                //indexofbyte /= someglobalschunkmesh.tinyChunkWidth;
                somefx = somefx % 4;
                somefy = somefy % 4;
                somefz = somefz % 4;*/





















                /*
                //CHUNK MESH BYTE BREAKING BUFFER MAP RESET
                //CHUNK MESH BYTE BREAKING BUFFER MAP RESET
                //CHUNK MESH BYTE BREAKING BUFFER MAP RESET
                somechunkresetcounter = 0;

                for (int xxxx = 0; xxxx < somechunkmeshswidth; xxxx++)
                {
                    for (int yyyy = 0; yyyy < somechunkmeshsheight; yyyy++)
                    {
                        for (int zzzz = 0; zzzz < somechunkmeshsdepth; zzzz++)
                        {
                            var someindexchunkkeyboardpriminstance = xxxx + somechunkmeshswidth * (yyyy + somechunkmeshsheight * zzzz);

                            for (int x = 0; x < someglobalschunkmesh.numberOfObjectInWidth; x++)
                            {
                                for (int y = 0; y < someglobalschunkmesh.numberOfObjectInHeight; y++)
                                {
                                    for (int z = 0; z < someglobalschunkmesh.numberOfObjectInDepth; z++)
                                    {
                                        int c = x + someglobalschunkmesh.numberOfObjectInWidth * (y + someglobalschunkmesh.numberOfObjectInHeight * z);

                                        if (somechunkmesh[someindexchunkkeyboardpriminstance].arrayOfChunkData[c].switchForRender == 1)
                                        {

                                        }
                                        else
                                        {
                                            for (int xx = 0; xx < someglobalschunkmesh.numberOfInstancesPerObjectInWidth; xx++)
                                            {
                                                for (int yy = 0; yy < someglobalschunkmesh.numberOfInstancesPerObjectInHeight; yy++)
                                                {
                                                    for (int zz = 0; zz < someglobalschunkmesh.numberOfInstancesPerObjectInDepth; zz++)
                                                    {
                                                        int cc = xx + someglobalschunkmesh.numberOfInstancesPerObjectInWidth * (yy + someglobalschunkmesh.numberOfInstancesPerObjectInHeight * zz);

                                                        if (sc_menu_scroller == 2 && somechunkresetcounter < somechunkmeshswidth * somechunkmeshsheight * somechunkmeshsdepth * someglobalschunkmesh.numberOfObjectInWidth * someglobalschunkmesh.numberOfObjectInHeight * someglobalschunkmesh.numberOfObjectInDepth * someglobalschunkmesh.numberOfInstancesPerObjectInWidth * someglobalschunkmesh.numberOfInstancesPerObjectInHeight * someglobalschunkmesh.numberOfInstancesPerObjectInDepth && resetvoxelladdercounter == 2) //somechunkmeshswidth * somechunkmeshsheight * somechunkmeshsdepth * someglobalschunkmesh.numberOfObjectInWidth * someglobalschunkmesh.numberOfObjectInHeight * someglobalschunkmesh.numberOfObjectInDepth * someglobalschunkmesh.numberOfInstancesPerObjectInWidth * someglobalschunkmesh.numberOfInstancesPerObjectInHeight * someglobalschunkmesh.numberOfInstancesPerObjectInDepth && 
                                                        {
                                                            //MainWindow.MessageBox((IntPtr)0, "menu option 3" , "sccs", 0);

                                                            int voxelchunkinvertoption = MainWindow.usetypeofvoxel;

                                                            somechunkmesh[someindexchunkkeyboardpriminstance].arrayofindexzeromesh[c].somechunk[cc].resetmap(out m11, out m12, out m13, out m14, out m21, out m22, out m23, out m24, out m31, out m32, out m33, out m34, out m41, out m42, out m43, out m44, -1, voxelchunkinvertoption);
                                                            //somechunkmesh[someindexchunkkeyboardpriminstance].arrayofindexzeromesh[c].somechunk[cc].setnewmap(out m11, out m12, out m13, out m14, out m21, out m22, out m23, out m24, out m31, out m32, out m33, out m34, out m41, out m42, out m43, out m44, -1, voxelchunkinvertoption); //

                                                            somechunkmesh[someindexchunkkeyboardpriminstance].arrayofindexzeromesh[c].instancesmatrix[cc].instancematrix.M11 = (float)m11;
                                                            somechunkmesh[someindexchunkkeyboardpriminstance].arrayofindexzeromesh[c].instancesmatrix[cc].instancematrix.M12 = (float)m12;
                                                            somechunkmesh[someindexchunkkeyboardpriminstance].arrayofindexzeromesh[c].instancesmatrix[cc].instancematrix.M13 = (float)m13;
                                                            somechunkmesh[someindexchunkkeyboardpriminstance].arrayofindexzeromesh[c].instancesmatrix[cc].instancematrix.M14 = (float)m14;

                                                            somechunkmesh[someindexchunkkeyboardpriminstance].arrayofindexzeromesh[c].instancesmatrix[cc].instancematrix.M21 = (float)m21;
                                                            somechunkmesh[someindexchunkkeyboardpriminstance].arrayofindexzeromesh[c].instancesmatrix[cc].instancematrix.M22 = (float)m22;
                                                            somechunkmesh[someindexchunkkeyboardpriminstance].arrayofindexzeromesh[c].instancesmatrix[cc].instancematrix.M23 = (float)m23;
                                                            somechunkmesh[someindexchunkkeyboardpriminstance].arrayofindexzeromesh[c].instancesmatrix[cc].instancematrix.M24 = (float)m24;

                                                            somechunkmesh[someindexchunkkeyboardpriminstance].arrayofindexzeromesh[c].instancesmatrix[cc].instancematrix.M31 = (float)m31;
                                                            somechunkmesh[someindexchunkkeyboardpriminstance].arrayofindexzeromesh[c].instancesmatrix[cc].instancematrix.M32 = (float)m32;
                                                            somechunkmesh[someindexchunkkeyboardpriminstance].arrayofindexzeromesh[c].instancesmatrix[cc].instancematrix.M33 = (float)m33;
                                                            somechunkmesh[someindexchunkkeyboardpriminstance].arrayofindexzeromesh[c].instancesmatrix[cc].instancematrix.M34 = (float)m34;

                                                            somechunkmesh[someindexchunkkeyboardpriminstance].arrayofindexzeromesh[c].instancesmatrix[cc].instancematrix.M41 = (float)m41;
                                                            somechunkmesh[someindexchunkkeyboardpriminstance].arrayofindexzeromesh[c].instancesmatrix[cc].instancematrix.M42 = (float)m42;
                                                            somechunkmesh[someindexchunkkeyboardpriminstance].arrayofindexzeromesh[c].instancesmatrix[cc].instancematrix.M43 = (float)m43;
                                                            somechunkmesh[someindexchunkkeyboardpriminstance].arrayofindexzeromesh[c].instancesmatrix[cc].instancematrix.M44 = (float)m44;

                                                            //somechunkmesh[someindexchunkkeyboardpriminstance].arrayOfChunkData[c].copytobuffer = 1;

                                                        }
                                                    }
                                                }
                                            }
                                        }
                                    }
                                }
                            }
                        }
                    }
                }
                somechunkresetcounter++;

                for (int xxxx = 0; xxxx < somechunkmeshswidth; xxxx++)
                {
                    for (int yyyy = 0; yyyy < somechunkmeshsheight; yyyy++)
                    {
                        for (int zzzz = 0; zzzz < somechunkmeshsdepth; zzzz++)
                        {
                            var someindexchunkkeyboardpriminstance = xxxx + somechunkmeshswidth * (yyyy + somechunkmeshsheight * zzzz);

                            for (int x = 0; x < someglobalschunkmesh.numberOfObjectInWidth; x++)
                            {
                                for (int y = 0; y < someglobalschunkmesh.numberOfObjectInHeight; y++)
                                {
                                    for (int z = 0; z < someglobalschunkmesh.numberOfObjectInDepth; z++)
                                    {
                                        int c = x + someglobalschunkmesh.numberOfObjectInWidth * (y + someglobalschunkmesh.numberOfObjectInHeight * z);

                                        if (somechunkmesh[someindexchunkkeyboardpriminstance].arrayOfChunkData[c].switchForRender == 1)
                                        {

                                        }
                                        else
                                        {
                                            for (int xx = 0; xx < someglobalschunkmesh.numberOfInstancesPerObjectInWidth; xx++)
                                            {
                                                for (int yy = 0; yy < someglobalschunkmesh.numberOfInstancesPerObjectInHeight; yy++)
                                                {
                                                    for (int zz = 0; zz < someglobalschunkmesh.numberOfInstancesPerObjectInDepth; zz++)
                                                    {
                                                        int cc = xx + someglobalschunkmesh.numberOfInstancesPerObjectInWidth * (yy + someglobalschunkmesh.numberOfInstancesPerObjectInHeight * zz);

                                                        if (sc_menu_scroller == 2 && somechunkresetcounter >= somechunkmeshswidth * somechunkmeshsheight * somechunkmeshsdepth * someglobalschunkmesh.numberOfObjectInWidth * someglobalschunkmesh.numberOfObjectInHeight * someglobalschunkmesh.numberOfObjectInDepth * someglobalschunkmesh.numberOfInstancesPerObjectInWidth * someglobalschunkmesh.numberOfInstancesPerObjectInHeight * someglobalschunkmesh.numberOfInstancesPerObjectInDepth && resetvoxelladdercounter == 2)
                                                        {
                                                            //MainWindow.MessageBox((IntPtr)0, "menu option 3" , "sccs", 0);

                                                            int voxelchunkinvertoption = MainWindow.usetypeofvoxel;

                                                            somechunkmesh[someindexchunkkeyboardpriminstance].arrayOfChunkData[c].copytobuffer = 1;

                                                            somechunkresetcounter = 0;
                                                        }
                                                    }
                                                }
                                            }
                                        }
                                    }
                                }
                            }
                        }
                    }
                }*/
                //CHUNK MESH BYTE BREAKING BUFFER MAP RESET
                //CHUNK MESH BYTE BREAKING BUFFER MAP RESET
                //CHUNK MESH BYTE BREAKING BUFFER MAP RESET






















                //resetvoxelladdercounter = 1;
                /*
                if (sc_menu_scroller == 3 && somecounterresetcounter >= somechunkmeshswidth * somechunkmeshsheight * somechunkmeshsdepth * someglobalschunkmesh.numberOfObjectInWidth * someglobalschunkmesh.numberOfObjectInHeight * someglobalschunkmesh.numberOfObjectInDepth * someglobalschunkmesh.numberOfInstancesPerObjectInWidth * someglobalschunkmesh.numberOfInstancesPerObjectInHeight * someglobalschunkmesh.numberOfInstancesPerObjectInDepth)
                {
                    //MainWindow.MessageBox((IntPtr)0, "resetted map", "sccs", 0);

                    somecounterresetcounter = 0;
                    resetvoxelladdercounter = 1;
                }*/








































                /*
                //VIRTUAL KEYBOARD VOXEL MESH BREAKING BUFFER MAP RESET
                //VIRTUAL KEYBOARD VOXEL MESH BREAKING BUFFER MAP RESET
                //VIRTUAL KEYBOARD VOXEL MESH BREAKING BUFFER MAP RESET
                for (int xxxx = 0; xxxx < somechunkkeyboardw; xxxx++)
                {
                    for (int yyyy = 0; yyyy < somechunkkeyboardh; yyyy++)
                    {
                        for (int zzzz = 0; zzzz < somechunkkeyboardd; zzzz++)
                        {
                            var voxelmainindex = xxxx + somechunkkeyboardw * (yyyy + somechunkkeyboardh * zzzz);

                            for (int x = 0; x < somechunkkeyboardglobals.numberOfObjectInWidth; x++)
                            {
                                for (int y = 0; y < somechunkkeyboardglobals.numberOfObjectInHeight; y++)
                                {
                                    for (int z = 0; z < somechunkkeyboardglobals.numberOfObjectInDepth; z++)
                                    {
                                        int c = x + somechunkkeyboardglobals.numberOfObjectInWidth * (y + somechunkkeyboardglobals.numberOfObjectInHeight * z);

                                        if (somechunkkeyboard[voxelmainindex].arrayOfChunkData[c].switchForRender == 1)
                                        {

                                        }
                                        else
                                        {
                                            for (int xx = 0; xx < somechunkkeyboardglobals.numberOfInstancesPerObjectInWidth; xx++)
                                            {
                                                for (int yy = 0; yy < somechunkkeyboardglobals.numberOfInstancesPerObjectInHeight; yy++)
                                                {
                                                    for (int zz = 0; zz < somechunkkeyboardglobals.numberOfInstancesPerObjectInDepth; zz++)
                                                    {
                                                        int cc = xx + somechunkkeyboardglobals.numberOfInstancesPerObjectInWidth * (yy + somechunkkeyboardglobals.numberOfInstancesPerObjectInHeight * zz);

                                                        if (sc_menu_scroller == 2 && somechunkplayerspatiallocationresetcounter < somechunkkeyboardw * somechunkkeyboardh * somechunkkeyboardd * somechunkkeyboardglobals.numberOfObjectInWidth * somechunkkeyboardglobals.numberOfObjectInHeight * somechunkkeyboardglobals.numberOfObjectInDepth * somechunkkeyboardglobals.numberOfInstancesPerObjectInWidth * somechunkkeyboardglobals.numberOfInstancesPerObjectInHeight * somechunkkeyboardglobals.numberOfInstancesPerObjectInDepth && resetvoxelladdercounter == 2)
                                                        {
                                                            //MainWindow.MessageBox((IntPtr)0, "menu option 3" , "sccs", 0);

                                                            int voxelchunkinvertoption = MainWindow.usetypeofvoxel;

                                                            somechunkkeyboard[voxelmainindex].arrayofindexzeromesh[c].somechunk[cc].resetmap(out m11, out m12, out m13, out m14, out m21, out m22, out m23, out m24, out m31, out m32, out m33, out m34, out m41, out m42, out m43, out m44, -1, voxelchunkinvertoption);
                                                            //somechunkkeyboard[voxelmainindex].arrayofindexzeromesh[c].somechunk[cc].setnewmap(out m11, out m12, out m13, out m14, out m21, out m22, out m23, out m24, out m31, out m32, out m33, out m34, out m41, out m42, out m43, out m44, -1, voxelchunkinvertoption); //

                                                            somechunkkeyboard[voxelmainindex].arrayofindexzeromesh[c].instancesmatrix[cc].instancematrix.M11 = (float)m11;
                                                            somechunkkeyboard[voxelmainindex].arrayofindexzeromesh[c].instancesmatrix[cc].instancematrix.M12 = (float)m12;
                                                            somechunkkeyboard[voxelmainindex].arrayofindexzeromesh[c].instancesmatrix[cc].instancematrix.M13 = (float)m13;
                                                            somechunkkeyboard[voxelmainindex].arrayofindexzeromesh[c].instancesmatrix[cc].instancematrix.M14 = (float)m14;

                                                            somechunkkeyboard[voxelmainindex].arrayofindexzeromesh[c].instancesmatrix[cc].instancematrix.M21 = (float)m21;
                                                            somechunkkeyboard[voxelmainindex].arrayofindexzeromesh[c].instancesmatrix[cc].instancematrix.M22 = (float)m22;
                                                            somechunkkeyboard[voxelmainindex].arrayofindexzeromesh[c].instancesmatrix[cc].instancematrix.M23 = (float)m23;
                                                            somechunkkeyboard[voxelmainindex].arrayofindexzeromesh[c].instancesmatrix[cc].instancematrix.M24 = (float)m24;

                                                            somechunkkeyboard[voxelmainindex].arrayofindexzeromesh[c].instancesmatrix[cc].instancematrix.M31 = (float)m31;
                                                            somechunkkeyboard[voxelmainindex].arrayofindexzeromesh[c].instancesmatrix[cc].instancematrix.M32 = (float)m32;
                                                            somechunkkeyboard[voxelmainindex].arrayofindexzeromesh[c].instancesmatrix[cc].instancematrix.M33 = (float)m33;
                                                            somechunkkeyboard[voxelmainindex].arrayofindexzeromesh[c].instancesmatrix[cc].instancematrix.M34 = (float)m34;

                                                            somechunkkeyboard[voxelmainindex].arrayofindexzeromesh[c].instancesmatrix[cc].instancematrix.M41 = (float)m41;
                                                            somechunkkeyboard[voxelmainindex].arrayofindexzeromesh[c].instancesmatrix[cc].instancematrix.M42 = (float)m42;
                                                            somechunkkeyboard[voxelmainindex].arrayofindexzeromesh[c].instancesmatrix[cc].instancematrix.M43 = (float)m43;
                                                            somechunkkeyboard[voxelmainindex].arrayofindexzeromesh[c].instancesmatrix[cc].instancematrix.M44 = (float)m44;

                                                            //somechunkkeyboard[voxelmainindex].arrayOfChunkData[c].copytobuffer = 1;


                                                        }
                                                    }
                                                }
                                            }
                                        }
                                    }
                                }
                            }
                        }
                    }
                }
                somechunkplayerspatiallocationresetcounter++;


                for (int xxxx = 0; xxxx < somechunkkeyboardw; xxxx++)
                {
                    for (int yyyy = 0; yyyy < somechunkkeyboardh; yyyy++)
                    {
                        for (int zzzz = 0; zzzz < somechunkkeyboardd; zzzz++)
                        {
                            var voxelmainindex = xxxx + somechunkkeyboardw * (yyyy + somechunkkeyboardh * zzzz);

                            for (int x = 0; x < somechunkkeyboardglobals.numberOfObjectInWidth; x++)
                            {
                                for (int y = 0; y < somechunkkeyboardglobals.numberOfObjectInHeight; y++)
                                {
                                    for (int z = 0; z < somechunkkeyboardglobals.numberOfObjectInDepth; z++)
                                    {
                                        int c = x + somechunkkeyboardglobals.numberOfObjectInWidth * (y + somechunkkeyboardglobals.numberOfObjectInHeight * z);

                                        if (somechunkkeyboard[voxelmainindex].arrayOfChunkData[c].switchForRender == 1)
                                        {

                                        }
                                        else
                                        {
                                            for (int xx = 0; xx < somechunkkeyboardglobals.numberOfInstancesPerObjectInWidth; xx++)
                                            {
                                                for (int yy = 0; yy < somechunkkeyboardglobals.numberOfInstancesPerObjectInHeight; yy++)
                                                {
                                                    for (int zz = 0; zz < somechunkkeyboardglobals.numberOfInstancesPerObjectInDepth; zz++)
                                                    {
                                                        int cc = xx + somechunkkeyboardglobals.numberOfInstancesPerObjectInWidth * (yy + somechunkkeyboardglobals.numberOfInstancesPerObjectInHeight * zz);

                                                        if (sc_menu_scroller == 2 && somechunkplayerspatiallocationresetcounter >= somechunkkeyboardw * somechunkkeyboardh * somechunkkeyboardd * somechunkkeyboardglobals.numberOfObjectInWidth * somechunkkeyboardglobals.numberOfObjectInHeight * somechunkkeyboardglobals.numberOfObjectInDepth * somechunkkeyboardglobals.numberOfInstancesPerObjectInWidth * somechunkkeyboardglobals.numberOfInstancesPerObjectInHeight * somechunkkeyboardglobals.numberOfInstancesPerObjectInDepth && resetvoxelladdercounter == 2)
                                                        {
                                                            //MainWindow.MessageBox((IntPtr)0, "menu option 3" , "sccs", 0);

                                                            int voxelchunkinvertoption = MainWindow.usetypeofvoxel;

                                                            somechunkkeyboard[voxelmainindex].arrayOfChunkData[c].copytobuffer = 1;

                                                            somechunkplayerspatiallocationresetcounter = 0;
                                                        }
                                                    }
                                                }
                                            }
                                        }
                                    }
                                }
                            }
                        }
                    }
                }
                resetvoxelladdercounter = 1;*/
                //VIRTUAL KEYBOARD VOXEL MESH BREAKING BUFFER MAP RESET
                //VIRTUAL KEYBOARD VOXEL MESH BREAKING BUFFER MAP RESET
                //VIRTUAL KEYBOARD VOXEL MESH BREAKING BUFFER MAP RESET
























                /*
                //VIRTUAL DESKTOP VOXEL MESH BREAKING BUFFER MAP RESET
                //VIRTUAL DESKTOP VOXEL MESH BREAKING BUFFER MAP RESET
                //VIRTUAL DESKTOP VOXEL MESH BREAKING BUFFER MAP RESET
                for (int xxxx = 0; xxxx < somevoxelvirtualdesktopw; xxxx++)
                {
                    for (int yyyy = 0; yyyy < somevoxelvirtualdesktoph; yyyy++)
                    {
                        for (int zzzz = 0; zzzz < somevoxelvirtualdesktopd; zzzz++)
                        {
                            var voxelmainindex = xxxx + somevoxelvirtualdesktopw * (yyyy + somevoxelvirtualdesktoph * zzzz);

                            for (int x = 0; x < somevoxelvirtualdesktopglobals.numberOfObjectInWidth; x++)
                            {
                                for (int y = 0; y < somevoxelvirtualdesktopglobals.numberOfObjectInHeight; y++)
                                {
                                    for (int z = 0; z < somevoxelvirtualdesktopglobals.numberOfObjectInDepth; z++)
                                    {
                                        int c = x + somevoxelvirtualdesktopglobals.numberOfObjectInWidth * (y + somevoxelvirtualdesktopglobals.numberOfObjectInHeight * z);

                                        if (somevoxelvirtualdesktop[voxelmainindex].arrayOfChunkData[c].switchForRender == 1)
                                        {

                                        }
                                        else
                                        {
                                            for (int xx = 0; xx < somevoxelvirtualdesktopglobals.numberOfInstancesPerObjectInWidth; xx++)
                                            {
                                                for (int yy = 0; yy < somevoxelvirtualdesktopglobals.numberOfInstancesPerObjectInHeight; yy++)
                                                {
                                                    for (int zz = 0; zz < somevoxelvirtualdesktopglobals.numberOfInstancesPerObjectInDepth; zz++)
                                                    {
                                                        int cc = xx + somevoxelvirtualdesktopglobals.numberOfInstancesPerObjectInWidth * (yy + somevoxelvirtualdesktopglobals.numberOfInstancesPerObjectInHeight * zz);

                                                        if (sc_menu_scroller == 2 && somechunkplayerspatiallocationresetcounter < somevoxelvirtualdesktopw * somevoxelvirtualdesktoph * somevoxelvirtualdesktopd * somevoxelvirtualdesktopglobals.numberOfObjectInWidth * somevoxelvirtualdesktopglobals.numberOfObjectInHeight * somevoxelvirtualdesktopglobals.numberOfObjectInDepth * somevoxelvirtualdesktopglobals.numberOfInstancesPerObjectInWidth * somevoxelvirtualdesktopglobals.numberOfInstancesPerObjectInHeight * somevoxelvirtualdesktopglobals.numberOfInstancesPerObjectInDepth && resetvoxelladdercounter == 2)
                                                        {
                                                            //MainWindow.MessageBox((IntPtr)0, "menu option 3" , "sccs", 0);

                                                            int voxelchunkinvertoption = MainWindow.usetypeofvoxel;

                                                            somevoxelvirtualdesktop[voxelmainindex].arrayofindexzeromesh[c].somechunk[cc].resetmap(out m11, out m12, out m13, out m14, out m21, out m22, out m23, out m24, out m31, out m32, out m33, out m34, out m41, out m42, out m43, out m44, -1, voxelchunkinvertoption);
                                                            //somevoxelvirtualdesktop[voxelmainindex].arrayofindexzeromesh[c].somechunk[cc].setnewmap(out m11, out m12, out m13, out m14, out m21, out m22, out m23, out m24, out m31, out m32, out m33, out m34, out m41, out m42, out m43, out m44, -1, voxelchunkinvertoption); //

                                                            somevoxelvirtualdesktop[voxelmainindex].arrayofindexzeromesh[c].instancesmatrix[cc].instancematrix.M11 = (float)m11;
                                                            somevoxelvirtualdesktop[voxelmainindex].arrayofindexzeromesh[c].instancesmatrix[cc].instancematrix.M12 = (float)m12;
                                                            somevoxelvirtualdesktop[voxelmainindex].arrayofindexzeromesh[c].instancesmatrix[cc].instancematrix.M13 = (float)m13;
                                                            somevoxelvirtualdesktop[voxelmainindex].arrayofindexzeromesh[c].instancesmatrix[cc].instancematrix.M14 = (float)m14;

                                                            somevoxelvirtualdesktop[voxelmainindex].arrayofindexzeromesh[c].instancesmatrix[cc].instancematrix.M21 = (float)m21;
                                                            somevoxelvirtualdesktop[voxelmainindex].arrayofindexzeromesh[c].instancesmatrix[cc].instancematrix.M22 = (float)m22;
                                                            somevoxelvirtualdesktop[voxelmainindex].arrayofindexzeromesh[c].instancesmatrix[cc].instancematrix.M23 = (float)m23;
                                                            somevoxelvirtualdesktop[voxelmainindex].arrayofindexzeromesh[c].instancesmatrix[cc].instancematrix.M24 = (float)m24;

                                                            somevoxelvirtualdesktop[voxelmainindex].arrayofindexzeromesh[c].instancesmatrix[cc].instancematrix.M31 = (float)m31;
                                                            somevoxelvirtualdesktop[voxelmainindex].arrayofindexzeromesh[c].instancesmatrix[cc].instancematrix.M32 = (float)m32;
                                                            somevoxelvirtualdesktop[voxelmainindex].arrayofindexzeromesh[c].instancesmatrix[cc].instancematrix.M33 = (float)m33;
                                                            somevoxelvirtualdesktop[voxelmainindex].arrayofindexzeromesh[c].instancesmatrix[cc].instancematrix.M34 = (float)m34;

                                                            somevoxelvirtualdesktop[voxelmainindex].arrayofindexzeromesh[c].instancesmatrix[cc].instancematrix.M41 = (float)m41;
                                                            somevoxelvirtualdesktop[voxelmainindex].arrayofindexzeromesh[c].instancesmatrix[cc].instancematrix.M42 = (float)m42;
                                                            somevoxelvirtualdesktop[voxelmainindex].arrayofindexzeromesh[c].instancesmatrix[cc].instancematrix.M43 = (float)m43;
                                                            somevoxelvirtualdesktop[voxelmainindex].arrayofindexzeromesh[c].instancesmatrix[cc].instancematrix.M44 = (float)m44;

                                                            //somevoxelvirtualdesktop[voxelmainindex].arrayOfChunkData[c].copytobuffer = 1;


                                                        }
                                                    }
                                                }
                                            }
                                        }
                                    }
                                }
                            }
                        }
                    }
                }
                somechunkplayerspatiallocationresetcounter++;



                for (int xxxx = 0; xxxx < somevoxelvirtualdesktopw; xxxx++)
                {
                    for (int yyyy = 0; yyyy < somevoxelvirtualdesktoph; yyyy++)
                    {
                        for (int zzzz = 0; zzzz < somevoxelvirtualdesktopd; zzzz++)
                        {
                            var voxelmainindex = xxxx + somevoxelvirtualdesktopw * (yyyy + somevoxelvirtualdesktoph * zzzz);

                            for (int x = 0; x < somevoxelvirtualdesktopglobals.numberOfObjectInWidth; x++)
                            {
                                for (int y = 0; y < somevoxelvirtualdesktopglobals.numberOfObjectInHeight; y++)
                                {
                                    for (int z = 0; z < somevoxelvirtualdesktopglobals.numberOfObjectInDepth; z++)
                                    {
                                        int c = x + somevoxelvirtualdesktopglobals.numberOfObjectInWidth * (y + somevoxelvirtualdesktopglobals.numberOfObjectInHeight * z);

                                        if (somevoxelvirtualdesktop[voxelmainindex].arrayOfChunkData[c].switchForRender == 1)
                                        {

                                        }
                                        else
                                        {
                                            for (int xx = 0; xx < somevoxelvirtualdesktopglobals.numberOfInstancesPerObjectInWidth; xx++)
                                            {
                                                for (int yy = 0; yy < somevoxelvirtualdesktopglobals.numberOfInstancesPerObjectInHeight; yy++)
                                                {
                                                    for (int zz = 0; zz < somevoxelvirtualdesktopglobals.numberOfInstancesPerObjectInDepth; zz++)
                                                    {
                                                        int cc = xx + somevoxelvirtualdesktopglobals.numberOfInstancesPerObjectInWidth * (yy + somevoxelvirtualdesktopglobals.numberOfInstancesPerObjectInHeight * zz);

                                                        if (sc_menu_scroller == 2 && somechunkplayerspatiallocationresetcounter >= somevoxelvirtualdesktopw * somevoxelvirtualdesktoph * somevoxelvirtualdesktopd * somevoxelvirtualdesktopglobals.numberOfObjectInWidth * somevoxelvirtualdesktopglobals.numberOfObjectInHeight * somevoxelvirtualdesktopglobals.numberOfObjectInDepth * somevoxelvirtualdesktopglobals.numberOfInstancesPerObjectInWidth * somevoxelvirtualdesktopglobals.numberOfInstancesPerObjectInHeight * somevoxelvirtualdesktopglobals.numberOfInstancesPerObjectInDepth && resetvoxelladdercounter == 2)
                                                        {
                                                            //MainWindow.MessageBox((IntPtr)0, "menu option 3" , "sccs", 0);

                                                            int voxelchunkinvertoption = MainWindow.usetypeofvoxel;

                                                            somevoxelvirtualdesktop[voxelmainindex].arrayOfChunkData[c].copytobuffer = 1;

                                                            somechunkplayerspatiallocationresetcounter = 0;
                                                        }
                                                    }
                                                }
                                            }
                                        }
                                    }
                                }
                            }
                        }
                    }
                }
                resetvoxelladdercounter = 1;*/
                //VIRTUAL DESKTOP VOXEL MESH BREAKING BUFFER MAP RESET
                //VIRTUAL DESKTOP VOXEL MESH BREAKING BUFFER MAP RESET
                //VIRTUAL DESKTOP VOXEL MESH BREAKING BUFFER MAP RESET























                /*
                //VIRTUAL KEYBOARD VOXEL MESH BREAKING BUFFER MAP RESET
                //VIRTUAL KEYBOARD VOXEL MESH BREAKING BUFFER MAP RESET
                //VIRTUAL KEYBOARD VOXEL MESH BREAKING BUFFER MAP RESET
                for (int xxxx = 0; xxxx < somevoxelroomw; xxxx++)
                {
                    for (int yyyy = 0; yyyy < somevoxelroomh; yyyy++)
                    {
                        for (int zzzz = 0; zzzz < somevoxelroomd; zzzz++)
                        {
                            var voxelmainindex = xxxx + somevoxelroomw * (yyyy + somevoxelroomh * zzzz);

                            for (int x = 0; x < somevoxelroomglobals.numberOfObjectInWidth; x++)
                            {
                                for (int y = 0; y < somevoxelroomglobals.numberOfObjectInHeight; y++)
                                {
                                    for (int z = 0; z < somevoxelroomglobals.numberOfObjectInDepth; z++)
                                    {
                                        int c = x + somevoxelroomglobals.numberOfObjectInWidth * (y + somevoxelroomglobals.numberOfObjectInHeight * z);

                                        if (somevoxelroom[voxelmainindex].arrayOfChunkData[c].switchForRender == 1)
                                        {

                                        }
                                        else
                                        {
                                            for (int xx = 0; xx < somevoxelroomglobals.numberOfInstancesPerObjectInWidth; xx++)
                                            {
                                                for (int yy = 0; yy < somevoxelroomglobals.numberOfInstancesPerObjectInHeight; yy++)
                                                {
                                                    for (int zz = 0; zz < somevoxelroomglobals.numberOfInstancesPerObjectInDepth; zz++)
                                                    {
                                                        int cc = xx + somevoxelroomglobals.numberOfInstancesPerObjectInWidth * (yy + somevoxelroomglobals.numberOfInstancesPerObjectInHeight * zz);

                                                        if (sc_menu_scroller == 2 && somechunkplayerspatiallocationresetcounter < somevoxelroomw * somevoxelroomh * somevoxelroomd * somevoxelroomglobals.numberOfObjectInWidth * somevoxelroomglobals.numberOfObjectInHeight * somevoxelroomglobals.numberOfObjectInDepth * somevoxelroomglobals.numberOfInstancesPerObjectInWidth * somevoxelroomglobals.numberOfInstancesPerObjectInHeight * somevoxelroomglobals.numberOfInstancesPerObjectInDepth && resetvoxelladdercounter == 2)
                                                        {
                                                            //MainWindow.MessageBox((IntPtr)0, "menu option 3" , "sccs", 0);

                                                            int voxelchunkinvertoption = MainWindow.usetypeofvoxel;

                                                            somevoxelroom[voxelmainindex].arrayofindexzeromesh[c].somechunk[cc].resetmap(out m11, out m12, out m13, out m14, out m21, out m22, out m23, out m24, out m31, out m32, out m33, out m34, out m41, out m42, out m43, out m44, -1, voxelchunkinvertoption);
                                                            //somevoxelroom[voxelmainindex].arrayofindexzeromesh[c].somechunk[cc].setnewmap(out m11, out m12, out m13, out m14, out m21, out m22, out m23, out m24, out m31, out m32, out m33, out m34, out m41, out m42, out m43, out m44, -1, voxelchunkinvertoption); //

                                                            somevoxelroom[voxelmainindex].arrayofindexzeromesh[c].instancesmatrix[cc].instancematrix.M11 = (float)m11;
                                                            somevoxelroom[voxelmainindex].arrayofindexzeromesh[c].instancesmatrix[cc].instancematrix.M12 = (float)m12;
                                                            somevoxelroom[voxelmainindex].arrayofindexzeromesh[c].instancesmatrix[cc].instancematrix.M13 = (float)m13;
                                                            somevoxelroom[voxelmainindex].arrayofindexzeromesh[c].instancesmatrix[cc].instancematrix.M14 = (float)m14;

                                                            somevoxelroom[voxelmainindex].arrayofindexzeromesh[c].instancesmatrix[cc].instancematrix.M21 = (float)m21;
                                                            somevoxelroom[voxelmainindex].arrayofindexzeromesh[c].instancesmatrix[cc].instancematrix.M22 = (float)m22;
                                                            somevoxelroom[voxelmainindex].arrayofindexzeromesh[c].instancesmatrix[cc].instancematrix.M23 = (float)m23;
                                                            somevoxelroom[voxelmainindex].arrayofindexzeromesh[c].instancesmatrix[cc].instancematrix.M24 = (float)m24;

                                                            somevoxelroom[voxelmainindex].arrayofindexzeromesh[c].instancesmatrix[cc].instancematrix.M31 = (float)m31;
                                                            somevoxelroom[voxelmainindex].arrayofindexzeromesh[c].instancesmatrix[cc].instancematrix.M32 = (float)m32;
                                                            somevoxelroom[voxelmainindex].arrayofindexzeromesh[c].instancesmatrix[cc].instancematrix.M33 = (float)m33;
                                                            somevoxelroom[voxelmainindex].arrayofindexzeromesh[c].instancesmatrix[cc].instancematrix.M34 = (float)m34;

                                                            somevoxelroom[voxelmainindex].arrayofindexzeromesh[c].instancesmatrix[cc].instancematrix.M41 = (float)m41;
                                                            somevoxelroom[voxelmainindex].arrayofindexzeromesh[c].instancesmatrix[cc].instancematrix.M42 = (float)m42;
                                                            somevoxelroom[voxelmainindex].arrayofindexzeromesh[c].instancesmatrix[cc].instancematrix.M43 = (float)m43;
                                                            somevoxelroom[voxelmainindex].arrayofindexzeromesh[c].instancesmatrix[cc].instancematrix.M44 = (float)m44;

                                                            //somevoxelroom[voxelmainindex].arrayOfChunkData[c].copytobuffer = 1;


                                                        }
                                                    }
                                                }
                                            }
                                        }
                                    }
                                }
                            }
                        }
                    }
                }
                somechunkplayerspatiallocationresetcounter++;


                for (int xxxx = 0; xxxx < somevoxelroomw; xxxx++)
                {
                    for (int yyyy = 0; yyyy < somevoxelroomh; yyyy++)
                    {
                        for (int zzzz = 0; zzzz < somevoxelroomd; zzzz++)
                        {
                            var voxelmainindex = xxxx + somevoxelroomw * (yyyy + somevoxelroomh * zzzz);

                            for (int x = 0; x < somevoxelroomglobals.numberOfObjectInWidth; x++)
                            {
                                for (int y = 0; y < somevoxelroomglobals.numberOfObjectInHeight; y++)
                                {
                                    for (int z = 0; z < somevoxelroomglobals.numberOfObjectInDepth; z++)
                                    {
                                        int c = x + somevoxelroomglobals.numberOfObjectInWidth * (y + somevoxelroomglobals.numberOfObjectInHeight * z);

                                        if (somevoxelroom[voxelmainindex].arrayOfChunkData[c].switchForRender == 1)
                                        {

                                        }
                                        else
                                        {
                                            for (int xx = 0; xx < somevoxelroomglobals.numberOfInstancesPerObjectInWidth; xx++)
                                            {
                                                for (int yy = 0; yy < somevoxelroomglobals.numberOfInstancesPerObjectInHeight; yy++)
                                                {
                                                    for (int zz = 0; zz < somevoxelroomglobals.numberOfInstancesPerObjectInDepth; zz++)
                                                    {
                                                        int cc = xx + somevoxelroomglobals.numberOfInstancesPerObjectInWidth * (yy + somevoxelroomglobals.numberOfInstancesPerObjectInHeight * zz);

                                                        if (sc_menu_scroller == 2 && somechunkplayerspatiallocationresetcounter >= somevoxelroomw * somevoxelroomh * somevoxelroomd * somevoxelroomglobals.numberOfObjectInWidth * somevoxelroomglobals.numberOfObjectInHeight * somevoxelroomglobals.numberOfObjectInDepth * somevoxelroomglobals.numberOfInstancesPerObjectInWidth * somevoxelroomglobals.numberOfInstancesPerObjectInHeight * somevoxelroomglobals.numberOfInstancesPerObjectInDepth && resetvoxelladdercounter == 2)
                                                        {
                                                            //MainWindow.MessageBox((IntPtr)0, "menu option 3" , "sccs", 0);

                                                            int voxelchunkinvertoption = MainWindow.usetypeofvoxel;

                                                            somevoxelroom[voxelmainindex].arrayOfChunkData[c].copytobuffer = 1;

                                                            somechunkplayerspatiallocationresetcounter = 0;
                                                        }
                                                    }
                                                }
                                            }
                                        }
                                    }
                                }
                            }
                        }
                    }
                }
                resetvoxelladdercounter = 1;
                //VOXEL ROOM*/













                /*
                for (int xxxx = 0; xxxx < somevoxelroomgridw; xxxx++)
                {
                    for (int yyyy = 0; yyyy < somevoxelroomgridh; yyyy++)
                    {
                        for (int zzzz = 0; zzzz < somevoxelroomgridd; zzzz++)
                        {
                            var voxelmainindex = xxxx + somevoxelroomgridw * (yyyy + somevoxelroomgridh * zzzz);

                            for (int x = 0; x < somevoxelroomgridglobals.numberOfObjectInWidth; x++)
                            {
                                for (int y = 0; y < somevoxelroomgridglobals.numberOfObjectInHeight; y++)
                                {
                                    for (int z = 0; z < somevoxelroomgridglobals.numberOfObjectInDepth; z++)
                                    {
                                        int c = x + somevoxelroomgridglobals.numberOfObjectInWidth * (y + somevoxelroomgridglobals.numberOfObjectInHeight * z);

                                        if (somevoxelroomgrid[voxelmainindex].arrayOfChunkData[c].switchForRender == 1)
                                        {

                                        }
                                        else
                                        {
                                            for (int xx = 0; xx < somevoxelroomgridglobals.numberOfInstancesPerObjectInWidth; xx++)
                                            {
                                                for (int yy = 0; yy < somevoxelroomgridglobals.numberOfInstancesPerObjectInHeight; yy++)
                                                {
                                                    for (int zz = 0; zz < somevoxelroomgridglobals.numberOfInstancesPerObjectInDepth; zz++)
                                                    {
                                                        int cc = xx + somevoxelroomgridglobals.numberOfInstancesPerObjectInWidth * (yy + somevoxelroomgridglobals.numberOfInstancesPerObjectInHeight * zz);

                                                        if (sc_menu_scroller == 2 && somechunkplayerspatiallocationresetcounter < somevoxelroomgridw * somevoxelroomgridh * somevoxelroomgridd * somevoxelroomgridglobals.numberOfObjectInWidth * somevoxelroomgridglobals.numberOfObjectInHeight * somevoxelroomgridglobals.numberOfObjectInDepth * somevoxelroomgridglobals.numberOfInstancesPerObjectInWidth * somevoxelroomgridglobals.numberOfInstancesPerObjectInHeight * somevoxelroomgridglobals.numberOfInstancesPerObjectInDepth && resetvoxelladdercounter == 2)
                                                        {
                                                            //MainWindow.MessageBox((IntPtr)0, "menu option 3" , "sccs", 0);

                                                            int voxelchunkinvertoption = MainWindow.usetypeofvoxel;

                                                            somevoxelroomgrid[voxelmainindex].arrayofindexzeromesh[c].somechunk[cc].resetmap(out m11, out m12, out m13, out m14, out m21, out m22, out m23, out m24, out m31, out m32, out m33, out m34, out m41, out m42, out m43, out m44, -1, voxelchunkinvertoption);
                                                            //somevoxelroomgrid[voxelmainindex].arrayofindexzeromesh[c].somechunk[cc].setnewmap(out m11, out m12, out m13, out m14, out m21, out m22, out m23, out m24, out m31, out m32, out m33, out m34, out m41, out m42, out m43, out m44, -1, voxelchunkinvertoption); //

                                                            somevoxelroomgrid[voxelmainindex].arrayofindexzeromesh[c].instancesmatrix[cc].instancematrix.M11 = (float)m11;
                                                            somevoxelroomgrid[voxelmainindex].arrayofindexzeromesh[c].instancesmatrix[cc].instancematrix.M12 = (float)m12;
                                                            somevoxelroomgrid[voxelmainindex].arrayofindexzeromesh[c].instancesmatrix[cc].instancematrix.M13 = (float)m13;
                                                            somevoxelroomgrid[voxelmainindex].arrayofindexzeromesh[c].instancesmatrix[cc].instancematrix.M14 = (float)m14;

                                                            somevoxelroomgrid[voxelmainindex].arrayofindexzeromesh[c].instancesmatrix[cc].instancematrix.M21 = (float)m21;
                                                            somevoxelroomgrid[voxelmainindex].arrayofindexzeromesh[c].instancesmatrix[cc].instancematrix.M22 = (float)m22;
                                                            somevoxelroomgrid[voxelmainindex].arrayofindexzeromesh[c].instancesmatrix[cc].instancematrix.M23 = (float)m23;
                                                            somevoxelroomgrid[voxelmainindex].arrayofindexzeromesh[c].instancesmatrix[cc].instancematrix.M24 = (float)m24;

                                                            somevoxelroomgrid[voxelmainindex].arrayofindexzeromesh[c].instancesmatrix[cc].instancematrix.M31 = (float)m31;
                                                            somevoxelroomgrid[voxelmainindex].arrayofindexzeromesh[c].instancesmatrix[cc].instancematrix.M32 = (float)m32;
                                                            somevoxelroomgrid[voxelmainindex].arrayofindexzeromesh[c].instancesmatrix[cc].instancematrix.M33 = (float)m33;
                                                            somevoxelroomgrid[voxelmainindex].arrayofindexzeromesh[c].instancesmatrix[cc].instancematrix.M34 = (float)m34;

                                                            somevoxelroomgrid[voxelmainindex].arrayofindexzeromesh[c].instancesmatrix[cc].instancematrix.M41 = (float)m41;
                                                            somevoxelroomgrid[voxelmainindex].arrayofindexzeromesh[c].instancesmatrix[cc].instancematrix.M42 = (float)m42;
                                                            somevoxelroomgrid[voxelmainindex].arrayofindexzeromesh[c].instancesmatrix[cc].instancematrix.M43 = (float)m43;
                                                            somevoxelroomgrid[voxelmainindex].arrayofindexzeromesh[c].instancesmatrix[cc].instancematrix.M44 = (float)m44;

                                                            //somevoxelroomgrid[voxelmainindex].arrayOfChunkData[c].copytobuffer = 1;


                                                        }
                                                    }
                                                }
                                            }
                                        }
                                    }
                                }
                            }
                        }
                    }
                }
                somechunkplayerspatiallocationresetcounter++;


                for (int xxxx = 0; xxxx < somevoxelroomgridw; xxxx++)
                {
                    for (int yyyy = 0; yyyy < somevoxelroomgridh; yyyy++)
                    {
                        for (int zzzz = 0; zzzz < somevoxelroomgridd; zzzz++)
                        {
                            var voxelmainindex = xxxx + somevoxelroomgridw * (yyyy + somevoxelroomgridh * zzzz);

                            for (int x = 0; x < somevoxelroomgridglobals.numberOfObjectInWidth; x++)
                            {
                                for (int y = 0; y < somevoxelroomgridglobals.numberOfObjectInHeight; y++)
                                {
                                    for (int z = 0; z < somevoxelroomgridglobals.numberOfObjectInDepth; z++)
                                    {
                                        int c = x + somevoxelroomgridglobals.numberOfObjectInWidth * (y + somevoxelroomgridglobals.numberOfObjectInHeight * z);

                                        if (somevoxelroomgrid[voxelmainindex].arrayOfChunkData[c].switchForRender == 1)
                                        {

                                        }
                                        else
                                        {
                                            for (int xx = 0; xx < somevoxelroomgridglobals.numberOfInstancesPerObjectInWidth; xx++)
                                            {
                                                for (int yy = 0; yy < somevoxelroomgridglobals.numberOfInstancesPerObjectInHeight; yy++)
                                                {
                                                    for (int zz = 0; zz < somevoxelroomgridglobals.numberOfInstancesPerObjectInDepth; zz++)
                                                    {
                                                        int cc = xx + somevoxelroomgridglobals.numberOfInstancesPerObjectInWidth * (yy + somevoxelroomgridglobals.numberOfInstancesPerObjectInHeight * zz);

                                                        if (sc_menu_scroller == 2 && somechunkplayerspatiallocationresetcounter >= somevoxelroomgridw * somevoxelroomgridh * somevoxelroomgridd * somevoxelroomgridglobals.numberOfObjectInWidth * somevoxelroomgridglobals.numberOfObjectInHeight * somevoxelroomgridglobals.numberOfObjectInDepth * somevoxelroomgridglobals.numberOfInstancesPerObjectInWidth * somevoxelroomgridglobals.numberOfInstancesPerObjectInHeight * somevoxelroomgridglobals.numberOfInstancesPerObjectInDepth && resetvoxelladdercounter == 2)
                                                        {
                                                            //MainWindow.MessageBox((IntPtr)0, "menu option 3" , "sccs", 0);

                                                            int voxelchunkinvertoption = MainWindow.usetypeofvoxel;

                                                            somevoxelroomgrid[voxelmainindex].arrayOfChunkData[c].copytobuffer = 1;

                                                            somechunkplayerspatiallocationresetcounter = 0;
                                                        }
                                                    }
                                                }
                                            }
                                        }
                                    }
                                }
                            }
                        }
                    }
                }
                resetvoxelladdercounter = 1;
                //VOXEL ROOM GRID*/





















            }
            catch (Exception ex)
            {
                MainWindow.MessageBox((IntPtr)0, "" + ex.ToString(), "sccs error message", 0);
            }























            return _sc_jitter_tasks;
        }






        Matrix heightmapmatrix;






        public scmessageobjectjitter[][] sccswriteikrigtobuffer(scgraphicssecpackage scgraphicssecpackagemessage)
        {


            scmessageobjectjitter[][] _sc_jitter_tasks = scgraphicssecpackagemessage.scjittertasks;
            Matrix viewMatrix = scgraphicssecpackagemessage.viewMatrix;
            Matrix projectionMatrix = scgraphicssecpackagemessage.projectionMatrix; //_projectionMatrix;
            Matrix originRot = scgraphicssecpackagemessage.originRot; // originRot;
            Matrix rotatingMatrix = scgraphicssecpackagemessage.rotatingMatrix; //rotatingMatrix;
            Matrix hmdrotMatrix = scgraphicssecpackagemessage.hmdmatrixRot; //hmdmatrixRot;
            Matrix hmd_matrix = scgraphicssecpackagemessage.hmd_matrix; //hmd_matrix;
            Matrix rotatingMatrixForPelvis = scgraphicssecpackagemessage.rotatingMatrixForPelvis; //rotatingMatrixForPelvis;
            Matrix _rightTouchMatrix = scgraphicssecpackagemessage.rightTouchMatrix; //_rightTouchMatrix;
            Matrix _leftTouchMatrix = scgraphicssecpackagemessage.leftTouchMatrix; //_leftTouchMatrix;
            Matrix oriProjectionMatrix = scgraphicssecpackagemessage.oriProjectionMatrix; //oriProjectionMatrix;
            Matrix extramatrix = scgraphicssecpackagemessage.someextrapelvismatrix; //someextrapelvismatrix;
            Vector3 OFFSETPOS = scgraphicssecpackagemessage.offsetpos; // OFFSETPOS;
            Posef handPoseRight = scgraphicssecpackagemessage.handPoseRight; //handPoseRight;
            Posef handPoseLeft = scgraphicssecpackagemessage.handPoseLeft; //handPoseLeft;












            //TO CHANGE HEIGHTMAPS SIZE
            //TO CHANGE HEIGHTMAPS SIZE
            heightmapmatrix = sc_maths.Scaling(heightmapscale) * ikarmvoxel[0].worldMatrix_instances_r_hand_grab[0][0][0];// worldMatrix_instances_r_hand_grab[0][0][0];
            //TO CHANGE HEIGHTMAPS SIZE
            //TO CHANGE HEIGHTMAPS SIZE



            heightmapmatrix.M41 = SC_Update.OFFSETPOS.X;
            heightmapmatrix.M42 = SC_Update.OFFSETPOS.Y;
            heightmapmatrix.M43 = SC_Update.OFFSETPOS.Z;









            for (int xxx = 0; xxx < somechunkpriminstancesikvoxelbodywidthR; xxx++)
            {

                float posX = (xxx);
                float posY = (0);
                float posZ = (0);


                var xxi = xxx;
                var yyi = 0;
                var zzi = 0;

                if (xxi < 0)
                {
                    xxi *= -1;
                    xxi = (somechunkpriminstancesikvoxelbodywidthR) + xxi;
                }
                if (yyi < 0)
                {
                    yyi *= -1;
                    yyi = (somechunkpriminstancesikvoxelbodyheightR) + yyi;
                }
                if (zzi < 0)
                {
                    zzi *= -1;
                    zzi = (somechunkpriminstancesikvoxelbodydepthR) + zzi;
                }

                int somechunkpriminstanceikvoxelbodyindex = xxi;// + (somechunkpriminstancesikvoxelbodywidthL) * (yyi + (somechunkpriminstancesikvoxelbodyheightL) * zzi);

                _sc_jitter_tasks = ikvoxelbody[somechunkpriminstanceikvoxelbodyindex].writeikbodytobuffer(_sc_jitter_tasks, viewMatrix, projectionMatrix, OFFSETPOS, originRot, rotatingMatrix, hmdrotMatrix, hmd_matrix, rotatingMatrixForPelvis, _rightTouchMatrix, _leftTouchMatrix, handPoseRight, handPoseLeft, oriProjectionMatrix);



                /*
                for (int yyy = -somechunkpriminstancesikvoxelbodyheightL; yyy <= somechunkpriminstancesikvoxelbodyheightR; yyy++)
                {
                    for (int zzz = -somechunkpriminstancesikvoxelbodydepthL; zzz <= somechunkpriminstancesikvoxelbodydepthR; zzz++)
                    {
}
                }*/
            }


            for (int xxx = 0; xxx < somechunkpriminstancesikarmvoxelwidthR; xxx++)
            {
                for (int yyy = 0; yyy < somechunkpriminstancesikarmvoxelheightR; yyy++)
                {

                    float posX = (xxx);
                    float posY = (yyy);
                    float posZ = (0);


                    var xxi = xxx;
                    var yyi = yyy;
                    var zzi = 0;

                    if (xxi < 0)
                    {
                        xxi *= -1;
                        xxi = (somechunkpriminstancesikarmvoxelwidthR) + xxi;
                    }
                    if (yyi < 0)
                    {
                        yyi *= -1;
                        yyi = (somechunkpriminstancesikarmvoxelheightR) + yyi;
                    }
                    if (zzi < 0)
                    {
                        zzi *= -1;
                        zzi = (somechunkpriminstancesikarmvoxeldepthR) + zzi;
                    }

                    //int somechunkpriminstanceikarmvoxelindex = xxi + (somechunkpriminstancesikarmvoxelwidthL) * (yyi + (somechunkpriminstancesikarmvoxelheightL) * zzi);
                    int somechunkpriminstanceikarmvoxelindex = xxi + (yyi * (somechunkpriminstancesikarmvoxelheightR));

                    _sc_jitter_tasks = ikarmvoxel[somechunkpriminstanceikarmvoxelindex].writeikarmtobuffer(_sc_jitter_tasks, viewMatrix, projectionMatrix, OFFSETPOS, originRot, rotatingMatrix, hmdrotMatrix, hmd_matrix, rotatingMatrixForPelvis, _rightTouchMatrix, _leftTouchMatrix, handPoseRight, handPoseLeft, oriProjectionMatrix);



                    /*
                    for (int zzz = -somechunkpriminstancesikarmvoxeldepthL; zzz <= somechunkpriminstancesikarmvoxeldepthR; zzz++)
                    {

                    }*/
                }
            }










            return _sc_jitter_tasks;
        }








        double displayMidpoint;
        TrackingState trackingState;
        Posef[] eyePoses;
        EyeType eye;
        //EyeTexture eyeTexture;
        bool latencyMark = false;
        TrackingState trackState;
        PoseStatef poseStatefer;
        Posef hmdPose;
        Quaternionf hmdRot;
        Vector3 _hmdPoser;
        Quaternion _hmdRoter;
        Vector3 oculusRiftDir = Vector3.Zero;





        public scmessageobjectjitter[][] sccswritescreenassetstobuffer(scmessageobjectjitter[][] _sc_jitter_tasks)
        {
            //PHYSICS SCREENS
            _world_screen_list[0][0]._WORLDMATRIXINSTANCES = worldMatrix_instances_screens[0][0];
            _world_screen_list[0][0]._POSITION = worldMatrix_base[0];
            //END OF 

            //PHYSICS SCREEN ASSETS
            _world_screen_assets_list[0][0]._WORLDMATRIXINSTANCES = worldMatrix_instances_screen_assets[0][0];
            _world_screen_assets_list[0][0]._POSITION = worldMatrix_base[0];
            //END OF

            //PHYSICS SCREENS
            var cuber = _world_screen_list[0][0];
            var instancers = cuber.instances;
            var sometester = cuber._WORLDMATRIXINSTANCES;

            for (int i = 0; i < instancers.Length; i++)
            {
                float xxx = sometester[i].M41;
                float yyy = sometester[i].M42;
                float zzz = sometester[i].M43;

                cuber.instances[i].position.X = xxx;
                cuber.instances[i].position.Y = yyy;
                cuber.instances[i].position.Z = zzz;
                cuber.instances[i].position.W = 1;
                Quaternion.RotationMatrix(ref sometester[i], out _testQuater);

                var dirInstance = sc_maths._newgetdirforward(_testQuater);
                cuber.instancesDataForward[i].rotation.X = dirInstance.X;
                cuber.instancesDataForward[i].rotation.Y = dirInstance.Y;
                cuber.instancesDataForward[i].rotation.Z = dirInstance.Z;
                cuber.instancesDataForward[i].rotation.W = 1;

                dirInstance = -sc_maths._newgetdirleft(_testQuater);
                cuber.instancesDataRIGHT[i].rotation.X = dirInstance.X;
                cuber.instancesDataRIGHT[i].rotation.Y = dirInstance.Y;
                cuber.instancesDataRIGHT[i].rotation.Z = dirInstance.Z;
                cuber.instancesDataRIGHT[i].rotation.W = 1;

                dirInstance = dirInstance = sc_maths._newgetdirup(_testQuater);
                cuber.instancesDataUP[i].rotation.X = dirInstance.X;
                cuber.instancesDataUP[i].rotation.Y = dirInstance.Y;
                cuber.instancesDataUP[i].rotation.Z = dirInstance.Z;
                cuber.instancesDataUP[i].rotation.W = 1;
            }
            //END OF

            //PHYSICS SCREEN ASSETS
            cuber = _world_screen_assets_list[0][0];
            instancers = cuber.instances;
            sometester = cuber._WORLDMATRIXINSTANCES;

            for (int i = 0; i < instancers.Length; i++)
            {
                var xxx = sometester[i].M41;
                var yyy = sometester[i].M42;
                var zzz = sometester[i].M43;

                cuber.instances[i].position.X = xxx;
                cuber.instances[i].position.Y = yyy;
                cuber.instances[i].position.Z = zzz;
                cuber.instances[i].position.W = 1;
                Quaternion.RotationMatrix(ref sometester[i], out _testQuater);

                var dirInstance = sc_maths._newgetdirforward(_testQuater);
                cuber.instancesDataForward[i].rotation.X = dirInstance.X;
                cuber.instancesDataForward[i].rotation.Y = dirInstance.Y;
                cuber.instancesDataForward[i].rotation.Z = dirInstance.Z;
                cuber.instancesDataForward[i].rotation.W = 1;

                dirInstance = -sc_maths._newgetdirleft(_testQuater);
                cuber.instancesDataRIGHT[i].rotation.X = dirInstance.X;
                cuber.instancesDataRIGHT[i].rotation.Y = dirInstance.Y;
                cuber.instancesDataRIGHT[i].rotation.Z = dirInstance.Z;
                cuber.instancesDataRIGHT[i].rotation.W = 1;

                dirInstance = dirInstance = sc_maths._newgetdirup(_testQuater);
                cuber.instancesDataUP[i].rotation.X = dirInstance.X;
                cuber.instancesDataUP[i].rotation.Y = dirInstance.Y;
                cuber.instancesDataUP[i].rotation.Z = dirInstance.Z;
                cuber.instancesDataUP[i].rotation.W = 1;
            }


            return _sc_jitter_tasks;
        }







        public scmessageobjectjitter[][] scwritetobuffer(scmessageobjectjitter[][] _sc_jitter_tasks)
        {
















            //DESTROYABLE VOXEL CHUNK
            //DESTROYABLE VOXEL CHUNK
            //DESTROYABLE VOXEL CHUNK
            /*
            for (int xxx = 0; xxx < somechunkmeshswidth; xxx++)
            {
                for (int yyy = 0; yyy < somechunkmeshsheight; yyy++)
                {
                    for (int zzz = 0; zzz < somechunkmeshsdepth; zzz++)
                    {
                        //somechunkmesh
                        var somechunkmeshindex = xxx + somechunkmeshswidth * (yyy + somechunkmeshsheight * zzz);


                        for (int x = 0; x < someglobalschunkmesh.numberOfObjectInWidth; x++)
                        {
                            for (int y = 0; y < someglobalschunkmesh.numberOfObjectInHeight; y++)
                            {
                                for (int z = 0; z < someglobalschunkmesh.numberOfObjectInDepth; z++)
                                {
                                    int c = x + someglobalschunkmesh.numberOfObjectInWidth * (y + someglobalschunkmesh.numberOfObjectInHeight * z);













                                    for (int xx = 0; xx < someglobalschunkmesh.numberOfInstancesPerObjectInWidth; xx++)
                                    {
                                        for (int yy = 0; yy < someglobalschunkmesh.numberOfInstancesPerObjectInHeight; yy++)
                                        {
                                            for (int zz = 0; zz < someglobalschunkmesh.numberOfInstancesPerObjectInDepth; zz++)
                                            {
                                                int cc = xx + someglobalschunkmesh.numberOfInstancesPerObjectInWidth * (yy + someglobalschunkmesh.numberOfInstancesPerObjectInHeight * zz);

                                                Matrix worldMatrixChunkDroneInstance = somechunkmesh[somechunkmeshindex].arrayofindexzeromesh[c].arrayofzeromeshinstances[cc].current_pos;

                                                Matrix worldMatrixmain = somechunkmesh[somechunkmeshindex].worldmatofobj;


                                                Quaternion _testQuator;


                                                //worldMatrixChunkDroneInstance = worldMatrixChunkDroneInstance * somechunkmesh[somechunkmeshindex].worldmatofobj;

                                                //TOREADD
                                                //TOREADD
                                                //TOREADD
                                                Quaternion.RotationMatrix(ref worldMatrixChunkDroneInstance, out _testQuator);

                                                var dirInstanceForward = sc_maths._newgetdirforward(_testQuator);
                                                somechunkmesh[somechunkmeshindex].arrayofindexzeromesh[c].instancesDataFORWARD[cc].instancePos.X = dirInstanceForward.X;
                                                somechunkmesh[somechunkmeshindex].arrayofindexzeromesh[c].instancesDataFORWARD[cc].instancePos.Y = dirInstanceForward.Y;
                                                somechunkmesh[somechunkmeshindex].arrayofindexzeromesh[c].instancesDataFORWARD[cc].instancePos.Z = dirInstanceForward.Z;
                                                somechunkmesh[somechunkmeshindex].arrayofindexzeromesh[c].instancesDataFORWARD[cc].instancePos.W = 1;

                                                //Quaternion.RotationMatrix(ref tempmat0, out quat_buffers);
                                                var dirInstanceRight = -sc_maths._newgetdirleft(_testQuator);
                                                somechunkmesh[somechunkmeshindex].arrayofindexzeromesh[c].instancesDataRIGHT[cc].instancePos.X = dirInstanceRight.X;
                                                somechunkmesh[somechunkmeshindex].arrayofindexzeromesh[c].instancesDataRIGHT[cc].instancePos.Y = dirInstanceRight.Y;
                                                somechunkmesh[somechunkmeshindex].arrayofindexzeromesh[c].instancesDataRIGHT[cc].instancePos.Z = dirInstanceRight.Z;
                                                somechunkmesh[somechunkmeshindex].arrayofindexzeromesh[c].instancesDataRIGHT[cc].instancePos.W = 1;

                                                //Quaternion.RotationMatrix(ref tempmat0, out quat_buffers);    
                                                var dirInstanceUp = sc_maths._newgetdirup(_testQuator);
                                                somechunkmesh[somechunkmeshindex].arrayofindexzeromesh[c].instancesDataUP[cc].instancePos.X = dirInstanceUp.X;
                                                somechunkmesh[somechunkmeshindex].arrayofindexzeromesh[c].instancesDataUP[cc].instancePos.Y = dirInstanceUp.Y;
                                                somechunkmesh[somechunkmeshindex].arrayofindexzeromesh[c].instancesDataUP[cc].instancePos.Z = dirInstanceUp.Z;
                                                somechunkmesh[somechunkmeshindex].arrayofindexzeromesh[c].instancesDataUP[cc].instancePos.W = 1;

                                                //TOREADD
                                                //TOREADD
                                                //TOREADD





                                                /*
                                                Quaternion.RotationMatrix(ref worldMatrixChunkDroneInstance, out _testQuator);

                                                var dirInstanceForward = sc_maths._newgetdirforward(_testQuator);
                                                somechunkmesh[somechunkmeshindex].arrayOfChunkData[c].SC_instancedChunk_InstancesFORWARD[cc].instancePos.X = dirInstanceForward.X;
                                                somechunkmesh[somechunkmeshindex].arrayOfChunkData[c].SC_instancedChunk_InstancesFORWARD[cc].instancePos.Y = dirInstanceForward.Y;
                                                somechunkmesh[somechunkmeshindex].arrayOfChunkData[c].SC_instancedChunk_InstancesFORWARD[cc].instancePos.Z = dirInstanceForward.Z;
                                                somechunkmesh[somechunkmeshindex].arrayOfChunkData[c].SC_instancedChunk_InstancesFORWARD[cc].instancePos.W = 1;

                                                //Quaternion.RotationMatrix(ref tempmat0, out quat_buffers);
                                                var dirInstanceRight = -sc_maths._newgetdirleft(_testQuator);
                                                somechunkmesh[somechunkmeshindex].arrayOfChunkData[c].SC_instancedChunk_InstancesRIGHT[cc].instancePos.X = dirInstanceRight.X;
                                                somechunkmesh[somechunkmeshindex].arrayOfChunkData[c].SC_instancedChunk_InstancesRIGHT[cc].instancePos.Y = dirInstanceRight.Y;
                                                somechunkmesh[somechunkmeshindex].arrayOfChunkData[c].SC_instancedChunk_InstancesRIGHT[cc].instancePos.Z = dirInstanceRight.Z;
                                                somechunkmesh[somechunkmeshindex].arrayOfChunkData[c].SC_instancedChunk_InstancesRIGHT[cc].instancePos.W = 1;

                                                //Quaternion.RotationMatrix(ref tempmat0, out quat_buffers);    
                                                var dirInstanceUp = sc_maths._newgetdirup(_testQuator);
                                                somechunkmesh[somechunkmeshindex].arrayOfChunkData[c].SC_instancedChunk_InstancesUP[cc].instancePos.X = dirInstanceUp.X;
                                                somechunkmesh[somechunkmeshindex].arrayOfChunkData[c].SC_instancedChunk_InstancesUP[cc].instancePos.Y = dirInstanceUp.Y;
                                                somechunkmesh[somechunkmeshindex].arrayOfChunkData[c].SC_instancedChunk_InstancesUP[cc].instancePos.Z = dirInstanceUp.Z;
                                                somechunkmesh[somechunkmeshindex].arrayOfChunkData[c].SC_instancedChunk_InstancesUP[cc].instancePos.W = 1;


                                                Vector3 currentmainobjectpos = new Vector3(somechunkmesh[somechunkmeshindex].worldmatofobj.M41, somechunkmesh[somechunkmeshindex].worldmatofobj.M42, somechunkmesh[somechunkmeshindex].worldmatofobj.M43);

                                                float diffmainpostoinstanceposx = somechunkmesh[somechunkmeshindex].arrayofindexzeromesh[c].instances[cc].instancePos.X - currentmainobjectpos.X;
                                                float diffmainpostoinstanceposy = somechunkmesh[somechunkmeshindex].arrayofindexzeromesh[c].instances[cc].instancePos.Y - currentmainobjectpos.Y;
                                                float diffmainpostoinstanceposz = somechunkmesh[somechunkmeshindex].arrayofindexzeromesh[c].instances[cc].instancePos.Z - currentmainobjectpos.Z;
                                                */




                                                /*Quaternion somedirquat;

                                                Quaternion.RotationMatrix(ref worldMatrixChunkDroneInstance, out somedirquat);

                                                var dirInstanceForward = sc_maths._newgetdirforward(somedirquat);
                                                var dirInstanceRight = -sc_maths._newgetdirleft(somedirquat);
                                                var dirInstanceUp = sc_maths._newgetdirup(somedirquat);*/

                                                /*Vector4 somevecx = new Vector4(dirInstanceRight.X, dirInstanceRight.Y, dirInstanceRight.Z, 1.0f);
                                                Vector4 somevecy = new Vector4(dirInstanceUp.X, dirInstanceUp.Y, dirInstanceUp.Z, 1.0f);
                                                Vector4 somevecz = new Vector4(dirInstanceForward.X, dirInstanceForward.Y, dirInstanceForward.Z, 1.0f);

                                                Vector4 someinstancepostest = Vector4.Zero;
                                                Vector4 somemainpos = new Vector4(worldMatrixmain.M41, worldMatrixmain.M42, worldMatrixmain.M43, 1.0f);

                                                someinstancepostest = somechunkmesh[somechunkmeshindex].arrayofindexzeromesh[c].instances[cc].instancePos + (somevecx);// * (xx * 4 * 4 * 0.01f * 0.5f * 0.5f));
                                                someinstancepostest = somechunkmesh[somechunkmeshindex].arrayofindexzeromesh[c].instances[cc].instancePos + (somevecy);//  * (yy * 4 * 4 * 0.01f * 0.5f * 0.5f));
                                                someinstancepostest = somechunkmesh[somechunkmeshindex].arrayofindexzeromesh[c].instances[cc].instancePos + (somevecz);//  * (zz * 4 * 4 * 0.01f * 0.5f * 0.5f));
                                                */
                                                //somechunkmesh[somechunkmeshindex].arrayofindexzeromesh[c].instances[cc].instancePos.X += somemainpos.X + someinstancepostest.X;
                                                //somechunkmesh[somechunkmeshindex].arrayofindexzeromesh[c].instances[cc].instancePos.Y += somemainpos.Y + someinstancepostest.Y;
                                                //somechunkmesh[somechunkmeshindex].arrayofindexzeromesh[c].instances[cc].instancePos.Z += somemainpos.Z + someinstancepostest.Z;
                                                /*
                                                somechunkmesh[somechunkmeshindex].arrayofindexzeromesh[c].instances[cc].instancePos.X = someinstancepostest.X;
                                                somechunkmesh[somechunkmeshindex].arrayofindexzeromesh[c].instances[cc].instancePos.Y = someinstancepostest.Y;
                                                somechunkmesh[somechunkmeshindex].arrayofindexzeromesh[c].instances[cc].instancePos.Z = someinstancepostest.Z;
                                                */


                                                //somechunkmesh[somechunkmeshindex].arrayOfChunkData[c].SC_instancedChunk_Instances[cc].instancePos.X = somechunkmesh[somechunkmeshindex].arrayOfChunkData[c].SC_instancedChunk_Instances[cc].instancePos.X + -(somechunkmesh[somechunkmeshindex].arrayOfChunkData[c].SC_instancedChunk_InstancesFORWARD[cc].instancePos.X * diffmainpostoinstanceposx);
                                                //somechunkmesh[somechunkmeshindex].arrayOfChunkData[c].SC_instancedChunk_Instances[cc].instancePos.Y = somechunkmesh[somechunkmeshindex].arrayOfChunkData[c].SC_instancedChunk_Instances[cc].instancePos.Y + -(somechunkmesh[somechunkmeshindex].arrayOfChunkData[c].SC_instancedChunk_InstancesFORWARD[cc].instancePos.Y * diffmainpostoinstanceposy);
                                                //somechunkmesh[somechunkmeshindex].arrayOfChunkData[c].SC_instancedChunk_Instances[cc].instancePos.Z = somechunkmesh[somechunkmeshindex].arrayOfChunkData[c].SC_instancedChunk_Instances[cc].instancePos.Z + -(somechunkmesh[somechunkmeshindex].arrayOfChunkData[c].SC_instancedChunk_InstancesFORWARD[cc].instancePos.Z * diffmainpostoinstanceposz);

                                                //somechunkmesh[somechunkmeshindex].arrayOfChunkData[c].SC_instancedChunk_Instances[cc].instancePos.X = currentmainobjectpos.X + (somechunkmesh[somechunkmeshindex].arrayofindexzeromesh[c].instan[cc].instancePos.X + (dirInstanceRight.X * diffmainpostoinstanceposx));
                                                //somechunkmesh[somechunkmeshindex].arrayOfChunkData[c].SC_instancedChunk_Instances[cc].instancePos.Y = currentmainobjectpos.Y + (somechunkmesh[somechunkmeshindex].arrayofindexzeromesh[c].instances[cc].instancePos.Y + (dirInstanceUp.Y * diffmainpostoinstanceposy));
                                                //somechunkmesh[somechunkmeshindex].arrayOfChunkData[c].SC_instancedChunk_Instances[cc].instancePos.Z = currentmainobjectpos.Z + (somechunkmesh[somechunkmeshindex].arrayofindexzeromesh[c].instances[cc].instancePos.Z + (dirInstanceForward.Z * diffmainpostoinstanceposz));


                                                /*Vector4 somevecx = new Vector4(dirInstanceRight.X, dirInstanceRight.Y, dirInstanceRight.Z, 1.0f);
                                                Vector4 somevecy = new Vector4(dirInstanceUp.X, dirInstanceUp.Y, dirInstanceUp.Z, 1.0f);
                                                Vector4 somevecz = new Vector4(dirInstanceForward.X, dirInstanceForward.Y, dirInstanceForward.Z, 1.0f);

                                                somechunkmesh[somechunkmeshindex].arrayOfChunkData[c].SC_instancedChunk_Instances[cc].instancePos = somechunkmesh[somechunkmeshindex].arrayOfChunkData[c].SC_instancedChunk_Instances[cc].instancePos + (somevecx * diffmainpostoinstanceposx);
                                                somechunkmesh[somechunkmeshindex].arrayOfChunkData[c].SC_instancedChunk_Instances[cc].instancePos = somechunkmesh[somechunkmeshindex].arrayOfChunkData[c].SC_instancedChunk_Instances[cc].instancePos + (somevecy * diffmainpostoinstanceposy);
                                                somechunkmesh[somechunkmeshindex].arrayOfChunkData[c].SC_instancedChunk_Instances[cc].instancePos = somechunkmesh[somechunkmeshindex].arrayOfChunkData[c].SC_instancedChunk_Instances[cc].instancePos + (somevecz * diffmainpostoinstanceposz);
                                                





                                            }
                                        }
                                    }






                                    if (somechunkmesh[somechunkmeshindex].arrayOfChunkData[c].copytobuffer == 1)
                                    {
                                        for (int xx = 0; xx < someglobalschunkmesh.numberOfInstancesPerObjectInWidth; xx++)
                                        {
                                            for (int yy = 0; yy < someglobalschunkmesh.numberOfInstancesPerObjectInHeight; yy++)
                                            {
                                                for (int zz = 0; zz < someglobalschunkmesh.numberOfInstancesPerObjectInDepth; zz++)
                                                {
                                                    int cc = xx + someglobalschunkmesh.numberOfInstancesPerObjectInWidth * (yy + someglobalschunkmesh.numberOfInstancesPerObjectInHeight * zz);

                                                    //Matrix worldMatrixChunkDroneInstance = somechunkmesh[somechunkmeshindex].arrayofindexzeromesh[c].arrayofzeromeshinstances[cc].current_pos;
                                                    //Quaternion _testQuator;


                                                    //TO READD FOR SOME LOGIC.
                                                    //Matrix lastPosTarget = _player_rght_hnd[0][0]._arrayOfInstances[0].current_pos;// //_rightTouchMatrix; //
                                                    //Quaternion.RotationMatrix(ref lastPosTarget, out _testQuator);
                                                    //TO READD FOR SOME LOGIC.




                                                    //arrayofindexzeromesh[c].arrayOfScriptForInstances[cc].

                                                    //var dirTargetInstanceForward = sc_maths._newgetdirforward(_testQuator);
                                                    //arrayofindexzeromesh[c].instancesDataFORWARD[cc].instancePos.X = dirTargetInstanceForward.X;
                                                    //arrayofindexzeromesh[c].instancesDataFORWARD[cc].instancePos.Y = dirTargetInstanceForward.Y;
                                                    //arrayofindexzeromesh[c].instancesDataFORWARD[cc].instancePos.Z = dirTargetInstanceForward.Z;
                                                    //arrayofindexzeromesh[c].instancesDataFORWARD[cc].instancePos.W = 1;

                                                    //Quaternion.RotationMatrix(ref tempmat0, out quat_buffers);
                                                    //var dirTargetInstanceRight = sc_maths._newgetdirleft(_testQuator);
                                                    //arrayofindexzeromesh[c].instancesDataRIGHT[cc].instancePos.X = dirTargetInstanceRight.X;
                                                    //arrayofindexzeromesh[c].instancesDataRIGHT[cc].instancePos.Y = dirTargetInstanceRight.Y;
                                                    //arrayofindexzeromesh[c].instancesDataRIGHT[cc].instancePos.Z = dirTargetInstanceRight.Z;
                                                    //arrayofindexzeromesh[c].instancesDataRIGHT[cc].instancePos.W = 1;

                                                    //Quaternion.RotationMatrix(ref tempmat0, out quat_buffers);
                                                    //var dirTargetInstanceUp = sc_maths._newgetdirup(_testQuator);
                                                    //arrayofindexzeromesh[c].instancesDataUP[cc].instancePos.X = dirTargetInstanceUp.X;
                                                    //arrayofindexzeromesh[c].instancesDataUP[cc].instancePos.Y = dirTargetInstanceUp.Y;
                                                    //arrayofindexzeromesh[c].instancesDataUP[cc].instancePos.Z = dirTargetInstanceUp.Z;
                                                    //arrayofindexzeromesh[c].instancesDataUP[cc].instancePos.W = 1;

                                                    //worldMatrixChunkDroneInstance = arrayofindexzeromesh[c].arrayOfScriptForInstances[cc].current_pos;
                                                    //Matrix lastPosDrone = _player_rght_hnd[0][0]._arrayOfInstances[0].current_pos;// //_rightTouchMatrix; //


                                                    //TOREADD
                                                    //TOREADD
                                                    //TOREADD
                                                    /*Quaternion.RotationMatrix(ref worldMatrixChunkDroneInstance, out _testQuator);

                                                    var dirInstanceForward = sc_maths._newgetdirforward(_testQuator);
                                                    somechunkmesh[somechunkmeshindex].arrayofindexzeromesh[c].instancesDataFORWARD[cc].instancePos.X = dirInstanceForward.X;
                                                    somechunkmesh[somechunkmeshindex].arrayofindexzeromesh[c].instancesDataFORWARD[cc].instancePos.Y = dirInstanceForward.Y;
                                                    somechunkmesh[somechunkmeshindex].arrayofindexzeromesh[c].instancesDataFORWARD[cc].instancePos.Z = dirInstanceForward.Z;
                                                    somechunkmesh[somechunkmeshindex].arrayofindexzeromesh[c].instancesDataFORWARD[cc].instancePos.W = 1;

                                                    //Quaternion.RotationMatrix(ref tempmat0, out quat_buffers);
                                                    var dirInstanceRight = -sc_maths._newgetdirleft(_testQuator);
                                                    somechunkmesh[somechunkmeshindex].arrayofindexzeromesh[c].instancesDataRIGHT[cc].instancePos.X = dirInstanceRight.X;
                                                    somechunkmesh[somechunkmeshindex].arrayofindexzeromesh[c].instancesDataRIGHT[cc].instancePos.Y = dirInstanceRight.Y;
                                                    somechunkmesh[somechunkmeshindex].arrayofindexzeromesh[c].instancesDataRIGHT[cc].instancePos.Z = dirInstanceRight.Z;
                                                    somechunkmesh[somechunkmeshindex].arrayofindexzeromesh[c].instancesDataRIGHT[cc].instancePos.W = 1;

                                                    //Quaternion.RotationMatrix(ref tempmat0, out quat_buffers);    
                                                    var dirInstanceUp = sc_maths._newgetdirup(_testQuator);
                                                    somechunkmesh[somechunkmeshindex].arrayofindexzeromesh[c].instancesDataUP[cc].instancePos.X = dirInstanceUp.X;
                                                    somechunkmesh[somechunkmeshindex].arrayofindexzeromesh[c].instancesDataUP[cc].instancePos.Y = dirInstanceUp.Y;
                                                    somechunkmesh[somechunkmeshindex].arrayofindexzeromesh[c].instancesDataUP[cc].instancePos.Z = dirInstanceUp.Z;
                                                    somechunkmesh[somechunkmeshindex].arrayofindexzeromesh[c].instancesDataUP[cc].instancePos.W = 1;
                                                    
                                                    //TOREADD
                                                    //TOREADD
                                                    //TOREADD







                                                    //somechunkmesh[somechunkmeshindex].arrayofindexzeromesh[c].arrayOfScriptForInstances[cc].current_pos.M41 = somechunkmesh[somechunkmeshindex].arrayofindexzeromesh[c].instances[cc].instancePos.X;
                                                    //somechunkmesh[somechunkmeshindex].arrayofindexzeromesh[c].arrayOfScriptForInstances[cc].current_pos.M42 = somechunkmesh[somechunkmeshindex].arrayofindexzeromesh[c].instances[cc].instancePos.Y;
                                                    //somechunkmesh[somechunkmeshindex].arrayofindexzeromesh[c].arrayOfScriptForInstances[cc].current_pos.M43 = somechunkmesh[somechunkmeshindex].arrayofindexzeromesh[c].instances[cc].instancePos.Z;


                                                    //somechunkmesh[somechunkmeshindex].arrayofindexzeromesh[c].arrayOfScriptForInstances[cc].current_pos.M41 = somechunkmesh[somechunkmeshindex].arrayofindexzeromesh[c].instances[cc].instancePos.X;
                                                    //somechunkmesh[somechunkmeshindex].arrayofindexzeromesh[c].arrayOfScriptForInstances[cc].current_pos.M42 = somechunkmesh[somechunkmeshindex].arrayofindexzeromesh[c].instances[cc].instancePos.Y;
                                                    //somechunkmesh[somechunkmeshindex].arrayofindexzeromesh[c].arrayOfScriptForInstances[cc].current_pos.M43 = somechunkmesh[somechunkmeshindex].arrayofindexzeromesh[c].instances[cc].instancePos.Z;



                                                    //TO READD
                                                    somechunkmesh[somechunkmeshindex].arrayOfChunkData[c].instancesmatrix[cc].instancematrix.M11 = somechunkmesh[somechunkmeshindex].arrayofindexzeromesh[c].instancesmatrix[cc].instancematrix.M11;
                                                    somechunkmesh[somechunkmeshindex].arrayOfChunkData[c].instancesmatrix[cc].instancematrix.M12 = somechunkmesh[somechunkmeshindex].arrayofindexzeromesh[c].instancesmatrix[cc].instancematrix.M12;
                                                    somechunkmesh[somechunkmeshindex].arrayOfChunkData[c].instancesmatrix[cc].instancematrix.M13 = somechunkmesh[somechunkmeshindex].arrayofindexzeromesh[c].instancesmatrix[cc].instancematrix.M13;
                                                    somechunkmesh[somechunkmeshindex].arrayOfChunkData[c].instancesmatrix[cc].instancematrix.M14 = somechunkmesh[somechunkmeshindex].arrayofindexzeromesh[c].instancesmatrix[cc].instancematrix.M14;

                                                    somechunkmesh[somechunkmeshindex].arrayOfChunkData[c].instancesmatrix[cc].instancematrix.M21 = somechunkmesh[somechunkmeshindex].arrayofindexzeromesh[c].instancesmatrix[cc].instancematrix.M21;
                                                    somechunkmesh[somechunkmeshindex].arrayOfChunkData[c].instancesmatrix[cc].instancematrix.M22 = somechunkmesh[somechunkmeshindex].arrayofindexzeromesh[c].instancesmatrix[cc].instancematrix.M22;
                                                    somechunkmesh[somechunkmeshindex].arrayOfChunkData[c].instancesmatrix[cc].instancematrix.M23 = somechunkmesh[somechunkmeshindex].arrayofindexzeromesh[c].instancesmatrix[cc].instancematrix.M23;
                                                    somechunkmesh[somechunkmeshindex].arrayOfChunkData[c].instancesmatrix[cc].instancematrix.M24 = somechunkmesh[somechunkmeshindex].arrayofindexzeromesh[c].instancesmatrix[cc].instancematrix.M24;


                                                    somechunkmesh[somechunkmeshindex].arrayOfChunkData[c].instancesmatrix[cc].instancematrix.M31 = somechunkmesh[somechunkmeshindex].arrayofindexzeromesh[c].instancesmatrix[cc].instancematrix.M31;
                                                    somechunkmesh[somechunkmeshindex].arrayOfChunkData[c].instancesmatrix[cc].instancematrix.M32 = somechunkmesh[somechunkmeshindex].arrayofindexzeromesh[c].instancesmatrix[cc].instancematrix.M32;
                                                    somechunkmesh[somechunkmeshindex].arrayOfChunkData[c].instancesmatrix[cc].instancematrix.M33 = somechunkmesh[somechunkmeshindex].arrayofindexzeromesh[c].instancesmatrix[cc].instancematrix.M33;
                                                    somechunkmesh[somechunkmeshindex].arrayOfChunkData[c].instancesmatrix[cc].instancematrix.M34 = somechunkmesh[somechunkmeshindex].arrayofindexzeromesh[c].instancesmatrix[cc].instancematrix.M34;


                                                    somechunkmesh[somechunkmeshindex].arrayOfChunkData[c].instancesmatrix[cc].instancematrix.M41 = somechunkmesh[somechunkmeshindex].arrayofindexzeromesh[c].instancesmatrix[cc].instancematrix.M41;
                                                    somechunkmesh[somechunkmeshindex].arrayOfChunkData[c].instancesmatrix[cc].instancematrix.M42 = somechunkmesh[somechunkmeshindex].arrayofindexzeromesh[c].instancesmatrix[cc].instancematrix.M42;
                                                    somechunkmesh[somechunkmeshindex].arrayOfChunkData[c].instancesmatrix[cc].instancematrix.M43 = somechunkmesh[somechunkmeshindex].arrayofindexzeromesh[c].instancesmatrix[cc].instancematrix.M43;
                                                    somechunkmesh[somechunkmeshindex].arrayOfChunkData[c].instancesmatrix[cc].instancematrix.M44 = somechunkmesh[somechunkmeshindex].arrayofindexzeromesh[c].instancesmatrix[cc].instancematrix.M44;


                                                }
                                            }
                                        }



                                        somechunkmesh[somechunkmeshindex].arrayOfChunkData[c].copytobuffer = 0;
                                    }




                                    somechunkmesh[somechunkmeshindex].arrayOfChunkData[c].instancesLocationW = somechunkmesh[somechunkmeshindex].arrayofindexzeromesh[c].instancesLocationW;
                                    somechunkmesh[somechunkmeshindex].arrayOfChunkData[c].instancesLocationH = somechunkmesh[somechunkmeshindex].arrayofindexzeromesh[c].instancesLocationH;

                                    somechunkmesh[somechunkmeshindex].arrayOfChunkData[c].SC_instancedChunk_InstancesFORWARD = somechunkmesh[somechunkmeshindex].arrayofindexzeromesh[c].instancesDataFORWARD;
                                    somechunkmesh[somechunkmeshindex].arrayOfChunkData[c].SC_instancedChunk_InstancesRIGHT = somechunkmesh[somechunkmeshindex].arrayofindexzeromesh[c].instancesDataRIGHT;
                                    somechunkmesh[somechunkmeshindex].arrayOfChunkData[c].SC_instancedChunk_InstancesUP = somechunkmesh[somechunkmeshindex].arrayofindexzeromesh[c].instancesDataUP;

                                    somechunkmesh[somechunkmeshindex].arrayOfChunkData[c].colorsNFaces = somechunkmesh[somechunkmeshindex].arrayofindexzeromesh[c].colorsNFaces;
                                    somechunkmesh[somechunkmeshindex].arrayOfChunkData[c].lightBuffer = somechunkmesh[somechunkmeshindex].lightBufferInstChunk;
                                    somechunkmesh[somechunkmeshindex].arrayOfChunkData[c].SC_instancedChunk_Instances = somechunkmesh[somechunkmeshindex].arrayofindexzeromesh[c].instances;

                                }
                            }
                        }
                    }
                }
            }*/
            //DESTROYABLE VOXEL CHUNK
            //DESTROYABLE VOXEL CHUNK
            //DESTROYABLE VOXEL CHUNK










            /*
            //NON-DESTROYABLE VOXEL CHUNK GRID
            //NON-DESTROYABLE VOXEL CHUNK GRID
            //NON-DESTROYABLE VOXEL CHUNK GRID

            for (int xxx = 0; xxx < somechunkmeshgridsw; xxx++)
            {
                for (int yyy = 0; yyy < somechunkmeshgridsh; yyy++)
                {
                    for (int zzz = 0; zzz < somechunkmeshgridsd; zzz++)
                    {
                        //somechunkmeshgrid
                        var somechunkmeshgridindex = xxx + somechunkmeshgridsw * (yyy + somechunkmeshgridsh * zzz);


                        for (int x = 0; x < someglobalschunkmeshgrid.numberOfObjectInWidth; x++)
                        {
                            for (int y = 0; y < someglobalschunkmeshgrid.numberOfObjectInHeight; y++)
                            {
                                for (int z = 0; z < someglobalschunkmeshgrid.numberOfObjectInDepth; z++)
                                {
                                    int c = x + someglobalschunkmeshgrid.numberOfObjectInWidth * (y + someglobalschunkmeshgrid.numberOfObjectInHeight * z);






                                    for (int xx = 0; xx < someglobalschunkmeshgrid.numberOfInstancesPerObjectInWidth; xx++)
                                    {
                                        for (int yy = 0; yy < someglobalschunkmeshgrid.numberOfInstancesPerObjectInHeight; yy++)
                                        {
                                            for (int zz = 0; zz < someglobalschunkmeshgrid.numberOfInstancesPerObjectInDepth; zz++)
                                            {
                                                int cc = xx + someglobalschunkmeshgrid.numberOfInstancesPerObjectInWidth * (yy + someglobalschunkmeshgrid.numberOfInstancesPerObjectInHeight * zz);

                                                Matrix worldMatrixChunkDroneInstance = somechunkmeshgrid[somechunkmeshgridindex].arrayofindexzeromesh[c].arrayofzeromeshinstances[cc].current_pos;
                                                Quaternion _testQuator;

                                                //TOREADD
                                                //TOREADD
                                                //TOREADD
                                                Quaternion.RotationMatrix(ref worldMatrixChunkDroneInstance, out _testQuator);

                                                var dirInstanceForward = sc_maths._newgetdirforward(_testQuator);
                                                somechunkmeshgrid[somechunkmeshgridindex].arrayofindexzeromesh[c].instancesDataFORWARD[cc].instancePos.X = dirInstanceForward.X;
                                                somechunkmeshgrid[somechunkmeshgridindex].arrayofindexzeromesh[c].instancesDataFORWARD[cc].instancePos.Y = dirInstanceForward.Y;
                                                somechunkmeshgrid[somechunkmeshgridindex].arrayofindexzeromesh[c].instancesDataFORWARD[cc].instancePos.Z = dirInstanceForward.Z;
                                                somechunkmeshgrid[somechunkmeshgridindex].arrayofindexzeromesh[c].instancesDataFORWARD[cc].instancePos.W = 1;

                                                //Quaternion.RotationMatrix(ref tempmat0, out quat_buffers);
                                                var dirInstanceRight = -sc_maths._newgetdirleft(_testQuator);
                                                somechunkmeshgrid[somechunkmeshgridindex].arrayofindexzeromesh[c].instancesDataRIGHT[cc].instancePos.X = dirInstanceRight.X;
                                                somechunkmeshgrid[somechunkmeshgridindex].arrayofindexzeromesh[c].instancesDataRIGHT[cc].instancePos.Y = dirInstanceRight.Y;
                                                somechunkmeshgrid[somechunkmeshgridindex].arrayofindexzeromesh[c].instancesDataRIGHT[cc].instancePos.Z = dirInstanceRight.Z;
                                                somechunkmeshgrid[somechunkmeshgridindex].arrayofindexzeromesh[c].instancesDataRIGHT[cc].instancePos.W = 1;

                                                //Quaternion.RotationMatrix(ref tempmat0, out quat_buffers);    
                                                var dirInstanceUp = sc_maths._newgetdirup(_testQuator);
                                                somechunkmeshgrid[somechunkmeshgridindex].arrayofindexzeromesh[c].instancesDataUP[cc].instancePos.X = dirInstanceUp.X;
                                                somechunkmeshgrid[somechunkmeshgridindex].arrayofindexzeromesh[c].instancesDataUP[cc].instancePos.Y = dirInstanceUp.Y;
                                                somechunkmeshgrid[somechunkmeshgridindex].arrayofindexzeromesh[c].instancesDataUP[cc].instancePos.Z = dirInstanceUp.Z;
                                                somechunkmeshgrid[somechunkmeshgridindex].arrayofindexzeromesh[c].instancesDataUP[cc].instancePos.W = 1;

                                                //TOREADD
                                                //TOREADD
                                                //TOREADD
                                            }
                                        }
                                    }











                                    if (somechunkmeshgrid[somechunkmeshgridindex].arrayOfChunkData[c].copytobuffer == 1)
                                    {
                                        for (int xx = 0; xx < someglobalschunkmeshgrid.numberOfInstancesPerObjectInWidth; xx++)
                                        {
                                            for (int yy = 0; yy < someglobalschunkmeshgrid.numberOfInstancesPerObjectInHeight; yy++)
                                            {
                                                for (int zz = 0; zz < someglobalschunkmeshgrid.numberOfInstancesPerObjectInDepth; zz++)
                                                {
                                                    int cc = xx + someglobalschunkmeshgrid.numberOfInstancesPerObjectInWidth * (yy + someglobalschunkmeshgrid.numberOfInstancesPerObjectInHeight * zz);

                                                    Matrix worldMatrixChunkDroneInstance = somechunkmeshgrid[somechunkmeshgridindex].arrayofindexzeromesh[c].arrayofzeromeshinstances[cc].current_pos;
                                                    Quaternion _testQuator;


                                                    //TO READD FOR SOME LOGIC.
                                                    //Matrix lastPosTarget = _player_rght_hnd[0][0]._arrayOfInstances[0].current_pos;// //_rightTouchMatrix; //
                                                    //Quaternion.RotationMatrix(ref lastPosTarget, out _testQuator);
                                                    //TO READD FOR SOME LOGIC.




                                                    //arrayofindexzeromesh[c].arrayOfScriptForInstances[cc].

                                                    //var dirTargetInstanceForward = sc_maths._newgetdirforward(_testQuator);
                                                    //arrayofindexzeromesh[c].instancesDataFORWARD[cc].instancePos.X = dirTargetInstanceForward.X;
                                                    //arrayofindexzeromesh[c].instancesDataFORWARD[cc].instancePos.Y = dirTargetInstanceForward.Y;
                                                    //arrayofindexzeromesh[c].instancesDataFORWARD[cc].instancePos.Z = dirTargetInstanceForward.Z;
                                                    //arrayofindexzeromesh[c].instancesDataFORWARD[cc].instancePos.W = 1;

                                                    //Quaternion.RotationMatrix(ref tempmat0, out quat_buffers);
                                                    //var dirTargetInstanceRight = sc_maths._newgetdirleft(_testQuator);
                                                    //arrayofindexzeromesh[c].instancesDataRIGHT[cc].instancePos.X = dirTargetInstanceRight.X;
                                                    //arrayofindexzeromesh[c].instancesDataRIGHT[cc].instancePos.Y = dirTargetInstanceRight.Y;
                                                    //arrayofindexzeromesh[c].instancesDataRIGHT[cc].instancePos.Z = dirTargetInstanceRight.Z;
                                                    //arrayofindexzeromesh[c].instancesDataRIGHT[cc].instancePos.W = 1;

                                                    //Quaternion.RotationMatrix(ref tempmat0, out quat_buffers);
                                                    //var dirTargetInstanceUp = sc_maths._newgetdirup(_testQuator);
                                                    //arrayofindexzeromesh[c].instancesDataUP[cc].instancePos.X = dirTargetInstanceUp.X;
                                                    //arrayofindexzeromesh[c].instancesDataUP[cc].instancePos.Y = dirTargetInstanceUp.Y;
                                                    //arrayofindexzeromesh[c].instancesDataUP[cc].instancePos.Z = dirTargetInstanceUp.Z;
                                                    //arrayofindexzeromesh[c].instancesDataUP[cc].instancePos.W = 1;

                                                    //worldMatrixChunkDroneInstance = arrayofindexzeromesh[c].arrayOfScriptForInstances[cc].current_pos;
                                                    //Matrix lastPosDrone = _player_rght_hnd[0][0]._arrayOfInstances[0].current_pos;// //_rightTouchMatrix; //


                                                    //TOREADD
                                                    //TOREADD
                                                    //TOREADD
                                                    /*Quaternion.RotationMatrix(ref worldMatrixChunkDroneInstance, out _testQuator);

                                                    var dirInstanceForward = sc_maths._newgetdirforward(_testQuator);
                                                    somechunkmeshgrid[somechunkmeshgridindex].arrayofindexzeromesh[c].instancesDataFORWARD[cc].instancePos.X = dirInstanceForward.X;
                                                    somechunkmeshgrid[somechunkmeshgridindex].arrayofindexzeromesh[c].instancesDataFORWARD[cc].instancePos.Y = dirInstanceForward.Y;
                                                    somechunkmeshgrid[somechunkmeshgridindex].arrayofindexzeromesh[c].instancesDataFORWARD[cc].instancePos.Z = dirInstanceForward.Z;
                                                    somechunkmeshgrid[somechunkmeshgridindex].arrayofindexzeromesh[c].instancesDataFORWARD[cc].instancePos.W = 1;

                                                    //Quaternion.RotationMatrix(ref tempmat0, out quat_buffers);
                                                    var dirInstanceRight = -sc_maths._newgetdirleft(_testQuator);
                                                    somechunkmeshgrid[somechunkmeshgridindex].arrayofindexzeromesh[c].instancesDataRIGHT[cc].instancePos.X = dirInstanceRight.X;
                                                    somechunkmeshgrid[somechunkmeshgridindex].arrayofindexzeromesh[c].instancesDataRIGHT[cc].instancePos.Y = dirInstanceRight.Y;
                                                    somechunkmeshgrid[somechunkmeshgridindex].arrayofindexzeromesh[c].instancesDataRIGHT[cc].instancePos.Z = dirInstanceRight.Z;
                                                    somechunkmeshgrid[somechunkmeshgridindex].arrayofindexzeromesh[c].instancesDataRIGHT[cc].instancePos.W = 1;

                                                    //Quaternion.RotationMatrix(ref tempmat0, out quat_buffers);    
                                                    var dirInstanceUp = sc_maths._newgetdirup(_testQuator);
                                                    somechunkmeshgrid[somechunkmeshgridindex].arrayofindexzeromesh[c].instancesDataUP[cc].instancePos.X = dirInstanceUp.X;
                                                    somechunkmeshgrid[somechunkmeshgridindex].arrayofindexzeromesh[c].instancesDataUP[cc].instancePos.Y = dirInstanceUp.Y;
                                                    somechunkmeshgrid[somechunkmeshgridindex].arrayofindexzeromesh[c].instancesDataUP[cc].instancePos.Z = dirInstanceUp.Z;
                                                    somechunkmeshgrid[somechunkmeshgridindex].arrayofindexzeromesh[c].instancesDataUP[cc].instancePos.W = 1;

                                                    //TOREADD
                                                    //TOREADD
                                                    //TOREADD
                                                    






                                                    //somechunkmeshgrid[somechunkmeshgridindex].arrayofindexzeromesh[c].arrayOfScriptForInstances[cc].current_pos.M41 = somechunkmeshgrid[somechunkmeshgridindex].arrayofindexzeromesh[c].instances[cc].instancePos.X;
                                                    //somechunkmeshgrid[somechunkmeshgridindex].arrayofindexzeromesh[c].arrayOfScriptForInstances[cc].current_pos.M42 = somechunkmeshgrid[somechunkmeshgridindex].arrayofindexzeromesh[c].instances[cc].instancePos.Y;
                                                    //somechunkmeshgrid[somechunkmeshgridindex].arrayofindexzeromesh[c].arrayOfScriptForInstances[cc].current_pos.M43 = somechunkmeshgrid[somechunkmeshgridindex].arrayofindexzeromesh[c].instances[cc].instancePos.Z;


                                                    //somechunkmeshgrid[somechunkmeshgridindex].arrayofindexzeromesh[c].arrayOfScriptForInstances[cc].current_pos.M41 = somechunkmeshgrid[somechunkmeshgridindex].arrayofindexzeromesh[c].instances[cc].instancePos.X;
                                                    //somechunkmeshgrid[somechunkmeshgridindex].arrayofindexzeromesh[c].arrayOfScriptForInstances[cc].current_pos.M42 = somechunkmeshgrid[somechunkmeshgridindex].arrayofindexzeromesh[c].instances[cc].instancePos.Y;
                                                    //somechunkmeshgrid[somechunkmeshgridindex].arrayofindexzeromesh[c].arrayOfScriptForInstances[cc].current_pos.M43 = somechunkmeshgrid[somechunkmeshgridindex].arrayofindexzeromesh[c].instances[cc].instancePos.Z;



                                                    //TO READD
                                                    somechunkmeshgrid[somechunkmeshgridindex].arrayOfChunkData[c].instancesmatrix[cc].instancematrix.M11 = somechunkmeshgrid[somechunkmeshgridindex].arrayofindexzeromesh[c].instancesmatrix[cc].instancematrix.M11;
                                                    somechunkmeshgrid[somechunkmeshgridindex].arrayOfChunkData[c].instancesmatrix[cc].instancematrix.M12 = somechunkmeshgrid[somechunkmeshgridindex].arrayofindexzeromesh[c].instancesmatrix[cc].instancematrix.M12;
                                                    somechunkmeshgrid[somechunkmeshgridindex].arrayOfChunkData[c].instancesmatrix[cc].instancematrix.M13 = somechunkmeshgrid[somechunkmeshgridindex].arrayofindexzeromesh[c].instancesmatrix[cc].instancematrix.M13;
                                                    somechunkmeshgrid[somechunkmeshgridindex].arrayOfChunkData[c].instancesmatrix[cc].instancematrix.M14 = somechunkmeshgrid[somechunkmeshgridindex].arrayofindexzeromesh[c].instancesmatrix[cc].instancematrix.M14;

                                                    somechunkmeshgrid[somechunkmeshgridindex].arrayOfChunkData[c].instancesmatrix[cc].instancematrix.M21 = somechunkmeshgrid[somechunkmeshgridindex].arrayofindexzeromesh[c].instancesmatrix[cc].instancematrix.M21;
                                                    somechunkmeshgrid[somechunkmeshgridindex].arrayOfChunkData[c].instancesmatrix[cc].instancematrix.M22 = somechunkmeshgrid[somechunkmeshgridindex].arrayofindexzeromesh[c].instancesmatrix[cc].instancematrix.M22;
                                                    somechunkmeshgrid[somechunkmeshgridindex].arrayOfChunkData[c].instancesmatrix[cc].instancematrix.M23 = somechunkmeshgrid[somechunkmeshgridindex].arrayofindexzeromesh[c].instancesmatrix[cc].instancematrix.M23;
                                                    somechunkmeshgrid[somechunkmeshgridindex].arrayOfChunkData[c].instancesmatrix[cc].instancematrix.M24 = somechunkmeshgrid[somechunkmeshgridindex].arrayofindexzeromesh[c].instancesmatrix[cc].instancematrix.M24;


                                                    somechunkmeshgrid[somechunkmeshgridindex].arrayOfChunkData[c].instancesmatrix[cc].instancematrix.M31 = somechunkmeshgrid[somechunkmeshgridindex].arrayofindexzeromesh[c].instancesmatrix[cc].instancematrix.M31;
                                                    somechunkmeshgrid[somechunkmeshgridindex].arrayOfChunkData[c].instancesmatrix[cc].instancematrix.M32 = somechunkmeshgrid[somechunkmeshgridindex].arrayofindexzeromesh[c].instancesmatrix[cc].instancematrix.M32;
                                                    somechunkmeshgrid[somechunkmeshgridindex].arrayOfChunkData[c].instancesmatrix[cc].instancematrix.M33 = somechunkmeshgrid[somechunkmeshgridindex].arrayofindexzeromesh[c].instancesmatrix[cc].instancematrix.M33;
                                                    somechunkmeshgrid[somechunkmeshgridindex].arrayOfChunkData[c].instancesmatrix[cc].instancematrix.M34 = somechunkmeshgrid[somechunkmeshgridindex].arrayofindexzeromesh[c].instancesmatrix[cc].instancematrix.M34;


                                                    somechunkmeshgrid[somechunkmeshgridindex].arrayOfChunkData[c].instancesmatrix[cc].instancematrix.M41 = somechunkmeshgrid[somechunkmeshgridindex].arrayofindexzeromesh[c].instancesmatrix[cc].instancematrix.M41;
                                                    somechunkmeshgrid[somechunkmeshgridindex].arrayOfChunkData[c].instancesmatrix[cc].instancematrix.M42 = somechunkmeshgrid[somechunkmeshgridindex].arrayofindexzeromesh[c].instancesmatrix[cc].instancematrix.M42;
                                                    somechunkmeshgrid[somechunkmeshgridindex].arrayOfChunkData[c].instancesmatrix[cc].instancematrix.M43 = somechunkmeshgrid[somechunkmeshgridindex].arrayofindexzeromesh[c].instancesmatrix[cc].instancematrix.M43;
                                                    somechunkmeshgrid[somechunkmeshgridindex].arrayOfChunkData[c].instancesmatrix[cc].instancematrix.M44 = somechunkmeshgrid[somechunkmeshgridindex].arrayofindexzeromesh[c].instancesmatrix[cc].instancematrix.M44;


                                                }
                                            }
                                        }
                                        somechunkmeshgrid[somechunkmeshgridindex].arrayOfChunkData[c].copytobuffer = 0;
                                    }





                                    somechunkmeshgrid[somechunkmeshgridindex].arrayOfChunkData[c].instancesLocationW = somechunkmeshgrid[somechunkmeshgridindex].arrayofindexzeromesh[c].instancesLocationW;
                                    somechunkmeshgrid[somechunkmeshgridindex].arrayOfChunkData[c].instancesLocationH = somechunkmeshgrid[somechunkmeshgridindex].arrayofindexzeromesh[c].instancesLocationH;


                                    somechunkmeshgrid[somechunkmeshgridindex].arrayOfChunkData[c].SC_instancedChunk_InstancesFORWARD = somechunkmeshgrid[somechunkmeshgridindex].arrayofindexzeromesh[c].instancesDataFORWARD;
                                    somechunkmeshgrid[somechunkmeshgridindex].arrayOfChunkData[c].SC_instancedChunk_InstancesRIGHT = somechunkmeshgrid[somechunkmeshgridindex].arrayofindexzeromesh[c].instancesDataRIGHT;
                                    somechunkmeshgrid[somechunkmeshgridindex].arrayOfChunkData[c].SC_instancedChunk_InstancesUP = somechunkmeshgrid[somechunkmeshgridindex].arrayofindexzeromesh[c].instancesDataUP;


                                    somechunkmeshgrid[somechunkmeshgridindex].arrayOfChunkData[c].colorsNFaces = somechunkmeshgrid[somechunkmeshgridindex].arrayofindexzeromesh[c].colorsNFaces;
                                    somechunkmeshgrid[somechunkmeshgridindex].arrayOfChunkData[c].lightBuffer = somechunkmeshgrid[somechunkmeshgridindex].lightBufferInstChunk;
                                    somechunkmeshgrid[somechunkmeshgridindex].arrayOfChunkData[c].SC_instancedChunk_Instances = somechunkmeshgrid[somechunkmeshgridindex].arrayofindexzeromesh[c].instances;

                                }
                            }
                        }
                    }
                }
            }*/
            //NON-DESTROYABLE VOXEL CHUNK GRID
            //NON-DESTROYABLE VOXEL CHUNK GRID
            //NON-DESTROYABLE VOXEL CHUNK GRID

































            //DESTROYABLE VOXEL KEYBOARD
            //DESTROYABLE VOXEL KEYBOARD
            //DESTROYABLE VOXEL KEYBOARD
            /*
            for (int xxx = 0; xxx < somechunkkeyboardw; xxx++)
            {
                for (int yyy = 0; yyy < somechunkkeyboardh; yyy++)
                {
                    for (int zzz = 0; zzz < somechunkkeyboardd; zzz++)
                    {
                        //somechunkmesh
                        var somechunkkeyboardindex = xxx + somechunkkeyboardw * (yyy + somechunkkeyboardh * zzz);


                        for (int x = 0; x < somechunkkeyboardglobals.numberOfObjectInWidth; x++)
                        {
                            for (int y = 0; y < somechunkkeyboardglobals.numberOfObjectInHeight; y++)
                            {
                                for (int z = 0; z < somechunkkeyboardglobals.numberOfObjectInDepth; z++)
                                {
                                    int c = x + somechunkkeyboardglobals.numberOfObjectInWidth * (y + somechunkkeyboardglobals.numberOfObjectInHeight * z);













                                    for (int xx = 0; xx < somechunkkeyboardglobals.numberOfInstancesPerObjectInWidth; xx++)
                                    {
                                        for (int yy = 0; yy < somechunkkeyboardglobals.numberOfInstancesPerObjectInHeight; yy++)
                                        {
                                            for (int zz = 0; zz < somechunkkeyboardglobals.numberOfInstancesPerObjectInDepth; zz++)
                                            {
                                                int cc = xx + somechunkkeyboardglobals.numberOfInstancesPerObjectInWidth * (yy + somechunkkeyboardglobals.numberOfInstancesPerObjectInHeight * zz);

                                                Matrix worldMatrixChunkDroneInstance = somechunkkeyboard[somechunkkeyboardindex].arrayofindexzeromesh[c].arrayofzeromeshinstances[cc].current_pos;

                                                Matrix worldMatrixmain = somechunkkeyboard[somechunkkeyboardindex].worldmatofobj;


                                                Quaternion _testQuator;


                                                //worldMatrixChunkDroneInstance = worldMatrixChunkDroneInstance * somechunkkeyboard[somechunkkeyboardindex].worldmatofobj;

                                                //TOREADD
                                                //TOREADD
                                                //TOREADD
                                                Quaternion.RotationMatrix(ref worldMatrixChunkDroneInstance, out _testQuator);

                                                var dirInstanceForward = sc_maths._newgetdirforward(_testQuator);
                                                somechunkkeyboard[somechunkkeyboardindex].arrayofindexzeromesh[c].instancesDataFORWARD[cc].instancePos.X = dirInstanceForward.X;
                                                somechunkkeyboard[somechunkkeyboardindex].arrayofindexzeromesh[c].instancesDataFORWARD[cc].instancePos.Y = dirInstanceForward.Y;
                                                somechunkkeyboard[somechunkkeyboardindex].arrayofindexzeromesh[c].instancesDataFORWARD[cc].instancePos.Z = dirInstanceForward.Z;
                                                somechunkkeyboard[somechunkkeyboardindex].arrayofindexzeromesh[c].instancesDataFORWARD[cc].instancePos.W = 1;

                                                //Quaternion.RotationMatrix(ref tempmat0, out quat_buffers);
                                                var dirInstanceRight = -sc_maths._newgetdirleft(_testQuator);
                                                somechunkkeyboard[somechunkkeyboardindex].arrayofindexzeromesh[c].instancesDataRIGHT[cc].instancePos.X = dirInstanceRight.X;
                                                somechunkkeyboard[somechunkkeyboardindex].arrayofindexzeromesh[c].instancesDataRIGHT[cc].instancePos.Y = dirInstanceRight.Y;
                                                somechunkkeyboard[somechunkkeyboardindex].arrayofindexzeromesh[c].instancesDataRIGHT[cc].instancePos.Z = dirInstanceRight.Z;
                                                somechunkkeyboard[somechunkkeyboardindex].arrayofindexzeromesh[c].instancesDataRIGHT[cc].instancePos.W = 1;

                                                //Quaternion.RotationMatrix(ref tempmat0, out quat_buffers);    
                                                var dirInstanceUp = sc_maths._newgetdirup(_testQuator);
                                                somechunkkeyboard[somechunkkeyboardindex].arrayofindexzeromesh[c].instancesDataUP[cc].instancePos.X = dirInstanceUp.X;
                                                somechunkkeyboard[somechunkkeyboardindex].arrayofindexzeromesh[c].instancesDataUP[cc].instancePos.Y = dirInstanceUp.Y;
                                                somechunkkeyboard[somechunkkeyboardindex].arrayofindexzeromesh[c].instancesDataUP[cc].instancePos.Z = dirInstanceUp.Z;
                                                somechunkkeyboard[somechunkkeyboardindex].arrayofindexzeromesh[c].instancesDataUP[cc].instancePos.W = 1;

                                                //TOREADD
                                                //TOREADD
                                                //TOREADD





                                                /*
                                                Quaternion.RotationMatrix(ref worldMatrixChunkDroneInstance, out _testQuator);

                                                var dirInstanceForward = sc_maths._newgetdirforward(_testQuator);
                                                somechunkkeyboard[somechunkkeyboardindex].arrayOfChunkData[c].SC_instancedChunk_InstancesFORWARD[cc].instancePos.X = dirInstanceForward.X;
                                                somechunkkeyboard[somechunkkeyboardindex].arrayOfChunkData[c].SC_instancedChunk_InstancesFORWARD[cc].instancePos.Y = dirInstanceForward.Y;
                                                somechunkkeyboard[somechunkkeyboardindex].arrayOfChunkData[c].SC_instancedChunk_InstancesFORWARD[cc].instancePos.Z = dirInstanceForward.Z;
                                                somechunkkeyboard[somechunkkeyboardindex].arrayOfChunkData[c].SC_instancedChunk_InstancesFORWARD[cc].instancePos.W = 1;

                                                //Quaternion.RotationMatrix(ref tempmat0, out quat_buffers);
                                                var dirInstanceRight = -sc_maths._newgetdirleft(_testQuator);
                                                somechunkkeyboard[somechunkkeyboardindex].arrayOfChunkData[c].SC_instancedChunk_InstancesRIGHT[cc].instancePos.X = dirInstanceRight.X;
                                                somechunkkeyboard[somechunkkeyboardindex].arrayOfChunkData[c].SC_instancedChunk_InstancesRIGHT[cc].instancePos.Y = dirInstanceRight.Y;
                                                somechunkkeyboard[somechunkkeyboardindex].arrayOfChunkData[c].SC_instancedChunk_InstancesRIGHT[cc].instancePos.Z = dirInstanceRight.Z;
                                                somechunkkeyboard[somechunkkeyboardindex].arrayOfChunkData[c].SC_instancedChunk_InstancesRIGHT[cc].instancePos.W = 1;

                                                //Quaternion.RotationMatrix(ref tempmat0, out quat_buffers);    
                                                var dirInstanceUp = sc_maths._newgetdirup(_testQuator);
                                                somechunkkeyboard[somechunkkeyboardindex].arrayOfChunkData[c].SC_instancedChunk_InstancesUP[cc].instancePos.X = dirInstanceUp.X;
                                                somechunkkeyboard[somechunkkeyboardindex].arrayOfChunkData[c].SC_instancedChunk_InstancesUP[cc].instancePos.Y = dirInstanceUp.Y;
                                                somechunkkeyboard[somechunkkeyboardindex].arrayOfChunkData[c].SC_instancedChunk_InstancesUP[cc].instancePos.Z = dirInstanceUp.Z;
                                                somechunkkeyboard[somechunkkeyboardindex].arrayOfChunkData[c].SC_instancedChunk_InstancesUP[cc].instancePos.W = 1;


                                                Vector3 currentmainobjectpos = new Vector3(somechunkkeyboard[somechunkkeyboardindex].worldmatofobj.M41, somechunkkeyboard[somechunkkeyboardindex].worldmatofobj.M42, somechunkkeyboard[somechunkkeyboardindex].worldmatofobj.M43);

                                                float diffmainpostoinstanceposx = somechunkkeyboard[somechunkkeyboardindex].arrayofindexzeromesh[c].instances[cc].instancePos.X - currentmainobjectpos.X;
                                                float diffmainpostoinstanceposy = somechunkkeyboard[somechunkkeyboardindex].arrayofindexzeromesh[c].instances[cc].instancePos.Y - currentmainobjectpos.Y;
                                                float diffmainpostoinstanceposz = somechunkkeyboard[somechunkkeyboardindex].arrayofindexzeromesh[c].instances[cc].instancePos.Z - currentmainobjectpos.Z;
                                                */




                                                /*Quaternion somedirquat;

                                                Quaternion.RotationMatrix(ref worldMatrixChunkDroneInstance, out somedirquat);

                                                var dirInstanceForward = sc_maths._newgetdirforward(somedirquat);
                                                var dirInstanceRight = -sc_maths._newgetdirleft(somedirquat);
                                                var dirInstanceUp = sc_maths._newgetdirup(somedirquat);*/

                                                /*Vector4 somevecx = new Vector4(dirInstanceRight.X, dirInstanceRight.Y, dirInstanceRight.Z, 1.0f);
                                                Vector4 somevecy = new Vector4(dirInstanceUp.X, dirInstanceUp.Y, dirInstanceUp.Z, 1.0f);
                                                Vector4 somevecz = new Vector4(dirInstanceForward.X, dirInstanceForward.Y, dirInstanceForward.Z, 1.0f);

                                                Vector4 someinstancepostest = Vector4.Zero;
                                                Vector4 somemainpos = new Vector4(worldMatrixmain.M41, worldMatrixmain.M42, worldMatrixmain.M43, 1.0f);

                                                someinstancepostest = somechunkkeyboard[somechunkkeyboardindex].arrayofindexzeromesh[c].instances[cc].instancePos + (somevecx);// * (xx * 4 * 4 * 0.01f * 0.5f * 0.5f));
                                                someinstancepostest = somechunkkeyboard[somechunkkeyboardindex].arrayofindexzeromesh[c].instances[cc].instancePos + (somevecy);//  * (yy * 4 * 4 * 0.01f * 0.5f * 0.5f));
                                                someinstancepostest = somechunkkeyboard[somechunkkeyboardindex].arrayofindexzeromesh[c].instances[cc].instancePos + (somevecz);//  * (zz * 4 * 4 * 0.01f * 0.5f * 0.5f));
                                                */
                                                //somechunkkeyboard[somechunkkeyboardindex].arrayofindexzeromesh[c].instances[cc].instancePos.X += somemainpos.X + someinstancepostest.X;
                                                //somechunkkeyboard[somechunkkeyboardindex].arrayofindexzeromesh[c].instances[cc].instancePos.Y += somemainpos.Y + someinstancepostest.Y;
                                                //somechunkkeyboard[somechunkkeyboardindex].arrayofindexzeromesh[c].instances[cc].instancePos.Z += somemainpos.Z + someinstancepostest.Z;
                                                /*
                                                somechunkkeyboard[somechunkkeyboardindex].arrayofindexzeromesh[c].instances[cc].instancePos.X = someinstancepostest.X;
                                                somechunkkeyboard[somechunkkeyboardindex].arrayofindexzeromesh[c].instances[cc].instancePos.Y = someinstancepostest.Y;
                                                somechunkkeyboard[somechunkkeyboardindex].arrayofindexzeromesh[c].instances[cc].instancePos.Z = someinstancepostest.Z;
                                                */


                                                //somechunkkeyboard[somechunkkeyboardindex].arrayOfChunkData[c].SC_instancedChunk_Instances[cc].instancePos.X = somechunkkeyboard[somechunkkeyboardindex].arrayOfChunkData[c].SC_instancedChunk_Instances[cc].instancePos.X + -(somechunkkeyboard[somechunkkeyboardindex].arrayOfChunkData[c].SC_instancedChunk_InstancesFORWARD[cc].instancePos.X * diffmainpostoinstanceposx);
                                                //somechunkkeyboard[somechunkkeyboardindex].arrayOfChunkData[c].SC_instancedChunk_Instances[cc].instancePos.Y = somechunkkeyboard[somechunkkeyboardindex].arrayOfChunkData[c].SC_instancedChunk_Instances[cc].instancePos.Y + -(somechunkkeyboard[somechunkkeyboardindex].arrayOfChunkData[c].SC_instancedChunk_InstancesFORWARD[cc].instancePos.Y * diffmainpostoinstanceposy);
                                                //somechunkkeyboard[somechunkkeyboardindex].arrayOfChunkData[c].SC_instancedChunk_Instances[cc].instancePos.Z = somechunkkeyboard[somechunkkeyboardindex].arrayOfChunkData[c].SC_instancedChunk_Instances[cc].instancePos.Z + -(somechunkkeyboard[somechunkkeyboardindex].arrayOfChunkData[c].SC_instancedChunk_InstancesFORWARD[cc].instancePos.Z * diffmainpostoinstanceposz);

                                                //somechunkkeyboard[somechunkkeyboardindex].arrayOfChunkData[c].SC_instancedChunk_Instances[cc].instancePos.X = currentmainobjectpos.X + (somechunkkeyboard[somechunkkeyboardindex].arrayofindexzeromesh[c].instan[cc].instancePos.X + (dirInstanceRight.X * diffmainpostoinstanceposx));
                                                //somechunkkeyboard[somechunkkeyboardindex].arrayOfChunkData[c].SC_instancedChunk_Instances[cc].instancePos.Y = currentmainobjectpos.Y + (somechunkkeyboard[somechunkkeyboardindex].arrayofindexzeromesh[c].instances[cc].instancePos.Y + (dirInstanceUp.Y * diffmainpostoinstanceposy));
                                                //somechunkkeyboard[somechunkkeyboardindex].arrayOfChunkData[c].SC_instancedChunk_Instances[cc].instancePos.Z = currentmainobjectpos.Z + (somechunkkeyboard[somechunkkeyboardindex].arrayofindexzeromesh[c].instances[cc].instancePos.Z + (dirInstanceForward.Z * diffmainpostoinstanceposz));


                                                /*Vector4 somevecx = new Vector4(dirInstanceRight.X, dirInstanceRight.Y, dirInstanceRight.Z, 1.0f);
                                                Vector4 somevecy = new Vector4(dirInstanceUp.X, dirInstanceUp.Y, dirInstanceUp.Z, 1.0f);
                                                Vector4 somevecz = new Vector4(dirInstanceForward.X, dirInstanceForward.Y, dirInstanceForward.Z, 1.0f);

                                                somechunkkeyboard[somechunkkeyboardindex].arrayOfChunkData[c].SC_instancedChunk_Instances[cc].instancePos = somechunkkeyboard[somechunkkeyboardindex].arrayOfChunkData[c].SC_instancedChunk_Instances[cc].instancePos + (somevecx * diffmainpostoinstanceposx);
                                                somechunkkeyboard[somechunkkeyboardindex].arrayOfChunkData[c].SC_instancedChunk_Instances[cc].instancePos = somechunkkeyboard[somechunkkeyboardindex].arrayOfChunkData[c].SC_instancedChunk_Instances[cc].instancePos + (somevecy * diffmainpostoinstanceposy);
                                                somechunkkeyboard[somechunkkeyboardindex].arrayOfChunkData[c].SC_instancedChunk_Instances[cc].instancePos = somechunkkeyboard[somechunkkeyboardindex].arrayOfChunkData[c].SC_instancedChunk_Instances[cc].instancePos + (somevecz * diffmainpostoinstanceposz);
                                                





                                            }
                                        }
                                    }






                                    if (somechunkkeyboard[somechunkkeyboardindex].arrayOfChunkData[c].copytobuffer == 1)
                                    {
                                        for (int xx = 0; xx < somechunkkeyboardglobals.numberOfInstancesPerObjectInWidth; xx++)
                                        {
                                            for (int yy = 0; yy < somechunkkeyboardglobals.numberOfInstancesPerObjectInHeight; yy++)
                                            {
                                                for (int zz = 0; zz < somechunkkeyboardglobals.numberOfInstancesPerObjectInDepth; zz++)
                                                {
                                                    int cc = xx + somechunkkeyboardglobals.numberOfInstancesPerObjectInWidth * (yy + somechunkkeyboardglobals.numberOfInstancesPerObjectInHeight * zz);

                                                    //Matrix worldMatrixChunkDroneInstance = somechunkkeyboard[somechunkkeyboardindex].arrayofindexzeromesh[c].arrayofzeromeshinstances[cc].current_pos;
                                                    //Quaternion _testQuator;


                                                    //TO READD FOR SOME LOGIC.
                                                    //Matrix lastPosTarget = _player_rght_hnd[0][0]._arrayOfInstances[0].current_pos;// //_rightTouchMatrix; //
                                                    //Quaternion.RotationMatrix(ref lastPosTarget, out _testQuator);
                                                    //TO READD FOR SOME LOGIC.




                                                    //arrayofindexzeromesh[c].arrayOfScriptForInstances[cc].

                                                    //var dirTargetInstanceForward = sc_maths._newgetdirforward(_testQuator);
                                                    //arrayofindexzeromesh[c].instancesDataFORWARD[cc].instancePos.X = dirTargetInstanceForward.X;
                                                    //arrayofindexzeromesh[c].instancesDataFORWARD[cc].instancePos.Y = dirTargetInstanceForward.Y;
                                                    //arrayofindexzeromesh[c].instancesDataFORWARD[cc].instancePos.Z = dirTargetInstanceForward.Z;
                                                    //arrayofindexzeromesh[c].instancesDataFORWARD[cc].instancePos.W = 1;

                                                    //Quaternion.RotationMatrix(ref tempmat0, out quat_buffers);
                                                    //var dirTargetInstanceRight = sc_maths._newgetdirleft(_testQuator);
                                                    //arrayofindexzeromesh[c].instancesDataRIGHT[cc].instancePos.X = dirTargetInstanceRight.X;
                                                    //arrayofindexzeromesh[c].instancesDataRIGHT[cc].instancePos.Y = dirTargetInstanceRight.Y;
                                                    //arrayofindexzeromesh[c].instancesDataRIGHT[cc].instancePos.Z = dirTargetInstanceRight.Z;
                                                    //arrayofindexzeromesh[c].instancesDataRIGHT[cc].instancePos.W = 1;

                                                    //Quaternion.RotationMatrix(ref tempmat0, out quat_buffers);
                                                    //var dirTargetInstanceUp = sc_maths._newgetdirup(_testQuator);
                                                    //arrayofindexzeromesh[c].instancesDataUP[cc].instancePos.X = dirTargetInstanceUp.X;
                                                    //arrayofindexzeromesh[c].instancesDataUP[cc].instancePos.Y = dirTargetInstanceUp.Y;
                                                    //arrayofindexzeromesh[c].instancesDataUP[cc].instancePos.Z = dirTargetInstanceUp.Z;
                                                    //arrayofindexzeromesh[c].instancesDataUP[cc].instancePos.W = 1;

                                                    //worldMatrixChunkDroneInstance = arrayofindexzeromesh[c].arrayOfScriptForInstances[cc].current_pos;
                                                    //Matrix lastPosDrone = _player_rght_hnd[0][0]._arrayOfInstances[0].current_pos;// //_rightTouchMatrix; //


                                                    //TOREADD
                                                    //TOREADD
                                                    //TOREADD
                                                    /*Quaternion.RotationMatrix(ref worldMatrixChunkDroneInstance, out _testQuator);

                                                    var dirInstanceForward = sc_maths._newgetdirforward(_testQuator);
                                                    somechunkkeyboard[somechunkkeyboardindex].arrayofindexzeromesh[c].instancesDataFORWARD[cc].instancePos.X = dirInstanceForward.X;
                                                    somechunkkeyboard[somechunkkeyboardindex].arrayofindexzeromesh[c].instancesDataFORWARD[cc].instancePos.Y = dirInstanceForward.Y;
                                                    somechunkkeyboard[somechunkkeyboardindex].arrayofindexzeromesh[c].instancesDataFORWARD[cc].instancePos.Z = dirInstanceForward.Z;
                                                    somechunkkeyboard[somechunkkeyboardindex].arrayofindexzeromesh[c].instancesDataFORWARD[cc].instancePos.W = 1;

                                                    //Quaternion.RotationMatrix(ref tempmat0, out quat_buffers);
                                                    var dirInstanceRight = -sc_maths._newgetdirleft(_testQuator);
                                                    somechunkkeyboard[somechunkkeyboardindex].arrayofindexzeromesh[c].instancesDataRIGHT[cc].instancePos.X = dirInstanceRight.X;
                                                    somechunkkeyboard[somechunkkeyboardindex].arrayofindexzeromesh[c].instancesDataRIGHT[cc].instancePos.Y = dirInstanceRight.Y;
                                                    somechunkkeyboard[somechunkkeyboardindex].arrayofindexzeromesh[c].instancesDataRIGHT[cc].instancePos.Z = dirInstanceRight.Z;
                                                    somechunkkeyboard[somechunkkeyboardindex].arrayofindexzeromesh[c].instancesDataRIGHT[cc].instancePos.W = 1;

                                                    //Quaternion.RotationMatrix(ref tempmat0, out quat_buffers);    
                                                    var dirInstanceUp = sc_maths._newgetdirup(_testQuator);
                                                    somechunkkeyboard[somechunkkeyboardindex].arrayofindexzeromesh[c].instancesDataUP[cc].instancePos.X = dirInstanceUp.X;
                                                    somechunkkeyboard[somechunkkeyboardindex].arrayofindexzeromesh[c].instancesDataUP[cc].instancePos.Y = dirInstanceUp.Y;
                                                    somechunkkeyboard[somechunkkeyboardindex].arrayofindexzeromesh[c].instancesDataUP[cc].instancePos.Z = dirInstanceUp.Z;
                                                    somechunkkeyboard[somechunkkeyboardindex].arrayofindexzeromesh[c].instancesDataUP[cc].instancePos.W = 1;
                                                    
                                                    //TOREADD
                                                    //TOREADD
                                                    //TOREADD







                                                    //somechunkkeyboard[somechunkkeyboardindex].arrayofindexzeromesh[c].arrayOfScriptForInstances[cc].current_pos.M41 = somechunkkeyboard[somechunkkeyboardindex].arrayofindexzeromesh[c].instances[cc].instancePos.X;
                                                    //somechunkkeyboard[somechunkkeyboardindex].arrayofindexzeromesh[c].arrayOfScriptForInstances[cc].current_pos.M42 = somechunkkeyboard[somechunkkeyboardindex].arrayofindexzeromesh[c].instances[cc].instancePos.Y;
                                                    //somechunkkeyboard[somechunkkeyboardindex].arrayofindexzeromesh[c].arrayOfScriptForInstances[cc].current_pos.M43 = somechunkkeyboard[somechunkkeyboardindex].arrayofindexzeromesh[c].instances[cc].instancePos.Z;


                                                    //somechunkkeyboard[somechunkkeyboardindex].arrayofindexzeromesh[c].arrayOfScriptForInstances[cc].current_pos.M41 = somechunkkeyboard[somechunkkeyboardindex].arrayofindexzeromesh[c].instances[cc].instancePos.X;
                                                    //somechunkkeyboard[somechunkkeyboardindex].arrayofindexzeromesh[c].arrayOfScriptForInstances[cc].current_pos.M42 = somechunkkeyboard[somechunkkeyboardindex].arrayofindexzeromesh[c].instances[cc].instancePos.Y;
                                                    //somechunkkeyboard[somechunkkeyboardindex].arrayofindexzeromesh[c].arrayOfScriptForInstances[cc].current_pos.M43 = somechunkkeyboard[somechunkkeyboardindex].arrayofindexzeromesh[c].instances[cc].instancePos.Z;



                                                    //TO READD
                                                    somechunkkeyboard[somechunkkeyboardindex].arrayOfChunkData[c].instancesmatrix[cc].instancematrix.M11 = somechunkkeyboard[somechunkkeyboardindex].arrayofindexzeromesh[c].instancesmatrix[cc].instancematrix.M11;
                                                    somechunkkeyboard[somechunkkeyboardindex].arrayOfChunkData[c].instancesmatrix[cc].instancematrix.M12 = somechunkkeyboard[somechunkkeyboardindex].arrayofindexzeromesh[c].instancesmatrix[cc].instancematrix.M12;
                                                    somechunkkeyboard[somechunkkeyboardindex].arrayOfChunkData[c].instancesmatrix[cc].instancematrix.M13 = somechunkkeyboard[somechunkkeyboardindex].arrayofindexzeromesh[c].instancesmatrix[cc].instancematrix.M13;
                                                    somechunkkeyboard[somechunkkeyboardindex].arrayOfChunkData[c].instancesmatrix[cc].instancematrix.M14 = somechunkkeyboard[somechunkkeyboardindex].arrayofindexzeromesh[c].instancesmatrix[cc].instancematrix.M14;

                                                    somechunkkeyboard[somechunkkeyboardindex].arrayOfChunkData[c].instancesmatrix[cc].instancematrix.M21 = somechunkkeyboard[somechunkkeyboardindex].arrayofindexzeromesh[c].instancesmatrix[cc].instancematrix.M21;
                                                    somechunkkeyboard[somechunkkeyboardindex].arrayOfChunkData[c].instancesmatrix[cc].instancematrix.M22 = somechunkkeyboard[somechunkkeyboardindex].arrayofindexzeromesh[c].instancesmatrix[cc].instancematrix.M22;
                                                    somechunkkeyboard[somechunkkeyboardindex].arrayOfChunkData[c].instancesmatrix[cc].instancematrix.M23 = somechunkkeyboard[somechunkkeyboardindex].arrayofindexzeromesh[c].instancesmatrix[cc].instancematrix.M23;
                                                    somechunkkeyboard[somechunkkeyboardindex].arrayOfChunkData[c].instancesmatrix[cc].instancematrix.M24 = somechunkkeyboard[somechunkkeyboardindex].arrayofindexzeromesh[c].instancesmatrix[cc].instancematrix.M24;


                                                    somechunkkeyboard[somechunkkeyboardindex].arrayOfChunkData[c].instancesmatrix[cc].instancematrix.M31 = somechunkkeyboard[somechunkkeyboardindex].arrayofindexzeromesh[c].instancesmatrix[cc].instancematrix.M31;
                                                    somechunkkeyboard[somechunkkeyboardindex].arrayOfChunkData[c].instancesmatrix[cc].instancematrix.M32 = somechunkkeyboard[somechunkkeyboardindex].arrayofindexzeromesh[c].instancesmatrix[cc].instancematrix.M32;
                                                    somechunkkeyboard[somechunkkeyboardindex].arrayOfChunkData[c].instancesmatrix[cc].instancematrix.M33 = somechunkkeyboard[somechunkkeyboardindex].arrayofindexzeromesh[c].instancesmatrix[cc].instancematrix.M33;
                                                    somechunkkeyboard[somechunkkeyboardindex].arrayOfChunkData[c].instancesmatrix[cc].instancematrix.M34 = somechunkkeyboard[somechunkkeyboardindex].arrayofindexzeromesh[c].instancesmatrix[cc].instancematrix.M34;


                                                    somechunkkeyboard[somechunkkeyboardindex].arrayOfChunkData[c].instancesmatrix[cc].instancematrix.M41 = somechunkkeyboard[somechunkkeyboardindex].arrayofindexzeromesh[c].instancesmatrix[cc].instancematrix.M41;
                                                    somechunkkeyboard[somechunkkeyboardindex].arrayOfChunkData[c].instancesmatrix[cc].instancematrix.M42 = somechunkkeyboard[somechunkkeyboardindex].arrayofindexzeromesh[c].instancesmatrix[cc].instancematrix.M42;
                                                    somechunkkeyboard[somechunkkeyboardindex].arrayOfChunkData[c].instancesmatrix[cc].instancematrix.M43 = somechunkkeyboard[somechunkkeyboardindex].arrayofindexzeromesh[c].instancesmatrix[cc].instancematrix.M43;
                                                    somechunkkeyboard[somechunkkeyboardindex].arrayOfChunkData[c].instancesmatrix[cc].instancematrix.M44 = somechunkkeyboard[somechunkkeyboardindex].arrayofindexzeromesh[c].instancesmatrix[cc].instancematrix.M44;


                                                }
                                            }
                                        }



                                        somechunkkeyboard[somechunkkeyboardindex].arrayOfChunkData[c].copytobuffer = 0;
                                    }




                                    somechunkkeyboard[somechunkkeyboardindex].arrayOfChunkData[c].instancesLocationW = somechunkkeyboard[somechunkkeyboardindex].arrayofindexzeromesh[c].instancesLocationW;
                                    somechunkkeyboard[somechunkkeyboardindex].arrayOfChunkData[c].instancesLocationH = somechunkkeyboard[somechunkkeyboardindex].arrayofindexzeromesh[c].instancesLocationH;

                                    somechunkkeyboard[somechunkkeyboardindex].arrayOfChunkData[c].SC_instancedChunk_InstancesFORWARD = somechunkkeyboard[somechunkkeyboardindex].arrayofindexzeromesh[c].instancesDataFORWARD;
                                    somechunkkeyboard[somechunkkeyboardindex].arrayOfChunkData[c].SC_instancedChunk_InstancesRIGHT = somechunkkeyboard[somechunkkeyboardindex].arrayofindexzeromesh[c].instancesDataRIGHT;
                                    somechunkkeyboard[somechunkkeyboardindex].arrayOfChunkData[c].SC_instancedChunk_InstancesUP = somechunkkeyboard[somechunkkeyboardindex].arrayofindexzeromesh[c].instancesDataUP;

                                    somechunkkeyboard[somechunkkeyboardindex].arrayOfChunkData[c].colorsNFaces = somechunkkeyboard[somechunkkeyboardindex].arrayofindexzeromesh[c].colorsNFaces;
                                    somechunkkeyboard[somechunkkeyboardindex].arrayOfChunkData[c].lightBuffer = somechunkkeyboard[somechunkkeyboardindex].lightBufferInstChunk;
                                    somechunkkeyboard[somechunkkeyboardindex].arrayOfChunkData[c].SC_instancedChunk_Instances = somechunkkeyboard[somechunkkeyboardindex].arrayofindexzeromesh[c].instances;

                                }
                            }
                        }
                    }
                }
            }*/
            //DESTROYABLE VOXEL KEYBOARD
            //DESTROYABLE VOXEL KEYBOARD
            //DESTROYABLE VOXEL KEYBOARD
















            /*
            //DESTROYABLE VOXEL KEYBOARD GRID
            //DESTROYABLE VOXEL KEYBOARD GRID
            //DESTROYABLE VOXEL KEYBOARD GRID

            for (int xxx = 0; xxx < somechunkkeyboardsgridw; xxx++)
            {
                for (int yyy = 0; yyy < somechunkkeyboardsgridh; yyy++)
                {
                    for (int zzz = 0; zzz < somechunkkeyboardsgridd; zzz++)
                    {
                        //somechunkmesh
                        var somechunkkeyboardgridindex = xxx + somechunkkeyboardsgridw * (yyy + somechunkkeyboardsgridh * zzz);


                        for (int x = 0; x < somechunkkeyboardglobalsgrid.numberOfObjectInWidth; x++)
                        {
                            for (int y = 0; y < somechunkkeyboardglobalsgrid.numberOfObjectInHeight; y++)
                            {
                                for (int z = 0; z < somechunkkeyboardglobalsgrid.numberOfObjectInDepth; z++)
                                {
                                    int c = x + somechunkkeyboardglobalsgrid.numberOfObjectInWidth * (y + somechunkkeyboardglobalsgrid.numberOfObjectInHeight * z);

                                    for (int xx = 0; xx < somechunkkeyboardglobalsgrid.numberOfInstancesPerObjectInWidth; xx++)
                                    {
                                        for (int yy = 0; yy < somechunkkeyboardglobalsgrid.numberOfInstancesPerObjectInHeight; yy++)
                                        {
                                            for (int zz = 0; zz < somechunkkeyboardglobalsgrid.numberOfInstancesPerObjectInDepth; zz++)
                                            {
                                                int cc = xx + somechunkkeyboardglobalsgrid.numberOfInstancesPerObjectInWidth * (yy + somechunkkeyboardglobalsgrid.numberOfInstancesPerObjectInHeight * zz);

                                                Matrix worldMatrixChunkDroneInstance = somechunkkeyboardgrid[somechunkkeyboardgridindex].arrayofindexzeromesh[c].arrayofzeromeshinstances[cc].current_pos;

                                                Matrix worldMatrixmain = somechunkkeyboardgrid[somechunkkeyboardgridindex].worldmatofobj;


                                                Quaternion _testQuator;


                                                //worldMatrixChunkDroneInstance = worldMatrixChunkDroneInstance * somechunkkeyboardgrid[somechunkkeyboardgridindex].worldmatofobj;

                                                //TOREADD
                                                //TOREADD
                                                //TOREADD
                                                Quaternion.RotationMatrix(ref worldMatrixChunkDroneInstance, out _testQuator);

                                                var dirInstanceForward = sc_maths._newgetdirforward(_testQuator);
                                                somechunkkeyboardgrid[somechunkkeyboardgridindex].arrayofindexzeromesh[c].instancesDataFORWARD[cc].instancePos.X = dirInstanceForward.X;
                                                somechunkkeyboardgrid[somechunkkeyboardgridindex].arrayofindexzeromesh[c].instancesDataFORWARD[cc].instancePos.Y = dirInstanceForward.Y;
                                                somechunkkeyboardgrid[somechunkkeyboardgridindex].arrayofindexzeromesh[c].instancesDataFORWARD[cc].instancePos.Z = dirInstanceForward.Z;
                                                somechunkkeyboardgrid[somechunkkeyboardgridindex].arrayofindexzeromesh[c].instancesDataFORWARD[cc].instancePos.W = 1;

                                                //Quaternion.RotationMatrix(ref tempmat0, out quat_buffers);
                                                var dirInstanceRight = -sc_maths._newgetdirleft(_testQuator);
                                                somechunkkeyboardgrid[somechunkkeyboardgridindex].arrayofindexzeromesh[c].instancesDataRIGHT[cc].instancePos.X = dirInstanceRight.X;
                                                somechunkkeyboardgrid[somechunkkeyboardgridindex].arrayofindexzeromesh[c].instancesDataRIGHT[cc].instancePos.Y = dirInstanceRight.Y;
                                                somechunkkeyboardgrid[somechunkkeyboardgridindex].arrayofindexzeromesh[c].instancesDataRIGHT[cc].instancePos.Z = dirInstanceRight.Z;
                                                somechunkkeyboardgrid[somechunkkeyboardgridindex].arrayofindexzeromesh[c].instancesDataRIGHT[cc].instancePos.W = 1;

                                                //Quaternion.RotationMatrix(ref tempmat0, out quat_buffers);    
                                                var dirInstanceUp = sc_maths._newgetdirup(_testQuator);
                                                somechunkkeyboardgrid[somechunkkeyboardgridindex].arrayofindexzeromesh[c].instancesDataUP[cc].instancePos.X = dirInstanceUp.X;
                                                somechunkkeyboardgrid[somechunkkeyboardgridindex].arrayofindexzeromesh[c].instancesDataUP[cc].instancePos.Y = dirInstanceUp.Y;
                                                somechunkkeyboardgrid[somechunkkeyboardgridindex].arrayofindexzeromesh[c].instancesDataUP[cc].instancePos.Z = dirInstanceUp.Z;
                                                somechunkkeyboardgrid[somechunkkeyboardgridindex].arrayofindexzeromesh[c].instancesDataUP[cc].instancePos.W = 1;

                                                //TOREADD
                                                //TOREADD
                                                //TOREADD





                                                /*
                                                Quaternion.RotationMatrix(ref worldMatrixChunkDroneInstance, out _testQuator);

                                                var dirInstanceForward = sc_maths._newgetdirforward(_testQuator);
                                                somechunkkeyboardgrid[somechunkkeyboardgridindex].arrayOfChunkData[c].SC_instancedChunk_InstancesFORWARD[cc].instancePos.X = dirInstanceForward.X;
                                                somechunkkeyboardgrid[somechunkkeyboardgridindex].arrayOfChunkData[c].SC_instancedChunk_InstancesFORWARD[cc].instancePos.Y = dirInstanceForward.Y;
                                                somechunkkeyboardgrid[somechunkkeyboardgridindex].arrayOfChunkData[c].SC_instancedChunk_InstancesFORWARD[cc].instancePos.Z = dirInstanceForward.Z;
                                                somechunkkeyboardgrid[somechunkkeyboardgridindex].arrayOfChunkData[c].SC_instancedChunk_InstancesFORWARD[cc].instancePos.W = 1;

                                                //Quaternion.RotationMatrix(ref tempmat0, out quat_buffers);
                                                var dirInstanceRight = -sc_maths._newgetdirleft(_testQuator);
                                                somechunkkeyboardgrid[somechunkkeyboardgridindex].arrayOfChunkData[c].SC_instancedChunk_InstancesRIGHT[cc].instancePos.X = dirInstanceRight.X;
                                                somechunkkeyboardgrid[somechunkkeyboardgridindex].arrayOfChunkData[c].SC_instancedChunk_InstancesRIGHT[cc].instancePos.Y = dirInstanceRight.Y;
                                                somechunkkeyboardgrid[somechunkkeyboardgridindex].arrayOfChunkData[c].SC_instancedChunk_InstancesRIGHT[cc].instancePos.Z = dirInstanceRight.Z;
                                                somechunkkeyboardgrid[somechunkkeyboardgridindex].arrayOfChunkData[c].SC_instancedChunk_InstancesRIGHT[cc].instancePos.W = 1;

                                                //Quaternion.RotationMatrix(ref tempmat0, out quat_buffers);    
                                                var dirInstanceUp = sc_maths._newgetdirup(_testQuator);
                                                somechunkkeyboardgrid[somechunkkeyboardgridindex].arrayOfChunkData[c].SC_instancedChunk_InstancesUP[cc].instancePos.X = dirInstanceUp.X;
                                                somechunkkeyboardgrid[somechunkkeyboardgridindex].arrayOfChunkData[c].SC_instancedChunk_InstancesUP[cc].instancePos.Y = dirInstanceUp.Y;
                                                somechunkkeyboardgrid[somechunkkeyboardgridindex].arrayOfChunkData[c].SC_instancedChunk_InstancesUP[cc].instancePos.Z = dirInstanceUp.Z;
                                                somechunkkeyboardgrid[somechunkkeyboardgridindex].arrayOfChunkData[c].SC_instancedChunk_InstancesUP[cc].instancePos.W = 1;


                                                Vector3 currentmainobjectpos = new Vector3(somechunkkeyboardgrid[somechunkkeyboardgridindex].worldmatofobj.M41, somechunkkeyboardgrid[somechunkkeyboardgridindex].worldmatofobj.M42, somechunkkeyboardgrid[somechunkkeyboardgridindex].worldmatofobj.M43);

                                                float diffmainpostoinstanceposx = somechunkkeyboardgrid[somechunkkeyboardgridindex].arrayofindexzeromesh[c].instances[cc].instancePos.X - currentmainobjectpos.X;
                                                float diffmainpostoinstanceposy = somechunkkeyboardgrid[somechunkkeyboardgridindex].arrayofindexzeromesh[c].instances[cc].instancePos.Y - currentmainobjectpos.Y;
                                                float diffmainpostoinstanceposz = somechunkkeyboardgrid[somechunkkeyboardgridindex].arrayofindexzeromesh[c].instances[cc].instancePos.Z - currentmainobjectpos.Z;
                                                */




                                                /*Quaternion somedirquat;

                                                Quaternion.RotationMatrix(ref worldMatrixChunkDroneInstance, out somedirquat);

                                                var dirInstanceForward = sc_maths._newgetdirforward(somedirquat);
                                                var dirInstanceRight = -sc_maths._newgetdirleft(somedirquat);
                                                var dirInstanceUp = sc_maths._newgetdirup(somedirquat);*/

                                                /*Vector4 somevecx = new Vector4(dirInstanceRight.X, dirInstanceRight.Y, dirInstanceRight.Z, 1.0f);
                                                Vector4 somevecy = new Vector4(dirInstanceUp.X, dirInstanceUp.Y, dirInstanceUp.Z, 1.0f);
                                                Vector4 somevecz = new Vector4(dirInstanceForward.X, dirInstanceForward.Y, dirInstanceForward.Z, 1.0f);

                                                Vector4 someinstancepostest = Vector4.Zero;
                                                Vector4 somemainpos = new Vector4(worldMatrixmain.M41, worldMatrixmain.M42, worldMatrixmain.M43, 1.0f);

                                                someinstancepostest = somechunkkeyboardgrid[somechunkkeyboardgridindex].arrayofindexzeromesh[c].instances[cc].instancePos + (somevecx);// * (xx * 4 * 4 * 0.01f * 0.5f * 0.5f));
                                                someinstancepostest = somechunkkeyboardgrid[somechunkkeyboardgridindex].arrayofindexzeromesh[c].instances[cc].instancePos + (somevecy);//  * (yy * 4 * 4 * 0.01f * 0.5f * 0.5f));
                                                someinstancepostest = somechunkkeyboardgrid[somechunkkeyboardgridindex].arrayofindexzeromesh[c].instances[cc].instancePos + (somevecz);//  * (zz * 4 * 4 * 0.01f * 0.5f * 0.5f));
                                                */
                                                //somechunkkeyboardgrid[somechunkkeyboardgridindex].arrayofindexzeromesh[c].instances[cc].instancePos.X += somemainpos.X + someinstancepostest.X;
                                                //somechunkkeyboardgrid[somechunkkeyboardgridindex].arrayofindexzeromesh[c].instances[cc].instancePos.Y += somemainpos.Y + someinstancepostest.Y;
                                                //somechunkkeyboardgrid[somechunkkeyboardgridindex].arrayofindexzeromesh[c].instances[cc].instancePos.Z += somemainpos.Z + someinstancepostest.Z;
                                                /*
                                                somechunkkeyboardgrid[somechunkkeyboardgridindex].arrayofindexzeromesh[c].instances[cc].instancePos.X = someinstancepostest.X;
                                                somechunkkeyboardgrid[somechunkkeyboardgridindex].arrayofindexzeromesh[c].instances[cc].instancePos.Y = someinstancepostest.Y;
                                                somechunkkeyboardgrid[somechunkkeyboardgridindex].arrayofindexzeromesh[c].instances[cc].instancePos.Z = someinstancepostest.Z;
                                                */


                                                //somechunkkeyboardgrid[somechunkkeyboardgridindex].arrayOfChunkData[c].SC_instancedChunk_Instances[cc].instancePos.X = somechunkkeyboardgrid[somechunkkeyboardgridindex].arrayOfChunkData[c].SC_instancedChunk_Instances[cc].instancePos.X + -(somechunkkeyboardgrid[somechunkkeyboardgridindex].arrayOfChunkData[c].SC_instancedChunk_InstancesFORWARD[cc].instancePos.X * diffmainpostoinstanceposx);
                                                //somechunkkeyboardgrid[somechunkkeyboardgridindex].arrayOfChunkData[c].SC_instancedChunk_Instances[cc].instancePos.Y = somechunkkeyboardgrid[somechunkkeyboardgridindex].arrayOfChunkData[c].SC_instancedChunk_Instances[cc].instancePos.Y + -(somechunkkeyboardgrid[somechunkkeyboardgridindex].arrayOfChunkData[c].SC_instancedChunk_InstancesFORWARD[cc].instancePos.Y * diffmainpostoinstanceposy);
                                                //somechunkkeyboardgrid[somechunkkeyboardgridindex].arrayOfChunkData[c].SC_instancedChunk_Instances[cc].instancePos.Z = somechunkkeyboardgrid[somechunkkeyboardgridindex].arrayOfChunkData[c].SC_instancedChunk_Instances[cc].instancePos.Z + -(somechunkkeyboardgrid[somechunkkeyboardgridindex].arrayOfChunkData[c].SC_instancedChunk_InstancesFORWARD[cc].instancePos.Z * diffmainpostoinstanceposz);

                                                //somechunkkeyboardgrid[somechunkkeyboardgridindex].arrayOfChunkData[c].SC_instancedChunk_Instances[cc].instancePos.X = currentmainobjectpos.X + (somechunkkeyboardgrid[somechunkkeyboardgridindex].arrayofindexzeromesh[c].instan[cc].instancePos.X + (dirInstanceRight.X * diffmainpostoinstanceposx));
                                                //somechunkkeyboardgrid[somechunkkeyboardgridindex].arrayOfChunkData[c].SC_instancedChunk_Instances[cc].instancePos.Y = currentmainobjectpos.Y + (somechunkkeyboardgrid[somechunkkeyboardgridindex].arrayofindexzeromesh[c].instances[cc].instancePos.Y + (dirInstanceUp.Y * diffmainpostoinstanceposy));
                                                //somechunkkeyboardgrid[somechunkkeyboardgridindex].arrayOfChunkData[c].SC_instancedChunk_Instances[cc].instancePos.Z = currentmainobjectpos.Z + (somechunkkeyboardgrid[somechunkkeyboardgridindex].arrayofindexzeromesh[c].instances[cc].instancePos.Z + (dirInstanceForward.Z * diffmainpostoinstanceposz));


                                                /*Vector4 somevecx = new Vector4(dirInstanceRight.X, dirInstanceRight.Y, dirInstanceRight.Z, 1.0f);
                                                Vector4 somevecy = new Vector4(dirInstanceUp.X, dirInstanceUp.Y, dirInstanceUp.Z, 1.0f);
                                                Vector4 somevecz = new Vector4(dirInstanceForward.X, dirInstanceForward.Y, dirInstanceForward.Z, 1.0f);

                                                somechunkkeyboardgrid[somechunkkeyboardgridindex].arrayOfChunkData[c].SC_instancedChunk_Instances[cc].instancePos = somechunkkeyboardgrid[somechunkkeyboardgridindex].arrayOfChunkData[c].SC_instancedChunk_Instances[cc].instancePos + (somevecx * diffmainpostoinstanceposx);
                                                somechunkkeyboardgrid[somechunkkeyboardgridindex].arrayOfChunkData[c].SC_instancedChunk_Instances[cc].instancePos = somechunkkeyboardgrid[somechunkkeyboardgridindex].arrayOfChunkData[c].SC_instancedChunk_Instances[cc].instancePos + (somevecy * diffmainpostoinstanceposy);
                                                somechunkkeyboardgrid[somechunkkeyboardgridindex].arrayOfChunkData[c].SC_instancedChunk_Instances[cc].instancePos = somechunkkeyboardgrid[somechunkkeyboardgridindex].arrayOfChunkData[c].SC_instancedChunk_Instances[cc].instancePos + (somevecz * diffmainpostoinstanceposz);
                                                





                                            }
                                        }
                                    }






                                    if (somechunkkeyboardgrid[somechunkkeyboardgridindex].arrayOfChunkData[c].copytobuffer == 1)
                                    {
                                        for (int xx = 0; xx < somechunkkeyboardglobalsgrid.numberOfInstancesPerObjectInWidth; xx++)
                                        {
                                            for (int yy = 0; yy < somechunkkeyboardglobalsgrid.numberOfInstancesPerObjectInHeight; yy++)
                                            {
                                                for (int zz = 0; zz < somechunkkeyboardglobalsgrid.numberOfInstancesPerObjectInDepth; zz++)
                                                {
                                                    int cc = xx + somechunkkeyboardglobalsgrid.numberOfInstancesPerObjectInWidth * (yy + somechunkkeyboardglobalsgrid.numberOfInstancesPerObjectInHeight * zz);

                                                    //Matrix worldMatrixChunkDroneInstance = somechunkkeyboardgrid[somechunkkeyboardgridindex].arrayofindexzeromesh[c].arrayofzeromeshinstances[cc].current_pos;
                                                    //Quaternion _testQuator;


                                                    //TO READD FOR SOME LOGIC.
                                                    //Matrix lastPosTarget = _player_rght_hnd[0][0]._arrayOfInstances[0].current_pos;// //_rightTouchMatrix; //
                                                    //Quaternion.RotationMatrix(ref lastPosTarget, out _testQuator);
                                                    //TO READD FOR SOME LOGIC.




                                                    //arrayofindexzeromesh[c].arrayOfScriptForInstances[cc].

                                                    //var dirTargetInstanceForward = sc_maths._newgetdirforward(_testQuator);
                                                    //arrayofindexzeromesh[c].instancesDataFORWARD[cc].instancePos.X = dirTargetInstanceForward.X;
                                                    //arrayofindexzeromesh[c].instancesDataFORWARD[cc].instancePos.Y = dirTargetInstanceForward.Y;
                                                    //arrayofindexzeromesh[c].instancesDataFORWARD[cc].instancePos.Z = dirTargetInstanceForward.Z;
                                                    //arrayofindexzeromesh[c].instancesDataFORWARD[cc].instancePos.W = 1;

                                                    //Quaternion.RotationMatrix(ref tempmat0, out quat_buffers);
                                                    //var dirTargetInstanceRight = sc_maths._newgetdirleft(_testQuator);
                                                    //arrayofindexzeromesh[c].instancesDataRIGHT[cc].instancePos.X = dirTargetInstanceRight.X;
                                                    //arrayofindexzeromesh[c].instancesDataRIGHT[cc].instancePos.Y = dirTargetInstanceRight.Y;
                                                    //arrayofindexzeromesh[c].instancesDataRIGHT[cc].instancePos.Z = dirTargetInstanceRight.Z;
                                                    //arrayofindexzeromesh[c].instancesDataRIGHT[cc].instancePos.W = 1;

                                                    //Quaternion.RotationMatrix(ref tempmat0, out quat_buffers);
                                                    //var dirTargetInstanceUp = sc_maths._newgetdirup(_testQuator);
                                                    //arrayofindexzeromesh[c].instancesDataUP[cc].instancePos.X = dirTargetInstanceUp.X;
                                                    //arrayofindexzeromesh[c].instancesDataUP[cc].instancePos.Y = dirTargetInstanceUp.Y;
                                                    //arrayofindexzeromesh[c].instancesDataUP[cc].instancePos.Z = dirTargetInstanceUp.Z;
                                                    //arrayofindexzeromesh[c].instancesDataUP[cc].instancePos.W = 1;

                                                    //worldMatrixChunkDroneInstance = arrayofindexzeromesh[c].arrayOfScriptForInstances[cc].current_pos;
                                                    //Matrix lastPosDrone = _player_rght_hnd[0][0]._arrayOfInstances[0].current_pos;// //_rightTouchMatrix; //


                                                    //TOREADD
                                                    //TOREADD
                                                    //TOREADD
                                                    /*Quaternion.RotationMatrix(ref worldMatrixChunkDroneInstance, out _testQuator);

                                                    var dirInstanceForward = sc_maths._newgetdirforward(_testQuator);
                                                    somechunkkeyboardgrid[somechunkkeyboardgridindex].arrayofindexzeromesh[c].instancesDataFORWARD[cc].instancePos.X = dirInstanceForward.X;
                                                    somechunkkeyboardgrid[somechunkkeyboardgridindex].arrayofindexzeromesh[c].instancesDataFORWARD[cc].instancePos.Y = dirInstanceForward.Y;
                                                    somechunkkeyboardgrid[somechunkkeyboardgridindex].arrayofindexzeromesh[c].instancesDataFORWARD[cc].instancePos.Z = dirInstanceForward.Z;
                                                    somechunkkeyboardgrid[somechunkkeyboardgridindex].arrayofindexzeromesh[c].instancesDataFORWARD[cc].instancePos.W = 1;

                                                    //Quaternion.RotationMatrix(ref tempmat0, out quat_buffers);
                                                    var dirInstanceRight = -sc_maths._newgetdirleft(_testQuator);
                                                    somechunkkeyboardgrid[somechunkkeyboardgridindex].arrayofindexzeromesh[c].instancesDataRIGHT[cc].instancePos.X = dirInstanceRight.X;
                                                    somechunkkeyboardgrid[somechunkkeyboardgridindex].arrayofindexzeromesh[c].instancesDataRIGHT[cc].instancePos.Y = dirInstanceRight.Y;
                                                    somechunkkeyboardgrid[somechunkkeyboardgridindex].arrayofindexzeromesh[c].instancesDataRIGHT[cc].instancePos.Z = dirInstanceRight.Z;
                                                    somechunkkeyboardgrid[somechunkkeyboardgridindex].arrayofindexzeromesh[c].instancesDataRIGHT[cc].instancePos.W = 1;

                                                    //Quaternion.RotationMatrix(ref tempmat0, out quat_buffers);    
                                                    var dirInstanceUp = sc_maths._newgetdirup(_testQuator);
                                                    somechunkkeyboardgrid[somechunkkeyboardgridindex].arrayofindexzeromesh[c].instancesDataUP[cc].instancePos.X = dirInstanceUp.X;
                                                    somechunkkeyboardgrid[somechunkkeyboardgridindex].arrayofindexzeromesh[c].instancesDataUP[cc].instancePos.Y = dirInstanceUp.Y;
                                                    somechunkkeyboardgrid[somechunkkeyboardgridindex].arrayofindexzeromesh[c].instancesDataUP[cc].instancePos.Z = dirInstanceUp.Z;
                                                    somechunkkeyboardgrid[somechunkkeyboardgridindex].arrayofindexzeromesh[c].instancesDataUP[cc].instancePos.W = 1;
                                                    
                                                    //TOREADD
                                                    //TOREADD
                                                    //TOREADD







                                                    //somechunkkeyboardgrid[somechunkkeyboardgridindex].arrayofindexzeromesh[c].arrayOfScriptForInstances[cc].current_pos.M41 = somechunkkeyboardgrid[somechunkkeyboardgridindex].arrayofindexzeromesh[c].instances[cc].instancePos.X;
                                                    //somechunkkeyboardgrid[somechunkkeyboardgridindex].arrayofindexzeromesh[c].arrayOfScriptForInstances[cc].current_pos.M42 = somechunkkeyboardgrid[somechunkkeyboardgridindex].arrayofindexzeromesh[c].instances[cc].instancePos.Y;
                                                    //somechunkkeyboardgrid[somechunkkeyboardgridindex].arrayofindexzeromesh[c].arrayOfScriptForInstances[cc].current_pos.M43 = somechunkkeyboardgrid[somechunkkeyboardgridindex].arrayofindexzeromesh[c].instances[cc].instancePos.Z;


                                                    //somechunkkeyboardgrid[somechunkkeyboardgridindex].arrayofindexzeromesh[c].arrayOfScriptForInstances[cc].current_pos.M41 = somechunkkeyboardgrid[somechunkkeyboardgridindex].arrayofindexzeromesh[c].instances[cc].instancePos.X;
                                                    //somechunkkeyboardgrid[somechunkkeyboardgridindex].arrayofindexzeromesh[c].arrayOfScriptForInstances[cc].current_pos.M42 = somechunkkeyboardgrid[somechunkkeyboardgridindex].arrayofindexzeromesh[c].instances[cc].instancePos.Y;
                                                    //somechunkkeyboardgrid[somechunkkeyboardgridindex].arrayofindexzeromesh[c].arrayOfScriptForInstances[cc].current_pos.M43 = somechunkkeyboardgrid[somechunkkeyboardgridindex].arrayofindexzeromesh[c].instances[cc].instancePos.Z;



                                                    //TO READD
                                                    somechunkkeyboardgrid[somechunkkeyboardgridindex].arrayOfChunkData[c].instancesmatrix[cc].instancematrix.M11 = somechunkkeyboardgrid[somechunkkeyboardgridindex].arrayofindexzeromesh[c].instancesmatrix[cc].instancematrix.M11;
                                                    somechunkkeyboardgrid[somechunkkeyboardgridindex].arrayOfChunkData[c].instancesmatrix[cc].instancematrix.M12 = somechunkkeyboardgrid[somechunkkeyboardgridindex].arrayofindexzeromesh[c].instancesmatrix[cc].instancematrix.M12;
                                                    somechunkkeyboardgrid[somechunkkeyboardgridindex].arrayOfChunkData[c].instancesmatrix[cc].instancematrix.M13 = somechunkkeyboardgrid[somechunkkeyboardgridindex].arrayofindexzeromesh[c].instancesmatrix[cc].instancematrix.M13;
                                                    somechunkkeyboardgrid[somechunkkeyboardgridindex].arrayOfChunkData[c].instancesmatrix[cc].instancematrix.M14 = somechunkkeyboardgrid[somechunkkeyboardgridindex].arrayofindexzeromesh[c].instancesmatrix[cc].instancematrix.M14;

                                                    somechunkkeyboardgrid[somechunkkeyboardgridindex].arrayOfChunkData[c].instancesmatrix[cc].instancematrix.M21 = somechunkkeyboardgrid[somechunkkeyboardgridindex].arrayofindexzeromesh[c].instancesmatrix[cc].instancematrix.M21;
                                                    somechunkkeyboardgrid[somechunkkeyboardgridindex].arrayOfChunkData[c].instancesmatrix[cc].instancematrix.M22 = somechunkkeyboardgrid[somechunkkeyboardgridindex].arrayofindexzeromesh[c].instancesmatrix[cc].instancematrix.M22;
                                                    somechunkkeyboardgrid[somechunkkeyboardgridindex].arrayOfChunkData[c].instancesmatrix[cc].instancematrix.M23 = somechunkkeyboardgrid[somechunkkeyboardgridindex].arrayofindexzeromesh[c].instancesmatrix[cc].instancematrix.M23;
                                                    somechunkkeyboardgrid[somechunkkeyboardgridindex].arrayOfChunkData[c].instancesmatrix[cc].instancematrix.M24 = somechunkkeyboardgrid[somechunkkeyboardgridindex].arrayofindexzeromesh[c].instancesmatrix[cc].instancematrix.M24;


                                                    somechunkkeyboardgrid[somechunkkeyboardgridindex].arrayOfChunkData[c].instancesmatrix[cc].instancematrix.M31 = somechunkkeyboardgrid[somechunkkeyboardgridindex].arrayofindexzeromesh[c].instancesmatrix[cc].instancematrix.M31;
                                                    somechunkkeyboardgrid[somechunkkeyboardgridindex].arrayOfChunkData[c].instancesmatrix[cc].instancematrix.M32 = somechunkkeyboardgrid[somechunkkeyboardgridindex].arrayofindexzeromesh[c].instancesmatrix[cc].instancematrix.M32;
                                                    somechunkkeyboardgrid[somechunkkeyboardgridindex].arrayOfChunkData[c].instancesmatrix[cc].instancematrix.M33 = somechunkkeyboardgrid[somechunkkeyboardgridindex].arrayofindexzeromesh[c].instancesmatrix[cc].instancematrix.M33;
                                                    somechunkkeyboardgrid[somechunkkeyboardgridindex].arrayOfChunkData[c].instancesmatrix[cc].instancematrix.M34 = somechunkkeyboardgrid[somechunkkeyboardgridindex].arrayofindexzeromesh[c].instancesmatrix[cc].instancematrix.M34;


                                                    somechunkkeyboardgrid[somechunkkeyboardgridindex].arrayOfChunkData[c].instancesmatrix[cc].instancematrix.M41 = somechunkkeyboardgrid[somechunkkeyboardgridindex].arrayofindexzeromesh[c].instancesmatrix[cc].instancematrix.M41;
                                                    somechunkkeyboardgrid[somechunkkeyboardgridindex].arrayOfChunkData[c].instancesmatrix[cc].instancematrix.M42 = somechunkkeyboardgrid[somechunkkeyboardgridindex].arrayofindexzeromesh[c].instancesmatrix[cc].instancematrix.M42;
                                                    somechunkkeyboardgrid[somechunkkeyboardgridindex].arrayOfChunkData[c].instancesmatrix[cc].instancematrix.M43 = somechunkkeyboardgrid[somechunkkeyboardgridindex].arrayofindexzeromesh[c].instancesmatrix[cc].instancematrix.M43;
                                                    somechunkkeyboardgrid[somechunkkeyboardgridindex].arrayOfChunkData[c].instancesmatrix[cc].instancematrix.M44 = somechunkkeyboardgrid[somechunkkeyboardgridindex].arrayofindexzeromesh[c].instancesmatrix[cc].instancematrix.M44;


                                                }
                                            }
                                        }



                                        somechunkkeyboardgrid[somechunkkeyboardgridindex].arrayOfChunkData[c].copytobuffer = 0;
                                    }




                                    somechunkkeyboardgrid[somechunkkeyboardgridindex].arrayOfChunkData[c].instancesLocationW = somechunkkeyboardgrid[somechunkkeyboardgridindex].arrayofindexzeromesh[c].instancesLocationW;
                                    somechunkkeyboardgrid[somechunkkeyboardgridindex].arrayOfChunkData[c].instancesLocationH = somechunkkeyboardgrid[somechunkkeyboardgridindex].arrayofindexzeromesh[c].instancesLocationH;

                                    somechunkkeyboardgrid[somechunkkeyboardgridindex].arrayOfChunkData[c].SC_instancedChunk_InstancesFORWARD = somechunkkeyboardgrid[somechunkkeyboardgridindex].arrayofindexzeromesh[c].instancesDataFORWARD;
                                    somechunkkeyboardgrid[somechunkkeyboardgridindex].arrayOfChunkData[c].SC_instancedChunk_InstancesRIGHT = somechunkkeyboardgrid[somechunkkeyboardgridindex].arrayofindexzeromesh[c].instancesDataRIGHT;
                                    somechunkkeyboardgrid[somechunkkeyboardgridindex].arrayOfChunkData[c].SC_instancedChunk_InstancesUP = somechunkkeyboardgrid[somechunkkeyboardgridindex].arrayofindexzeromesh[c].instancesDataUP;

                                    somechunkkeyboardgrid[somechunkkeyboardgridindex].arrayOfChunkData[c].colorsNFaces = somechunkkeyboardgrid[somechunkkeyboardgridindex].arrayofindexzeromesh[c].colorsNFaces;
                                    somechunkkeyboardgrid[somechunkkeyboardgridindex].arrayOfChunkData[c].lightBuffer = somechunkkeyboardgrid[somechunkkeyboardgridindex].lightBufferInstChunk;
                                    somechunkkeyboardgrid[somechunkkeyboardgridindex].arrayOfChunkData[c].SC_instancedChunk_Instances = somechunkkeyboardgrid[somechunkkeyboardgridindex].arrayofindexzeromesh[c].instances;

                                }
                            }
                        }
                    }
                }
            }*/
            //DESTROYABLE VOXEL KEYBOARD GRID
            //DESTROYABLE VOXEL KEYBOARD GRID
            //DESTROYABLE VOXEL KEYBOARD GRID




























            
            //VOXEL VIRTUAL DESKTOP
            //VOXEL VIRTUAL DESKTOP
            //VOXEL VIRTUAL DESKTOP
            for (int xxx = 0; xxx < somevoxelvirtualdesktopw; xxx++)
            {
                for (int yyy = 0; yyy < somevoxelvirtualdesktoph; yyy++)
                {
                    for (int zzz = 0; zzz < somevoxelvirtualdesktopd; zzz++)
                    {
                        //somechunkmesh
                        var somevoxelvirtualdesktopindex = xxx + somevoxelvirtualdesktopw * (yyy + somevoxelvirtualdesktoph * zzz);


                        for (int x = 0; x < somevoxelvirtualdesktopglobals.numberOfObjectInWidth; x++)
                        {
                            for (int y = 0; y < somevoxelvirtualdesktopglobals.numberOfObjectInHeight; y++)
                            {
                                for (int z = 0; z < somevoxelvirtualdesktopglobals.numberOfObjectInDepth; z++)
                                {
                                    int c = x + somevoxelvirtualdesktopglobals.numberOfObjectInWidth * (y + somevoxelvirtualdesktopglobals.numberOfObjectInHeight * z);

                                    for (int xx = 0; xx < somevoxelvirtualdesktopglobals.numberOfInstancesPerObjectInWidth; xx++)
                                    {
                                        for (int yy = 0; yy < somevoxelvirtualdesktopglobals.numberOfInstancesPerObjectInHeight; yy++)
                                        {
                                            for (int zz = 0; zz < somevoxelvirtualdesktopglobals.numberOfInstancesPerObjectInDepth; zz++)
                                            {
                                                int cc = xx + somevoxelvirtualdesktopglobals.numberOfInstancesPerObjectInWidth * (yy + somevoxelvirtualdesktopglobals.numberOfInstancesPerObjectInHeight * zz);

                                                Matrix worldMatrixChunkDroneInstance = somevoxelvirtualdesktop[somevoxelvirtualdesktopindex].arrayofindexzeromesh[c].arrayofzeromeshinstances[cc].current_pos;

                                                Matrix worldMatrixmain = somevoxelvirtualdesktop[somevoxelvirtualdesktopindex].worldmatofobj;


                                                Quaternion _testQuator;


                                                //worldMatrixChunkDroneInstance = worldMatrixChunkDroneInstance * somevoxelvirtualdesktop[somevoxelvirtualdesktopindex].worldmatofobj;

                                                //TOREADD
                                                //TOREADD
                                                //TOREADD
                                                Quaternion.RotationMatrix(ref worldMatrixChunkDroneInstance, out _testQuator);

                                                var dirInstanceForward = sc_maths._newgetdirforward(_testQuator);
                                                somevoxelvirtualdesktop[somevoxelvirtualdesktopindex].arrayofindexzeromesh[c].instancesDataFORWARD[cc].instancePos.X = dirInstanceForward.X;
                                                somevoxelvirtualdesktop[somevoxelvirtualdesktopindex].arrayofindexzeromesh[c].instancesDataFORWARD[cc].instancePos.Y = dirInstanceForward.Y;
                                                somevoxelvirtualdesktop[somevoxelvirtualdesktopindex].arrayofindexzeromesh[c].instancesDataFORWARD[cc].instancePos.Z = dirInstanceForward.Z;
                                                somevoxelvirtualdesktop[somevoxelvirtualdesktopindex].arrayofindexzeromesh[c].instancesDataFORWARD[cc].instancePos.W = 1;

                                                //Quaternion.RotationMatrix(ref tempmat0, out quat_buffers);
                                                var dirInstanceRight = -sc_maths._newgetdirleft(_testQuator);
                                                somevoxelvirtualdesktop[somevoxelvirtualdesktopindex].arrayofindexzeromesh[c].instancesDataRIGHT[cc].instancePos.X = dirInstanceRight.X;
                                                somevoxelvirtualdesktop[somevoxelvirtualdesktopindex].arrayofindexzeromesh[c].instancesDataRIGHT[cc].instancePos.Y = dirInstanceRight.Y;
                                                somevoxelvirtualdesktop[somevoxelvirtualdesktopindex].arrayofindexzeromesh[c].instancesDataRIGHT[cc].instancePos.Z = dirInstanceRight.Z;
                                                somevoxelvirtualdesktop[somevoxelvirtualdesktopindex].arrayofindexzeromesh[c].instancesDataRIGHT[cc].instancePos.W = 1;

                                                //Quaternion.RotationMatrix(ref tempmat0, out quat_buffers);    
                                                var dirInstanceUp = sc_maths._newgetdirup(_testQuator);
                                                somevoxelvirtualdesktop[somevoxelvirtualdesktopindex].arrayofindexzeromesh[c].instancesDataUP[cc].instancePos.X = dirInstanceUp.X;
                                                somevoxelvirtualdesktop[somevoxelvirtualdesktopindex].arrayofindexzeromesh[c].instancesDataUP[cc].instancePos.Y = dirInstanceUp.Y;
                                                somevoxelvirtualdesktop[somevoxelvirtualdesktopindex].arrayofindexzeromesh[c].instancesDataUP[cc].instancePos.Z = dirInstanceUp.Z;
                                                somevoxelvirtualdesktop[somevoxelvirtualdesktopindex].arrayofindexzeromesh[c].instancesDataUP[cc].instancePos.W = 1;

                                                //TOREADD
                                                //TOREADD
                                                //TOREADD





                                                /*
                                                Quaternion.RotationMatrix(ref worldMatrixChunkDroneInstance, out _testQuator);

                                                var dirInstanceForward = sc_maths._newgetdirforward(_testQuator);
                                                somevoxelvirtualdesktop[somevoxelvirtualdesktopindex].arrayOfChunkData[c].SC_instancedChunk_InstancesFORWARD[cc].instancePos.X = dirInstanceForward.X;
                                                somevoxelvirtualdesktop[somevoxelvirtualdesktopindex].arrayOfChunkData[c].SC_instancedChunk_InstancesFORWARD[cc].instancePos.Y = dirInstanceForward.Y;
                                                somevoxelvirtualdesktop[somevoxelvirtualdesktopindex].arrayOfChunkData[c].SC_instancedChunk_InstancesFORWARD[cc].instancePos.Z = dirInstanceForward.Z;
                                                somevoxelvirtualdesktop[somevoxelvirtualdesktopindex].arrayOfChunkData[c].SC_instancedChunk_InstancesFORWARD[cc].instancePos.W = 1;

                                                //Quaternion.RotationMatrix(ref tempmat0, out quat_buffers);
                                                var dirInstanceRight = -sc_maths._newgetdirleft(_testQuator);
                                                somevoxelvirtualdesktop[somevoxelvirtualdesktopindex].arrayOfChunkData[c].SC_instancedChunk_InstancesRIGHT[cc].instancePos.X = dirInstanceRight.X;
                                                somevoxelvirtualdesktop[somevoxelvirtualdesktopindex].arrayOfChunkData[c].SC_instancedChunk_InstancesRIGHT[cc].instancePos.Y = dirInstanceRight.Y;
                                                somevoxelvirtualdesktop[somevoxelvirtualdesktopindex].arrayOfChunkData[c].SC_instancedChunk_InstancesRIGHT[cc].instancePos.Z = dirInstanceRight.Z;
                                                somevoxelvirtualdesktop[somevoxelvirtualdesktopindex].arrayOfChunkData[c].SC_instancedChunk_InstancesRIGHT[cc].instancePos.W = 1;

                                                //Quaternion.RotationMatrix(ref tempmat0, out quat_buffers);    
                                                var dirInstanceUp = sc_maths._newgetdirup(_testQuator);
                                                somevoxelvirtualdesktop[somevoxelvirtualdesktopindex].arrayOfChunkData[c].SC_instancedChunk_InstancesUP[cc].instancePos.X = dirInstanceUp.X;
                                                somevoxelvirtualdesktop[somevoxelvirtualdesktopindex].arrayOfChunkData[c].SC_instancedChunk_InstancesUP[cc].instancePos.Y = dirInstanceUp.Y;
                                                somevoxelvirtualdesktop[somevoxelvirtualdesktopindex].arrayOfChunkData[c].SC_instancedChunk_InstancesUP[cc].instancePos.Z = dirInstanceUp.Z;
                                                somevoxelvirtualdesktop[somevoxelvirtualdesktopindex].arrayOfChunkData[c].SC_instancedChunk_InstancesUP[cc].instancePos.W = 1;


                                                Vector3 currentmainobjectpos = new Vector3(somevoxelvirtualdesktop[somevoxelvirtualdesktopindex].worldmatofobj.M41, somevoxelvirtualdesktop[somevoxelvirtualdesktopindex].worldmatofobj.M42, somevoxelvirtualdesktop[somevoxelvirtualdesktopindex].worldmatofobj.M43);

                                                float diffmainpostoinstanceposx = somevoxelvirtualdesktop[somevoxelvirtualdesktopindex].arrayofindexzeromesh[c].instances[cc].instancePos.X - currentmainobjectpos.X;
                                                float diffmainpostoinstanceposy = somevoxelvirtualdesktop[somevoxelvirtualdesktopindex].arrayofindexzeromesh[c].instances[cc].instancePos.Y - currentmainobjectpos.Y;
                                                float diffmainpostoinstanceposz = somevoxelvirtualdesktop[somevoxelvirtualdesktopindex].arrayofindexzeromesh[c].instances[cc].instancePos.Z - currentmainobjectpos.Z;
                                                */




                                                /*Quaternion somedirquat;

                                                Quaternion.RotationMatrix(ref worldMatrixChunkDroneInstance, out somedirquat);

                                                var dirInstanceForward = sc_maths._newgetdirforward(somedirquat);
                                                var dirInstanceRight = -sc_maths._newgetdirleft(somedirquat);
                                                var dirInstanceUp = sc_maths._newgetdirup(somedirquat);*/

                                                /*Vector4 somevecx = new Vector4(dirInstanceRight.X, dirInstanceRight.Y, dirInstanceRight.Z, 1.0f);
                                                Vector4 somevecy = new Vector4(dirInstanceUp.X, dirInstanceUp.Y, dirInstanceUp.Z, 1.0f);
                                                Vector4 somevecz = new Vector4(dirInstanceForward.X, dirInstanceForward.Y, dirInstanceForward.Z, 1.0f);

                                                Vector4 someinstancepostest = Vector4.Zero;
                                                Vector4 somemainpos = new Vector4(worldMatrixmain.M41, worldMatrixmain.M42, worldMatrixmain.M43, 1.0f);

                                                someinstancepostest = somevoxelvirtualdesktop[somevoxelvirtualdesktopindex].arrayofindexzeromesh[c].instances[cc].instancePos + (somevecx);// * (xx * 4 * 4 * 0.01f * 0.5f * 0.5f));
                                                someinstancepostest = somevoxelvirtualdesktop[somevoxelvirtualdesktopindex].arrayofindexzeromesh[c].instances[cc].instancePos + (somevecy);//  * (yy * 4 * 4 * 0.01f * 0.5f * 0.5f));
                                                someinstancepostest = somevoxelvirtualdesktop[somevoxelvirtualdesktopindex].arrayofindexzeromesh[c].instances[cc].instancePos + (somevecz);//  * (zz * 4 * 4 * 0.01f * 0.5f * 0.5f));
                                                */
                                                //somevoxelvirtualdesktop[somevoxelvirtualdesktopindex].arrayofindexzeromesh[c].instances[cc].instancePos.X += somemainpos.X + someinstancepostest.X;
                                                //somevoxelvirtualdesktop[somevoxelvirtualdesktopindex].arrayofindexzeromesh[c].instances[cc].instancePos.Y += somemainpos.Y + someinstancepostest.Y;
                                                //somevoxelvirtualdesktop[somevoxelvirtualdesktopindex].arrayofindexzeromesh[c].instances[cc].instancePos.Z += somemainpos.Z + someinstancepostest.Z;
                                                /*
                                                somevoxelvirtualdesktop[somevoxelvirtualdesktopindex].arrayofindexzeromesh[c].instances[cc].instancePos.X = someinstancepostest.X;
                                                somevoxelvirtualdesktop[somevoxelvirtualdesktopindex].arrayofindexzeromesh[c].instances[cc].instancePos.Y = someinstancepostest.Y;
                                                somevoxelvirtualdesktop[somevoxelvirtualdesktopindex].arrayofindexzeromesh[c].instances[cc].instancePos.Z = someinstancepostest.Z;
                                                */


                                                //somevoxelvirtualdesktop[somevoxelvirtualdesktopindex].arrayOfChunkData[c].SC_instancedChunk_Instances[cc].instancePos.X = somevoxelvirtualdesktop[somevoxelvirtualdesktopindex].arrayOfChunkData[c].SC_instancedChunk_Instances[cc].instancePos.X + -(somevoxelvirtualdesktop[somevoxelvirtualdesktopindex].arrayOfChunkData[c].SC_instancedChunk_InstancesFORWARD[cc].instancePos.X * diffmainpostoinstanceposx);
                                                //somevoxelvirtualdesktop[somevoxelvirtualdesktopindex].arrayOfChunkData[c].SC_instancedChunk_Instances[cc].instancePos.Y = somevoxelvirtualdesktop[somevoxelvirtualdesktopindex].arrayOfChunkData[c].SC_instancedChunk_Instances[cc].instancePos.Y + -(somevoxelvirtualdesktop[somevoxelvirtualdesktopindex].arrayOfChunkData[c].SC_instancedChunk_InstancesFORWARD[cc].instancePos.Y * diffmainpostoinstanceposy);
                                                //somevoxelvirtualdesktop[somevoxelvirtualdesktopindex].arrayOfChunkData[c].SC_instancedChunk_Instances[cc].instancePos.Z = somevoxelvirtualdesktop[somevoxelvirtualdesktopindex].arrayOfChunkData[c].SC_instancedChunk_Instances[cc].instancePos.Z + -(somevoxelvirtualdesktop[somevoxelvirtualdesktopindex].arrayOfChunkData[c].SC_instancedChunk_InstancesFORWARD[cc].instancePos.Z * diffmainpostoinstanceposz);

                                                //somevoxelvirtualdesktop[somevoxelvirtualdesktopindex].arrayOfChunkData[c].SC_instancedChunk_Instances[cc].instancePos.X = currentmainobjectpos.X + (somevoxelvirtualdesktop[somevoxelvirtualdesktopindex].arrayofindexzeromesh[c].instan[cc].instancePos.X + (dirInstanceRight.X * diffmainpostoinstanceposx));
                                                //somevoxelvirtualdesktop[somevoxelvirtualdesktopindex].arrayOfChunkData[c].SC_instancedChunk_Instances[cc].instancePos.Y = currentmainobjectpos.Y + (somevoxelvirtualdesktop[somevoxelvirtualdesktopindex].arrayofindexzeromesh[c].instances[cc].instancePos.Y + (dirInstanceUp.Y * diffmainpostoinstanceposy));
                                                //somevoxelvirtualdesktop[somevoxelvirtualdesktopindex].arrayOfChunkData[c].SC_instancedChunk_Instances[cc].instancePos.Z = currentmainobjectpos.Z + (somevoxelvirtualdesktop[somevoxelvirtualdesktopindex].arrayofindexzeromesh[c].instances[cc].instancePos.Z + (dirInstanceForward.Z * diffmainpostoinstanceposz));


                                                /*Vector4 somevecx = new Vector4(dirInstanceRight.X, dirInstanceRight.Y, dirInstanceRight.Z, 1.0f);
                                                Vector4 somevecy = new Vector4(dirInstanceUp.X, dirInstanceUp.Y, dirInstanceUp.Z, 1.0f);
                                                Vector4 somevecz = new Vector4(dirInstanceForward.X, dirInstanceForward.Y, dirInstanceForward.Z, 1.0f);

                                                somevoxelvirtualdesktop[somevoxelvirtualdesktopindex].arrayOfChunkData[c].SC_instancedChunk_Instances[cc].instancePos = somevoxelvirtualdesktop[somevoxelvirtualdesktopindex].arrayOfChunkData[c].SC_instancedChunk_Instances[cc].instancePos + (somevecx * diffmainpostoinstanceposx);
                                                somevoxelvirtualdesktop[somevoxelvirtualdesktopindex].arrayOfChunkData[c].SC_instancedChunk_Instances[cc].instancePos = somevoxelvirtualdesktop[somevoxelvirtualdesktopindex].arrayOfChunkData[c].SC_instancedChunk_Instances[cc].instancePos + (somevecy * diffmainpostoinstanceposy);
                                                somevoxelvirtualdesktop[somevoxelvirtualdesktopindex].arrayOfChunkData[c].SC_instancedChunk_Instances[cc].instancePos = somevoxelvirtualdesktop[somevoxelvirtualdesktopindex].arrayOfChunkData[c].SC_instancedChunk_Instances[cc].instancePos + (somevecz * diffmainpostoinstanceposz);
                                                
                                                */




                                            }
                                        }
                                    }






                                    if (somevoxelvirtualdesktop[somevoxelvirtualdesktopindex].arrayOfChunkData[c].copytobuffer == 1)
                                    {
                                        for (int xx = 0; xx < somevoxelvirtualdesktopglobals.numberOfInstancesPerObjectInWidth; xx++)
                                        {
                                            for (int yy = 0; yy < somevoxelvirtualdesktopglobals.numberOfInstancesPerObjectInHeight; yy++)
                                            {
                                                for (int zz = 0; zz < somevoxelvirtualdesktopglobals.numberOfInstancesPerObjectInDepth; zz++)
                                                {
                                                    int cc = xx + somevoxelvirtualdesktopglobals.numberOfInstancesPerObjectInWidth * (yy + somevoxelvirtualdesktopglobals.numberOfInstancesPerObjectInHeight * zz);

                                                    //Matrix worldMatrixChunkDroneInstance = somevoxelvirtualdesktop[somevoxelvirtualdesktopindex].arrayofindexzeromesh[c].arrayofzeromeshinstances[cc].current_pos;
                                                    //Quaternion _testQuator;


                                                    //TO READD FOR SOME LOGIC.
                                                    //Matrix lastPosTarget = _player_rght_hnd[0][0]._arrayOfInstances[0].current_pos;// //_rightTouchMatrix; //
                                                    //Quaternion.RotationMatrix(ref lastPosTarget, out _testQuator);
                                                    //TO READD FOR SOME LOGIC.




                                                    //arrayofindexzeromesh[c].arrayOfScriptForInstances[cc].

                                                    //var dirTargetInstanceForward = sc_maths._newgetdirforward(_testQuator);
                                                    //arrayofindexzeromesh[c].instancesDataFORWARD[cc].instancePos.X = dirTargetInstanceForward.X;
                                                    //arrayofindexzeromesh[c].instancesDataFORWARD[cc].instancePos.Y = dirTargetInstanceForward.Y;
                                                    //arrayofindexzeromesh[c].instancesDataFORWARD[cc].instancePos.Z = dirTargetInstanceForward.Z;
                                                    //arrayofindexzeromesh[c].instancesDataFORWARD[cc].instancePos.W = 1;

                                                    //Quaternion.RotationMatrix(ref tempmat0, out quat_buffers);
                                                    //var dirTargetInstanceRight = sc_maths._newgetdirleft(_testQuator);
                                                    //arrayofindexzeromesh[c].instancesDataRIGHT[cc].instancePos.X = dirTargetInstanceRight.X;
                                                    //arrayofindexzeromesh[c].instancesDataRIGHT[cc].instancePos.Y = dirTargetInstanceRight.Y;
                                                    //arrayofindexzeromesh[c].instancesDataRIGHT[cc].instancePos.Z = dirTargetInstanceRight.Z;
                                                    //arrayofindexzeromesh[c].instancesDataRIGHT[cc].instancePos.W = 1;

                                                    //Quaternion.RotationMatrix(ref tempmat0, out quat_buffers);
                                                    //var dirTargetInstanceUp = sc_maths._newgetdirup(_testQuator);
                                                    //arrayofindexzeromesh[c].instancesDataUP[cc].instancePos.X = dirTargetInstanceUp.X;
                                                    //arrayofindexzeromesh[c].instancesDataUP[cc].instancePos.Y = dirTargetInstanceUp.Y;
                                                    //arrayofindexzeromesh[c].instancesDataUP[cc].instancePos.Z = dirTargetInstanceUp.Z;
                                                    //arrayofindexzeromesh[c].instancesDataUP[cc].instancePos.W = 1;

                                                    //worldMatrixChunkDroneInstance = arrayofindexzeromesh[c].arrayOfScriptForInstances[cc].current_pos;
                                                    //Matrix lastPosDrone = _player_rght_hnd[0][0]._arrayOfInstances[0].current_pos;// //_rightTouchMatrix; //


                                                    //TOREADD
                                                    //TOREADD
                                                    //TOREADD
                                                    /*Quaternion.RotationMatrix(ref worldMatrixChunkDroneInstance, out _testQuator);

                                                    var dirInstanceForward = sc_maths._newgetdirforward(_testQuator);
                                                    somevoxelvirtualdesktop[somevoxelvirtualdesktopindex].arrayofindexzeromesh[c].instancesDataFORWARD[cc].instancePos.X = dirInstanceForward.X;
                                                    somevoxelvirtualdesktop[somevoxelvirtualdesktopindex].arrayofindexzeromesh[c].instancesDataFORWARD[cc].instancePos.Y = dirInstanceForward.Y;
                                                    somevoxelvirtualdesktop[somevoxelvirtualdesktopindex].arrayofindexzeromesh[c].instancesDataFORWARD[cc].instancePos.Z = dirInstanceForward.Z;
                                                    somevoxelvirtualdesktop[somevoxelvirtualdesktopindex].arrayofindexzeromesh[c].instancesDataFORWARD[cc].instancePos.W = 1;

                                                    //Quaternion.RotationMatrix(ref tempmat0, out quat_buffers);
                                                    var dirInstanceRight = -sc_maths._newgetdirleft(_testQuator);
                                                    somevoxelvirtualdesktop[somevoxelvirtualdesktopindex].arrayofindexzeromesh[c].instancesDataRIGHT[cc].instancePos.X = dirInstanceRight.X;
                                                    somevoxelvirtualdesktop[somevoxelvirtualdesktopindex].arrayofindexzeromesh[c].instancesDataRIGHT[cc].instancePos.Y = dirInstanceRight.Y;
                                                    somevoxelvirtualdesktop[somevoxelvirtualdesktopindex].arrayofindexzeromesh[c].instancesDataRIGHT[cc].instancePos.Z = dirInstanceRight.Z;
                                                    somevoxelvirtualdesktop[somevoxelvirtualdesktopindex].arrayofindexzeromesh[c].instancesDataRIGHT[cc].instancePos.W = 1;

                                                    //Quaternion.RotationMatrix(ref tempmat0, out quat_buffers);    
                                                    var dirInstanceUp = sc_maths._newgetdirup(_testQuator);
                                                    somevoxelvirtualdesktop[somevoxelvirtualdesktopindex].arrayofindexzeromesh[c].instancesDataUP[cc].instancePos.X = dirInstanceUp.X;
                                                    somevoxelvirtualdesktop[somevoxelvirtualdesktopindex].arrayofindexzeromesh[c].instancesDataUP[cc].instancePos.Y = dirInstanceUp.Y;
                                                    somevoxelvirtualdesktop[somevoxelvirtualdesktopindex].arrayofindexzeromesh[c].instancesDataUP[cc].instancePos.Z = dirInstanceUp.Z;
                                                    somevoxelvirtualdesktop[somevoxelvirtualdesktopindex].arrayofindexzeromesh[c].instancesDataUP[cc].instancePos.W = 1;
                                                    */
                                                    //TOREADD
                                                    //TOREADD
                                                    //TOREADD







                                                    //somevoxelvirtualdesktop[somevoxelvirtualdesktopindex].arrayofindexzeromesh[c].arrayOfScriptForInstances[cc].current_pos.M41 = somevoxelvirtualdesktop[somevoxelvirtualdesktopindex].arrayofindexzeromesh[c].instances[cc].instancePos.X;
                                                    //somevoxelvirtualdesktop[somevoxelvirtualdesktopindex].arrayofindexzeromesh[c].arrayOfScriptForInstances[cc].current_pos.M42 = somevoxelvirtualdesktop[somevoxelvirtualdesktopindex].arrayofindexzeromesh[c].instances[cc].instancePos.Y;
                                                    //somevoxelvirtualdesktop[somevoxelvirtualdesktopindex].arrayofindexzeromesh[c].arrayOfScriptForInstances[cc].current_pos.M43 = somevoxelvirtualdesktop[somevoxelvirtualdesktopindex].arrayofindexzeromesh[c].instances[cc].instancePos.Z;


                                                    //somevoxelvirtualdesktop[somevoxelvirtualdesktopindex].arrayofindexzeromesh[c].arrayOfScriptForInstances[cc].current_pos.M41 = somevoxelvirtualdesktop[somevoxelvirtualdesktopindex].arrayofindexzeromesh[c].instances[cc].instancePos.X;
                                                    //somevoxelvirtualdesktop[somevoxelvirtualdesktopindex].arrayofindexzeromesh[c].arrayOfScriptForInstances[cc].current_pos.M42 = somevoxelvirtualdesktop[somevoxelvirtualdesktopindex].arrayofindexzeromesh[c].instances[cc].instancePos.Y;
                                                    //somevoxelvirtualdesktop[somevoxelvirtualdesktopindex].arrayofindexzeromesh[c].arrayOfScriptForInstances[cc].current_pos.M43 = somevoxelvirtualdesktop[somevoxelvirtualdesktopindex].arrayofindexzeromesh[c].instances[cc].instancePos.Z;



                                                    //TO READD
                                                    somevoxelvirtualdesktop[somevoxelvirtualdesktopindex].arrayOfChunkData[c].instancesmatrix[cc].instancematrix.M11 = somevoxelvirtualdesktop[somevoxelvirtualdesktopindex].arrayofindexzeromesh[c].instancesmatrix[cc].instancematrix.M11;
                                                    somevoxelvirtualdesktop[somevoxelvirtualdesktopindex].arrayOfChunkData[c].instancesmatrix[cc].instancematrix.M12 = somevoxelvirtualdesktop[somevoxelvirtualdesktopindex].arrayofindexzeromesh[c].instancesmatrix[cc].instancematrix.M12;
                                                    somevoxelvirtualdesktop[somevoxelvirtualdesktopindex].arrayOfChunkData[c].instancesmatrix[cc].instancematrix.M13 = somevoxelvirtualdesktop[somevoxelvirtualdesktopindex].arrayofindexzeromesh[c].instancesmatrix[cc].instancematrix.M13;
                                                    somevoxelvirtualdesktop[somevoxelvirtualdesktopindex].arrayOfChunkData[c].instancesmatrix[cc].instancematrix.M14 = somevoxelvirtualdesktop[somevoxelvirtualdesktopindex].arrayofindexzeromesh[c].instancesmatrix[cc].instancematrix.M14;

                                                    somevoxelvirtualdesktop[somevoxelvirtualdesktopindex].arrayOfChunkData[c].instancesmatrix[cc].instancematrix.M21 = somevoxelvirtualdesktop[somevoxelvirtualdesktopindex].arrayofindexzeromesh[c].instancesmatrix[cc].instancematrix.M21;
                                                    somevoxelvirtualdesktop[somevoxelvirtualdesktopindex].arrayOfChunkData[c].instancesmatrix[cc].instancematrix.M22 = somevoxelvirtualdesktop[somevoxelvirtualdesktopindex].arrayofindexzeromesh[c].instancesmatrix[cc].instancematrix.M22;
                                                    somevoxelvirtualdesktop[somevoxelvirtualdesktopindex].arrayOfChunkData[c].instancesmatrix[cc].instancematrix.M23 = somevoxelvirtualdesktop[somevoxelvirtualdesktopindex].arrayofindexzeromesh[c].instancesmatrix[cc].instancematrix.M23;
                                                    somevoxelvirtualdesktop[somevoxelvirtualdesktopindex].arrayOfChunkData[c].instancesmatrix[cc].instancematrix.M24 = somevoxelvirtualdesktop[somevoxelvirtualdesktopindex].arrayofindexzeromesh[c].instancesmatrix[cc].instancematrix.M24;


                                                    somevoxelvirtualdesktop[somevoxelvirtualdesktopindex].arrayOfChunkData[c].instancesmatrix[cc].instancematrix.M31 = somevoxelvirtualdesktop[somevoxelvirtualdesktopindex].arrayofindexzeromesh[c].instancesmatrix[cc].instancematrix.M31;
                                                    somevoxelvirtualdesktop[somevoxelvirtualdesktopindex].arrayOfChunkData[c].instancesmatrix[cc].instancematrix.M32 = somevoxelvirtualdesktop[somevoxelvirtualdesktopindex].arrayofindexzeromesh[c].instancesmatrix[cc].instancematrix.M32;
                                                    somevoxelvirtualdesktop[somevoxelvirtualdesktopindex].arrayOfChunkData[c].instancesmatrix[cc].instancematrix.M33 = somevoxelvirtualdesktop[somevoxelvirtualdesktopindex].arrayofindexzeromesh[c].instancesmatrix[cc].instancematrix.M33;
                                                    somevoxelvirtualdesktop[somevoxelvirtualdesktopindex].arrayOfChunkData[c].instancesmatrix[cc].instancematrix.M34 = somevoxelvirtualdesktop[somevoxelvirtualdesktopindex].arrayofindexzeromesh[c].instancesmatrix[cc].instancematrix.M34;


                                                    somevoxelvirtualdesktop[somevoxelvirtualdesktopindex].arrayOfChunkData[c].instancesmatrix[cc].instancematrix.M41 = somevoxelvirtualdesktop[somevoxelvirtualdesktopindex].arrayofindexzeromesh[c].instancesmatrix[cc].instancematrix.M41;
                                                    somevoxelvirtualdesktop[somevoxelvirtualdesktopindex].arrayOfChunkData[c].instancesmatrix[cc].instancematrix.M42 = somevoxelvirtualdesktop[somevoxelvirtualdesktopindex].arrayofindexzeromesh[c].instancesmatrix[cc].instancematrix.M42;
                                                    somevoxelvirtualdesktop[somevoxelvirtualdesktopindex].arrayOfChunkData[c].instancesmatrix[cc].instancematrix.M43 = somevoxelvirtualdesktop[somevoxelvirtualdesktopindex].arrayofindexzeromesh[c].instancesmatrix[cc].instancematrix.M43;
                                                    somevoxelvirtualdesktop[somevoxelvirtualdesktopindex].arrayOfChunkData[c].instancesmatrix[cc].instancematrix.M44 = somevoxelvirtualdesktop[somevoxelvirtualdesktopindex].arrayofindexzeromesh[c].instancesmatrix[cc].instancematrix.M44;





                                                    //TO READD
                                                    somevoxelvirtualdesktop[somevoxelvirtualdesktopindex].arrayOfChunkData[c].instancesmatrixb[cc].instancematrix.M11 = somevoxelvirtualdesktop[somevoxelvirtualdesktopindex].arrayofindexzeromesh[c].instancesmatrixb[cc].instancematrix.M11;
                                                    somevoxelvirtualdesktop[somevoxelvirtualdesktopindex].arrayOfChunkData[c].instancesmatrixb[cc].instancematrix.M12 = somevoxelvirtualdesktop[somevoxelvirtualdesktopindex].arrayofindexzeromesh[c].instancesmatrixb[cc].instancematrix.M12;
                                                    somevoxelvirtualdesktop[somevoxelvirtualdesktopindex].arrayOfChunkData[c].instancesmatrixb[cc].instancematrix.M13 = somevoxelvirtualdesktop[somevoxelvirtualdesktopindex].arrayofindexzeromesh[c].instancesmatrixb[cc].instancematrix.M13;
                                                    somevoxelvirtualdesktop[somevoxelvirtualdesktopindex].arrayOfChunkData[c].instancesmatrixb[cc].instancematrix.M14 = somevoxelvirtualdesktop[somevoxelvirtualdesktopindex].arrayofindexzeromesh[c].instancesmatrixb[cc].instancematrix.M14;

                                                    somevoxelvirtualdesktop[somevoxelvirtualdesktopindex].arrayOfChunkData[c].instancesmatrixb[cc].instancematrix.M21 = somevoxelvirtualdesktop[somevoxelvirtualdesktopindex].arrayofindexzeromesh[c].instancesmatrixb[cc].instancematrix.M21;
                                                    somevoxelvirtualdesktop[somevoxelvirtualdesktopindex].arrayOfChunkData[c].instancesmatrixb[cc].instancematrix.M22 = somevoxelvirtualdesktop[somevoxelvirtualdesktopindex].arrayofindexzeromesh[c].instancesmatrixb[cc].instancematrix.M22;
                                                    somevoxelvirtualdesktop[somevoxelvirtualdesktopindex].arrayOfChunkData[c].instancesmatrixb[cc].instancematrix.M23 = somevoxelvirtualdesktop[somevoxelvirtualdesktopindex].arrayofindexzeromesh[c].instancesmatrixb[cc].instancematrix.M23;
                                                    somevoxelvirtualdesktop[somevoxelvirtualdesktopindex].arrayOfChunkData[c].instancesmatrixb[cc].instancematrix.M24 = somevoxelvirtualdesktop[somevoxelvirtualdesktopindex].arrayofindexzeromesh[c].instancesmatrixb[cc].instancematrix.M24;


                                                    somevoxelvirtualdesktop[somevoxelvirtualdesktopindex].arrayOfChunkData[c].instancesmatrixb[cc].instancematrix.M31 = somevoxelvirtualdesktop[somevoxelvirtualdesktopindex].arrayofindexzeromesh[c].instancesmatrixb[cc].instancematrix.M31;
                                                    somevoxelvirtualdesktop[somevoxelvirtualdesktopindex].arrayOfChunkData[c].instancesmatrixb[cc].instancematrix.M32 = somevoxelvirtualdesktop[somevoxelvirtualdesktopindex].arrayofindexzeromesh[c].instancesmatrixb[cc].instancematrix.M32;
                                                    somevoxelvirtualdesktop[somevoxelvirtualdesktopindex].arrayOfChunkData[c].instancesmatrixb[cc].instancematrix.M33 = somevoxelvirtualdesktop[somevoxelvirtualdesktopindex].arrayofindexzeromesh[c].instancesmatrixb[cc].instancematrix.M33;
                                                    somevoxelvirtualdesktop[somevoxelvirtualdesktopindex].arrayOfChunkData[c].instancesmatrixb[cc].instancematrix.M34 = somevoxelvirtualdesktop[somevoxelvirtualdesktopindex].arrayofindexzeromesh[c].instancesmatrixb[cc].instancematrix.M34;


                                                    somevoxelvirtualdesktop[somevoxelvirtualdesktopindex].arrayOfChunkData[c].instancesmatrixb[cc].instancematrix.M41 = somevoxelvirtualdesktop[somevoxelvirtualdesktopindex].arrayofindexzeromesh[c].instancesmatrixb[cc].instancematrix.M41;
                                                    somevoxelvirtualdesktop[somevoxelvirtualdesktopindex].arrayOfChunkData[c].instancesmatrixb[cc].instancematrix.M42 = somevoxelvirtualdesktop[somevoxelvirtualdesktopindex].arrayofindexzeromesh[c].instancesmatrixb[cc].instancematrix.M42;
                                                    somevoxelvirtualdesktop[somevoxelvirtualdesktopindex].arrayOfChunkData[c].instancesmatrixb[cc].instancematrix.M43 = somevoxelvirtualdesktop[somevoxelvirtualdesktopindex].arrayofindexzeromesh[c].instancesmatrixb[cc].instancematrix.M43;
                                                    somevoxelvirtualdesktop[somevoxelvirtualdesktopindex].arrayOfChunkData[c].instancesmatrixb[cc].instancematrix.M44 = somevoxelvirtualdesktop[somevoxelvirtualdesktopindex].arrayofindexzeromesh[c].instancesmatrixb[cc].instancematrix.M44;






                                                    //TO READD
                                                    somevoxelvirtualdesktop[somevoxelvirtualdesktopindex].arrayOfChunkData[c].instancesmatrixc[cc].instancematrix.M11 = somevoxelvirtualdesktop[somevoxelvirtualdesktopindex].arrayofindexzeromesh[c].instancesmatrixc[cc].instancematrix.M11;
                                                    somevoxelvirtualdesktop[somevoxelvirtualdesktopindex].arrayOfChunkData[c].instancesmatrixc[cc].instancematrix.M12 = somevoxelvirtualdesktop[somevoxelvirtualdesktopindex].arrayofindexzeromesh[c].instancesmatrixc[cc].instancematrix.M12;
                                                    somevoxelvirtualdesktop[somevoxelvirtualdesktopindex].arrayOfChunkData[c].instancesmatrixc[cc].instancematrix.M13 = somevoxelvirtualdesktop[somevoxelvirtualdesktopindex].arrayofindexzeromesh[c].instancesmatrixc[cc].instancematrix.M13;
                                                    somevoxelvirtualdesktop[somevoxelvirtualdesktopindex].arrayOfChunkData[c].instancesmatrixc[cc].instancematrix.M14 = somevoxelvirtualdesktop[somevoxelvirtualdesktopindex].arrayofindexzeromesh[c].instancesmatrixc[cc].instancematrix.M14;

                                                    somevoxelvirtualdesktop[somevoxelvirtualdesktopindex].arrayOfChunkData[c].instancesmatrixc[cc].instancematrix.M21 = somevoxelvirtualdesktop[somevoxelvirtualdesktopindex].arrayofindexzeromesh[c].instancesmatrixc[cc].instancematrix.M21;
                                                    somevoxelvirtualdesktop[somevoxelvirtualdesktopindex].arrayOfChunkData[c].instancesmatrixc[cc].instancematrix.M22 = somevoxelvirtualdesktop[somevoxelvirtualdesktopindex].arrayofindexzeromesh[c].instancesmatrixc[cc].instancematrix.M22;
                                                    somevoxelvirtualdesktop[somevoxelvirtualdesktopindex].arrayOfChunkData[c].instancesmatrixc[cc].instancematrix.M23 = somevoxelvirtualdesktop[somevoxelvirtualdesktopindex].arrayofindexzeromesh[c].instancesmatrixc[cc].instancematrix.M23;
                                                    somevoxelvirtualdesktop[somevoxelvirtualdesktopindex].arrayOfChunkData[c].instancesmatrixc[cc].instancematrix.M24 = somevoxelvirtualdesktop[somevoxelvirtualdesktopindex].arrayofindexzeromesh[c].instancesmatrixc[cc].instancematrix.M24;


                                                    somevoxelvirtualdesktop[somevoxelvirtualdesktopindex].arrayOfChunkData[c].instancesmatrixc[cc].instancematrix.M31 = somevoxelvirtualdesktop[somevoxelvirtualdesktopindex].arrayofindexzeromesh[c].instancesmatrixc[cc].instancematrix.M31;
                                                    somevoxelvirtualdesktop[somevoxelvirtualdesktopindex].arrayOfChunkData[c].instancesmatrixc[cc].instancematrix.M32 = somevoxelvirtualdesktop[somevoxelvirtualdesktopindex].arrayofindexzeromesh[c].instancesmatrixc[cc].instancematrix.M32;
                                                    somevoxelvirtualdesktop[somevoxelvirtualdesktopindex].arrayOfChunkData[c].instancesmatrixc[cc].instancematrix.M33 = somevoxelvirtualdesktop[somevoxelvirtualdesktopindex].arrayofindexzeromesh[c].instancesmatrixc[cc].instancematrix.M33;
                                                    somevoxelvirtualdesktop[somevoxelvirtualdesktopindex].arrayOfChunkData[c].instancesmatrixc[cc].instancematrix.M34 = somevoxelvirtualdesktop[somevoxelvirtualdesktopindex].arrayofindexzeromesh[c].instancesmatrixc[cc].instancematrix.M34;


                                                    somevoxelvirtualdesktop[somevoxelvirtualdesktopindex].arrayOfChunkData[c].instancesmatrixc[cc].instancematrix.M41 = somevoxelvirtualdesktop[somevoxelvirtualdesktopindex].arrayofindexzeromesh[c].instancesmatrixc[cc].instancematrix.M41;
                                                    somevoxelvirtualdesktop[somevoxelvirtualdesktopindex].arrayOfChunkData[c].instancesmatrixc[cc].instancematrix.M42 = somevoxelvirtualdesktop[somevoxelvirtualdesktopindex].arrayofindexzeromesh[c].instancesmatrixc[cc].instancematrix.M42;
                                                    somevoxelvirtualdesktop[somevoxelvirtualdesktopindex].arrayOfChunkData[c].instancesmatrixc[cc].instancematrix.M43 = somevoxelvirtualdesktop[somevoxelvirtualdesktopindex].arrayofindexzeromesh[c].instancesmatrixc[cc].instancematrix.M43;
                                                    somevoxelvirtualdesktop[somevoxelvirtualdesktopindex].arrayOfChunkData[c].instancesmatrixc[cc].instancematrix.M44 = somevoxelvirtualdesktop[somevoxelvirtualdesktopindex].arrayofindexzeromesh[c].instancesmatrixc[cc].instancematrix.M44;




                                                    //TO READD
                                                    somevoxelvirtualdesktop[somevoxelvirtualdesktopindex].arrayOfChunkData[c].instancesmatrixd[cc].instancematrix.M11 = somevoxelvirtualdesktop[somevoxelvirtualdesktopindex].arrayofindexzeromesh[c].instancesmatrixd[cc].instancematrix.M11;
                                                    somevoxelvirtualdesktop[somevoxelvirtualdesktopindex].arrayOfChunkData[c].instancesmatrixd[cc].instancematrix.M12 = somevoxelvirtualdesktop[somevoxelvirtualdesktopindex].arrayofindexzeromesh[c].instancesmatrixd[cc].instancematrix.M12;
                                                    somevoxelvirtualdesktop[somevoxelvirtualdesktopindex].arrayOfChunkData[c].instancesmatrixd[cc].instancematrix.M13 = somevoxelvirtualdesktop[somevoxelvirtualdesktopindex].arrayofindexzeromesh[c].instancesmatrixd[cc].instancematrix.M13;
                                                    somevoxelvirtualdesktop[somevoxelvirtualdesktopindex].arrayOfChunkData[c].instancesmatrixd[cc].instancematrix.M14 = somevoxelvirtualdesktop[somevoxelvirtualdesktopindex].arrayofindexzeromesh[c].instancesmatrixd[cc].instancematrix.M14;

                                                    somevoxelvirtualdesktop[somevoxelvirtualdesktopindex].arrayOfChunkData[c].instancesmatrixd[cc].instancematrix.M21 = somevoxelvirtualdesktop[somevoxelvirtualdesktopindex].arrayofindexzeromesh[c].instancesmatrixd[cc].instancematrix.M21;
                                                    somevoxelvirtualdesktop[somevoxelvirtualdesktopindex].arrayOfChunkData[c].instancesmatrixd[cc].instancematrix.M22 = somevoxelvirtualdesktop[somevoxelvirtualdesktopindex].arrayofindexzeromesh[c].instancesmatrixd[cc].instancematrix.M22;
                                                    somevoxelvirtualdesktop[somevoxelvirtualdesktopindex].arrayOfChunkData[c].instancesmatrixd[cc].instancematrix.M23 = somevoxelvirtualdesktop[somevoxelvirtualdesktopindex].arrayofindexzeromesh[c].instancesmatrixd[cc].instancematrix.M23;
                                                    somevoxelvirtualdesktop[somevoxelvirtualdesktopindex].arrayOfChunkData[c].instancesmatrixd[cc].instancematrix.M24 = somevoxelvirtualdesktop[somevoxelvirtualdesktopindex].arrayofindexzeromesh[c].instancesmatrixd[cc].instancematrix.M24;


                                                    somevoxelvirtualdesktop[somevoxelvirtualdesktopindex].arrayOfChunkData[c].instancesmatrixd[cc].instancematrix.M31 = somevoxelvirtualdesktop[somevoxelvirtualdesktopindex].arrayofindexzeromesh[c].instancesmatrixd[cc].instancematrix.M31;
                                                    somevoxelvirtualdesktop[somevoxelvirtualdesktopindex].arrayOfChunkData[c].instancesmatrixd[cc].instancematrix.M32 = somevoxelvirtualdesktop[somevoxelvirtualdesktopindex].arrayofindexzeromesh[c].instancesmatrixd[cc].instancematrix.M32;
                                                    somevoxelvirtualdesktop[somevoxelvirtualdesktopindex].arrayOfChunkData[c].instancesmatrixd[cc].instancematrix.M33 = somevoxelvirtualdesktop[somevoxelvirtualdesktopindex].arrayofindexzeromesh[c].instancesmatrixd[cc].instancematrix.M33;
                                                    somevoxelvirtualdesktop[somevoxelvirtualdesktopindex].arrayOfChunkData[c].instancesmatrixd[cc].instancematrix.M34 = somevoxelvirtualdesktop[somevoxelvirtualdesktopindex].arrayofindexzeromesh[c].instancesmatrixd[cc].instancematrix.M34;


                                                    somevoxelvirtualdesktop[somevoxelvirtualdesktopindex].arrayOfChunkData[c].instancesmatrixd[cc].instancematrix.M41 = somevoxelvirtualdesktop[somevoxelvirtualdesktopindex].arrayofindexzeromesh[c].instancesmatrixd[cc].instancematrix.M41;
                                                    somevoxelvirtualdesktop[somevoxelvirtualdesktopindex].arrayOfChunkData[c].instancesmatrixd[cc].instancematrix.M42 = somevoxelvirtualdesktop[somevoxelvirtualdesktopindex].arrayofindexzeromesh[c].instancesmatrixd[cc].instancematrix.M42;
                                                    somevoxelvirtualdesktop[somevoxelvirtualdesktopindex].arrayOfChunkData[c].instancesmatrixd[cc].instancematrix.M43 = somevoxelvirtualdesktop[somevoxelvirtualdesktopindex].arrayofindexzeromesh[c].instancesmatrixd[cc].instancematrix.M43;
                                                    somevoxelvirtualdesktop[somevoxelvirtualdesktopindex].arrayOfChunkData[c].instancesmatrixd[cc].instancematrix.M44 = somevoxelvirtualdesktop[somevoxelvirtualdesktopindex].arrayofindexzeromesh[c].instancesmatrixd[cc].instancematrix.M44;


















                                                }
                                            }
                                        }



                                        somevoxelvirtualdesktop[somevoxelvirtualdesktopindex].arrayOfChunkData[c].copytobuffer = 0;
                                    }




                                    somevoxelvirtualdesktop[somevoxelvirtualdesktopindex].arrayOfChunkData[c].instancesLocationW = somevoxelvirtualdesktop[somevoxelvirtualdesktopindex].arrayofindexzeromesh[c].instancesLocationW;
                                    somevoxelvirtualdesktop[somevoxelvirtualdesktopindex].arrayOfChunkData[c].instancesLocationH = somevoxelvirtualdesktop[somevoxelvirtualdesktopindex].arrayofindexzeromesh[c].instancesLocationH;

                                    somevoxelvirtualdesktop[somevoxelvirtualdesktopindex].arrayOfChunkData[c].SC_instancedChunk_InstancesFORWARD = somevoxelvirtualdesktop[somevoxelvirtualdesktopindex].arrayofindexzeromesh[c].instancesDataFORWARD;
                                    somevoxelvirtualdesktop[somevoxelvirtualdesktopindex].arrayOfChunkData[c].SC_instancedChunk_InstancesRIGHT = somevoxelvirtualdesktop[somevoxelvirtualdesktopindex].arrayofindexzeromesh[c].instancesDataRIGHT;
                                    somevoxelvirtualdesktop[somevoxelvirtualdesktopindex].arrayOfChunkData[c].SC_instancedChunk_InstancesUP = somevoxelvirtualdesktop[somevoxelvirtualdesktopindex].arrayofindexzeromesh[c].instancesDataUP;

                                    somevoxelvirtualdesktop[somevoxelvirtualdesktopindex].arrayOfChunkData[c].colorsNFaces = somevoxelvirtualdesktop[somevoxelvirtualdesktopindex].arrayofindexzeromesh[c].colorsNFaces;
                                    somevoxelvirtualdesktop[somevoxelvirtualdesktopindex].arrayOfChunkData[c].lightBuffer = somevoxelvirtualdesktop[somevoxelvirtualdesktopindex].lightBufferInstChunk;
                                    somevoxelvirtualdesktop[somevoxelvirtualdesktopindex].arrayOfChunkData[c].SC_instancedChunk_Instances = somevoxelvirtualdesktop[somevoxelvirtualdesktopindex].arrayofindexzeromesh[c].instances;

                                }
                            }
                        }
                    }
                }
            }
            //VOXEL VIRTUAL DESKTOP
            //VOXEL VIRTUAL DESKTOP
            //VOXEL VIRTUAL DESKTOP








            /*
            //VOXEL VIRTUAL DESKTOP GRID
            //VOXEL VIRTUAL DESKTOP GRID
            //VOXEL VIRTUAL DESKTOP GRID
            for (int xxx = 0; xxx < somevoxelvirtualdesktopgridw; xxx++)
            {
                for (int yyy = 0; yyy < somevoxelvirtualdesktopgridh; yyy++)
                {
                    for (int zzz = 0; zzz < somevoxelvirtualdesktopgridd; zzz++)
                    {
                        //somechunkmesh
                        var somevoxelvirtualdesktopgridindex = xxx + somevoxelvirtualdesktopgridw * (yyy + somevoxelvirtualdesktopgridh * zzz);


                        for (int x = 0; x < somevoxelvirtualdesktopglobalsgrid.numberOfObjectInWidth; x++)
                        {
                            for (int y = 0; y < somevoxelvirtualdesktopglobalsgrid.numberOfObjectInHeight; y++)
                            {
                                for (int z = 0; z < somevoxelvirtualdesktopglobalsgrid.numberOfObjectInDepth; z++)
                                {
                                    int c = x + somevoxelvirtualdesktopglobalsgrid.numberOfObjectInWidth * (y + somevoxelvirtualdesktopglobalsgrid.numberOfObjectInHeight * z);

                                    for (int xx = 0; xx < somevoxelvirtualdesktopglobalsgrid.numberOfInstancesPerObjectInWidth; xx++)
                                    {
                                        for (int yy = 0; yy < somevoxelvirtualdesktopglobalsgrid.numberOfInstancesPerObjectInHeight; yy++)
                                        {
                                            for (int zz = 0; zz < somevoxelvirtualdesktopglobalsgrid.numberOfInstancesPerObjectInDepth; zz++)
                                            {
                                                int cc = xx + somevoxelvirtualdesktopglobalsgrid.numberOfInstancesPerObjectInWidth * (yy + somevoxelvirtualdesktopglobalsgrid.numberOfInstancesPerObjectInHeight * zz);

                                                Matrix worldMatrixChunkDroneInstance = somevoxelvirtualdesktopgrid[somevoxelvirtualdesktopgridindex].arrayofindexzeromesh[c].arrayofzeromeshinstances[cc].current_pos;

                                                Matrix worldMatrixmain = somevoxelvirtualdesktopgrid[somevoxelvirtualdesktopgridindex].worldmatofobj;


                                                Quaternion _testQuator;


                                                //worldMatrixChunkDroneInstance = worldMatrixChunkDroneInstance * somevoxelvirtualdesktopgrid[somevoxelvirtualdesktopgridindex].worldmatofobj;

                                                //TOREADD
                                                //TOREADD
                                                //TOREADD
                                                Quaternion.RotationMatrix(ref worldMatrixChunkDroneInstance, out _testQuator);

                                                var dirInstanceForward = sc_maths._newgetdirforward(_testQuator);
                                                somevoxelvirtualdesktopgrid[somevoxelvirtualdesktopgridindex].arrayofindexzeromesh[c].instancesDataFORWARD[cc].instancePos.X = dirInstanceForward.X;
                                                somevoxelvirtualdesktopgrid[somevoxelvirtualdesktopgridindex].arrayofindexzeromesh[c].instancesDataFORWARD[cc].instancePos.Y = dirInstanceForward.Y;
                                                somevoxelvirtualdesktopgrid[somevoxelvirtualdesktopgridindex].arrayofindexzeromesh[c].instancesDataFORWARD[cc].instancePos.Z = dirInstanceForward.Z;
                                                somevoxelvirtualdesktopgrid[somevoxelvirtualdesktopgridindex].arrayofindexzeromesh[c].instancesDataFORWARD[cc].instancePos.W = 1;

                                                //Quaternion.RotationMatrix(ref tempmat0, out quat_buffers);
                                                var dirInstanceRight = -sc_maths._newgetdirleft(_testQuator);
                                                somevoxelvirtualdesktopgrid[somevoxelvirtualdesktopgridindex].arrayofindexzeromesh[c].instancesDataRIGHT[cc].instancePos.X = dirInstanceRight.X;
                                                somevoxelvirtualdesktopgrid[somevoxelvirtualdesktopgridindex].arrayofindexzeromesh[c].instancesDataRIGHT[cc].instancePos.Y = dirInstanceRight.Y;
                                                somevoxelvirtualdesktopgrid[somevoxelvirtualdesktopgridindex].arrayofindexzeromesh[c].instancesDataRIGHT[cc].instancePos.Z = dirInstanceRight.Z;
                                                somevoxelvirtualdesktopgrid[somevoxelvirtualdesktopgridindex].arrayofindexzeromesh[c].instancesDataRIGHT[cc].instancePos.W = 1;

                                                //Quaternion.RotationMatrix(ref tempmat0, out quat_buffers);    
                                                var dirInstanceUp = sc_maths._newgetdirup(_testQuator);
                                                somevoxelvirtualdesktopgrid[somevoxelvirtualdesktopgridindex].arrayofindexzeromesh[c].instancesDataUP[cc].instancePos.X = dirInstanceUp.X;
                                                somevoxelvirtualdesktopgrid[somevoxelvirtualdesktopgridindex].arrayofindexzeromesh[c].instancesDataUP[cc].instancePos.Y = dirInstanceUp.Y;
                                                somevoxelvirtualdesktopgrid[somevoxelvirtualdesktopgridindex].arrayofindexzeromesh[c].instancesDataUP[cc].instancePos.Z = dirInstanceUp.Z;
                                                somevoxelvirtualdesktopgrid[somevoxelvirtualdesktopgridindex].arrayofindexzeromesh[c].instancesDataUP[cc].instancePos.W = 1;

                                                //TOREADD
                                                //TOREADD
                                                //TOREADD





                                                /*
                                                Quaternion.RotationMatrix(ref worldMatrixChunkDroneInstance, out _testQuator);

                                                var dirInstanceForward = sc_maths._newgetdirforward(_testQuator);
                                                somevoxelvirtualdesktopgrid[somevoxelvirtualdesktopgridindex].arrayOfChunkData[c].SC_instancedChunk_InstancesFORWARD[cc].instancePos.X = dirInstanceForward.X;
                                                somevoxelvirtualdesktopgrid[somevoxelvirtualdesktopgridindex].arrayOfChunkData[c].SC_instancedChunk_InstancesFORWARD[cc].instancePos.Y = dirInstanceForward.Y;
                                                somevoxelvirtualdesktopgrid[somevoxelvirtualdesktopgridindex].arrayOfChunkData[c].SC_instancedChunk_InstancesFORWARD[cc].instancePos.Z = dirInstanceForward.Z;
                                                somevoxelvirtualdesktopgrid[somevoxelvirtualdesktopgridindex].arrayOfChunkData[c].SC_instancedChunk_InstancesFORWARD[cc].instancePos.W = 1;

                                                //Quaternion.RotationMatrix(ref tempmat0, out quat_buffers);
                                                var dirInstanceRight = -sc_maths._newgetdirleft(_testQuator);
                                                somevoxelvirtualdesktopgrid[somevoxelvirtualdesktopgridindex].arrayOfChunkData[c].SC_instancedChunk_InstancesRIGHT[cc].instancePos.X = dirInstanceRight.X;
                                                somevoxelvirtualdesktopgrid[somevoxelvirtualdesktopgridindex].arrayOfChunkData[c].SC_instancedChunk_InstancesRIGHT[cc].instancePos.Y = dirInstanceRight.Y;
                                                somevoxelvirtualdesktopgrid[somevoxelvirtualdesktopgridindex].arrayOfChunkData[c].SC_instancedChunk_InstancesRIGHT[cc].instancePos.Z = dirInstanceRight.Z;
                                                somevoxelvirtualdesktopgrid[somevoxelvirtualdesktopgridindex].arrayOfChunkData[c].SC_instancedChunk_InstancesRIGHT[cc].instancePos.W = 1;

                                                //Quaternion.RotationMatrix(ref tempmat0, out quat_buffers);    
                                                var dirInstanceUp = sc_maths._newgetdirup(_testQuator);
                                                somevoxelvirtualdesktopgrid[somevoxelvirtualdesktopgridindex].arrayOfChunkData[c].SC_instancedChunk_InstancesUP[cc].instancePos.X = dirInstanceUp.X;
                                                somevoxelvirtualdesktopgrid[somevoxelvirtualdesktopgridindex].arrayOfChunkData[c].SC_instancedChunk_InstancesUP[cc].instancePos.Y = dirInstanceUp.Y;
                                                somevoxelvirtualdesktopgrid[somevoxelvirtualdesktopgridindex].arrayOfChunkData[c].SC_instancedChunk_InstancesUP[cc].instancePos.Z = dirInstanceUp.Z;
                                                somevoxelvirtualdesktopgrid[somevoxelvirtualdesktopgridindex].arrayOfChunkData[c].SC_instancedChunk_InstancesUP[cc].instancePos.W = 1;


                                                Vector3 currentmainobjectpos = new Vector3(somevoxelvirtualdesktopgrid[somevoxelvirtualdesktopgridindex].worldmatofobj.M41, somevoxelvirtualdesktopgrid[somevoxelvirtualdesktopgridindex].worldmatofobj.M42, somevoxelvirtualdesktopgrid[somevoxelvirtualdesktopgridindex].worldmatofobj.M43);

                                                float diffmainpostoinstanceposx = somevoxelvirtualdesktopgrid[somevoxelvirtualdesktopgridindex].arrayofindexzeromesh[c].instances[cc].instancePos.X - currentmainobjectpos.X;
                                                float diffmainpostoinstanceposy = somevoxelvirtualdesktopgrid[somevoxelvirtualdesktopgridindex].arrayofindexzeromesh[c].instances[cc].instancePos.Y - currentmainobjectpos.Y;
                                                float diffmainpostoinstanceposz = somevoxelvirtualdesktopgrid[somevoxelvirtualdesktopgridindex].arrayofindexzeromesh[c].instances[cc].instancePos.Z - currentmainobjectpos.Z;
                                                */




                                                /*Quaternion somedirquat;

                                                Quaternion.RotationMatrix(ref worldMatrixChunkDroneInstance, out somedirquat);

                                                var dirInstanceForward = sc_maths._newgetdirforward(somedirquat);
                                                var dirInstanceRight = -sc_maths._newgetdirleft(somedirquat);
                                                var dirInstanceUp = sc_maths._newgetdirup(somedirquat);*/

                                                /*Vector4 somevecx = new Vector4(dirInstanceRight.X, dirInstanceRight.Y, dirInstanceRight.Z, 1.0f);
                                                Vector4 somevecy = new Vector4(dirInstanceUp.X, dirInstanceUp.Y, dirInstanceUp.Z, 1.0f);
                                                Vector4 somevecz = new Vector4(dirInstanceForward.X, dirInstanceForward.Y, dirInstanceForward.Z, 1.0f);

                                                Vector4 someinstancepostest = Vector4.Zero;
                                                Vector4 somemainpos = new Vector4(worldMatrixmain.M41, worldMatrixmain.M42, worldMatrixmain.M43, 1.0f);

                                                someinstancepostest = somevoxelvirtualdesktopgrid[somevoxelvirtualdesktopgridindex].arrayofindexzeromesh[c].instances[cc].instancePos + (somevecx);// * (xx * 4 * 4 * 0.01f * 0.5f * 0.5f));
                                                someinstancepostest = somevoxelvirtualdesktopgrid[somevoxelvirtualdesktopgridindex].arrayofindexzeromesh[c].instances[cc].instancePos + (somevecy);//  * (yy * 4 * 4 * 0.01f * 0.5f * 0.5f));
                                                someinstancepostest = somevoxelvirtualdesktopgrid[somevoxelvirtualdesktopgridindex].arrayofindexzeromesh[c].instances[cc].instancePos + (somevecz);//  * (zz * 4 * 4 * 0.01f * 0.5f * 0.5f));
                                                */
                                                //somevoxelvirtualdesktopgrid[somevoxelvirtualdesktopgridindex].arrayofindexzeromesh[c].instances[cc].instancePos.X += somemainpos.X + someinstancepostest.X;
                                                //somevoxelvirtualdesktopgrid[somevoxelvirtualdesktopgridindex].arrayofindexzeromesh[c].instances[cc].instancePos.Y += somemainpos.Y + someinstancepostest.Y;
                                                //somevoxelvirtualdesktopgrid[somevoxelvirtualdesktopgridindex].arrayofindexzeromesh[c].instances[cc].instancePos.Z += somemainpos.Z + someinstancepostest.Z;
                                                /*
                                                somevoxelvirtualdesktopgrid[somevoxelvirtualdesktopgridindex].arrayofindexzeromesh[c].instances[cc].instancePos.X = someinstancepostest.X;
                                                somevoxelvirtualdesktopgrid[somevoxelvirtualdesktopgridindex].arrayofindexzeromesh[c].instances[cc].instancePos.Y = someinstancepostest.Y;
                                                somevoxelvirtualdesktopgrid[somevoxelvirtualdesktopgridindex].arrayofindexzeromesh[c].instances[cc].instancePos.Z = someinstancepostest.Z;
                                                */


                                                //somevoxelvirtualdesktopgrid[somevoxelvirtualdesktopgridindex].arrayOfChunkData[c].SC_instancedChunk_Instances[cc].instancePos.X = somevoxelvirtualdesktopgrid[somevoxelvirtualdesktopgridindex].arrayOfChunkData[c].SC_instancedChunk_Instances[cc].instancePos.X + -(somevoxelvirtualdesktopgrid[somevoxelvirtualdesktopgridindex].arrayOfChunkData[c].SC_instancedChunk_InstancesFORWARD[cc].instancePos.X * diffmainpostoinstanceposx);
                                                //somevoxelvirtualdesktopgrid[somevoxelvirtualdesktopgridindex].arrayOfChunkData[c].SC_instancedChunk_Instances[cc].instancePos.Y = somevoxelvirtualdesktopgrid[somevoxelvirtualdesktopgridindex].arrayOfChunkData[c].SC_instancedChunk_Instances[cc].instancePos.Y + -(somevoxelvirtualdesktopgrid[somevoxelvirtualdesktopgridindex].arrayOfChunkData[c].SC_instancedChunk_InstancesFORWARD[cc].instancePos.Y * diffmainpostoinstanceposy);
                                                //somevoxelvirtualdesktopgrid[somevoxelvirtualdesktopgridindex].arrayOfChunkData[c].SC_instancedChunk_Instances[cc].instancePos.Z = somevoxelvirtualdesktopgrid[somevoxelvirtualdesktopgridindex].arrayOfChunkData[c].SC_instancedChunk_Instances[cc].instancePos.Z + -(somevoxelvirtualdesktopgrid[somevoxelvirtualdesktopgridindex].arrayOfChunkData[c].SC_instancedChunk_InstancesFORWARD[cc].instancePos.Z * diffmainpostoinstanceposz);

                                                //somevoxelvirtualdesktopgrid[somevoxelvirtualdesktopgridindex].arrayOfChunkData[c].SC_instancedChunk_Instances[cc].instancePos.X = currentmainobjectpos.X + (somevoxelvirtualdesktopgrid[somevoxelvirtualdesktopgridindex].arrayofindexzeromesh[c].instan[cc].instancePos.X + (dirInstanceRight.X * diffmainpostoinstanceposx));
                                                //somevoxelvirtualdesktopgrid[somevoxelvirtualdesktopgridindex].arrayOfChunkData[c].SC_instancedChunk_Instances[cc].instancePos.Y = currentmainobjectpos.Y + (somevoxelvirtualdesktopgrid[somevoxelvirtualdesktopgridindex].arrayofindexzeromesh[c].instances[cc].instancePos.Y + (dirInstanceUp.Y * diffmainpostoinstanceposy));
                                                //somevoxelvirtualdesktopgrid[somevoxelvirtualdesktopgridindex].arrayOfChunkData[c].SC_instancedChunk_Instances[cc].instancePos.Z = currentmainobjectpos.Z + (somevoxelvirtualdesktopgrid[somevoxelvirtualdesktopgridindex].arrayofindexzeromesh[c].instances[cc].instancePos.Z + (dirInstanceForward.Z * diffmainpostoinstanceposz));


                                                /*Vector4 somevecx = new Vector4(dirInstanceRight.X, dirInstanceRight.Y, dirInstanceRight.Z, 1.0f);
                                                Vector4 somevecy = new Vector4(dirInstanceUp.X, dirInstanceUp.Y, dirInstanceUp.Z, 1.0f);
                                                Vector4 somevecz = new Vector4(dirInstanceForward.X, dirInstanceForward.Y, dirInstanceForward.Z, 1.0f);

                                                somevoxelvirtualdesktopgrid[somevoxelvirtualdesktopgridindex].arrayOfChunkData[c].SC_instancedChunk_Instances[cc].instancePos = somevoxelvirtualdesktopgrid[somevoxelvirtualdesktopgridindex].arrayOfChunkData[c].SC_instancedChunk_Instances[cc].instancePos + (somevecx * diffmainpostoinstanceposx);
                                                somevoxelvirtualdesktopgrid[somevoxelvirtualdesktopgridindex].arrayOfChunkData[c].SC_instancedChunk_Instances[cc].instancePos = somevoxelvirtualdesktopgrid[somevoxelvirtualdesktopgridindex].arrayOfChunkData[c].SC_instancedChunk_Instances[cc].instancePos + (somevecy * diffmainpostoinstanceposy);
                                                somevoxelvirtualdesktopgrid[somevoxelvirtualdesktopgridindex].arrayOfChunkData[c].SC_instancedChunk_Instances[cc].instancePos = somevoxelvirtualdesktopgrid[somevoxelvirtualdesktopgridindex].arrayOfChunkData[c].SC_instancedChunk_Instances[cc].instancePos + (somevecz * diffmainpostoinstanceposz);
                                                





                                            }
                                        }
                                    }






                                    if (somevoxelvirtualdesktopgrid[somevoxelvirtualdesktopgridindex].arrayOfChunkData[c].copytobuffer == 1)
                                    {
                                        for (int xx = 0; xx < somevoxelvirtualdesktopglobalsgrid.numberOfInstancesPerObjectInWidth; xx++)
                                        {
                                            for (int yy = 0; yy < somevoxelvirtualdesktopglobalsgrid.numberOfInstancesPerObjectInHeight; yy++)
                                            {
                                                for (int zz = 0; zz < somevoxelvirtualdesktopglobalsgrid.numberOfInstancesPerObjectInDepth; zz++)
                                                {
                                                    int cc = xx + somevoxelvirtualdesktopglobalsgrid.numberOfInstancesPerObjectInWidth * (yy + somevoxelvirtualdesktopglobalsgrid.numberOfInstancesPerObjectInHeight * zz);

                                                    //Matrix worldMatrixChunkDroneInstance = somevoxelvirtualdesktopgrid[somevoxelvirtualdesktopgridindex].arrayofindexzeromesh[c].arrayofzeromeshinstances[cc].current_pos;
                                                    //Quaternion _testQuator;


                                                    //TO READD FOR SOME LOGIC.
                                                    //Matrix lastPosTarget = _player_rght_hnd[0][0]._arrayOfInstances[0].current_pos;// //_rightTouchMatrix; //
                                                    //Quaternion.RotationMatrix(ref lastPosTarget, out _testQuator);
                                                    //TO READD FOR SOME LOGIC.




                                                    //arrayofindexzeromesh[c].arrayOfScriptForInstances[cc].

                                                    //var dirTargetInstanceForward = sc_maths._newgetdirforward(_testQuator);
                                                    //arrayofindexzeromesh[c].instancesDataFORWARD[cc].instancePos.X = dirTargetInstanceForward.X;
                                                    //arrayofindexzeromesh[c].instancesDataFORWARD[cc].instancePos.Y = dirTargetInstanceForward.Y;
                                                    //arrayofindexzeromesh[c].instancesDataFORWARD[cc].instancePos.Z = dirTargetInstanceForward.Z;
                                                    //arrayofindexzeromesh[c].instancesDataFORWARD[cc].instancePos.W = 1;

                                                    //Quaternion.RotationMatrix(ref tempmat0, out quat_buffers);
                                                    //var dirTargetInstanceRight = sc_maths._newgetdirleft(_testQuator);
                                                    //arrayofindexzeromesh[c].instancesDataRIGHT[cc].instancePos.X = dirTargetInstanceRight.X;
                                                    //arrayofindexzeromesh[c].instancesDataRIGHT[cc].instancePos.Y = dirTargetInstanceRight.Y;
                                                    //arrayofindexzeromesh[c].instancesDataRIGHT[cc].instancePos.Z = dirTargetInstanceRight.Z;
                                                    //arrayofindexzeromesh[c].instancesDataRIGHT[cc].instancePos.W = 1;

                                                    //Quaternion.RotationMatrix(ref tempmat0, out quat_buffers);
                                                    //var dirTargetInstanceUp = sc_maths._newgetdirup(_testQuator);
                                                    //arrayofindexzeromesh[c].instancesDataUP[cc].instancePos.X = dirTargetInstanceUp.X;
                                                    //arrayofindexzeromesh[c].instancesDataUP[cc].instancePos.Y = dirTargetInstanceUp.Y;
                                                    //arrayofindexzeromesh[c].instancesDataUP[cc].instancePos.Z = dirTargetInstanceUp.Z;
                                                    //arrayofindexzeromesh[c].instancesDataUP[cc].instancePos.W = 1;

                                                    //worldMatrixChunkDroneInstance = arrayofindexzeromesh[c].arrayOfScriptForInstances[cc].current_pos;
                                                    //Matrix lastPosDrone = _player_rght_hnd[0][0]._arrayOfInstances[0].current_pos;// //_rightTouchMatrix; //


                                                    //TOREADD
                                                    //TOREADD
                                                    //TOREADD
                                                    /*Quaternion.RotationMatrix(ref worldMatrixChunkDroneInstance, out _testQuator);

                                                    var dirInstanceForward = sc_maths._newgetdirforward(_testQuator);
                                                    somevoxelvirtualdesktopgrid[somevoxelvirtualdesktopgridindex].arrayofindexzeromesh[c].instancesDataFORWARD[cc].instancePos.X = dirInstanceForward.X;
                                                    somevoxelvirtualdesktopgrid[somevoxelvirtualdesktopgridindex].arrayofindexzeromesh[c].instancesDataFORWARD[cc].instancePos.Y = dirInstanceForward.Y;
                                                    somevoxelvirtualdesktopgrid[somevoxelvirtualdesktopgridindex].arrayofindexzeromesh[c].instancesDataFORWARD[cc].instancePos.Z = dirInstanceForward.Z;
                                                    somevoxelvirtualdesktopgrid[somevoxelvirtualdesktopgridindex].arrayofindexzeromesh[c].instancesDataFORWARD[cc].instancePos.W = 1;

                                                    //Quaternion.RotationMatrix(ref tempmat0, out quat_buffers);
                                                    var dirInstanceRight = -sc_maths._newgetdirleft(_testQuator);
                                                    somevoxelvirtualdesktopgrid[somevoxelvirtualdesktopgridindex].arrayofindexzeromesh[c].instancesDataRIGHT[cc].instancePos.X = dirInstanceRight.X;
                                                    somevoxelvirtualdesktopgrid[somevoxelvirtualdesktopgridindex].arrayofindexzeromesh[c].instancesDataRIGHT[cc].instancePos.Y = dirInstanceRight.Y;
                                                    somevoxelvirtualdesktopgrid[somevoxelvirtualdesktopgridindex].arrayofindexzeromesh[c].instancesDataRIGHT[cc].instancePos.Z = dirInstanceRight.Z;
                                                    somevoxelvirtualdesktopgrid[somevoxelvirtualdesktopgridindex].arrayofindexzeromesh[c].instancesDataRIGHT[cc].instancePos.W = 1;

                                                    //Quaternion.RotationMatrix(ref tempmat0, out quat_buffers);    
                                                    var dirInstanceUp = sc_maths._newgetdirup(_testQuator);
                                                    somevoxelvirtualdesktopgrid[somevoxelvirtualdesktopgridindex].arrayofindexzeromesh[c].instancesDataUP[cc].instancePos.X = dirInstanceUp.X;
                                                    somevoxelvirtualdesktopgrid[somevoxelvirtualdesktopgridindex].arrayofindexzeromesh[c].instancesDataUP[cc].instancePos.Y = dirInstanceUp.Y;
                                                    somevoxelvirtualdesktopgrid[somevoxelvirtualdesktopgridindex].arrayofindexzeromesh[c].instancesDataUP[cc].instancePos.Z = dirInstanceUp.Z;
                                                    somevoxelvirtualdesktopgrid[somevoxelvirtualdesktopgridindex].arrayofindexzeromesh[c].instancesDataUP[cc].instancePos.W = 1;
                                                    
                                                    //TOREADD
                                                    //TOREADD
                                                    //TOREADD







                                                    //somevoxelvirtualdesktopgrid[somevoxelvirtualdesktopgridindex].arrayofindexzeromesh[c].arrayOfScriptForInstances[cc].current_pos.M41 = somevoxelvirtualdesktopgrid[somevoxelvirtualdesktopgridindex].arrayofindexzeromesh[c].instances[cc].instancePos.X;
                                                    //somevoxelvirtualdesktopgrid[somevoxelvirtualdesktopgridindex].arrayofindexzeromesh[c].arrayOfScriptForInstances[cc].current_pos.M42 = somevoxelvirtualdesktopgrid[somevoxelvirtualdesktopgridindex].arrayofindexzeromesh[c].instances[cc].instancePos.Y;
                                                    //somevoxelvirtualdesktopgrid[somevoxelvirtualdesktopgridindex].arrayofindexzeromesh[c].arrayOfScriptForInstances[cc].current_pos.M43 = somevoxelvirtualdesktopgrid[somevoxelvirtualdesktopgridindex].arrayofindexzeromesh[c].instances[cc].instancePos.Z;


                                                    //somevoxelvirtualdesktopgrid[somevoxelvirtualdesktopgridindex].arrayofindexzeromesh[c].arrayOfScriptForInstances[cc].current_pos.M41 = somevoxelvirtualdesktopgrid[somevoxelvirtualdesktopgridindex].arrayofindexzeromesh[c].instances[cc].instancePos.X;
                                                    //somevoxelvirtualdesktopgrid[somevoxelvirtualdesktopgridindex].arrayofindexzeromesh[c].arrayOfScriptForInstances[cc].current_pos.M42 = somevoxelvirtualdesktopgrid[somevoxelvirtualdesktopgridindex].arrayofindexzeromesh[c].instances[cc].instancePos.Y;
                                                    //somevoxelvirtualdesktopgrid[somevoxelvirtualdesktopgridindex].arrayofindexzeromesh[c].arrayOfScriptForInstances[cc].current_pos.M43 = somevoxelvirtualdesktopgrid[somevoxelvirtualdesktopgridindex].arrayofindexzeromesh[c].instances[cc].instancePos.Z;



                                                    //TO READD
                                                    somevoxelvirtualdesktopgrid[somevoxelvirtualdesktopgridindex].arrayOfChunkData[c].instancesmatrix[cc].instancematrix.M11 = somevoxelvirtualdesktopgrid[somevoxelvirtualdesktopgridindex].arrayofindexzeromesh[c].instancesmatrix[cc].instancematrix.M11;
                                                    somevoxelvirtualdesktopgrid[somevoxelvirtualdesktopgridindex].arrayOfChunkData[c].instancesmatrix[cc].instancematrix.M12 = somevoxelvirtualdesktopgrid[somevoxelvirtualdesktopgridindex].arrayofindexzeromesh[c].instancesmatrix[cc].instancematrix.M12;
                                                    somevoxelvirtualdesktopgrid[somevoxelvirtualdesktopgridindex].arrayOfChunkData[c].instancesmatrix[cc].instancematrix.M13 = somevoxelvirtualdesktopgrid[somevoxelvirtualdesktopgridindex].arrayofindexzeromesh[c].instancesmatrix[cc].instancematrix.M13;
                                                    somevoxelvirtualdesktopgrid[somevoxelvirtualdesktopgridindex].arrayOfChunkData[c].instancesmatrix[cc].instancematrix.M14 = somevoxelvirtualdesktopgrid[somevoxelvirtualdesktopgridindex].arrayofindexzeromesh[c].instancesmatrix[cc].instancematrix.M14;

                                                    somevoxelvirtualdesktopgrid[somevoxelvirtualdesktopgridindex].arrayOfChunkData[c].instancesmatrix[cc].instancematrix.M21 = somevoxelvirtualdesktopgrid[somevoxelvirtualdesktopgridindex].arrayofindexzeromesh[c].instancesmatrix[cc].instancematrix.M21;
                                                    somevoxelvirtualdesktopgrid[somevoxelvirtualdesktopgridindex].arrayOfChunkData[c].instancesmatrix[cc].instancematrix.M22 = somevoxelvirtualdesktopgrid[somevoxelvirtualdesktopgridindex].arrayofindexzeromesh[c].instancesmatrix[cc].instancematrix.M22;
                                                    somevoxelvirtualdesktopgrid[somevoxelvirtualdesktopgridindex].arrayOfChunkData[c].instancesmatrix[cc].instancematrix.M23 = somevoxelvirtualdesktopgrid[somevoxelvirtualdesktopgridindex].arrayofindexzeromesh[c].instancesmatrix[cc].instancematrix.M23;
                                                    somevoxelvirtualdesktopgrid[somevoxelvirtualdesktopgridindex].arrayOfChunkData[c].instancesmatrix[cc].instancematrix.M24 = somevoxelvirtualdesktopgrid[somevoxelvirtualdesktopgridindex].arrayofindexzeromesh[c].instancesmatrix[cc].instancematrix.M24;


                                                    somevoxelvirtualdesktopgrid[somevoxelvirtualdesktopgridindex].arrayOfChunkData[c].instancesmatrix[cc].instancematrix.M31 = somevoxelvirtualdesktopgrid[somevoxelvirtualdesktopgridindex].arrayofindexzeromesh[c].instancesmatrix[cc].instancematrix.M31;
                                                    somevoxelvirtualdesktopgrid[somevoxelvirtualdesktopgridindex].arrayOfChunkData[c].instancesmatrix[cc].instancematrix.M32 = somevoxelvirtualdesktopgrid[somevoxelvirtualdesktopgridindex].arrayofindexzeromesh[c].instancesmatrix[cc].instancematrix.M32;
                                                    somevoxelvirtualdesktopgrid[somevoxelvirtualdesktopgridindex].arrayOfChunkData[c].instancesmatrix[cc].instancematrix.M33 = somevoxelvirtualdesktopgrid[somevoxelvirtualdesktopgridindex].arrayofindexzeromesh[c].instancesmatrix[cc].instancematrix.M33;
                                                    somevoxelvirtualdesktopgrid[somevoxelvirtualdesktopgridindex].arrayOfChunkData[c].instancesmatrix[cc].instancematrix.M34 = somevoxelvirtualdesktopgrid[somevoxelvirtualdesktopgridindex].arrayofindexzeromesh[c].instancesmatrix[cc].instancematrix.M34;


                                                    somevoxelvirtualdesktopgrid[somevoxelvirtualdesktopgridindex].arrayOfChunkData[c].instancesmatrix[cc].instancematrix.M41 = somevoxelvirtualdesktopgrid[somevoxelvirtualdesktopgridindex].arrayofindexzeromesh[c].instancesmatrix[cc].instancematrix.M41;
                                                    somevoxelvirtualdesktopgrid[somevoxelvirtualdesktopgridindex].arrayOfChunkData[c].instancesmatrix[cc].instancematrix.M42 = somevoxelvirtualdesktopgrid[somevoxelvirtualdesktopgridindex].arrayofindexzeromesh[c].instancesmatrix[cc].instancematrix.M42;
                                                    somevoxelvirtualdesktopgrid[somevoxelvirtualdesktopgridindex].arrayOfChunkData[c].instancesmatrix[cc].instancematrix.M43 = somevoxelvirtualdesktopgrid[somevoxelvirtualdesktopgridindex].arrayofindexzeromesh[c].instancesmatrix[cc].instancematrix.M43;
                                                    somevoxelvirtualdesktopgrid[somevoxelvirtualdesktopgridindex].arrayOfChunkData[c].instancesmatrix[cc].instancematrix.M44 = somevoxelvirtualdesktopgrid[somevoxelvirtualdesktopgridindex].arrayofindexzeromesh[c].instancesmatrix[cc].instancematrix.M44;


                                                }
                                            }
                                        }



                                        somevoxelvirtualdesktopgrid[somevoxelvirtualdesktopgridindex].arrayOfChunkData[c].copytobuffer = 0;
                                    }




                                    somevoxelvirtualdesktopgrid[somevoxelvirtualdesktopgridindex].arrayOfChunkData[c].instancesLocationW = somevoxelvirtualdesktopgrid[somevoxelvirtualdesktopgridindex].arrayofindexzeromesh[c].instancesLocationW;
                                    somevoxelvirtualdesktopgrid[somevoxelvirtualdesktopgridindex].arrayOfChunkData[c].instancesLocationH = somevoxelvirtualdesktopgrid[somevoxelvirtualdesktopgridindex].arrayofindexzeromesh[c].instancesLocationH;

                                    somevoxelvirtualdesktopgrid[somevoxelvirtualdesktopgridindex].arrayOfChunkData[c].SC_instancedChunk_InstancesFORWARD = somevoxelvirtualdesktopgrid[somevoxelvirtualdesktopgridindex].arrayofindexzeromesh[c].instancesDataFORWARD;
                                    somevoxelvirtualdesktopgrid[somevoxelvirtualdesktopgridindex].arrayOfChunkData[c].SC_instancedChunk_InstancesRIGHT = somevoxelvirtualdesktopgrid[somevoxelvirtualdesktopgridindex].arrayofindexzeromesh[c].instancesDataRIGHT;
                                    somevoxelvirtualdesktopgrid[somevoxelvirtualdesktopgridindex].arrayOfChunkData[c].SC_instancedChunk_InstancesUP = somevoxelvirtualdesktopgrid[somevoxelvirtualdesktopgridindex].arrayofindexzeromesh[c].instancesDataUP;

                                    somevoxelvirtualdesktopgrid[somevoxelvirtualdesktopgridindex].arrayOfChunkData[c].colorsNFaces = somevoxelvirtualdesktopgrid[somevoxelvirtualdesktopgridindex].arrayofindexzeromesh[c].colorsNFaces;
                                    somevoxelvirtualdesktopgrid[somevoxelvirtualdesktopgridindex].arrayOfChunkData[c].lightBuffer = somevoxelvirtualdesktopgrid[somevoxelvirtualdesktopgridindex].lightBufferInstChunk;
                                    somevoxelvirtualdesktopgrid[somevoxelvirtualdesktopgridindex].arrayOfChunkData[c].SC_instancedChunk_Instances = somevoxelvirtualdesktopgrid[somevoxelvirtualdesktopgridindex].arrayofindexzeromesh[c].instances;

                                }
                            }
                        }
                    }
                }
            }*/
            //VOXEL VIRTUAL DESKTOP GRID
            //VOXEL VIRTUAL DESKTOP GRID
            //VOXEL VIRTUAL DESKTOP GRID










            /*
            //SCCS VIRTUAL REALITY PLAYER CHUNK SPATIAL LOCATION VISUALIZER
            //SCCS VIRTUAL REALITY PLAYER CHUNK SPATIAL LOCATION VISUALIZER
            //SCCS VIRTUAL REALITY PLAYER CHUNK SPATIAL LOCATION VISUALIZER
            for (int xxx = 0; xxx < somechunkplayerspatiallocationscenesw; xxx++)
            {
                for (int yyy = 0; yyy < somechunkplayerspatiallocationscenesh; yyy++)
                {
                    for (int zzz = 0; zzz < somechunkplayerspatiallocationscenesd; zzz++)
                    {
                        //somechunkmeshgrid
                        var somescenegridindex = xxx + somechunkplayerspatiallocationscenesw * (yyy + somechunkplayerspatiallocationscenesh * zzz);

                        for (int x = 0; x < someglobalsplayerspatiallocation.numberOfObjectInWidth; x++)
                        {
                            for (int y = 0; y < someglobalsplayerspatiallocation.numberOfObjectInHeight; y++)
                            {
                                for (int z = 0; z < someglobalsplayerspatiallocation.numberOfObjectInDepth; z++)
                                {
                                    int c = x + someglobalsplayerspatiallocation.numberOfObjectInWidth * (y + someglobalsplayerspatiallocation.numberOfObjectInHeight * z);






                                    for (int xx = 0; xx < someglobalsplayerspatiallocation.numberOfInstancesPerObjectInWidth; xx++)
                                    {
                                        for (int yy = 0; yy < someglobalsplayerspatiallocation.numberOfInstancesPerObjectInHeight; yy++)
                                        {
                                            for (int zz = 0; zz < someglobalsplayerspatiallocation.numberOfInstancesPerObjectInDepth; zz++)
                                            {
                                                int cc = xx + someglobalsplayerspatiallocation.numberOfInstancesPerObjectInWidth * (yy + someglobalsplayerspatiallocation.numberOfInstancesPerObjectInHeight * zz);

                                                Matrix worldMatrixChunkDroneInstance = somechunkplayerspatiallocationscene[somescenegridindex].arrayofindexzeromesh[c].arrayofzeromeshinstances[cc].current_pos;
                                                Quaternion _testQuator;

                                                //TOREADD
                                                //TOREADD
                                                //TOREADD
                                                Quaternion.RotationMatrix(ref worldMatrixChunkDroneInstance, out _testQuator);

                                                var dirInstanceForward = sc_maths._newgetdirforward(_testQuator);
                                                somechunkplayerspatiallocationscene[somescenegridindex].arrayofindexzeromesh[c].instancesDataFORWARD[cc].instancePos.X = dirInstanceForward.X;
                                                somechunkplayerspatiallocationscene[somescenegridindex].arrayofindexzeromesh[c].instancesDataFORWARD[cc].instancePos.Y = dirInstanceForward.Y;
                                                somechunkplayerspatiallocationscene[somescenegridindex].arrayofindexzeromesh[c].instancesDataFORWARD[cc].instancePos.Z = dirInstanceForward.Z;
                                                somechunkplayerspatiallocationscene[somescenegridindex].arrayofindexzeromesh[c].instancesDataFORWARD[cc].instancePos.W = 1;

                                                //Quaternion.RotationMatrix(ref tempmat0, out quat_buffers);
                                                var dirInstanceRight = -sc_maths._newgetdirleft(_testQuator);
                                                somechunkplayerspatiallocationscene[somescenegridindex].arrayofindexzeromesh[c].instancesDataRIGHT[cc].instancePos.X = dirInstanceRight.X;
                                                somechunkplayerspatiallocationscene[somescenegridindex].arrayofindexzeromesh[c].instancesDataRIGHT[cc].instancePos.Y = dirInstanceRight.Y;
                                                somechunkplayerspatiallocationscene[somescenegridindex].arrayofindexzeromesh[c].instancesDataRIGHT[cc].instancePos.Z = dirInstanceRight.Z;
                                                somechunkplayerspatiallocationscene[somescenegridindex].arrayofindexzeromesh[c].instancesDataRIGHT[cc].instancePos.W = 1;

                                                //Quaternion.RotationMatrix(ref tempmat0, out quat_buffers);    
                                                var dirInstanceUp = sc_maths._newgetdirup(_testQuator);
                                                somechunkplayerspatiallocationscene[somescenegridindex].arrayofindexzeromesh[c].instancesDataUP[cc].instancePos.X = dirInstanceUp.X;
                                                somechunkplayerspatiallocationscene[somescenegridindex].arrayofindexzeromesh[c].instancesDataUP[cc].instancePos.Y = dirInstanceUp.Y;
                                                somechunkplayerspatiallocationscene[somescenegridindex].arrayofindexzeromesh[c].instancesDataUP[cc].instancePos.Z = dirInstanceUp.Z;
                                                somechunkplayerspatiallocationscene[somescenegridindex].arrayofindexzeromesh[c].instancesDataUP[cc].instancePos.W = 1;

                                                //TOREADD
                                                //TOREADD
                                                //TOREADD
                                            }
                                        }
                                    }











                                    if (somechunkplayerspatiallocationscene[somescenegridindex].arrayOfChunkData[c].copytobuffer == 1)
                                    {
                                        for (int xx = 0; xx < someglobalsplayerspatiallocation.numberOfInstancesPerObjectInWidth; xx++)
                                        {
                                            for (int yy = 0; yy < someglobalsplayerspatiallocation.numberOfInstancesPerObjectInHeight; yy++)
                                            {
                                                for (int zz = 0; zz < someglobalsplayerspatiallocation.numberOfInstancesPerObjectInDepth; zz++)
                                                {
                                                    int cc = xx + someglobalsplayerspatiallocation.numberOfInstancesPerObjectInWidth * (yy + someglobalsplayerspatiallocation.numberOfInstancesPerObjectInHeight * zz);

                                                    Matrix worldMatrixChunkDroneInstance = somechunkplayerspatiallocationscene[somescenegridindex].arrayofindexzeromesh[c].arrayofzeromeshinstances[cc].current_pos;
                                                    Quaternion _testQuator;


                                                    //TO READD FOR SOME LOGIC.
                                                    //Matrix lastPosTarget = _player_rght_hnd[0][0]._arrayOfInstances[0].current_pos;// //_rightTouchMatrix; //
                                                    //Quaternion.RotationMatrix(ref lastPosTarget, out _testQuator);
                                                    //TO READD FOR SOME LOGIC.




                                                    //arrayofindexzeromesh[c].arrayOfScriptForInstances[cc].

                                                    //var dirTargetInstanceForward = sc_maths._newgetdirforward(_testQuator);
                                                    //arrayofindexzeromesh[c].instancesDataFORWARD[cc].instancePos.X = dirTargetInstanceForward.X;
                                                    //arrayofindexzeromesh[c].instancesDataFORWARD[cc].instancePos.Y = dirTargetInstanceForward.Y;
                                                    //arrayofindexzeromesh[c].instancesDataFORWARD[cc].instancePos.Z = dirTargetInstanceForward.Z;
                                                    //arrayofindexzeromesh[c].instancesDataFORWARD[cc].instancePos.W = 1;

                                                    //Quaternion.RotationMatrix(ref tempmat0, out quat_buffers);
                                                    //var dirTargetInstanceRight = sc_maths._newgetdirleft(_testQuator);
                                                    //arrayofindexzeromesh[c].instancesDataRIGHT[cc].instancePos.X = dirTargetInstanceRight.X;
                                                    //arrayofindexzeromesh[c].instancesDataRIGHT[cc].instancePos.Y = dirTargetInstanceRight.Y;
                                                    //arrayofindexzeromesh[c].instancesDataRIGHT[cc].instancePos.Z = dirTargetInstanceRight.Z;
                                                    //arrayofindexzeromesh[c].instancesDataRIGHT[cc].instancePos.W = 1;

                                                    //Quaternion.RotationMatrix(ref tempmat0, out quat_buffers);
                                                    //var dirTargetInstanceUp = sc_maths._newgetdirup(_testQuator);
                                                    //arrayofindexzeromesh[c].instancesDataUP[cc].instancePos.X = dirTargetInstanceUp.X;
                                                    //arrayofindexzeromesh[c].instancesDataUP[cc].instancePos.Y = dirTargetInstanceUp.Y;
                                                    //arrayofindexzeromesh[c].instancesDataUP[cc].instancePos.Z = dirTargetInstanceUp.Z;
                                                    //arrayofindexzeromesh[c].instancesDataUP[cc].instancePos.W = 1;

                                                    //worldMatrixChunkDroneInstance = arrayofindexzeromesh[c].arrayOfScriptForInstances[cc].current_pos;
                                                    //Matrix lastPosDrone = _player_rght_hnd[0][0]._arrayOfInstances[0].current_pos;// //_rightTouchMatrix; //


                                                    //TOREADD
                                                    //TOREADD
                                                    //TOREADD
                                                    /*Quaternion.RotationMatrix(ref worldMatrixChunkDroneInstance, out _testQuator);

                                                    var dirInstanceForward = sc_maths._newgetdirforward(_testQuator);
                                                    somechunkplayerspatiallocationscene[somescenegridindex].arrayofindexzeromesh[c].instancesDataFORWARD[cc].instancePos.X = dirInstanceForward.X;
                                                    somechunkplayerspatiallocationscene[somescenegridindex].arrayofindexzeromesh[c].instancesDataFORWARD[cc].instancePos.Y = dirInstanceForward.Y;
                                                    somechunkplayerspatiallocationscene[somescenegridindex].arrayofindexzeromesh[c].instancesDataFORWARD[cc].instancePos.Z = dirInstanceForward.Z;
                                                    somechunkplayerspatiallocationscene[somescenegridindex].arrayofindexzeromesh[c].instancesDataFORWARD[cc].instancePos.W = 1;

                                                    //Quaternion.RotationMatrix(ref tempmat0, out quat_buffers);
                                                    var dirInstanceRight = -sc_maths._newgetdirleft(_testQuator);
                                                    somechunkplayerspatiallocationscene[somescenegridindex].arrayofindexzeromesh[c].instancesDataRIGHT[cc].instancePos.X = dirInstanceRight.X;
                                                    somechunkplayerspatiallocationscene[somescenegridindex].arrayofindexzeromesh[c].instancesDataRIGHT[cc].instancePos.Y = dirInstanceRight.Y;
                                                    somechunkplayerspatiallocationscene[somescenegridindex].arrayofindexzeromesh[c].instancesDataRIGHT[cc].instancePos.Z = dirInstanceRight.Z;
                                                    somechunkplayerspatiallocationscene[somescenegridindex].arrayofindexzeromesh[c].instancesDataRIGHT[cc].instancePos.W = 1;

                                                    //Quaternion.RotationMatrix(ref tempmat0, out quat_buffers);    
                                                    var dirInstanceUp = sc_maths._newgetdirup(_testQuator);
                                                    somechunkplayerspatiallocationscene[somescenegridindex].arrayofindexzeromesh[c].instancesDataUP[cc].instancePos.X = dirInstanceUp.X;
                                                    somechunkplayerspatiallocationscene[somescenegridindex].arrayofindexzeromesh[c].instancesDataUP[cc].instancePos.Y = dirInstanceUp.Y;
                                                    somechunkplayerspatiallocationscene[somescenegridindex].arrayofindexzeromesh[c].instancesDataUP[cc].instancePos.Z = dirInstanceUp.Z;
                                                    somechunkplayerspatiallocationscene[somescenegridindex].arrayofindexzeromesh[c].instancesDataUP[cc].instancePos.W = 1;

                                                    //TOREADD
                                                    //TOREADD
                                                    //TOREADD
                                                    






                                                    //somechunkplayerspatiallocationscene[somescenegridindex].arrayofindexzeromesh[c].arrayOfScriptForInstances[cc].current_pos.M41 = somechunkplayerspatiallocationscene[somescenegridindex].arrayofindexzeromesh[c].instances[cc].instancePos.X;
                                                    //somechunkplayerspatiallocationscene[somescenegridindex].arrayofindexzeromesh[c].arrayOfScriptForInstances[cc].current_pos.M42 = somechunkplayerspatiallocationscene[somescenegridindex].arrayofindexzeromesh[c].instances[cc].instancePos.Y;
                                                    //somechunkplayerspatiallocationscene[somescenegridindex].arrayofindexzeromesh[c].arrayOfScriptForInstances[cc].current_pos.M43 = somechunkplayerspatiallocationscene[somescenegridindex].arrayofindexzeromesh[c].instances[cc].instancePos.Z;


                                                    //somechunkplayerspatiallocationscene[somescenegridindex].arrayofindexzeromesh[c].arrayOfScriptForInstances[cc].current_pos.M41 = somechunkplayerspatiallocationscene[somescenegridindex].arrayofindexzeromesh[c].instances[cc].instancePos.X;
                                                    //somechunkplayerspatiallocationscene[somescenegridindex].arrayofindexzeromesh[c].arrayOfScriptForInstances[cc].current_pos.M42 = somechunkplayerspatiallocationscene[somescenegridindex].arrayofindexzeromesh[c].instances[cc].instancePos.Y;
                                                    //somechunkplayerspatiallocationscene[somescenegridindex].arrayofindexzeromesh[c].arrayOfScriptForInstances[cc].current_pos.M43 = somechunkplayerspatiallocationscene[somescenegridindex].arrayofindexzeromesh[c].instances[cc].instancePos.Z;



                                                    //TO READD
                                                    somechunkplayerspatiallocationscene[somescenegridindex].arrayOfChunkData[c].instancesmatrix[cc].instancematrix.M11 = somechunkplayerspatiallocationscene[somescenegridindex].arrayofindexzeromesh[c].instancesmatrix[cc].instancematrix.M11;
                                                    somechunkplayerspatiallocationscene[somescenegridindex].arrayOfChunkData[c].instancesmatrix[cc].instancematrix.M12 = somechunkplayerspatiallocationscene[somescenegridindex].arrayofindexzeromesh[c].instancesmatrix[cc].instancematrix.M12;
                                                    somechunkplayerspatiallocationscene[somescenegridindex].arrayOfChunkData[c].instancesmatrix[cc].instancematrix.M13 = somechunkplayerspatiallocationscene[somescenegridindex].arrayofindexzeromesh[c].instancesmatrix[cc].instancematrix.M13;
                                                    somechunkplayerspatiallocationscene[somescenegridindex].arrayOfChunkData[c].instancesmatrix[cc].instancematrix.M14 = somechunkplayerspatiallocationscene[somescenegridindex].arrayofindexzeromesh[c].instancesmatrix[cc].instancematrix.M14;

                                                    somechunkplayerspatiallocationscene[somescenegridindex].arrayOfChunkData[c].instancesmatrix[cc].instancematrix.M21 = somechunkplayerspatiallocationscene[somescenegridindex].arrayofindexzeromesh[c].instancesmatrix[cc].instancematrix.M21;
                                                    somechunkplayerspatiallocationscene[somescenegridindex].arrayOfChunkData[c].instancesmatrix[cc].instancematrix.M22 = somechunkplayerspatiallocationscene[somescenegridindex].arrayofindexzeromesh[c].instancesmatrix[cc].instancematrix.M22;
                                                    somechunkplayerspatiallocationscene[somescenegridindex].arrayOfChunkData[c].instancesmatrix[cc].instancematrix.M23 = somechunkplayerspatiallocationscene[somescenegridindex].arrayofindexzeromesh[c].instancesmatrix[cc].instancematrix.M23;
                                                    somechunkplayerspatiallocationscene[somescenegridindex].arrayOfChunkData[c].instancesmatrix[cc].instancematrix.M24 = somechunkplayerspatiallocationscene[somescenegridindex].arrayofindexzeromesh[c].instancesmatrix[cc].instancematrix.M24;


                                                    somechunkplayerspatiallocationscene[somescenegridindex].arrayOfChunkData[c].instancesmatrix[cc].instancematrix.M31 = somechunkplayerspatiallocationscene[somescenegridindex].arrayofindexzeromesh[c].instancesmatrix[cc].instancematrix.M31;
                                                    somechunkplayerspatiallocationscene[somescenegridindex].arrayOfChunkData[c].instancesmatrix[cc].instancematrix.M32 = somechunkplayerspatiallocationscene[somescenegridindex].arrayofindexzeromesh[c].instancesmatrix[cc].instancematrix.M32;
                                                    somechunkplayerspatiallocationscene[somescenegridindex].arrayOfChunkData[c].instancesmatrix[cc].instancematrix.M33 = somechunkplayerspatiallocationscene[somescenegridindex].arrayofindexzeromesh[c].instancesmatrix[cc].instancematrix.M33;
                                                    somechunkplayerspatiallocationscene[somescenegridindex].arrayOfChunkData[c].instancesmatrix[cc].instancematrix.M34 = somechunkplayerspatiallocationscene[somescenegridindex].arrayofindexzeromesh[c].instancesmatrix[cc].instancematrix.M34;


                                                    somechunkplayerspatiallocationscene[somescenegridindex].arrayOfChunkData[c].instancesmatrix[cc].instancematrix.M41 = somechunkplayerspatiallocationscene[somescenegridindex].arrayofindexzeromesh[c].instancesmatrix[cc].instancematrix.M41;
                                                    somechunkplayerspatiallocationscene[somescenegridindex].arrayOfChunkData[c].instancesmatrix[cc].instancematrix.M42 = somechunkplayerspatiallocationscene[somescenegridindex].arrayofindexzeromesh[c].instancesmatrix[cc].instancematrix.M42;
                                                    somechunkplayerspatiallocationscene[somescenegridindex].arrayOfChunkData[c].instancesmatrix[cc].instancematrix.M43 = somechunkplayerspatiallocationscene[somescenegridindex].arrayofindexzeromesh[c].instancesmatrix[cc].instancematrix.M43;
                                                    somechunkplayerspatiallocationscene[somescenegridindex].arrayOfChunkData[c].instancesmatrix[cc].instancematrix.M44 = somechunkplayerspatiallocationscene[somescenegridindex].arrayofindexzeromesh[c].instancesmatrix[cc].instancematrix.M44;


                                                }
                                            }
                                        }
                                        somechunkplayerspatiallocationscene[somescenegridindex].arrayOfChunkData[c].copytobuffer = 0;
                                    }





                                    somechunkplayerspatiallocationscene[somescenegridindex].arrayOfChunkData[c].instancesLocationW = somechunkplayerspatiallocationscene[somescenegridindex].arrayofindexzeromesh[c].instancesLocationW;
                                    somechunkplayerspatiallocationscene[somescenegridindex].arrayOfChunkData[c].instancesLocationH = somechunkplayerspatiallocationscene[somescenegridindex].arrayofindexzeromesh[c].instancesLocationH;


                                    somechunkplayerspatiallocationscene[somescenegridindex].arrayOfChunkData[c].SC_instancedChunk_InstancesFORWARD = somechunkplayerspatiallocationscene[somescenegridindex].arrayofindexzeromesh[c].instancesDataFORWARD;
                                    somechunkplayerspatiallocationscene[somescenegridindex].arrayOfChunkData[c].SC_instancedChunk_InstancesRIGHT = somechunkplayerspatiallocationscene[somescenegridindex].arrayofindexzeromesh[c].instancesDataRIGHT;
                                    somechunkplayerspatiallocationscene[somescenegridindex].arrayOfChunkData[c].SC_instancedChunk_InstancesUP = somechunkplayerspatiallocationscene[somescenegridindex].arrayofindexzeromesh[c].instancesDataUP;


                                    somechunkplayerspatiallocationscene[somescenegridindex].arrayOfChunkData[c].colorsNFaces = somechunkplayerspatiallocationscene[somescenegridindex].arrayofindexzeromesh[c].colorsNFaces;
                                    somechunkplayerspatiallocationscene[somescenegridindex].arrayOfChunkData[c].lightBuffer = somechunkplayerspatiallocationscene[somescenegridindex].lightBufferInstChunk;
                                    somechunkplayerspatiallocationscene[somescenegridindex].arrayOfChunkData[c].SC_instancedChunk_Instances = somechunkplayerspatiallocationscene[somescenegridindex].arrayofindexzeromesh[c].instances;

                                }
                            }
                        }
                    }
                }
            }*/
            //SCCS VIRTUAL REALITY PLAYER CHUNK SPATIAL LOCATION VISUALIZER
            //SCCS VIRTUAL REALITY PLAYER CHUNK SPATIAL LOCATION VISUALIZER
            //SCCS VIRTUAL REALITY PLAYER CHUNK SPATIAL LOCATION VISUALIZER


















            /*
            //VOXEL ROOM
            for (int xxx = 0; xxx < somevoxelroomw; xxx++)
            {
                for (int yyy = 0; yyy < somechunkkeyboardsgridh; yyy++)
                {
                    for (int zzz = 0; zzz < somechunkkeyboardsgridd; zzz++)
                    {
                        //somechunkmesh
                        var somevoxelroomindex = xxx + somevoxelroomw * (yyy + somechunkkeyboardsgridh * zzz);


                        for (int x = 0; x < somevoxelroomglobals.numberOfObjectInWidth; x++)
                        {
                            for (int y = 0; y < somevoxelroomglobals.numberOfObjectInHeight; y++)
                            {
                                for (int z = 0; z < somevoxelroomglobals.numberOfObjectInDepth; z++)
                                {
                                    int c = x + somevoxelroomglobals.numberOfObjectInWidth * (y + somevoxelroomglobals.numberOfObjectInHeight * z);

                                    for (int xx = 0; xx < somevoxelroomglobals.numberOfInstancesPerObjectInWidth; xx++)
                                    {
                                        for (int yy = 0; yy < somevoxelroomglobals.numberOfInstancesPerObjectInHeight; yy++)
                                        {
                                            for (int zz = 0; zz < somevoxelroomglobals.numberOfInstancesPerObjectInDepth; zz++)
                                            {
                                                int cc = xx + somevoxelroomglobals.numberOfInstancesPerObjectInWidth * (yy + somevoxelroomglobals.numberOfInstancesPerObjectInHeight * zz);

                                                Matrix worldMatrixChunkDroneInstance = somevoxelroom[somevoxelroomindex].arrayofindexzeromesh[c].arrayofzeromeshinstances[cc].current_pos;

                                                Matrix worldMatrixmain = somevoxelroom[somevoxelroomindex].worldmatofobj;


                                                Quaternion _testQuator;


                                                //worldMatrixChunkDroneInstance = worldMatrixChunkDroneInstance * somevoxelroom[somevoxelroomindex].worldmatofobj;

                                                //TOREADD
                                                //TOREADD
                                                //TOREADD
                                                Quaternion.RotationMatrix(ref worldMatrixChunkDroneInstance, out _testQuator);

                                                var dirInstanceForward = sc_maths._newgetdirforward(_testQuator);
                                                somevoxelroom[somevoxelroomindex].arrayofindexzeromesh[c].instancesDataFORWARD[cc].instancePos.X = dirInstanceForward.X;
                                                somevoxelroom[somevoxelroomindex].arrayofindexzeromesh[c].instancesDataFORWARD[cc].instancePos.Y = dirInstanceForward.Y;
                                                somevoxelroom[somevoxelroomindex].arrayofindexzeromesh[c].instancesDataFORWARD[cc].instancePos.Z = dirInstanceForward.Z;
                                                somevoxelroom[somevoxelroomindex].arrayofindexzeromesh[c].instancesDataFORWARD[cc].instancePos.W = 1;

                                                //Quaternion.RotationMatrix(ref tempmat0, out quat_buffers);
                                                var dirInstanceRight = -sc_maths._newgetdirleft(_testQuator);
                                                somevoxelroom[somevoxelroomindex].arrayofindexzeromesh[c].instancesDataRIGHT[cc].instancePos.X = dirInstanceRight.X;
                                                somevoxelroom[somevoxelroomindex].arrayofindexzeromesh[c].instancesDataRIGHT[cc].instancePos.Y = dirInstanceRight.Y;
                                                somevoxelroom[somevoxelroomindex].arrayofindexzeromesh[c].instancesDataRIGHT[cc].instancePos.Z = dirInstanceRight.Z;
                                                somevoxelroom[somevoxelroomindex].arrayofindexzeromesh[c].instancesDataRIGHT[cc].instancePos.W = 1;

                                                //Quaternion.RotationMatrix(ref tempmat0, out quat_buffers);    
                                                var dirInstanceUp = sc_maths._newgetdirup(_testQuator);
                                                somevoxelroom[somevoxelroomindex].arrayofindexzeromesh[c].instancesDataUP[cc].instancePos.X = dirInstanceUp.X;
                                                somevoxelroom[somevoxelroomindex].arrayofindexzeromesh[c].instancesDataUP[cc].instancePos.Y = dirInstanceUp.Y;
                                                somevoxelroom[somevoxelroomindex].arrayofindexzeromesh[c].instancesDataUP[cc].instancePos.Z = dirInstanceUp.Z;
                                                somevoxelroom[somevoxelroomindex].arrayofindexzeromesh[c].instancesDataUP[cc].instancePos.W = 1;

                                                //TOREADD
                                                //TOREADD
                                                //TOREADD





                                                /*
                                                Quaternion.RotationMatrix(ref worldMatrixChunkDroneInstance, out _testQuator);

                                                var dirInstanceForward = sc_maths._newgetdirforward(_testQuator);
                                                somevoxelroom[somevoxelroomindex].arrayOfChunkData[c].SC_instancedChunk_InstancesFORWARD[cc].instancePos.X = dirInstanceForward.X;
                                                somevoxelroom[somevoxelroomindex].arrayOfChunkData[c].SC_instancedChunk_InstancesFORWARD[cc].instancePos.Y = dirInstanceForward.Y;
                                                somevoxelroom[somevoxelroomindex].arrayOfChunkData[c].SC_instancedChunk_InstancesFORWARD[cc].instancePos.Z = dirInstanceForward.Z;
                                                somevoxelroom[somevoxelroomindex].arrayOfChunkData[c].SC_instancedChunk_InstancesFORWARD[cc].instancePos.W = 1;

                                                //Quaternion.RotationMatrix(ref tempmat0, out quat_buffers);
                                                var dirInstanceRight = -sc_maths._newgetdirleft(_testQuator);
                                                somevoxelroom[somevoxelroomindex].arrayOfChunkData[c].SC_instancedChunk_InstancesRIGHT[cc].instancePos.X = dirInstanceRight.X;
                                                somevoxelroom[somevoxelroomindex].arrayOfChunkData[c].SC_instancedChunk_InstancesRIGHT[cc].instancePos.Y = dirInstanceRight.Y;
                                                somevoxelroom[somevoxelroomindex].arrayOfChunkData[c].SC_instancedChunk_InstancesRIGHT[cc].instancePos.Z = dirInstanceRight.Z;
                                                somevoxelroom[somevoxelroomindex].arrayOfChunkData[c].SC_instancedChunk_InstancesRIGHT[cc].instancePos.W = 1;

                                                //Quaternion.RotationMatrix(ref tempmat0, out quat_buffers);    
                                                var dirInstanceUp = sc_maths._newgetdirup(_testQuator);
                                                somevoxelroom[somevoxelroomindex].arrayOfChunkData[c].SC_instancedChunk_InstancesUP[cc].instancePos.X = dirInstanceUp.X;
                                                somevoxelroom[somevoxelroomindex].arrayOfChunkData[c].SC_instancedChunk_InstancesUP[cc].instancePos.Y = dirInstanceUp.Y;
                                                somevoxelroom[somevoxelroomindex].arrayOfChunkData[c].SC_instancedChunk_InstancesUP[cc].instancePos.Z = dirInstanceUp.Z;
                                                somevoxelroom[somevoxelroomindex].arrayOfChunkData[c].SC_instancedChunk_InstancesUP[cc].instancePos.W = 1;


                                                Vector3 currentmainobjectpos = new Vector3(somevoxelroom[somevoxelroomindex].worldmatofobj.M41, somevoxelroom[somevoxelroomindex].worldmatofobj.M42, somevoxelroom[somevoxelroomindex].worldmatofobj.M43);

                                                float diffmainpostoinstanceposx = somevoxelroom[somevoxelroomindex].arrayofindexzeromesh[c].instances[cc].instancePos.X - currentmainobjectpos.X;
                                                float diffmainpostoinstanceposy = somevoxelroom[somevoxelroomindex].arrayofindexzeromesh[c].instances[cc].instancePos.Y - currentmainobjectpos.Y;
                                                float diffmainpostoinstanceposz = somevoxelroom[somevoxelroomindex].arrayofindexzeromesh[c].instances[cc].instancePos.Z - currentmainobjectpos.Z;
                                                */




                                                /*Quaternion somedirquat;

                                                Quaternion.RotationMatrix(ref worldMatrixChunkDroneInstance, out somedirquat);

                                                var dirInstanceForward = sc_maths._newgetdirforward(somedirquat);
                                                var dirInstanceRight = -sc_maths._newgetdirleft(somedirquat);
                                                var dirInstanceUp = sc_maths._newgetdirup(somedirquat);*/

                                                /*Vector4 somevecx = new Vector4(dirInstanceRight.X, dirInstanceRight.Y, dirInstanceRight.Z, 1.0f);
                                                Vector4 somevecy = new Vector4(dirInstanceUp.X, dirInstanceUp.Y, dirInstanceUp.Z, 1.0f);
                                                Vector4 somevecz = new Vector4(dirInstanceForward.X, dirInstanceForward.Y, dirInstanceForward.Z, 1.0f);

                                                Vector4 someinstancepostest = Vector4.Zero;
                                                Vector4 somemainpos = new Vector4(worldMatrixmain.M41, worldMatrixmain.M42, worldMatrixmain.M43, 1.0f);

                                                someinstancepostest = somevoxelroom[somevoxelroomindex].arrayofindexzeromesh[c].instances[cc].instancePos + (somevecx);// * (xx * 4 * 4 * 0.01f * 0.5f * 0.5f));
                                                someinstancepostest = somevoxelroom[somevoxelroomindex].arrayofindexzeromesh[c].instances[cc].instancePos + (somevecy);//  * (yy * 4 * 4 * 0.01f * 0.5f * 0.5f));
                                                someinstancepostest = somevoxelroom[somevoxelroomindex].arrayofindexzeromesh[c].instances[cc].instancePos + (somevecz);//  * (zz * 4 * 4 * 0.01f * 0.5f * 0.5f));
                                                */
                                                //somevoxelroom[somevoxelroomindex].arrayofindexzeromesh[c].instances[cc].instancePos.X += somemainpos.X + someinstancepostest.X;
                                                //somevoxelroom[somevoxelroomindex].arrayofindexzeromesh[c].instances[cc].instancePos.Y += somemainpos.Y + someinstancepostest.Y;
                                                //somevoxelroom[somevoxelroomindex].arrayofindexzeromesh[c].instances[cc].instancePos.Z += somemainpos.Z + someinstancepostest.Z;
                                                /*
                                                somevoxelroom[somevoxelroomindex].arrayofindexzeromesh[c].instances[cc].instancePos.X = someinstancepostest.X;
                                                somevoxelroom[somevoxelroomindex].arrayofindexzeromesh[c].instances[cc].instancePos.Y = someinstancepostest.Y;
                                                somevoxelroom[somevoxelroomindex].arrayofindexzeromesh[c].instances[cc].instancePos.Z = someinstancepostest.Z;
                                                */


                                                //somevoxelroom[somevoxelroomindex].arrayOfChunkData[c].SC_instancedChunk_Instances[cc].instancePos.X = somevoxelroom[somevoxelroomindex].arrayOfChunkData[c].SC_instancedChunk_Instances[cc].instancePos.X + -(somevoxelroom[somevoxelroomindex].arrayOfChunkData[c].SC_instancedChunk_InstancesFORWARD[cc].instancePos.X * diffmainpostoinstanceposx);
                                                //somevoxelroom[somevoxelroomindex].arrayOfChunkData[c].SC_instancedChunk_Instances[cc].instancePos.Y = somevoxelroom[somevoxelroomindex].arrayOfChunkData[c].SC_instancedChunk_Instances[cc].instancePos.Y + -(somevoxelroom[somevoxelroomindex].arrayOfChunkData[c].SC_instancedChunk_InstancesFORWARD[cc].instancePos.Y * diffmainpostoinstanceposy);
                                                //somevoxelroom[somevoxelroomindex].arrayOfChunkData[c].SC_instancedChunk_Instances[cc].instancePos.Z = somevoxelroom[somevoxelroomindex].arrayOfChunkData[c].SC_instancedChunk_Instances[cc].instancePos.Z + -(somevoxelroom[somevoxelroomindex].arrayOfChunkData[c].SC_instancedChunk_InstancesFORWARD[cc].instancePos.Z * diffmainpostoinstanceposz);

                                                //somevoxelroom[somevoxelroomindex].arrayOfChunkData[c].SC_instancedChunk_Instances[cc].instancePos.X = currentmainobjectpos.X + (somevoxelroom[somevoxelroomindex].arrayofindexzeromesh[c].instan[cc].instancePos.X + (dirInstanceRight.X * diffmainpostoinstanceposx));
                                                //somevoxelroom[somevoxelroomindex].arrayOfChunkData[c].SC_instancedChunk_Instances[cc].instancePos.Y = currentmainobjectpos.Y + (somevoxelroom[somevoxelroomindex].arrayofindexzeromesh[c].instances[cc].instancePos.Y + (dirInstanceUp.Y * diffmainpostoinstanceposy));
                                                //somevoxelroom[somevoxelroomindex].arrayOfChunkData[c].SC_instancedChunk_Instances[cc].instancePos.Z = currentmainobjectpos.Z + (somevoxelroom[somevoxelroomindex].arrayofindexzeromesh[c].instances[cc].instancePos.Z + (dirInstanceForward.Z * diffmainpostoinstanceposz));


                                                /*Vector4 somevecx = new Vector4(dirInstanceRight.X, dirInstanceRight.Y, dirInstanceRight.Z, 1.0f);
                                                Vector4 somevecy = new Vector4(dirInstanceUp.X, dirInstanceUp.Y, dirInstanceUp.Z, 1.0f);
                                                Vector4 somevecz = new Vector4(dirInstanceForward.X, dirInstanceForward.Y, dirInstanceForward.Z, 1.0f);

                                                somevoxelroom[somevoxelroomindex].arrayOfChunkData[c].SC_instancedChunk_Instances[cc].instancePos = somevoxelroom[somevoxelroomindex].arrayOfChunkData[c].SC_instancedChunk_Instances[cc].instancePos + (somevecx * diffmainpostoinstanceposx);
                                                somevoxelroom[somevoxelroomindex].arrayOfChunkData[c].SC_instancedChunk_Instances[cc].instancePos = somevoxelroom[somevoxelroomindex].arrayOfChunkData[c].SC_instancedChunk_Instances[cc].instancePos + (somevecy * diffmainpostoinstanceposy);
                                                somevoxelroom[somevoxelroomindex].arrayOfChunkData[c].SC_instancedChunk_Instances[cc].instancePos = somevoxelroom[somevoxelroomindex].arrayOfChunkData[c].SC_instancedChunk_Instances[cc].instancePos + (somevecz * diffmainpostoinstanceposz);
                                                





                                            }
                                        }
                                    }






                                    if (somevoxelroom[somevoxelroomindex].arrayOfChunkData[c].copytobuffer == 1)
                                    {
                                        for (int xx = 0; xx < somevoxelroomglobals.numberOfInstancesPerObjectInWidth; xx++)
                                        {
                                            for (int yy = 0; yy < somevoxelroomglobals.numberOfInstancesPerObjectInHeight; yy++)
                                            {
                                                for (int zz = 0; zz < somevoxelroomglobals.numberOfInstancesPerObjectInDepth; zz++)
                                                {
                                                    int cc = xx + somevoxelroomglobals.numberOfInstancesPerObjectInWidth * (yy + somevoxelroomglobals.numberOfInstancesPerObjectInHeight * zz);

                                                    //Matrix worldMatrixChunkDroneInstance = somevoxelroom[somevoxelroomindex].arrayofindexzeromesh[c].arrayofzeromeshinstances[cc].current_pos;
                                                    //Quaternion _testQuator;


                                                    //TO READD FOR SOME LOGIC.
                                                    //Matrix lastPosTarget = _player_rght_hnd[0][0]._arrayOfInstances[0].current_pos;// //_rightTouchMatrix; //
                                                    //Quaternion.RotationMatrix(ref lastPosTarget, out _testQuator);
                                                    //TO READD FOR SOME LOGIC.




                                                    //arrayofindexzeromesh[c].arrayOfScriptForInstances[cc].

                                                    //var dirTargetInstanceForward = sc_maths._newgetdirforward(_testQuator);
                                                    //arrayofindexzeromesh[c].instancesDataFORWARD[cc].instancePos.X = dirTargetInstanceForward.X;
                                                    //arrayofindexzeromesh[c].instancesDataFORWARD[cc].instancePos.Y = dirTargetInstanceForward.Y;
                                                    //arrayofindexzeromesh[c].instancesDataFORWARD[cc].instancePos.Z = dirTargetInstanceForward.Z;
                                                    //arrayofindexzeromesh[c].instancesDataFORWARD[cc].instancePos.W = 1;

                                                    //Quaternion.RotationMatrix(ref tempmat0, out quat_buffers);
                                                    //var dirTargetInstanceRight = sc_maths._newgetdirleft(_testQuator);
                                                    //arrayofindexzeromesh[c].instancesDataRIGHT[cc].instancePos.X = dirTargetInstanceRight.X;
                                                    //arrayofindexzeromesh[c].instancesDataRIGHT[cc].instancePos.Y = dirTargetInstanceRight.Y;
                                                    //arrayofindexzeromesh[c].instancesDataRIGHT[cc].instancePos.Z = dirTargetInstanceRight.Z;
                                                    //arrayofindexzeromesh[c].instancesDataRIGHT[cc].instancePos.W = 1;

                                                    //Quaternion.RotationMatrix(ref tempmat0, out quat_buffers);
                                                    //var dirTargetInstanceUp = sc_maths._newgetdirup(_testQuator);
                                                    //arrayofindexzeromesh[c].instancesDataUP[cc].instancePos.X = dirTargetInstanceUp.X;
                                                    //arrayofindexzeromesh[c].instancesDataUP[cc].instancePos.Y = dirTargetInstanceUp.Y;
                                                    //arrayofindexzeromesh[c].instancesDataUP[cc].instancePos.Z = dirTargetInstanceUp.Z;
                                                    //arrayofindexzeromesh[c].instancesDataUP[cc].instancePos.W = 1;

                                                    //worldMatrixChunkDroneInstance = arrayofindexzeromesh[c].arrayOfScriptForInstances[cc].current_pos;
                                                    //Matrix lastPosDrone = _player_rght_hnd[0][0]._arrayOfInstances[0].current_pos;// //_rightTouchMatrix; //


                                                    //TOREADD
                                                    //TOREADD
                                                    //TOREADD
                                                    /*Quaternion.RotationMatrix(ref worldMatrixChunkDroneInstance, out _testQuator);

                                                    var dirInstanceForward = sc_maths._newgetdirforward(_testQuator);
                                                    somevoxelroom[somevoxelroomindex].arrayofindexzeromesh[c].instancesDataFORWARD[cc].instancePos.X = dirInstanceForward.X;
                                                    somevoxelroom[somevoxelroomindex].arrayofindexzeromesh[c].instancesDataFORWARD[cc].instancePos.Y = dirInstanceForward.Y;
                                                    somevoxelroom[somevoxelroomindex].arrayofindexzeromesh[c].instancesDataFORWARD[cc].instancePos.Z = dirInstanceForward.Z;
                                                    somevoxelroom[somevoxelroomindex].arrayofindexzeromesh[c].instancesDataFORWARD[cc].instancePos.W = 1;

                                                    //Quaternion.RotationMatrix(ref tempmat0, out quat_buffers);
                                                    var dirInstanceRight = -sc_maths._newgetdirleft(_testQuator);
                                                    somevoxelroom[somevoxelroomindex].arrayofindexzeromesh[c].instancesDataRIGHT[cc].instancePos.X = dirInstanceRight.X;
                                                    somevoxelroom[somevoxelroomindex].arrayofindexzeromesh[c].instancesDataRIGHT[cc].instancePos.Y = dirInstanceRight.Y;
                                                    somevoxelroom[somevoxelroomindex].arrayofindexzeromesh[c].instancesDataRIGHT[cc].instancePos.Z = dirInstanceRight.Z;
                                                    somevoxelroom[somevoxelroomindex].arrayofindexzeromesh[c].instancesDataRIGHT[cc].instancePos.W = 1;

                                                    //Quaternion.RotationMatrix(ref tempmat0, out quat_buffers);    
                                                    var dirInstanceUp = sc_maths._newgetdirup(_testQuator);
                                                    somevoxelroom[somevoxelroomindex].arrayofindexzeromesh[c].instancesDataUP[cc].instancePos.X = dirInstanceUp.X;
                                                    somevoxelroom[somevoxelroomindex].arrayofindexzeromesh[c].instancesDataUP[cc].instancePos.Y = dirInstanceUp.Y;
                                                    somevoxelroom[somevoxelroomindex].arrayofindexzeromesh[c].instancesDataUP[cc].instancePos.Z = dirInstanceUp.Z;
                                                    somevoxelroom[somevoxelroomindex].arrayofindexzeromesh[c].instancesDataUP[cc].instancePos.W = 1;
                                                    
                                                    //TOREADD
                                                    //TOREADD
                                                    //TOREADD







                                                    //somevoxelroom[somevoxelroomindex].arrayofindexzeromesh[c].arrayOfScriptForInstances[cc].current_pos.M41 = somevoxelroom[somevoxelroomindex].arrayofindexzeromesh[c].instances[cc].instancePos.X;
                                                    //somevoxelroom[somevoxelroomindex].arrayofindexzeromesh[c].arrayOfScriptForInstances[cc].current_pos.M42 = somevoxelroom[somevoxelroomindex].arrayofindexzeromesh[c].instances[cc].instancePos.Y;
                                                    //somevoxelroom[somevoxelroomindex].arrayofindexzeromesh[c].arrayOfScriptForInstances[cc].current_pos.M43 = somevoxelroom[somevoxelroomindex].arrayofindexzeromesh[c].instances[cc].instancePos.Z;


                                                    //somevoxelroom[somevoxelroomindex].arrayofindexzeromesh[c].arrayOfScriptForInstances[cc].current_pos.M41 = somevoxelroom[somevoxelroomindex].arrayofindexzeromesh[c].instances[cc].instancePos.X;
                                                    //somevoxelroom[somevoxelroomindex].arrayofindexzeromesh[c].arrayOfScriptForInstances[cc].current_pos.M42 = somevoxelroom[somevoxelroomindex].arrayofindexzeromesh[c].instances[cc].instancePos.Y;
                                                    //somevoxelroom[somevoxelroomindex].arrayofindexzeromesh[c].arrayOfScriptForInstances[cc].current_pos.M43 = somevoxelroom[somevoxelroomindex].arrayofindexzeromesh[c].instances[cc].instancePos.Z;



                                                    //TO READD
                                                    somevoxelroom[somevoxelroomindex].arrayOfChunkData[c].instancesmatrix[cc].instancematrix.M11 = somevoxelroom[somevoxelroomindex].arrayofindexzeromesh[c].instancesmatrix[cc].instancematrix.M11;
                                                    somevoxelroom[somevoxelroomindex].arrayOfChunkData[c].instancesmatrix[cc].instancematrix.M12 = somevoxelroom[somevoxelroomindex].arrayofindexzeromesh[c].instancesmatrix[cc].instancematrix.M12;
                                                    somevoxelroom[somevoxelroomindex].arrayOfChunkData[c].instancesmatrix[cc].instancematrix.M13 = somevoxelroom[somevoxelroomindex].arrayofindexzeromesh[c].instancesmatrix[cc].instancematrix.M13;
                                                    somevoxelroom[somevoxelroomindex].arrayOfChunkData[c].instancesmatrix[cc].instancematrix.M14 = somevoxelroom[somevoxelroomindex].arrayofindexzeromesh[c].instancesmatrix[cc].instancematrix.M14;

                                                    somevoxelroom[somevoxelroomindex].arrayOfChunkData[c].instancesmatrix[cc].instancematrix.M21 = somevoxelroom[somevoxelroomindex].arrayofindexzeromesh[c].instancesmatrix[cc].instancematrix.M21;
                                                    somevoxelroom[somevoxelroomindex].arrayOfChunkData[c].instancesmatrix[cc].instancematrix.M22 = somevoxelroom[somevoxelroomindex].arrayofindexzeromesh[c].instancesmatrix[cc].instancematrix.M22;
                                                    somevoxelroom[somevoxelroomindex].arrayOfChunkData[c].instancesmatrix[cc].instancematrix.M23 = somevoxelroom[somevoxelroomindex].arrayofindexzeromesh[c].instancesmatrix[cc].instancematrix.M23;
                                                    somevoxelroom[somevoxelroomindex].arrayOfChunkData[c].instancesmatrix[cc].instancematrix.M24 = somevoxelroom[somevoxelroomindex].arrayofindexzeromesh[c].instancesmatrix[cc].instancematrix.M24;


                                                    somevoxelroom[somevoxelroomindex].arrayOfChunkData[c].instancesmatrix[cc].instancematrix.M31 = somevoxelroom[somevoxelroomindex].arrayofindexzeromesh[c].instancesmatrix[cc].instancematrix.M31;
                                                    somevoxelroom[somevoxelroomindex].arrayOfChunkData[c].instancesmatrix[cc].instancematrix.M32 = somevoxelroom[somevoxelroomindex].arrayofindexzeromesh[c].instancesmatrix[cc].instancematrix.M32;
                                                    somevoxelroom[somevoxelroomindex].arrayOfChunkData[c].instancesmatrix[cc].instancematrix.M33 = somevoxelroom[somevoxelroomindex].arrayofindexzeromesh[c].instancesmatrix[cc].instancematrix.M33;
                                                    somevoxelroom[somevoxelroomindex].arrayOfChunkData[c].instancesmatrix[cc].instancematrix.M34 = somevoxelroom[somevoxelroomindex].arrayofindexzeromesh[c].instancesmatrix[cc].instancematrix.M34;


                                                    somevoxelroom[somevoxelroomindex].arrayOfChunkData[c].instancesmatrix[cc].instancematrix.M41 = somevoxelroom[somevoxelroomindex].arrayofindexzeromesh[c].instancesmatrix[cc].instancematrix.M41;
                                                    somevoxelroom[somevoxelroomindex].arrayOfChunkData[c].instancesmatrix[cc].instancematrix.M42 = somevoxelroom[somevoxelroomindex].arrayofindexzeromesh[c].instancesmatrix[cc].instancematrix.M42;
                                                    somevoxelroom[somevoxelroomindex].arrayOfChunkData[c].instancesmatrix[cc].instancematrix.M43 = somevoxelroom[somevoxelroomindex].arrayofindexzeromesh[c].instancesmatrix[cc].instancematrix.M43;
                                                    somevoxelroom[somevoxelroomindex].arrayOfChunkData[c].instancesmatrix[cc].instancematrix.M44 = somevoxelroom[somevoxelroomindex].arrayofindexzeromesh[c].instancesmatrix[cc].instancematrix.M44;


                                                }
                                            }
                                        }



                                        somevoxelroom[somevoxelroomindex].arrayOfChunkData[c].copytobuffer = 0;
                                    }




                                    somevoxelroom[somevoxelroomindex].arrayOfChunkData[c].instancesLocationW = somevoxelroom[somevoxelroomindex].arrayofindexzeromesh[c].instancesLocationW;
                                    somevoxelroom[somevoxelroomindex].arrayOfChunkData[c].instancesLocationH = somevoxelroom[somevoxelroomindex].arrayofindexzeromesh[c].instancesLocationH;

                                    somevoxelroom[somevoxelroomindex].arrayOfChunkData[c].SC_instancedChunk_InstancesFORWARD = somevoxelroom[somevoxelroomindex].arrayofindexzeromesh[c].instancesDataFORWARD;
                                    somevoxelroom[somevoxelroomindex].arrayOfChunkData[c].SC_instancedChunk_InstancesRIGHT = somevoxelroom[somevoxelroomindex].arrayofindexzeromesh[c].instancesDataRIGHT;
                                    somevoxelroom[somevoxelroomindex].arrayOfChunkData[c].SC_instancedChunk_InstancesUP = somevoxelroom[somevoxelroomindex].arrayofindexzeromesh[c].instancesDataUP;

                                    somevoxelroom[somevoxelroomindex].arrayOfChunkData[c].colorsNFaces = somevoxelroom[somevoxelroomindex].arrayofindexzeromesh[c].colorsNFaces;
                                    somevoxelroom[somevoxelroomindex].arrayOfChunkData[c].lightBuffer = somevoxelroom[somevoxelroomindex].lightBufferInstChunk;
                                    somevoxelroom[somevoxelroomindex].arrayOfChunkData[c].SC_instancedChunk_Instances = somevoxelroom[somevoxelroomindex].arrayofindexzeromesh[c].instances;

                                }
                            }
                        }
                    }
                }
            }*/
            //VOXEL ROOM





















            /*
            //VOXEL ROOM GRID
            for (int xxx = 0; xxx < somevoxelroomgridw; xxx++)
            {
                for (int yyy = 0; yyy < somechunkkeyboardsgridh; yyy++)
                {
                    for (int zzz = 0; zzz < somechunkkeyboardsgridd; zzz++)
                    {
                        //somechunkmesh
                        var somevoxelroomindex = xxx + somevoxelroomgridw * (yyy + somechunkkeyboardsgridh * zzz);


                        for (int x = 0; x < somevoxelroomgridglobals.numberOfObjectInWidth; x++)
                        {
                            for (int y = 0; y < somevoxelroomgridglobals.numberOfObjectInHeight; y++)
                            {
                                for (int z = 0; z < somevoxelroomgridglobals.numberOfObjectInDepth; z++)
                                {
                                    int c = x + somevoxelroomgridglobals.numberOfObjectInWidth * (y + somevoxelroomgridglobals.numberOfObjectInHeight * z);

                                    for (int xx = 0; xx < somevoxelroomgridglobals.numberOfInstancesPerObjectInWidth; xx++)
                                    {
                                        for (int yy = 0; yy < somevoxelroomgridglobals.numberOfInstancesPerObjectInHeight; yy++)
                                        {
                                            for (int zz = 0; zz < somevoxelroomgridglobals.numberOfInstancesPerObjectInDepth; zz++)
                                            {
                                                int cc = xx + somevoxelroomgridglobals.numberOfInstancesPerObjectInWidth * (yy + somevoxelroomgridglobals.numberOfInstancesPerObjectInHeight * zz);

                                                Matrix worldMatrixChunkDroneInstance = somevoxelroomgrid[somevoxelroomindex].arrayofindexzeromesh[c].arrayofzeromeshinstances[cc].current_pos;

                                                Matrix worldMatrixmain = somevoxelroomgrid[somevoxelroomindex].worldmatofobj;


                                                Quaternion _testQuator;


                                                //worldMatrixChunkDroneInstance = worldMatrixChunkDroneInstance * somevoxelroomgrid[somevoxelroomindex].worldmatofobj;

                                                //TOREADD
                                                //TOREADD
                                                //TOREADD
                                                Quaternion.RotationMatrix(ref worldMatrixChunkDroneInstance, out _testQuator);

                                                var dirInstanceForward = sc_maths._newgetdirforward(_testQuator);
                                                somevoxelroomgrid[somevoxelroomindex].arrayofindexzeromesh[c].instancesDataFORWARD[cc].instancePos.X = dirInstanceForward.X;
                                                somevoxelroomgrid[somevoxelroomindex].arrayofindexzeromesh[c].instancesDataFORWARD[cc].instancePos.Y = dirInstanceForward.Y;
                                                somevoxelroomgrid[somevoxelroomindex].arrayofindexzeromesh[c].instancesDataFORWARD[cc].instancePos.Z = dirInstanceForward.Z;
                                                somevoxelroomgrid[somevoxelroomindex].arrayofindexzeromesh[c].instancesDataFORWARD[cc].instancePos.W = 1;

                                                //Quaternion.RotationMatrix(ref tempmat0, out quat_buffers);
                                                var dirInstanceRight = -sc_maths._newgetdirleft(_testQuator);
                                                somevoxelroomgrid[somevoxelroomindex].arrayofindexzeromesh[c].instancesDataRIGHT[cc].instancePos.X = dirInstanceRight.X;
                                                somevoxelroomgrid[somevoxelroomindex].arrayofindexzeromesh[c].instancesDataRIGHT[cc].instancePos.Y = dirInstanceRight.Y;
                                                somevoxelroomgrid[somevoxelroomindex].arrayofindexzeromesh[c].instancesDataRIGHT[cc].instancePos.Z = dirInstanceRight.Z;
                                                somevoxelroomgrid[somevoxelroomindex].arrayofindexzeromesh[c].instancesDataRIGHT[cc].instancePos.W = 1;

                                                //Quaternion.RotationMatrix(ref tempmat0, out quat_buffers);    
                                                var dirInstanceUp = sc_maths._newgetdirup(_testQuator);
                                                somevoxelroomgrid[somevoxelroomindex].arrayofindexzeromesh[c].instancesDataUP[cc].instancePos.X = dirInstanceUp.X;
                                                somevoxelroomgrid[somevoxelroomindex].arrayofindexzeromesh[c].instancesDataUP[cc].instancePos.Y = dirInstanceUp.Y;
                                                somevoxelroomgrid[somevoxelroomindex].arrayofindexzeromesh[c].instancesDataUP[cc].instancePos.Z = dirInstanceUp.Z;
                                                somevoxelroomgrid[somevoxelroomindex].arrayofindexzeromesh[c].instancesDataUP[cc].instancePos.W = 1;

                                                //TOREADD
                                                //TOREADD
                                                //TOREADD





                                                /*
                                                Quaternion.RotationMatrix(ref worldMatrixChunkDroneInstance, out _testQuator);

                                                var dirInstanceForward = sc_maths._newgetdirforward(_testQuator);
                                                somevoxelroomgrid[somevoxelroomindex].arrayOfChunkData[c].SC_instancedChunk_InstancesFORWARD[cc].instancePos.X = dirInstanceForward.X;
                                                somevoxelroomgrid[somevoxelroomindex].arrayOfChunkData[c].SC_instancedChunk_InstancesFORWARD[cc].instancePos.Y = dirInstanceForward.Y;
                                                somevoxelroomgrid[somevoxelroomindex].arrayOfChunkData[c].SC_instancedChunk_InstancesFORWARD[cc].instancePos.Z = dirInstanceForward.Z;
                                                somevoxelroomgrid[somevoxelroomindex].arrayOfChunkData[c].SC_instancedChunk_InstancesFORWARD[cc].instancePos.W = 1;

                                                //Quaternion.RotationMatrix(ref tempmat0, out quat_buffers);
                                                var dirInstanceRight = -sc_maths._newgetdirleft(_testQuator);
                                                somevoxelroomgrid[somevoxelroomindex].arrayOfChunkData[c].SC_instancedChunk_InstancesRIGHT[cc].instancePos.X = dirInstanceRight.X;
                                                somevoxelroomgrid[somevoxelroomindex].arrayOfChunkData[c].SC_instancedChunk_InstancesRIGHT[cc].instancePos.Y = dirInstanceRight.Y;
                                                somevoxelroomgrid[somevoxelroomindex].arrayOfChunkData[c].SC_instancedChunk_InstancesRIGHT[cc].instancePos.Z = dirInstanceRight.Z;
                                                somevoxelroomgrid[somevoxelroomindex].arrayOfChunkData[c].SC_instancedChunk_InstancesRIGHT[cc].instancePos.W = 1;

                                                //Quaternion.RotationMatrix(ref tempmat0, out quat_buffers);    
                                                var dirInstanceUp = sc_maths._newgetdirup(_testQuator);
                                                somevoxelroomgrid[somevoxelroomindex].arrayOfChunkData[c].SC_instancedChunk_InstancesUP[cc].instancePos.X = dirInstanceUp.X;
                                                somevoxelroomgrid[somevoxelroomindex].arrayOfChunkData[c].SC_instancedChunk_InstancesUP[cc].instancePos.Y = dirInstanceUp.Y;
                                                somevoxelroomgrid[somevoxelroomindex].arrayOfChunkData[c].SC_instancedChunk_InstancesUP[cc].instancePos.Z = dirInstanceUp.Z;
                                                somevoxelroomgrid[somevoxelroomindex].arrayOfChunkData[c].SC_instancedChunk_InstancesUP[cc].instancePos.W = 1;


                                                Vector3 currentmainobjectpos = new Vector3(somevoxelroomgrid[somevoxelroomindex].worldmatofobj.M41, somevoxelroomgrid[somevoxelroomindex].worldmatofobj.M42, somevoxelroomgrid[somevoxelroomindex].worldmatofobj.M43);

                                                float diffmainpostoinstanceposx = somevoxelroomgrid[somevoxelroomindex].arrayofindexzeromesh[c].instances[cc].instancePos.X - currentmainobjectpos.X;
                                                float diffmainpostoinstanceposy = somevoxelroomgrid[somevoxelroomindex].arrayofindexzeromesh[c].instances[cc].instancePos.Y - currentmainobjectpos.Y;
                                                float diffmainpostoinstanceposz = somevoxelroomgrid[somevoxelroomindex].arrayofindexzeromesh[c].instances[cc].instancePos.Z - currentmainobjectpos.Z;
                                                */




                                                /*Quaternion somedirquat;

                                                Quaternion.RotationMatrix(ref worldMatrixChunkDroneInstance, out somedirquat);

                                                var dirInstanceForward = sc_maths._newgetdirforward(somedirquat);
                                                var dirInstanceRight = -sc_maths._newgetdirleft(somedirquat);
                                                var dirInstanceUp = sc_maths._newgetdirup(somedirquat);*/

                                                /*Vector4 somevecx = new Vector4(dirInstanceRight.X, dirInstanceRight.Y, dirInstanceRight.Z, 1.0f);
                                                Vector4 somevecy = new Vector4(dirInstanceUp.X, dirInstanceUp.Y, dirInstanceUp.Z, 1.0f);
                                                Vector4 somevecz = new Vector4(dirInstanceForward.X, dirInstanceForward.Y, dirInstanceForward.Z, 1.0f);

                                                Vector4 someinstancepostest = Vector4.Zero;
                                                Vector4 somemainpos = new Vector4(worldMatrixmain.M41, worldMatrixmain.M42, worldMatrixmain.M43, 1.0f);

                                                someinstancepostest = somevoxelroomgrid[somevoxelroomindex].arrayofindexzeromesh[c].instances[cc].instancePos + (somevecx);// * (xx * 4 * 4 * 0.01f * 0.5f * 0.5f));
                                                someinstancepostest = somevoxelroomgrid[somevoxelroomindex].arrayofindexzeromesh[c].instances[cc].instancePos + (somevecy);//  * (yy * 4 * 4 * 0.01f * 0.5f * 0.5f));
                                                someinstancepostest = somevoxelroomgrid[somevoxelroomindex].arrayofindexzeromesh[c].instances[cc].instancePos + (somevecz);//  * (zz * 4 * 4 * 0.01f * 0.5f * 0.5f));
                                                */
                                                //somevoxelroomgrid[somevoxelroomindex].arrayofindexzeromesh[c].instances[cc].instancePos.X += somemainpos.X + someinstancepostest.X;
                                                //somevoxelroomgrid[somevoxelroomindex].arrayofindexzeromesh[c].instances[cc].instancePos.Y += somemainpos.Y + someinstancepostest.Y;
                                                //somevoxelroomgrid[somevoxelroomindex].arrayofindexzeromesh[c].instances[cc].instancePos.Z += somemainpos.Z + someinstancepostest.Z;
                                                /*
                                                somevoxelroomgrid[somevoxelroomindex].arrayofindexzeromesh[c].instances[cc].instancePos.X = someinstancepostest.X;
                                                somevoxelroomgrid[somevoxelroomindex].arrayofindexzeromesh[c].instances[cc].instancePos.Y = someinstancepostest.Y;
                                                somevoxelroomgrid[somevoxelroomindex].arrayofindexzeromesh[c].instances[cc].instancePos.Z = someinstancepostest.Z;
                                                */


                                                //somevoxelroomgrid[somevoxelroomindex].arrayOfChunkData[c].SC_instancedChunk_Instances[cc].instancePos.X = somevoxelroomgrid[somevoxelroomindex].arrayOfChunkData[c].SC_instancedChunk_Instances[cc].instancePos.X + -(somevoxelroomgrid[somevoxelroomindex].arrayOfChunkData[c].SC_instancedChunk_InstancesFORWARD[cc].instancePos.X * diffmainpostoinstanceposx);
                                                //somevoxelroomgrid[somevoxelroomindex].arrayOfChunkData[c].SC_instancedChunk_Instances[cc].instancePos.Y = somevoxelroomgrid[somevoxelroomindex].arrayOfChunkData[c].SC_instancedChunk_Instances[cc].instancePos.Y + -(somevoxelroomgrid[somevoxelroomindex].arrayOfChunkData[c].SC_instancedChunk_InstancesFORWARD[cc].instancePos.Y * diffmainpostoinstanceposy);
                                                //somevoxelroomgrid[somevoxelroomindex].arrayOfChunkData[c].SC_instancedChunk_Instances[cc].instancePos.Z = somevoxelroomgrid[somevoxelroomindex].arrayOfChunkData[c].SC_instancedChunk_Instances[cc].instancePos.Z + -(somevoxelroomgrid[somevoxelroomindex].arrayOfChunkData[c].SC_instancedChunk_InstancesFORWARD[cc].instancePos.Z * diffmainpostoinstanceposz);

                                                //somevoxelroomgrid[somevoxelroomindex].arrayOfChunkData[c].SC_instancedChunk_Instances[cc].instancePos.X = currentmainobjectpos.X + (somevoxelroomgrid[somevoxelroomindex].arrayofindexzeromesh[c].instan[cc].instancePos.X + (dirInstanceRight.X * diffmainpostoinstanceposx));
                                                //somevoxelroomgrid[somevoxelroomindex].arrayOfChunkData[c].SC_instancedChunk_Instances[cc].instancePos.Y = currentmainobjectpos.Y + (somevoxelroomgrid[somevoxelroomindex].arrayofindexzeromesh[c].instances[cc].instancePos.Y + (dirInstanceUp.Y * diffmainpostoinstanceposy));
                                                //somevoxelroomgrid[somevoxelroomindex].arrayOfChunkData[c].SC_instancedChunk_Instances[cc].instancePos.Z = currentmainobjectpos.Z + (somevoxelroomgrid[somevoxelroomindex].arrayofindexzeromesh[c].instances[cc].instancePos.Z + (dirInstanceForward.Z * diffmainpostoinstanceposz));


                                                /*Vector4 somevecx = new Vector4(dirInstanceRight.X, dirInstanceRight.Y, dirInstanceRight.Z, 1.0f);
                                                Vector4 somevecy = new Vector4(dirInstanceUp.X, dirInstanceUp.Y, dirInstanceUp.Z, 1.0f);
                                                Vector4 somevecz = new Vector4(dirInstanceForward.X, dirInstanceForward.Y, dirInstanceForward.Z, 1.0f);

                                                somevoxelroomgrid[somevoxelroomindex].arrayOfChunkData[c].SC_instancedChunk_Instances[cc].instancePos = somevoxelroomgrid[somevoxelroomindex].arrayOfChunkData[c].SC_instancedChunk_Instances[cc].instancePos + (somevecx * diffmainpostoinstanceposx);
                                                somevoxelroomgrid[somevoxelroomindex].arrayOfChunkData[c].SC_instancedChunk_Instances[cc].instancePos = somevoxelroomgrid[somevoxelroomindex].arrayOfChunkData[c].SC_instancedChunk_Instances[cc].instancePos + (somevecy * diffmainpostoinstanceposy);
                                                somevoxelroomgrid[somevoxelroomindex].arrayOfChunkData[c].SC_instancedChunk_Instances[cc].instancePos = somevoxelroomgrid[somevoxelroomindex].arrayOfChunkData[c].SC_instancedChunk_Instances[cc].instancePos + (somevecz * diffmainpostoinstanceposz);
                                                





                                            }
                                        }
                                    }






                                    if (somevoxelroomgrid[somevoxelroomindex].arrayOfChunkData[c].copytobuffer == 1)
                                    {
                                        for (int xx = 0; xx < somevoxelroomgridglobals.numberOfInstancesPerObjectInWidth; xx++)
                                        {
                                            for (int yy = 0; yy < somevoxelroomgridglobals.numberOfInstancesPerObjectInHeight; yy++)
                                            {
                                                for (int zz = 0; zz < somevoxelroomgridglobals.numberOfInstancesPerObjectInDepth; zz++)
                                                {
                                                    int cc = xx + somevoxelroomgridglobals.numberOfInstancesPerObjectInWidth * (yy + somevoxelroomgridglobals.numberOfInstancesPerObjectInHeight * zz);

                                                    //Matrix worldMatrixChunkDroneInstance = somevoxelroomgrid[somevoxelroomindex].arrayofindexzeromesh[c].arrayofzeromeshinstances[cc].current_pos;
                                                    //Quaternion _testQuator;


                                                    //TO READD FOR SOME LOGIC.
                                                    //Matrix lastPosTarget = _player_rght_hnd[0][0]._arrayOfInstances[0].current_pos;// //_rightTouchMatrix; //
                                                    //Quaternion.RotationMatrix(ref lastPosTarget, out _testQuator);
                                                    //TO READD FOR SOME LOGIC.




                                                    //arrayofindexzeromesh[c].arrayOfScriptForInstances[cc].

                                                    //var dirTargetInstanceForward = sc_maths._newgetdirforward(_testQuator);
                                                    //arrayofindexzeromesh[c].instancesDataFORWARD[cc].instancePos.X = dirTargetInstanceForward.X;
                                                    //arrayofindexzeromesh[c].instancesDataFORWARD[cc].instancePos.Y = dirTargetInstanceForward.Y;
                                                    //arrayofindexzeromesh[c].instancesDataFORWARD[cc].instancePos.Z = dirTargetInstanceForward.Z;
                                                    //arrayofindexzeromesh[c].instancesDataFORWARD[cc].instancePos.W = 1;

                                                    //Quaternion.RotationMatrix(ref tempmat0, out quat_buffers);
                                                    //var dirTargetInstanceRight = sc_maths._newgetdirleft(_testQuator);
                                                    //arrayofindexzeromesh[c].instancesDataRIGHT[cc].instancePos.X = dirTargetInstanceRight.X;
                                                    //arrayofindexzeromesh[c].instancesDataRIGHT[cc].instancePos.Y = dirTargetInstanceRight.Y;
                                                    //arrayofindexzeromesh[c].instancesDataRIGHT[cc].instancePos.Z = dirTargetInstanceRight.Z;
                                                    //arrayofindexzeromesh[c].instancesDataRIGHT[cc].instancePos.W = 1;

                                                    //Quaternion.RotationMatrix(ref tempmat0, out quat_buffers);
                                                    //var dirTargetInstanceUp = sc_maths._newgetdirup(_testQuator);
                                                    //arrayofindexzeromesh[c].instancesDataUP[cc].instancePos.X = dirTargetInstanceUp.X;
                                                    //arrayofindexzeromesh[c].instancesDataUP[cc].instancePos.Y = dirTargetInstanceUp.Y;
                                                    //arrayofindexzeromesh[c].instancesDataUP[cc].instancePos.Z = dirTargetInstanceUp.Z;
                                                    //arrayofindexzeromesh[c].instancesDataUP[cc].instancePos.W = 1;

                                                    //worldMatrixChunkDroneInstance = arrayofindexzeromesh[c].arrayOfScriptForInstances[cc].current_pos;
                                                    //Matrix lastPosDrone = _player_rght_hnd[0][0]._arrayOfInstances[0].current_pos;// //_rightTouchMatrix; //


                                                    //TOREADD
                                                    //TOREADD
                                                    //TOREADD
                                                    /*Quaternion.RotationMatrix(ref worldMatrixChunkDroneInstance, out _testQuator);

                                                    var dirInstanceForward = sc_maths._newgetdirforward(_testQuator);
                                                    somevoxelroomgrid[somevoxelroomindex].arrayofindexzeromesh[c].instancesDataFORWARD[cc].instancePos.X = dirInstanceForward.X;
                                                    somevoxelroomgrid[somevoxelroomindex].arrayofindexzeromesh[c].instancesDataFORWARD[cc].instancePos.Y = dirInstanceForward.Y;
                                                    somevoxelroomgrid[somevoxelroomindex].arrayofindexzeromesh[c].instancesDataFORWARD[cc].instancePos.Z = dirInstanceForward.Z;
                                                    somevoxelroomgrid[somevoxelroomindex].arrayofindexzeromesh[c].instancesDataFORWARD[cc].instancePos.W = 1;

                                                    //Quaternion.RotationMatrix(ref tempmat0, out quat_buffers);
                                                    var dirInstanceRight = -sc_maths._newgetdirleft(_testQuator);
                                                    somevoxelroomgrid[somevoxelroomindex].arrayofindexzeromesh[c].instancesDataRIGHT[cc].instancePos.X = dirInstanceRight.X;
                                                    somevoxelroomgrid[somevoxelroomindex].arrayofindexzeromesh[c].instancesDataRIGHT[cc].instancePos.Y = dirInstanceRight.Y;
                                                    somevoxelroomgrid[somevoxelroomindex].arrayofindexzeromesh[c].instancesDataRIGHT[cc].instancePos.Z = dirInstanceRight.Z;
                                                    somevoxelroomgrid[somevoxelroomindex].arrayofindexzeromesh[c].instancesDataRIGHT[cc].instancePos.W = 1;

                                                    //Quaternion.RotationMatrix(ref tempmat0, out quat_buffers);    
                                                    var dirInstanceUp = sc_maths._newgetdirup(_testQuator);
                                                    somevoxelroomgrid[somevoxelroomindex].arrayofindexzeromesh[c].instancesDataUP[cc].instancePos.X = dirInstanceUp.X;
                                                    somevoxelroomgrid[somevoxelroomindex].arrayofindexzeromesh[c].instancesDataUP[cc].instancePos.Y = dirInstanceUp.Y;
                                                    somevoxelroomgrid[somevoxelroomindex].arrayofindexzeromesh[c].instancesDataUP[cc].instancePos.Z = dirInstanceUp.Z;
                                                    somevoxelroomgrid[somevoxelroomindex].arrayofindexzeromesh[c].instancesDataUP[cc].instancePos.W = 1;
                                                    
                                                    //TOREADD
                                                    //TOREADD
                                                    //TOREADD







                                                    //somevoxelroomgrid[somevoxelroomindex].arrayofindexzeromesh[c].arrayOfScriptForInstances[cc].current_pos.M41 = somevoxelroomgrid[somevoxelroomindex].arrayofindexzeromesh[c].instances[cc].instancePos.X;
                                                    //somevoxelroomgrid[somevoxelroomindex].arrayofindexzeromesh[c].arrayOfScriptForInstances[cc].current_pos.M42 = somevoxelroomgrid[somevoxelroomindex].arrayofindexzeromesh[c].instances[cc].instancePos.Y;
                                                    //somevoxelroomgrid[somevoxelroomindex].arrayofindexzeromesh[c].arrayOfScriptForInstances[cc].current_pos.M43 = somevoxelroomgrid[somevoxelroomindex].arrayofindexzeromesh[c].instances[cc].instancePos.Z;


                                                    //somevoxelroomgrid[somevoxelroomindex].arrayofindexzeromesh[c].arrayOfScriptForInstances[cc].current_pos.M41 = somevoxelroomgrid[somevoxelroomindex].arrayofindexzeromesh[c].instances[cc].instancePos.X;
                                                    //somevoxelroomgrid[somevoxelroomindex].arrayofindexzeromesh[c].arrayOfScriptForInstances[cc].current_pos.M42 = somevoxelroomgrid[somevoxelroomindex].arrayofindexzeromesh[c].instances[cc].instancePos.Y;
                                                    //somevoxelroomgrid[somevoxelroomindex].arrayofindexzeromesh[c].arrayOfScriptForInstances[cc].current_pos.M43 = somevoxelroomgrid[somevoxelroomindex].arrayofindexzeromesh[c].instances[cc].instancePos.Z;



                                                    //TO READD
                                                    somevoxelroomgrid[somevoxelroomindex].arrayOfChunkData[c].instancesmatrix[cc].instancematrix.M11 = somevoxelroomgrid[somevoxelroomindex].arrayofindexzeromesh[c].instancesmatrix[cc].instancematrix.M11;
                                                    somevoxelroomgrid[somevoxelroomindex].arrayOfChunkData[c].instancesmatrix[cc].instancematrix.M12 = somevoxelroomgrid[somevoxelroomindex].arrayofindexzeromesh[c].instancesmatrix[cc].instancematrix.M12;
                                                    somevoxelroomgrid[somevoxelroomindex].arrayOfChunkData[c].instancesmatrix[cc].instancematrix.M13 = somevoxelroomgrid[somevoxelroomindex].arrayofindexzeromesh[c].instancesmatrix[cc].instancematrix.M13;
                                                    somevoxelroomgrid[somevoxelroomindex].arrayOfChunkData[c].instancesmatrix[cc].instancematrix.M14 = somevoxelroomgrid[somevoxelroomindex].arrayofindexzeromesh[c].instancesmatrix[cc].instancematrix.M14;

                                                    somevoxelroomgrid[somevoxelroomindex].arrayOfChunkData[c].instancesmatrix[cc].instancematrix.M21 = somevoxelroomgrid[somevoxelroomindex].arrayofindexzeromesh[c].instancesmatrix[cc].instancematrix.M21;
                                                    somevoxelroomgrid[somevoxelroomindex].arrayOfChunkData[c].instancesmatrix[cc].instancematrix.M22 = somevoxelroomgrid[somevoxelroomindex].arrayofindexzeromesh[c].instancesmatrix[cc].instancematrix.M22;
                                                    somevoxelroomgrid[somevoxelroomindex].arrayOfChunkData[c].instancesmatrix[cc].instancematrix.M23 = somevoxelroomgrid[somevoxelroomindex].arrayofindexzeromesh[c].instancesmatrix[cc].instancematrix.M23;
                                                    somevoxelroomgrid[somevoxelroomindex].arrayOfChunkData[c].instancesmatrix[cc].instancematrix.M24 = somevoxelroomgrid[somevoxelroomindex].arrayofindexzeromesh[c].instancesmatrix[cc].instancematrix.M24;


                                                    somevoxelroomgrid[somevoxelroomindex].arrayOfChunkData[c].instancesmatrix[cc].instancematrix.M31 = somevoxelroomgrid[somevoxelroomindex].arrayofindexzeromesh[c].instancesmatrix[cc].instancematrix.M31;
                                                    somevoxelroomgrid[somevoxelroomindex].arrayOfChunkData[c].instancesmatrix[cc].instancematrix.M32 = somevoxelroomgrid[somevoxelroomindex].arrayofindexzeromesh[c].instancesmatrix[cc].instancematrix.M32;
                                                    somevoxelroomgrid[somevoxelroomindex].arrayOfChunkData[c].instancesmatrix[cc].instancematrix.M33 = somevoxelroomgrid[somevoxelroomindex].arrayofindexzeromesh[c].instancesmatrix[cc].instancematrix.M33;
                                                    somevoxelroomgrid[somevoxelroomindex].arrayOfChunkData[c].instancesmatrix[cc].instancematrix.M34 = somevoxelroomgrid[somevoxelroomindex].arrayofindexzeromesh[c].instancesmatrix[cc].instancematrix.M34;


                                                    somevoxelroomgrid[somevoxelroomindex].arrayOfChunkData[c].instancesmatrix[cc].instancematrix.M41 = somevoxelroomgrid[somevoxelroomindex].arrayofindexzeromesh[c].instancesmatrix[cc].instancematrix.M41;
                                                    somevoxelroomgrid[somevoxelroomindex].arrayOfChunkData[c].instancesmatrix[cc].instancematrix.M42 = somevoxelroomgrid[somevoxelroomindex].arrayofindexzeromesh[c].instancesmatrix[cc].instancematrix.M42;
                                                    somevoxelroomgrid[somevoxelroomindex].arrayOfChunkData[c].instancesmatrix[cc].instancematrix.M43 = somevoxelroomgrid[somevoxelroomindex].arrayofindexzeromesh[c].instancesmatrix[cc].instancematrix.M43;
                                                    somevoxelroomgrid[somevoxelroomindex].arrayOfChunkData[c].instancesmatrix[cc].instancematrix.M44 = somevoxelroomgrid[somevoxelroomindex].arrayofindexzeromesh[c].instancesmatrix[cc].instancematrix.M44;


                                                }
                                            }
                                        }



                                        somevoxelroomgrid[somevoxelroomindex].arrayOfChunkData[c].copytobuffer = 0;
                                    }




                                    somevoxelroomgrid[somevoxelroomindex].arrayOfChunkData[c].instancesLocationW = somevoxelroomgrid[somevoxelroomindex].arrayofindexzeromesh[c].instancesLocationW;
                                    somevoxelroomgrid[somevoxelroomindex].arrayOfChunkData[c].instancesLocationH = somevoxelroomgrid[somevoxelroomindex].arrayofindexzeromesh[c].instancesLocationH;

                                    somevoxelroomgrid[somevoxelroomindex].arrayOfChunkData[c].SC_instancedChunk_InstancesFORWARD = somevoxelroomgrid[somevoxelroomindex].arrayofindexzeromesh[c].instancesDataFORWARD;
                                    somevoxelroomgrid[somevoxelroomindex].arrayOfChunkData[c].SC_instancedChunk_InstancesRIGHT = somevoxelroomgrid[somevoxelroomindex].arrayofindexzeromesh[c].instancesDataRIGHT;
                                    somevoxelroomgrid[somevoxelroomindex].arrayOfChunkData[c].SC_instancedChunk_InstancesUP = somevoxelroomgrid[somevoxelroomindex].arrayofindexzeromesh[c].instancesDataUP;

                                    somevoxelroomgrid[somevoxelroomindex].arrayOfChunkData[c].colorsNFaces = somevoxelroomgrid[somevoxelroomindex].arrayofindexzeromesh[c].colorsNFaces;
                                    somevoxelroomgrid[somevoxelroomindex].arrayOfChunkData[c].lightBuffer = somevoxelroomgrid[somevoxelroomindex].lightBufferInstChunk;
                                    somevoxelroomgrid[somevoxelroomindex].arrayOfChunkData[c].SC_instancedChunk_Instances = somevoxelroomgrid[somevoxelroomindex].arrayofindexzeromesh[c].instances;

                                }
                            }
                        }
                    }
                }
            }*/
            //VOXEL ROOM GRID











            //SC BUFFERS
            //SC BUFFERS
            //SC BUFFERS
            //TERRAIN CUBE
            _terrain[0][0]._WORLDMATRIXINSTANCES = worldMatrix_instances_terrain[0][0];
            _terrain[0][0]._POSITION = worldMatrix_base[0];

            var cuber = _terrain[0][0];
            var instancers = cuber.instances;
            var sometester = cuber._WORLDMATRIXINSTANCES;

            for (int i = 0; i < instancers.Length; i++)
            {
                float xxx = sometester[i].M41;
                float yyy = sometester[i].M42;
                float zzz = sometester[i].M43;

                cuber.instances[i].position.X = xxx;
                cuber.instances[i].position.Y = yyy;
                cuber.instances[i].position.Z = zzz;
                cuber.instances[i].position.W = 1;
                Quaternion.RotationMatrix(ref sometester[i], out quat_buffers);

                var dirInstance = sc_maths._newgetdirforward(quat_buffers);
                cuber.instancesDataForward[i].rotation.X = dirInstance.X;
                cuber.instancesDataForward[i].rotation.Y = dirInstance.Y;
                cuber.instancesDataForward[i].rotation.Z = dirInstance.Z;
                cuber.instancesDataForward[i].rotation.W = 1;

                dirInstance = -sc_maths._newgetdirleft(quat_buffers);
                cuber.instancesDataRIGHT[i].rotation.X = dirInstance.X;
                cuber.instancesDataRIGHT[i].rotation.Y = dirInstance.Y;
                cuber.instancesDataRIGHT[i].rotation.Z = dirInstance.Z;
                cuber.instancesDataRIGHT[i].rotation.W = 1;

                dirInstance = dirInstance = sc_maths._newgetdirup(quat_buffers);
                cuber.instancesDataUP[i].rotation.X = dirInstance.X;
                cuber.instancesDataUP[i].rotation.Y = dirInstance.Y;
                cuber.instancesDataUP[i].rotation.Z = dirInstance.Z;
                cuber.instancesDataUP[i].rotation.W = 1;
            }
            //END OF




            //SPECTRUM
            _world_spectrum_list[0][0]._WORLDMATRIXINSTANCES = worldMatrix_instances_spectrum[0][0];
            _world_spectrum_list[0][0]._POSITION = worldMatrix_base[0];

            var cuber_spectrum = _world_spectrum_list[0][0];
            var instancers_spectrum = cuber_spectrum.instances;
            var sometester_spectrum = cuber_spectrum._WORLDMATRIXINSTANCES;

            for (int i = 0; i < instancers_spectrum.Length; i++)
            {
                float xxx = sometester_spectrum[i].M41;
                float yyy = sometester_spectrum[i].M42;
                float zzz = sometester_spectrum[i].M43;

                cuber_spectrum.instances[i].position.X = xxx;
                cuber_spectrum.instances[i].position.Y = yyy;
                cuber_spectrum.instances[i].position.Z = zzz;
                cuber_spectrum.instances[i].position.W = 1;
                Quaternion.RotationMatrix(ref sometester_spectrum[i], out quat_buffers);

                var dirInstance = sc_maths._newgetdirforward(quat_buffers);
                cuber_spectrum.instancesDataForward[i].rotation.X = dirInstance.X;
                cuber_spectrum.instancesDataForward[i].rotation.Y = dirInstance.Y;
                cuber_spectrum.instancesDataForward[i].rotation.Z = dirInstance.Z;
                cuber_spectrum.instancesDataForward[i].rotation.W = 1;

                dirInstance = -sc_maths._newgetdirleft(quat_buffers);
                cuber_spectrum.instancesDataRIGHT[i].rotation.X = dirInstance.X;
                cuber_spectrum.instancesDataRIGHT[i].rotation.Y = dirInstance.Y;
                cuber_spectrum.instancesDataRIGHT[i].rotation.Z = dirInstance.Z;
                cuber_spectrum.instancesDataRIGHT[i].rotation.W = 1;

                dirInstance = dirInstance = sc_maths._newgetdirup(quat_buffers);
                cuber_spectrum.instancesDataUP[i].rotation.X = dirInstance.X;
                cuber_spectrum.instancesDataUP[i].rotation.Y = dirInstance.Y;
                cuber_spectrum.instancesDataUP[i].rotation.Z = dirInstance.Z;
                cuber_spectrum.instancesDataUP[i].rotation.W = 1;
            }
            //END OF












            //TERRAIN FLOOR
            _floor[0][0]._WORLDMATRIXINSTANCES = worldMatrix_instances_floor[0][0];
            _floor[0][0]._POSITION = worldMatrix_base[0];

            var cuber_floor = _floor[0][0];
            var instancers_floor = cuber_floor.instances;
            var sometester_floor = cuber_floor._WORLDMATRIXINSTANCES;

            for (int i = 0; i < instancers_floor.Length; i++)
            {
                float xxx = sometester_floor[i].M41;
                float yyy = sometester_floor[i].M42;
                float zzz = sometester_floor[i].M43;

                cuber_floor.instances[i].position.X = xxx;
                cuber_floor.instances[i].position.Y = yyy;
                cuber_floor.instances[i].position.Z = zzz;
                cuber_floor.instances[i].position.W = 1;

                Quaternion.RotationMatrix(ref sometester_floor[i], out quat_buffers);

                var dirInstance = sc_maths._newgetdirforward(quat_buffers);
                cuber_floor.instancesDataForward[i].rotation.X = dirInstance.X;
                cuber_floor.instancesDataForward[i].rotation.Y = dirInstance.Y;
                cuber_floor.instancesDataForward[i].rotation.Z = dirInstance.Z;
                cuber_floor.instancesDataForward[i].rotation.W = 1;

                dirInstance = -sc_maths._newgetdirleft(quat_buffers);
                cuber_floor.instancesDataRIGHT[i].rotation.X = dirInstance.X;
                cuber_floor.instancesDataRIGHT[i].rotation.Y = dirInstance.Y;
                cuber_floor.instancesDataRIGHT[i].rotation.Z = dirInstance.Z;
                cuber_floor.instancesDataRIGHT[i].rotation.W = 1;

                dirInstance = dirInstance = sc_maths._newgetdirup(quat_buffers);
                cuber_floor.instancesDataUP[i].rotation.X = dirInstance.X;
                cuber_floor.instancesDataUP[i].rotation.Y = dirInstance.Y;
                cuber_floor.instancesDataUP[i].rotation.Z = dirInstance.Z;
                cuber_floor.instancesDataUP[i].rotation.W = 1;
            }
            //END OF






















            //PHYSICS GRID
            _world_grid_list[0][0]._WORLDMATRIXINSTANCES = worldMatrix_instances_grid[0][0]; // 
            _world_grid_list[0][0]._POSITION = worldMatrix_base[0];

            var cuber_grid = _world_grid_list[0][0];
            var instancers_grid = cuber_grid.instances;
            var sometester_grid = cuber_grid._WORLDMATRIXINSTANCES;

            for (int i = 0; i < instancers_grid.Length; i++)
            {
                float xxx = sometester_grid[i].M41;
                float yyy = sometester_grid[i].M42;
                float zzz = sometester_grid[i].M43;

                cuber_grid.instances[i].position.X = xxx;
                cuber_grid.instances[i].position.Y = yyy;
                cuber_grid.instances[i].position.Z = zzz;
                cuber_grid.instances[i].position.W = 1;

                Quaternion.RotationMatrix(ref sometester_grid[i], out quat_buffers);

                var dirInstance = sc_maths._newgetdirforward(quat_buffers);
                //var dirInstance = _newgetdirforward(_testQuater);
                cuber_grid.instancesDataForward[i].rotation.X = dirInstance.X;
                cuber_grid.instancesDataForward[i].rotation.Y = dirInstance.Y;
                cuber_grid.instancesDataForward[i].rotation.Z = dirInstance.Z;
                cuber_grid.instancesDataForward[i].rotation.W = 1;

                dirInstance = -sc_maths._newgetdirleft(quat_buffers);
                //dirInstance = -_newgetdirleft(_testQuater);
                cuber_grid.instancesDataRIGHT[i].rotation.X = dirInstance.X;
                cuber_grid.instancesDataRIGHT[i].rotation.Y = dirInstance.Y;
                cuber_grid.instancesDataRIGHT[i].rotation.Z = dirInstance.Z;
                cuber_grid.instancesDataRIGHT[i].rotation.W = 1;

                dirInstance = sc_maths._newgetdirup(quat_buffers);
                //dirInstance = dirInstance = _newgetdirup(_testQuater);
                cuber_grid.instancesDataUP[i].rotation.X = dirInstance.X;
                cuber_grid.instancesDataUP[i].rotation.Y = dirInstance.Y;
                cuber_grid.instancesDataUP[i].rotation.Z = dirInstance.Z;
                cuber_grid.instancesDataUP[i].rotation.W = 1;
            }
            //END OF


            //PHYSICS GRID
            _world_containment_grid_screen[0][0]._WORLDMATRIXINSTANCES = worldMatrix_instances_containment_grid_screen[0][0]; // 
            _world_containment_grid_screen[0][0]._POSITION = worldMatrix_base[0];

            var cuber_grid_screen = _world_containment_grid_screen[0][0];
            var instancers_grid_screen = cuber_grid_screen.instances;
            var sometester_grid_screen = cuber_grid_screen._WORLDMATRIXINSTANCES;

            for (int i = 0; i < instancers_grid_screen.Length; i++)
            {
                float xxx = sometester_grid_screen[i].M41;
                float yyy = sometester_grid_screen[i].M42;
                float zzz = sometester_grid_screen[i].M43;

                cuber_grid_screen.instances[i].position.X = xxx;
                cuber_grid_screen.instances[i].position.Y = yyy;
                cuber_grid_screen.instances[i].position.Z = zzz;
                cuber_grid_screen.instances[i].position.W = 1;

                Quaternion.RotationMatrix(ref sometester_grid_screen[i], out quat_buffers);

                var dirInstance = sc_maths._newgetdirforward(quat_buffers);
                //var dirInstance = _newgetdirforward(_testQuater);
                cuber_grid_screen.instancesDataForward[i].rotation.X = dirInstance.X;
                cuber_grid_screen.instancesDataForward[i].rotation.Y = dirInstance.Y;
                cuber_grid_screen.instancesDataForward[i].rotation.Z = dirInstance.Z;
                cuber_grid_screen.instancesDataForward[i].rotation.W = 1;

                dirInstance = -sc_maths._newgetdirleft(quat_buffers);
                //dirInstance = -_newgetdirleft(_testQuater);
                cuber_grid_screen.instancesDataRIGHT[i].rotation.X = dirInstance.X;
                cuber_grid_screen.instancesDataRIGHT[i].rotation.Y = dirInstance.Y;
                cuber_grid_screen.instancesDataRIGHT[i].rotation.Z = dirInstance.Z;
                cuber_grid_screen.instancesDataRIGHT[i].rotation.W = 1;

                dirInstance = sc_maths._newgetdirup(quat_buffers);
                //dirInstance = dirInstance = _newgetdirup(_testQuater);
                cuber_grid_screen.instancesDataUP[i].rotation.X = dirInstance.X;
                cuber_grid_screen.instancesDataUP[i].rotation.Y = dirInstance.Y;
                cuber_grid_screen.instancesDataUP[i].rotation.Z = dirInstance.Z;
                cuber_grid_screen.instancesDataUP[i].rotation.W = 1;
            }
            //END OF



            for (int xx = 0; xx < MainWindow._physics_engine_instance_x; xx++)
            {
                for (int yy = 0; yy < MainWindow._physics_engine_instance_y; yy++)
                {
                    for (int zz = 0; zz < MainWindow._physics_engine_instance_z; zz++)
                    {
                        var indexer00 = xx + MainWindow._physics_engine_instance_x * (yy + MainWindow._physics_engine_instance_y * zz);

                        try
                        {
                            for (int x = 0; x < MainWindow.world_width; x++)
                            {
                                for (int y = 0; y < MainWindow.world_height; y++)
                                {
                                    for (int z = 0; z < MainWindow.world_depth; z++)
                                    {
                                        var indexer01 = x + MainWindow.world_width * (y + MainWindow.world_height * z);

                                        //PHYSICS CUBES
                                        _world_cube_list[indexer00][indexer01]._WORLDMATRIXINSTANCES = worldMatrix_instances_cubes[indexer00][indexer01]; // 
                                        _world_cube_list[indexer00][indexer01]._POSITION = worldMatrix_base[0];

                                        cuber = _world_cube_list[indexer00][indexer01];
                                        instancers = cuber.instances;
                                        sometester = cuber._WORLDMATRIXINSTANCES;

                                        for (int i = 0; i < instancers.Length; i++)
                                        {
                                            float xxx = sometester[i].M41;
                                            float yyy = sometester[i].M42;
                                            float zzz = sometester[i].M43;

                                            cuber.instances[i].position.X = xxx;
                                            cuber.instances[i].position.Y = yyy;
                                            cuber.instances[i].position.Z = zzz;
                                            cuber.instances[i].position.W = 1;

                                            Quaternion.RotationMatrix(ref sometester[i], out quat_buffers);

                                            var dirInstance = sc_maths._newgetdirforward(quat_buffers);
                                            //var dirInstance = _newgetdirforward(_testQuater);
                                            cuber.instancesDataForward[i].rotation.X = dirInstance.X;
                                            cuber.instancesDataForward[i].rotation.Y = dirInstance.Y;
                                            cuber.instancesDataForward[i].rotation.Z = dirInstance.Z;
                                            cuber.instancesDataForward[i].rotation.W = 1;

                                            dirInstance = -sc_maths._newgetdirleft(quat_buffers);
                                            //dirInstance = -_newgetdirleft(_testQuater);
                                            cuber.instancesDataRIGHT[i].rotation.X = dirInstance.X;
                                            cuber.instancesDataRIGHT[i].rotation.Y = dirInstance.Y;
                                            cuber.instancesDataRIGHT[i].rotation.Z = dirInstance.Z;
                                            cuber.instancesDataRIGHT[i].rotation.W = 1;

                                            dirInstance = sc_maths._newgetdirup(quat_buffers);
                                            //dirInstance = dirInstance = _newgetdirup(_testQuater);
                                            cuber.instancesDataUP[i].rotation.X = dirInstance.X;
                                            cuber.instancesDataUP[i].rotation.Y = dirInstance.Y;
                                            cuber.instancesDataUP[i].rotation.Z = dirInstance.Z;
                                            cuber.instancesDataUP[i].rotation.W = 1;
                                        }
                                        //END OF

                                        //PHYSICS CONES
                                        _world_cone_list[indexer00][indexer01]._WORLDMATRIXINSTANCES = worldMatrix_instances_cone[indexer00][indexer01]; // 
                                        _world_cone_list[indexer00][indexer01]._POSITION = worldMatrix_base[0];
                                        cuber = _world_cone_list[indexer00][indexer01];
                                        instancers = cuber.instances;
                                        sometester = cuber._WORLDMATRIXINSTANCES;

                                        for (int i = 0; i < instancers.Length; i++)
                                        {
                                            float xxx = sometester[i].M41;
                                            float yyy = sometester[i].M42;
                                            float zzz = sometester[i].M43;

                                            cuber.instances[i].position.X = xxx;
                                            cuber.instances[i].position.Y = yyy;
                                            cuber.instances[i].position.Z = zzz;
                                            cuber.instances[i].position.W = 1;

                                            Quaternion.RotationMatrix(ref sometester[i], out quat_buffers);

                                            var dirInstance = sc_maths._newgetdirforward(quat_buffers);
                                            //var dirInstance = _newgetdirforward(_testQuater);
                                            cuber.instancesDataForward[i].rotation.X = dirInstance.X;
                                            cuber.instancesDataForward[i].rotation.Y = dirInstance.Y;
                                            cuber.instancesDataForward[i].rotation.Z = dirInstance.Z;
                                            cuber.instancesDataForward[i].rotation.W = 1;

                                            dirInstance = -sc_maths._newgetdirleft(quat_buffers);
                                            //dirInstance = -_newgetdirleft(_testQuater);
                                            cuber.instancesDataRIGHT[i].rotation.X = dirInstance.X;
                                            cuber.instancesDataRIGHT[i].rotation.Y = dirInstance.Y;
                                            cuber.instancesDataRIGHT[i].rotation.Z = dirInstance.Z;
                                            cuber.instancesDataRIGHT[i].rotation.W = 1;

                                            dirInstance = sc_maths._newgetdirup(quat_buffers);
                                            //dirInstance = dirInstance = _newgetdirup(_testQuater);
                                            cuber.instancesDataUP[i].rotation.X = dirInstance.X;
                                            cuber.instancesDataUP[i].rotation.Y = dirInstance.Y;
                                            cuber.instancesDataUP[i].rotation.Z = dirInstance.Z;
                                            cuber.instancesDataUP[i].rotation.W = 1;
                                        }
                                        //END OF



                                        //PHYSICS CYLINDERS
                                        _world_cylinder_list[indexer00][indexer01]._WORLDMATRIXINSTANCES = worldMatrix_instances_cylinder[indexer00][indexer01]; // 
                                        _world_cylinder_list[indexer00][indexer01]._POSITION = worldMatrix_base[0];
                                        cuber = _world_cylinder_list[indexer00][indexer01];
                                        instancers = cuber.instances;
                                        sometester = cuber._WORLDMATRIXINSTANCES;

                                        for (int i = 0; i < instancers.Length; i++)
                                        {
                                            float xxx = sometester[i].M41;
                                            float yyy = sometester[i].M42;
                                            float zzz = sometester[i].M43;

                                            cuber.instances[i].position.X = xxx;
                                            cuber.instances[i].position.Y = yyy;
                                            cuber.instances[i].position.Z = zzz;
                                            cuber.instances[i].position.W = 1;

                                            Quaternion.RotationMatrix(ref sometester[i], out quat_buffers);

                                            var dirInstance = sc_maths._newgetdirforward(quat_buffers);
                                            //var dirInstance = _newgetdirforward(_testQuater);
                                            cuber.instancesDataForward[i].rotation.X = dirInstance.X;
                                            cuber.instancesDataForward[i].rotation.Y = dirInstance.Y;
                                            cuber.instancesDataForward[i].rotation.Z = dirInstance.Z;
                                            cuber.instancesDataForward[i].rotation.W = 1;

                                            dirInstance = -sc_maths._newgetdirleft(quat_buffers);
                                            //dirInstance = -_newgetdirleft(_testQuater);
                                            cuber.instancesDataRIGHT[i].rotation.X = dirInstance.X;
                                            cuber.instancesDataRIGHT[i].rotation.Y = dirInstance.Y;
                                            cuber.instancesDataRIGHT[i].rotation.Z = dirInstance.Z;
                                            cuber.instancesDataRIGHT[i].rotation.W = 1;

                                            dirInstance = sc_maths._newgetdirup(quat_buffers);
                                            //dirInstance = dirInstance = _newgetdirup(_testQuater);
                                            cuber.instancesDataUP[i].rotation.X = dirInstance.X;
                                            cuber.instancesDataUP[i].rotation.Y = dirInstance.Y;
                                            cuber.instancesDataUP[i].rotation.Z = dirInstance.Z;
                                            cuber.instancesDataUP[i].rotation.W = 1;
                                        }
                                        //END OF




                                        //PHYSICS CAPSULES
                                        _world_capsule_list[indexer00][indexer01]._WORLDMATRIXINSTANCES = worldMatrix_instances_capsule[indexer00][indexer01]; // 
                                        _world_capsule_list[indexer00][indexer01]._POSITION = worldMatrix_base[0];
                                        cuber = _world_capsule_list[indexer00][indexer01];
                                        instancers = cuber.instances;
                                        sometester = cuber._WORLDMATRIXINSTANCES;

                                        for (int i = 0; i < instancers.Length; i++)
                                        {
                                            float xxx = sometester[i].M41;
                                            float yyy = sometester[i].M42;
                                            float zzz = sometester[i].M43;

                                            cuber.instances[i].position.X = xxx;
                                            cuber.instances[i].position.Y = yyy;
                                            cuber.instances[i].position.Z = zzz;
                                            cuber.instances[i].position.W = 1;

                                            Quaternion.RotationMatrix(ref sometester[i], out quat_buffers);

                                            var dirInstance = sc_maths._newgetdirforward(quat_buffers);
                                            //var dirInstance = _newgetdirforward(_testQuater);
                                            cuber.instancesDataForward[i].rotation.X = dirInstance.X;
                                            cuber.instancesDataForward[i].rotation.Y = dirInstance.Y;
                                            cuber.instancesDataForward[i].rotation.Z = dirInstance.Z;
                                            cuber.instancesDataForward[i].rotation.W = 1;

                                            dirInstance = -sc_maths._newgetdirleft(quat_buffers);
                                            //dirInstance = -_newgetdirleft(_testQuater);
                                            cuber.instancesDataRIGHT[i].rotation.X = dirInstance.X;
                                            cuber.instancesDataRIGHT[i].rotation.Y = dirInstance.Y;
                                            cuber.instancesDataRIGHT[i].rotation.Z = dirInstance.Z;
                                            cuber.instancesDataRIGHT[i].rotation.W = 1;

                                            dirInstance = sc_maths._newgetdirup(quat_buffers);
                                            //dirInstance = dirInstance = _newgetdirup(_testQuater);
                                            cuber.instancesDataUP[i].rotation.X = dirInstance.X;
                                            cuber.instancesDataUP[i].rotation.Y = dirInstance.Y;
                                            cuber.instancesDataUP[i].rotation.Z = dirInstance.Z;
                                            cuber.instancesDataUP[i].rotation.W = 1;
                                        }
                                        //END OF




                                        //PHYSICS SPHERES
                                        _world_sphere_list[indexer00][indexer01]._WORLDMATRIXINSTANCES = worldMatrix_instances_sphere[indexer00][indexer01]; // 
                                        _world_sphere_list[indexer00][indexer01]._POSITION = worldMatrix_base[0];
                                        cuber = _world_sphere_list[indexer00][indexer01];
                                        instancers = cuber.instances;
                                        sometester = cuber._WORLDMATRIXINSTANCES;

                                        for (int i = 0; i < instancers.Length; i++)
                                        {
                                            float xxx = sometester[i].M41;
                                            float yyy = sometester[i].M42;
                                            float zzz = sometester[i].M43;

                                            cuber.instances[i].position.X = xxx;
                                            cuber.instances[i].position.Y = yyy;
                                            cuber.instances[i].position.Z = zzz;
                                            cuber.instances[i].position.W = 1;

                                            Quaternion.RotationMatrix(ref sometester[i], out quat_buffers);

                                            var dirInstance = sc_maths._newgetdirforward(quat_buffers);
                                            //var dirInstance = _newgetdirforward(_testQuater);
                                            cuber.instancesDataForward[i].rotation.X = dirInstance.X;
                                            cuber.instancesDataForward[i].rotation.Y = dirInstance.Y;
                                            cuber.instancesDataForward[i].rotation.Z = dirInstance.Z;
                                            cuber.instancesDataForward[i].rotation.W = 1;

                                            dirInstance = -sc_maths._newgetdirleft(quat_buffers);
                                            //dirInstance = -_newgetdirleft(_testQuater);
                                            cuber.instancesDataRIGHT[i].rotation.X = dirInstance.X;
                                            cuber.instancesDataRIGHT[i].rotation.Y = dirInstance.Y;
                                            cuber.instancesDataRIGHT[i].rotation.Z = dirInstance.Z;
                                            cuber.instancesDataRIGHT[i].rotation.W = 1;

                                            dirInstance = sc_maths._newgetdirup(quat_buffers);
                                            //dirInstance = dirInstance = _newgetdirup(_testQuater);
                                            cuber.instancesDataUP[i].rotation.X = dirInstance.X;
                                            cuber.instancesDataUP[i].rotation.Y = dirInstance.Y;
                                            cuber.instancesDataUP[i].rotation.Z = dirInstance.Z;
                                            cuber.instancesDataUP[i].rotation.W = 1;
                                        }
                                        //END OF









                                        //PHYSICS VOXEL SPHEROID
                                        _world_voxel_cube_lists[indexer00][indexer01]._WORLDMATRIXINSTANCES = worldMatrix_instances_voxel_cube[indexer00][indexer01];
                                        _world_voxel_cube_lists[indexer00][indexer01]._POSITION = worldMatrix_base[0];
                                        //END OF

                                        //PHYSICS VOXEL THINGS
                                        var voxel_cube = _world_voxel_cube_lists[indexer00][indexer01];
                                        var instances_voxel_cube = voxel_cube.instances;
                                        var _voxel_cube_Worldmatrix_of_instances = voxel_cube._WORLDMATRIXINSTANCES;

                                        for (int i = 0; i < instances_voxel_cube.Length; i++)
                                        {
                                            float xxx = _voxel_cube_Worldmatrix_of_instances[i].M41;
                                            float yyy = _voxel_cube_Worldmatrix_of_instances[i].M42;
                                            float zzz = _voxel_cube_Worldmatrix_of_instances[i].M43;

                                            voxel_cube.instances[i].position.X = xxx;
                                            voxel_cube.instances[i].position.Y = yyy;
                                            voxel_cube.instances[i].position.Z = zzz;
                                            voxel_cube.instances[i].position.W = 1;
                                            Quaternion.RotationMatrix(ref _voxel_cube_Worldmatrix_of_instances[i], out quat_buffers);

                                            var dirInstance = sc_maths._newgetdirforward(quat_buffers);
                                            voxel_cube.instancesDataForward[i].rotation.X = dirInstance.X;
                                            voxel_cube.instancesDataForward[i].rotation.Y = dirInstance.Y;
                                            voxel_cube.instancesDataForward[i].rotation.Z = dirInstance.Z;
                                            voxel_cube.instancesDataForward[i].rotation.W = 1;

                                            dirInstance = -sc_maths._newgetdirleft(quat_buffers);
                                            voxel_cube.instancesDataRIGHT[i].rotation.X = dirInstance.X;
                                            voxel_cube.instancesDataRIGHT[i].rotation.Y = dirInstance.Y;
                                            voxel_cube.instancesDataRIGHT[i].rotation.Z = dirInstance.Z;
                                            voxel_cube.instancesDataRIGHT[i].rotation.W = 1;

                                            dirInstance = sc_maths._newgetdirup(quat_buffers);
                                            voxel_cube.instancesDataUP[i].rotation.X = dirInstance.X;
                                            voxel_cube.instancesDataUP[i].rotation.Y = dirInstance.Y;
                                            voxel_cube.instancesDataUP[i].rotation.Z = dirInstance.Z;
                                            voxel_cube.instancesDataUP[i].rotation.W = 1;
                                        }
                                        //END OF


                                        //////////////TO READD MAYBE
                                        //////////////TO READD MAYBE
                                        //////////////TO READD MAYBE
                                        // Vector3 playerPos = new Vector3(_player_torso[0][0]._arrayOfInstances[0].current_pos.M41, _player_torso[0][0]._arrayOfInstances[0].current_pos.M42, _player_torso[0][0]._arrayOfInstances[0].current_pos.M43);
                                        //////////////TO READD MAYBE
                                        //////////////TO READD MAYBE
                                        //////////////TO READDMAYBE





                                        //////////////TO READD
                                        //////////////TO READD
                                        //////////////TO READD
                                        /*
                                        for (int yc = -PlanetChunkHeight_L; yc <= PlanetChunkHeight_R; yc += realplanetwidth)
                                        {
                                            for (int xc = -PlanetChunkWidth_L; xc <= PlanetChunkWidth_R; xc += realplanetwidth)
                                            {
                                                for (int zc = -PlanetChunkDepth_L; zc <= PlanetChunkDepth_R; zc += realplanetwidth)
                                                {
                                                    var xxc = xc;
                                                    var yyc = yc;
                                                    var zzc = zc;

                                                    if (xxc < 0)
                                                    {
                                                        xxc *= -1;
                                                        xxc = (PlanetChunkWidth_R) + xxc;
                                                    }
                                                    if (yyc < 0)
                                                    {
                                                        yyc *= -1;
                                                        yyc = (PlanetChunkHeight_R) + yyc;
                                                    }
                                                    if (zzc < 0)
                                                    {
                                                        zzc *= -1;
                                                        zzc = (PlanetChunkDepth_R) + zzc;
                                                    }

                                                    int _index = xxc + (PlanetChunkWidth_L + PlanetChunkWidth_R + 1) * (yyc + (PlanetChunkHeight_L + PlanetChunkHeight_R + 1) * zzc);


                                                    Vector3 chunkPos = new Vector3(arrayOfPlanetChunk[_index].current_pos.M41, arrayOfPlanetChunk[_index].current_pos.M42, arrayOfPlanetChunk[_index].current_pos.M43);

                                                    //if (Vector3.Distance(chunkPos, playerPos) < 30)
                                                    //var dist = sc_maths.sc_check_distance_node_3d_geometry(chunkPos, playerPos, 100, 100, 100, 100, 100, 100);
                                                    //Console.WriteLine(dist);
                                                    //if (dist < 5000)
                                                    {
                                                        if (arrayOfPlanetChunk[_index] != null)
                                                        {
                                                            if (arrayOfPlanetChunk[_index].Vertices != null)
                                                            {
                                                                if (arrayOfPlanetChunk[_index].Vertices.Length > 0)
                                                                {
                                                                    //float posX = (xc);
                                                                    //float posY = (yc);
                                                                    //float posZ = (zc);

                                                                    //Vector3 planetchunkpos = new Vector3(posX, posY, posZ) + new Vector3(0,5,0);

                                                                    //Matrix[] matArray = new Matrix[1];

                                                                    //matArray[0] = new Matrix();
                                                                    ///matArray[0].M41 = arrayOfPlanetChunk[_index]._ORIGINPOSITION.M41; //planetchunkpos.X;// 
                                                                    //matArray[0].M42 = arrayOfPlanetChunk[_index]._ORIGINPOSITION.M42; //planetchunkpos.Y;//
                                                                    //matArray[0].M43 = arrayOfPlanetChunk[_index]._ORIGINPOSITION.M43; //planetchunkpos.Z;//

                                                                    //PHYSICS VOXEL SPHEROID
                                                                    arrayOfPlanetChunk[_index]._WORLDMATRIXINSTANCES = worldMatrix_instances_voxel_pchunk[indexer00][indexer01][_index]; //matArray;// 
                                                                    arrayOfPlanetChunk[_index]._POSITION = worldMatrix_base[0];
                                                                    //END OF

                                                                    //PHYSICS VOXEL THINGS
                                                                    var voxel_pchunk = arrayOfPlanetChunk[_index];
                                                                    var instances_voxel_pchunk = voxel_pchunk.instances;
                                                                    var _voxel_pchunk_Worldmatrix_of_instancespchunk = voxel_pchunk._WORLDMATRIXINSTANCES;

                                                                    for (int i = 0; i < instances_voxel_pchunk.Length; i++)
                                                                    {
                                                                        float xxx = _voxel_pchunk_Worldmatrix_of_instancespchunk[i].M41;
                                                                        float yyy = _voxel_pchunk_Worldmatrix_of_instancespchunk[i].M42;
                                                                        float zzz = _voxel_pchunk_Worldmatrix_of_instancespchunk[i].M43;

                                                                        voxel_pchunk.instances[i].position.X = xxx;
                                                                        voxel_pchunk.instances[i].position.Y = yyy;
                                                                        voxel_pchunk.instances[i].position.Z = zzz;
                                                                        voxel_pchunk.instances[i].position.W = 1;
                                                                        Quaternion.RotationMatrix(ref _voxel_pchunk_Worldmatrix_of_instancespchunk[i], out quat_buffers);

                                                                        var dirInstance = sc_maths._newgetdirforward(quat_buffers);
                                                                        voxel_pchunk.instancesDataForward[i].rotation.X = dirInstance.X;
                                                                        voxel_pchunk.instancesDataForward[i].rotation.Y = dirInstance.Y;
                                                                        voxel_pchunk.instancesDataForward[i].rotation.Z = dirInstance.Z;
                                                                        voxel_pchunk.instancesDataForward[i].rotation.W = 1;

                                                                        dirInstance = -sc_maths._newgetdirleft(quat_buffers);
                                                                        voxel_pchunk.instancesDataRIGHT[i].rotation.X = dirInstance.X;
                                                                        voxel_pchunk.instancesDataRIGHT[i].rotation.Y = dirInstance.Y;
                                                                        voxel_pchunk.instancesDataRIGHT[i].rotation.Z = dirInstance.Z;
                                                                        voxel_pchunk.instancesDataRIGHT[i].rotation.W = 1;

                                                                        dirInstance = sc_maths._newgetdirup(quat_buffers);
                                                                        voxel_pchunk.instancesDataUP[i].rotation.X = dirInstance.X;
                                                                        voxel_pchunk.instancesDataUP[i].rotation.Y = dirInstance.Y;
                                                                        voxel_pchunk.instancesDataUP[i].rotation.Z = dirInstance.Z;
                                                                        voxel_pchunk.instancesDataUP[i].rotation.W = 1;
                                                                    }
                                                                }
                                                            }
                                                        }
                                                    }
                                                }
                                            }
                                        }*/
                                        //////////////TO READD
                                        //////////////TO READD
                                        //////////////TO READD




                                        /*
                                        for (int pc = 0; pc < arrayOfPlanetChunk.Length; pc++)
                                        {
                                            if (arrayOfPlanetChunk[pc] != null)
                                            {
                                                if (arrayOfPlanetChunk[pc].Vertices != null)
                                                {
                                                    if (arrayOfPlanetChunk[pc].Vertices.Length > 0)
                                                    {
                                                        //float posX = (xc);
                                                        //float posY = (yc);
                                                        //float posZ = (zc);

                                                        //Vector3 planetchunkpos = new Vector3(posX, posY, posZ) + new Vector3(0,5,0);

                                                        //Matrix[] matArray = new Matrix[1];

                                                        //matArray[0] = new Matrix();
                                                        ///matArray[0].M41 = arrayOfPlanetChunk[_index]._ORIGINPOSITION.M41; //planetchunkpos.X;// 
                                                        //matArray[0].M42 = arrayOfPlanetChunk[_index]._ORIGINPOSITION.M42; //planetchunkpos.Y;//
                                                        //matArray[0].M43 = arrayOfPlanetChunk[_index]._ORIGINPOSITION.M43; //planetchunkpos.Z;//

                                                        //PHYSICS VOXEL SPHEROID
                                                        arrayOfPlanetChunk[pc]._WORLDMATRIXINSTANCES = worldMatrix_instances_voxel_pchunk[indexer00][indexer01][pc]; //matArray;// 
                                                        arrayOfPlanetChunk[pc]._POSITION = worldMatrix_base[0];

                                                        //END OF
                                                        //END OF
                                                        //PHYSICS VOXEL THINGS
                                                        var voxel_pchunk = arrayOfPlanetChunk[pc];
                                                        var instances_voxel_pchunk = voxel_pchunk.instances;
                                                        var _voxel_pchunk_Worldmatrix_of_instancespchunk = voxel_pchunk._WORLDMATRIXINSTANCES;

                                                        for (int i = 0; i < instances_voxel_pchunk.Length; i++)
                                                        {
                                                            float xxx = _voxel_pchunk_Worldmatrix_of_instancespchunk[i].M41;
                                                            float yyy = _voxel_pchunk_Worldmatrix_of_instancespchunk[i].M42;
                                                            float zzz = _voxel_pchunk_Worldmatrix_of_instancespchunk[i].M43;

                                                            voxel_pchunk.instances[i].position.X = xxx;
                                                            voxel_pchunk.instances[i].position.Y = yyy;
                                                            voxel_pchunk.instances[i].position.Z = zzz;
                                                            voxel_pchunk.instances[i].position.W = 1;
                                                            Quaternion.RotationMatrix(ref _voxel_pchunk_Worldmatrix_of_instancespchunk[i], out quat_buffers);

                                                            var dirInstance = sc_maths._newgetdirforward(quat_buffers);
                                                            voxel_pchunk.instancesDataForward[i].rotation.X = dirInstance.X;
                                                            voxel_pchunk.instancesDataForward[i].rotation.Y = dirInstance.Y;
                                                            voxel_pchunk.instancesDataForward[i].rotation.Z = dirInstance.Z;
                                                            voxel_pchunk.instancesDataForward[i].rotation.W = 1;

                                                            dirInstance = -sc_maths._newgetdirleft(quat_buffers);
                                                            voxel_pchunk.instancesDataRIGHT[i].rotation.X = dirInstance.X;
                                                            voxel_pchunk.instancesDataRIGHT[i].rotation.Y = dirInstance.Y;
                                                            voxel_pchunk.instancesDataRIGHT[i].rotation.Z = dirInstance.Z;
                                                            voxel_pchunk.instancesDataRIGHT[i].rotation.W = 1;

                                                            dirInstance = sc_maths._newgetdirup(quat_buffers);
                                                            voxel_pchunk.instancesDataUP[i].rotation.X = dirInstance.X;
                                                            voxel_pchunk.instancesDataUP[i].rotation.Y = dirInstance.Y;
                                                            voxel_pchunk.instancesDataUP[i].rotation.Z = dirInstance.Z;
                                                            voxel_pchunk.instancesDataUP[i].rotation.W = 1;
                                                        }
                                                    }
                                                }
                                            }
                                            //END OF
                                        }*/
                                    }
                                }
                            }
                        }
                        catch (Exception ex)
                        {
                            Console.WriteLine(ex.ToString());
                        }
                    }
                }
            }
            //SC BUFFERS
            //SC BUFFERS
            //SC BUFFERS































            /*
            //LEFT CONTROLLER HITPOINT
            //////////////////////////////////////////////////////////////////////////

            if (currentFrameLeft < arrayOfStabilizerPosLeft.Length)
            {
                arrayOfStabilizerPosXLeft[currentFrameLeft] = intersectPointLeft.X;
                arrayOfStabilizerPosYLeft[currentFrameLeft] = intersectPointLeft.Y;
                arrayOfStabilizerPosZLeft[currentFrameLeft] = intersectPointLeft.Z;
                arrayOfStabilizerPosLeft[currentFrameLeft] = intersectPointLeft;
            }
            else
            {
                differenceX = 0;
                differenceY = 0;
                differenceZ = 0;

                int j = 1;
                for (int i = 0; i < arrayOfStabilizerPosXLeft.Length - 1; i++, j++)
                {
                    currentX = arrayOfStabilizerPosXLeft[j];
                    currentY = arrayOfStabilizerPosYLeft[j];
                    currentZ = arrayOfStabilizerPosZLeft[j];

                    lastLeftHitPointXFrameOne = arrayOfStabilizerPosXLeft[i];
                    lastLeftHitPointYFrameOne = arrayOfStabilizerPosYLeft[i];
                    lastLeftHitPointZFrameOne = arrayOfStabilizerPosZLeft[i];

                    if (lastLeftHitPointXFrameOne >= currentX)
                    {
                        differenceX = lastLeftHitPointXFrameOne - currentX;
                    }
                    else
                    {
                        differenceX = currentX - lastLeftHitPointXFrameOne;
                    }
                    arrayOfStabilizerPosDifferenceXLeft[i] = differenceX;

                    if (lastLeftHitPointYFrameOne >= currentY)
                    {
                        differenceY = lastLeftHitPointYFrameOne - currentY;
                    }
                    else
                    {
                        differenceY = currentY - lastLeftHitPointYFrameOne;
                    }
                    arrayOfStabilizerPosDifferenceYLeft[i] = differenceY;


                    if (lastLeftHitPointZFrameOne >= currentZ)
                    {
                        differenceZ = lastLeftHitPointZFrameOne - currentZ;
                    }
                    else
                    {
                        differenceZ = currentZ - lastLeftHitPointZFrameOne;
                    }
                    arrayOfStabilizerPosDifferenceZLeft[i] = differenceZ;
                }

                averageXLeft = 0;
                averageYLeft = 0;
                averageZLeft = 0;


                for (int i = 0; i < arrayOfStabilizerPosDifferenceXLeft.Length; i++)
                {
                    averageXLeft += arrayOfStabilizerPosDifferenceXLeft[i];
                    averageYLeft += arrayOfStabilizerPosDifferenceYLeft[i];
                    averageZLeft += arrayOfStabilizerPosDifferenceZLeft[i];
                }

                averageXLeft = averageXLeft / arrayOfStabilizerPosDifferenceXLeft.Length;
                averageYLeft = averageYLeft / arrayOfStabilizerPosDifferenceYLeft.Length;
                averageZLeft = averageZLeft / arrayOfStabilizerPosDifferenceZLeft.Length;

                restartFrameCounterLeft = true;
            }

            if (!restartFrameCounterLeft)
            {
                currentFrameLeft++;
            }
            else
            {
                currentFrameLeft = 0;
                restartFrameCounterLeft = false;
            }

            positionXLeft = 0;
            positionYLeft = 0;
            positionZLeft = 0;

            for (int i = 0; i < arrayOfStabilizerPosLeft.Length; i++)
            {
                positionXLeft += arrayOfStabilizerPosLeft[i].X;
                positionYLeft += arrayOfStabilizerPosLeft[i].Y;
                positionZLeft += arrayOfStabilizerPosLeft[i].Z;
            }

            positionXLeft = positionXLeft / arrayOfStabilizerPosLeft.Length;
            positionYLeft = positionYLeft / arrayOfStabilizerPosLeft.Length;
            positionZLeft = positionZLeft / arrayOfStabilizerPosLeft.Length;

            stabilizedIntersectionPosLeft = new Vector3((float)positionXLeft, (float)positionYLeft, (float)positionZLeft);
            _intersectTouchLeftMatrix.M41 = stabilizedIntersectionPosLeft.X;
            _intersectTouchLeftMatrix.M42 = stabilizedIntersectionPosLeft.Y;
            _intersectTouchLeftMatrix.M43 = stabilizedIntersectionPosLeft.Z;
            */
            //intersectPointRight.Z;


            /*//CIRCLE CIRCLE INTERSECTION //http://mathworld.wolfram.com/Circle-CircleIntersection.html
            //d = (point3DCollection[2] - point3DCollection[0]).Length();
            //widthLength = (point3DCollection[2] - point3DCollection[0]).Length();
            //heightLength = (point3DCollection[1] - point3DCollection[0]).Length();
            r = (stabilizedIntersectionPosLeft - point3DCollection[0][0]).Length();
            R = (stabilizedIntersectionPosLeft - point3DCollection[0][2]).Length();

            x = ((d * d) - (r * r) + (R * R)) / (2 * d);
            d1 = x;
            d2 = d - x;

            //r is with d2
            //R is with d1
            //a2 + b2 = c2

            b = Math.Sqrt((r * r) - (d2 * d2));
            currentPosWidth = widthLength - d1;
            currentPosHeight = heightLength - b;

            percentXLeft = currentPosWidth / widthLength;
            percentYLeft = currentPosHeight / heightLength;
            percentXLeft *= SC_console_directx.D3D.SurfaceWidth;
            percentYLeft *= SC_console_directx.D3D.SurfaceHeight;







            double realMousePosX = 0;
            double realMousePosY = 0;

            r = (intersectPointRight - point3DCollection[0][0]).Length();
            R = (intersectPointRight - point3DCollection[0][2]).Length();


            x = ((d * d) - (r * r) + (R * R)) / (2 * d);
            d1 = x;
            d2 = d - x;

            //r is with d2
            //R is with d1
            //a2 + b2 = c2

            b = Math.Sqrt((r * r) - (d2 * d2));
            currentPosWidth = widthLength - d1;
            currentPosHeight = heightLength - b;

            percentXRight = currentPosWidth / widthLength;
            percentYRight = currentPosHeight / heightLength;
            percentXRight *= SC_console_directx.D3D.SurfaceWidth;
            percentYRight *= SC_console_directx.D3D.SurfaceHeight;

            realMousePosX = percentXRight;
            realMousePosY = percentYRight;*/













            /*
            //Console.WriteLine("x: " + _final_percentXRight + " y: " + _final_percentYRight);

            _MicrosoftWindowsMouseRight(_final_percentXRight, _final_percentYRight, thumbStickRight, percentXLeft, percentYLeft, thumbStickLeft, realMousePosX, realMousePosY);

            _oculus_touch_controls(_final_percentXRight, _final_percentYRight, thumbStickRight, percentXLeft, percentYLeft, thumbStickLeft, realMousePosX, realMousePosY);

            //var absoluteMoveX = Convert.ToUInt32((percentXRight * 65535) / SC_console_directx.D3D.SurfaceWidth);
            //var absoluteMoveY = Convert.ToUInt32((percentYRight * 65535) / SC_console_directx.D3D.SurfaceHeight);

            _mouseCursorMatrix.M41 = (float)((percentXRight * 65535) / SC_console_directx.D3D.SurfaceWidth);
            _mouseCursorMatrix.M42 = (float)((percentYRight * 65535) / SC_console_directx.D3D.SurfaceHeight);

            _last_final_hand_pos_right = new Vector3(_player_rght_hnd[0]._arrayOfInstances[0].current_pos.M41, _player_rght_hnd[0]._arrayOfInstances[0].current_pos.M42, _player_rght_hnd[0]._arrayOfInstances[0].current_pos.M43);
            _last_frame_handPos = new Vector3(_player_rght_hnd[0]._arrayOfInstances[0].current_pos.M41, _player_rght_hnd[0]._arrayOfInstances[0].current_pos.M42, _player_rght_hnd[0]._arrayOfInstances[0].current_pos.M43);

            //final_hand_pos_right_locked = _player_rght_hnd[0]._arrayOfInstances[0].current_pos;

            if (_grabbed_body_right != null)
            {
                _last_frame_rigid_grab_pos = new Vector3(_grabbed_body_right.Position.X, _grabbed_body_right.Position.Y, _grabbed_body_right.Position.Z);
                _last_frame_rigid_grab_rot = _grabbed_body_right.Orientation;//new JQuaternion();// new Vector3(rigidbody.Position.X, rigidbody.Position.Y, rigidbody.Position.Z);
            }*/

            /*
            lastHasUsedHandTriggerLeft = hasUsedHandTriggerLeft;
            lastbuttonPressedOculusTouchRight = buttonPressedOculusTouchRight;
            lastbuttonPressedOculusTouchLeft = buttonPressedOculusTouchLeft;
            */













            /*//DISCARDED TO REINSERT
            //DISCARDED TO REINSERT
            //DISCARDED TO REINSERT
            lastHasUsedHandTriggerLeft = hasUsedHandTriggerLeft;
            lastbuttonPressedOculusTouchRight = buttonPressedOculusTouchRight;
            lastbuttonPressedOculusTouchLeft = buttonPressedOculusTouchLeft;

            final_hand_pos_right_locked =ikarmvoxel[3]._player_rght_hnd[0][0]._arrayOfInstances[0].current_pos;
            final_hand_pos_left_locked = ikarmvoxel[0]._player_rght_hnd[0][0]._arrayOfInstances[0].current_pos;
            _last_final_hand_pos_right = new Vector3(ikarmvoxel[3]._player_rght_hnd[0][0]._arrayOfInstances[0].current_pos.M41, ikarmvoxel[3]._player_rght_hnd[0][0]._arrayOfInstances[0].current_pos.M42, ikarmvoxel[3]._player_rght_hnd[0][0]._arrayOfInstances[0].current_pos.M43);
            _last_frame_handPos = new Vector3(ikarmvoxel[3]._player_rght_hnd[0][0]._arrayOfInstances[0].current_pos.M41, ikarmvoxel[3]._player_rght_hnd[0][0]._arrayOfInstances[0].current_pos.M42, ikarmvoxel[3]._player_rght_hnd[0][0]._arrayOfInstances[0].current_pos.M43);
            ///DISCARDED TO REINSERT
            //DISCARDED TO REINSERT
            //DISCARDED TO REINSERT*/








            return _sc_jitter_tasks;
        }

        bool _canResetCounterTouchRightButtonA = false;
        bool _canResetCounterTouchRightButtonB = false;
        int _frameCounterTouchLeft = 0;
        bool _canResetCounterTouchLeftButtonA = false;
        bool _canResetCounterTouchLeftButtonB = false;
        bool _canResetCounterTouchLeftButtonX = false;
        bool _canResetCounterTouchLeftButtonY = false;
        bool hasUsedThumbStickLeftW = false;
        bool hasUsedThumbStickLeftS = false;
        bool hasUsedThumbStickLeftA = false;
        bool hasUsedThumbStickRightD = false;
        bool hasUsedThumbStickRightQ = false;
        bool hasUsedThumbStickRightE = false;
        bool lastHasUsedHandTriggerLeft = false;
        bool hasUsedHandTriggerLeft = false;


















        private void _oculus_touch_controls(double percentXRight, double percentYRight, Vector2f[] thumbStickRight, double percentXLeft, double percentYLeft, Vector2f[] thumbStickLeft, double realMousePosX, double realMousePosY) //
        {
            if (MainWindow.useArduinoOVRTouchKeymapper == 1)
            {
                var homebuttonLeftTouchControllerArduino = SC_Update.arduinoDIYOculusTouchArrayOfData[5];

                //Console.WriteLine("homebuttonLeftTouchControllerArduino:" + homebuttonLeftTouchControllerArduino);
                if (homebuttonLeftTouchControllerArduino == 1)//buttonPressedOculusTouchLeft == 1048576)
                {
                    if (hasClickedHomeButtonTouchLeft == 0)
                    {
                        SC_console_directx.D3D.OVR.RecenterTrackingOrigin(SC_console_directx.D3D.sessionPtr);

                        //hmdrotMatrix

                        Quaternion currentRot;// = hmd_matrix_current;
                        Quaternion.RotationMatrix(ref hmd_matrix_current, out currentRot);

                        hmd_matrix_current = hmd_matrix_current * OriginRot * RotatingMatrix * RotatingMatrixForPelvis * hmdmatrixRot_; //viewMatrix_;


                        hmdmatrixcurrentforpelvis = hmdmatrixcurrentforpelvis * OriginRot * RotatingMatrix * RotatingMatrixForPelvis * hmdmatrixRot_;


                        //RotatingMatrixForPelvis = hmdmatrixRot_ * RotatingMatrixForPelvis;



                        //RotatingMatrixForPelvis = hmd_matrix_current * RotatingMatrixForPelvis;
                        //OriginRot = hmd_matrix_current * OriginRot;





                        //Quaternion currentRotAfter;
                        //Quaternion.RotationMatrix(ref hmd_matrix_current, out currentRotAfter);
                        //Quaternion.Lerp(ref currentRot, ref currentRotAfter, 0.001f, out currentRotAfter);
                        //Matrix.RotationQuaternion(ref currentRotAfter,out hmd_matrix_current);

                        //var timeSinceStart = (float)(DateTime.Now - SC_Update.startTime).TotalSeconds;
                        //Matrix worldmatlightrot = Matrix.Scaling(1.0f) * Matrix.RotationX(timeSinceStart * disco_sphere_rot_speed) * Matrix.RotationY(timeSinceStart * 2 * disco_sphere_rot_speed) * Matrix.RotationZ(timeSinceStart * 3 * disco_sphere_rot_speed);



                        Quaternion _testQuator;
                        Quaternion.RotationMatrix(ref hmd_matrix_current, out _testQuator);

                        var xq = _testQuator.X;
                        var yq = _testQuator.Y;
                        var zq = _testQuator.Z;
                        var wq = _testQuator.W;

                        float roller = (float)(Math.Atan2(2 * yq * wq - 2 * xq * zq, 1 - 2 * yq * yq - 2 * zq * zq));// * (180 / Math.PI));
                        float pitcher = (float)(Math.Atan2(2 * yq * wq - 2 * xq * zq, 1 - 2 * yq * yq - 2 * zq * zq));// * (180 / Math.PI));//
                        float yawer = (float)(Math.Atan2(2 * yq * wq - 2 * xq * zq, 1 - 2 * yq * yq - 2 * zq * zq));// * (180 / Math.PI));

                        //RotationY4Pelvis
                        //Matrix tempMat = RotatingMatrixForPelvis * hmdmatrixRot_;
                        Quaternion.RotationMatrix(ref hmd_matrix_current, out _testQuator);

                        xq = _testQuator.X;
                        yq = _testQuator.Y;
                        zq = _testQuator.Z;
                        wq = _testQuator.W;

                        float rollerPelvis = (float)(Math.Atan2(2 * yq * wq - 2 * xq * zq, 1 - 2 * yq * yq - 2 * zq * zq));// * (180 / Math.PI));
                        float pitcherPelvis = (float)(Math.Atan2(2 * yq * wq - 2 * xq * zq, 1 - 2 * yq * yq - 2 * zq * zq));// * (180 / Math.PI));//
                        float yawerPelvis = (float)(Math.Atan2(2 * yq * wq - 2 * xq * zq, 1 - 2 * yq * yq - 2 * zq * zq));// * (180 / Math.PI));

                        //var pitch = (float)((Math.PI * pitcher + 45) / 180);
                        //var roll = (float)(0);
                        //var yaw = (float)(0);

                        SC_Update.RotationX4Pelvis = pitcher;
                        SC_Update.RotationY4Pelvis = 0;
                        SC_Update.RotationZ4Pelvis = 0;

                        SC_Update.rotatingMatrixForPelvis = SharpDX.Matrix.RotationYawPitchRoll(pitcher, 0, 0);
                        SC_Update.hmdmatrixRot = SharpDX.Matrix.RotationYawPitchRoll(pitcher, 0, 0);

                        hasClickedHomeButtonTouchLeft = 1;
                    }
                }


                if (hasClickedHomeButtonTouchLeft == 1)
                {
                    if (hasClickedHomeButtonTouchLeftCounter > 20)
                    {
                        hasClickedHomeButtonTouchLeft = 0;
                        hasClickedHomeButtonTouchLeftCounter = 0;
                    }
                    hasClickedHomeButtonTouchLeftCounter++;
                }



                var XLeftTouchControllerArduino = SC_Update.arduinoDIYOculusTouchArrayOfData[4];

                //Console.WriteLine("XLeftTouchControllerArduino:" + XLeftTouchControllerArduino);
                if (XLeftTouchControllerArduino == 1)
                {
                    if (sc_menu_scroller_counter >= 75)
                    {
                        if (sc_menu_scroller == 0)
                        {
                            sc_menu_scroller = 1;
                        }
                        else if (sc_menu_scroller == 1)
                        {
                            sc_menu_scroller = 2;
                        }
                        else if (sc_menu_scroller == 2)
                        {
                            sc_menu_scroller = 3;
                        }
                        else if (sc_menu_scroller == 3)
                        {
                            sc_menu_scroller = 4;
                        }
                        else if (sc_menu_scroller == 4)
                        {
                            sc_menu_scroller = 0;
                        }
                        sc_menu_scroller_counter = 0;
                    }
                }
                sc_menu_scroller_counter++;



                var YLeftTouchControllerArduino = SC_Update.arduinoDIYOculusTouchArrayOfData[3];


                if (_has_locked_screen_pos_counter >= 50)
                {
                    if (YLeftTouchControllerArduino == 1)
                    {
                        if (sc_menu_scroller == 0)
                        {
                            if (frame_counter_4_buttonY >= 75)
                            {
                                if (display_grid_type == 0)
                                {
                                    display_grid_type = 1;
                                }
                                else if (display_grid_type == 1)
                                {
                                    display_grid_type = 2;
                                }
                                else if (display_grid_type == 2)
                                {
                                    display_grid_type = 3;
                                }
                                else if (display_grid_type == 3)
                                {
                                    display_grid_type = 0;
                                }
                                frame_counter_4_buttonY = 0;
                            }
                        }
                        else if (sc_menu_scroller == 1)
                        {
                            if (_has_locked_screen_pos == 0)
                            {
                                _has_locked_screen_pos_counter = 0;
                                _has_locked_screen_pos = 1;
                            }
                            else if (_has_locked_screen_pos == 1)
                            {
                                _has_locked_screen_pos_counter = 0;
                                _has_locked_screen_pos = 0;
                            }
                        }
                    }
                }
                frame_counter_4_buttonY++;
                _has_locked_screen_pos_counter++;






                if (sc_menu_scroller == 2)
                {
                    /////////////LEFT OCULUS TOUCH/////////////////////////////////////////////////////////////////////////////////////
                    if (percentXLeft >= 0 && percentXLeft <= 1920 && percentYLeft >= 0 && percentYLeft <= 1080)
                    {
                        var absoluteMoveX = Convert.ToUInt32((percentXLeft * (65535 - 1)) / SC_console_directx.D3D.SurfaceWidth);
                        var absoluteMoveY = Convert.ToUInt32((percentYLeft * (65535 - 1)) / SC_console_directx.D3D.SurfaceHeight);

                        if (percentXLeft >= 0 && percentXLeft < SC_console_directx.D3D.SurfaceWidth)
                        {

                        }
                        else
                        {
                            percentXLeft = SC_console_directx.D3D.SurfaceWidth;
                            absoluteMoveX = Convert.ToUInt32((percentXLeft * (65535 - 1)) / SC_console_directx.D3D.SurfaceWidth);
                        }

                        if (percentYLeft >= 0 && percentYLeft < SC_console_directx.D3D.SurfaceHeight)
                        {

                        }
                        else
                        {
                            percentYLeft = SC_console_directx.D3D.SurfaceHeight;
                            absoluteMoveY = Convert.ToUInt32((percentYLeft * (65535 - 1)) / SC_console_directx.D3D.SurfaceHeight);
                        }


                        //MOUSE DOUBLE CLICK LOGIC. IF the PLAYER clicked at one location then it stores the location, and if the player re-clicks inside of 20 frames, then click at the first click location.
                        //It's very basic, and at least I should implement also a certain "radius" of distance from the first click and the second click... If the second click is too far from the first click,
                        //then disregard the first click location.
                        if (_frameCounterTouchLeft >= 50)
                        {

                            if (YLeftTouchControllerArduino == 1)
                            {
                                if (hasClickedBUTTONX == 0)
                                {
                                    absoluteMoveX = Convert.ToUInt32((percentXLeft * 65535 - 1) / SC_console_directx.D3D.SurfaceWidth);
                                    absoluteMoveY = Convert.ToUInt32((percentYLeft * 65535 - 1) / SC_console_directx.D3D.SurfaceHeight);

                                    //if (_out_of_bounds_left == 0)
                                    //{
                                    //  
                                    //}

                                    SetCursorPos((int)percentXLeft, (int)percentYLeft);
                                    //mouse_event(MOUSEEVENTF_MOVE | MOUSEEVENTF_ABSOLUTE, _lastMousePosXRight, _lastMousePosYRight, 0, 0);
                                    _frameCounterTouchLeft = 0;

                                    //mouse_event(MOUSEEVENTF_MOVE | MOUSEEVENTF_ABSOLUTE, absoluteMoveX, absoluteMoveY, 0, 0);
                                    //mouse_event(MOUSEEVENTF_LEFTDOWN | MOUSEEVENTF_LEFTUP, absoluteMoveX, absoluteMoveY, 0, 0);


                                    MainWindow.mousesim.LeftButtonDown();
                                    //MainWindow.mousesim.MoveMouseToPositionOnVirtualDesktop();
                                    //MainWindow.mousesim.LeftButtonClick();

                                    //_lastMousePosXLeft = absoluteMoveX;
                                    //_lastMousePosYLeft = absoluteMoveY;
                                    _canResetCounterTouchLeftButtonX = true;
                                    hasClickedBUTTONX = 1;
                                }
                            }
                            /*else if (YLeftTouchControllerArduino == 512)
                            {
                                if (hasClickedBUTTONY == 0)
                                {
                                    if (_out_of_bounds_right == 0)
                                    {
                                        absoluteMoveX = Convert.ToUInt32((realMousePosX * 65535 - 1) / SC_console_directx.D3D.SurfaceWidth);
                                        absoluteMoveY = Convert.ToUInt32((realMousePosY * 65535 - 1) / SC_console_directx.D3D.SurfaceHeight);
                                    }
                                    mouse_event(MOUSEEVENTF_RIGHTDOWN, 0, 0, 0, 0);
                                    //_lastMousePosX = absoluteMoveX;
                                    //_lastMousePosY = absoluteMoveY;
                                    //_canResetCounterTouchRight = true;
                                    hasClickedBUTTONY = 1;
                                }
                            }*/


                        }
                        _out_of_bounds_left = 0;
                    }
                    else
                    {
                        _out_of_bounds_left = 1;
                    }
                    if (hasClickedBUTTONX == 1)
                    {
                        if (_frameCounterTouchLeft >= 10)
                        {
                            hasClickedBUTTONX = 0;
                        }
                    }
                }
                _frameCounterTouchLeft++;

                //TO READD WHEN I ORDER THE ARDUINO TRIGGERS OR NOT
                //TO READD WHEN I ORDER THE ARDUINO TRIGGERS OR NOT
                /*
                if (indexTriggerRight[1] > 0.0001f)
                {
                    if (heightmapscale > heightmapscaleMax)
                    {
                        heightmapscale = heightmapscaleMax;
                    }
                    else
                    {
                        heightmapscale += 0.00001f;
                    }
                }

                if (indexTriggerLeft[0] > 0.0001f)
                {
                    if (heightmapscale < heightmapscaleMin)
                    {
                        heightmapscale = heightmapscaleMin;
                    }
                    else
                    {
                        heightmapscale -= 0.00001f;
                    }
                }
                //if (Math.Abs(Math.Abs(indexTriggerRightLastAbs) - Math.Abs(indexTriggerRight[1])) > 0.0001f)
                //if (Math.Abs(Math.Abs(indexTriggerLeftLastAbs) - Math.Abs(indexTriggerLeft[0])) > 0.0001f)
                indexTriggerRightLastAbs = indexTriggerRight[1];
                indexTriggerLeftLastAbs = indexTriggerLeft[0];*/
                //TO READD WHEN I ORDER THE ARDUINO TRIGGERS OR NOT
                //TO READD WHEN I ORDER THE ARDUINO TRIGGERS OR NOT
            }
            else if (MainWindow.useArduinoOVRTouchKeymapper == 0)
            {
                if (buttonPressedOculusTouchLeft == 1048576)
                {
                    if (hasClickedHomeButtonTouchLeft == 0)
                    {
                        SC_console_directx.D3D.OVR.RecenterTrackingOrigin(SC_console_directx.D3D.sessionPtr);

                        //hmdrotMatrix

                        Quaternion currentRot;// = hmd_matrix_current;
                        Quaternion.RotationMatrix(ref hmd_matrix_current, out currentRot);

                        hmd_matrix_current = hmd_matrix_current * OriginRot * RotatingMatrix * RotatingMatrixForPelvis * hmdmatrixRot_; //viewMatrix_;


                        //Quaternion currentRotAfter;
                        //Quaternion.RotationMatrix(ref hmd_matrix_current, out currentRotAfter);
                        //Quaternion.Lerp(ref currentRot, ref currentRotAfter, 0.001f, out currentRotAfter);
                        //Matrix.RotationQuaternion(ref currentRotAfter,out hmd_matrix_current);

                        //var timeSinceStart = (float)(DateTime.Now - SC_Update.startTime).TotalSeconds;
                        //Matrix worldmatlightrot = Matrix.Scaling(1.0f) * Matrix.RotationX(timeSinceStart * disco_sphere_rot_speed) * Matrix.RotationY(timeSinceStart * 2 * disco_sphere_rot_speed) * Matrix.RotationZ(timeSinceStart * 3 * disco_sphere_rot_speed);



                        Quaternion _testQuator;
                        Quaternion.RotationMatrix(ref hmd_matrix_current, out _testQuator);

                        var xq = _testQuator.X;
                        var yq = _testQuator.Y;
                        var zq = _testQuator.Z;
                        var wq = _testQuator.W;

                        float roller = (float)(Math.Atan2(2 * yq * wq - 2 * xq * zq, 1 - 2 * yq * yq - 2 * zq * zq));// * (180 / Math.PI));
                        float pitcher = (float)(Math.Atan2(2 * yq * wq - 2 * xq * zq, 1 - 2 * yq * yq - 2 * zq * zq));// * (180 / Math.PI));//
                        float yawer = (float)(Math.Atan2(2 * yq * wq - 2 * xq * zq, 1 - 2 * yq * yq - 2 * zq * zq));// * (180 / Math.PI));

                        //RotationY4Pelvis
                        //Matrix tempMat = RotatingMatrixForPelvis * hmdmatrixRot_;
                        Quaternion.RotationMatrix(ref hmd_matrix_current, out _testQuator);

                        xq = _testQuator.X;
                        yq = _testQuator.Y;
                        zq = _testQuator.Z;
                        wq = _testQuator.W;

                        float rollerPelvis = (float)(Math.Atan2(2 * yq * wq - 2 * xq * zq, 1 - 2 * yq * yq - 2 * zq * zq));// * (180 / Math.PI));
                        float pitcherPelvis = (float)(Math.Atan2(2 * yq * wq - 2 * xq * zq, 1 - 2 * yq * yq - 2 * zq * zq));// * (180 / Math.PI));//
                        float yawerPelvis = (float)(Math.Atan2(2 * yq * wq - 2 * xq * zq, 1 - 2 * yq * yq - 2 * zq * zq));// * (180 / Math.PI));

                        //var pitch = (float)((Math.PI * pitcher + 45) / 180);
                        //var roll = (float)(0);
                        //var yaw = (float)(0);

                        SC_Update.RotationX4Pelvis = pitcher;
                        SC_Update.RotationY4Pelvis = 0;
                        SC_Update.RotationZ4Pelvis = 0;

                        SC_Update.rotatingMatrixForPelvis = SharpDX.Matrix.RotationYawPitchRoll(pitcher, 0, 0);
                        SC_Update.hmdmatrixRot = SharpDX.Matrix.RotationYawPitchRoll(pitcher, 0, 0);

                        hasClickedHomeButtonTouchLeft = 1;
                    }
                }

                if (hasClickedHomeButtonTouchLeft == 1)
                {
                    if (hasClickedHomeButtonTouchLeftCounter > 20)
                    {
                        hasClickedHomeButtonTouchLeft = 0;
                        hasClickedHomeButtonTouchLeftCounter = 0;
                    }
                    hasClickedHomeButtonTouchLeftCounter++;
                }

                if (buttonPressedOculusTouchLeft != 0)
                {
                    if (buttonPressedOculusTouchLeft == 512)
                    {
                        if (sc_menu_scroller_counter >= 75)
                        {
                            if (sc_menu_scroller == 0)
                            {
                                sc_menu_scroller = 1;
                            }
                            else if (sc_menu_scroller == 1)
                            {
                                sc_menu_scroller = 2;
                            }
                            else if (sc_menu_scroller == 2)
                            {
                                sc_menu_scroller = 0;
                            }
                            /*else if (sc_menu_scroller == 3)
                            {
                                sc_menu_scroller = 0;
                            }*/
                            /*else if (sc_menu_scroller == 4)
                            {
                                sc_menu_scroller = 0;
                            }*/
                            sc_menu_scroller_counter = 0;
                        }
                    }
                }
                sc_menu_scroller_counter++;

                if (_has_locked_screen_pos_counter >= 50)
                {
                    if (buttonPressedOculusTouchLeft == 256)
                    {
                        if (sc_menu_scroller == 0)
                        {
                            if (frame_counter_4_buttonY >= 75)
                            {
                                if (display_grid_type == 0)
                                {
                                    display_grid_type = 1;
                                }
                                else if (display_grid_type == 1)
                                {
                                    display_grid_type = 2;
                                }
                                else if (display_grid_type == 2)
                                {
                                    display_grid_type = 3;
                                }
                                else if (display_grid_type == 3)
                                {
                                    display_grid_type = 0;
                                }

                                frame_counter_4_buttonY = 0;
                            }
                        }
                        else if (sc_menu_scroller == 1)
                        {
                            if (_has_locked_screen_pos == 0)
                            {
                                _has_locked_screen_pos_counter = 0;
                                _has_locked_screen_pos = 1;
                            }
                            else if (_has_locked_screen_pos == 1)
                            {
                                _has_locked_screen_pos_counter = 0;
                                _has_locked_screen_pos = 0;
                            }
                        }
                        else if (sc_menu_scroller == 2)
                        {
                            if (frame_counter_4_buttonY >= 75)
                            {

                                if (resetvoxelladdercounter == 1)
                                {
                                    //5 full chunk cube all 1s for byte breaking when 1s becomes 0s (and for byte adding when byte 0s become 1s WIP)
                                    //4 full chunk cube all 0s for path tracing with path traced with bytes becoming 1s when the player moves around the invisible chunk.
                                    //3 full chunk cube all 0s for a way to visualize spatial location of objects in a 3d scene.
                                    //2 full chunk cube all 1s for byte breaking when 1s becomes 0s (and for byte adding when byte 0s become 1s WIP) - using random perlin WIP
                                    //1 WIP TRANSPARENCY GRID LIKE CHUNK WITH MY UPCOMING CODING CHALLENGE TO LEARN RASTERTEK C# TRANSPARENCY.

                                    if (resetvoxelladder == 0)
                                    {
                                        MainWindow.usetypeofvoxel = 5; // full chunk cube all 1s for byte breaking when 1s becomes 0s (and for byte adding when byte 0s become 1s WIP)
                                        somechunkplayerspatiallocationresetcounter = 0;
                                        somechunkresetcounter = 0;
                                        resetvoxelladdercounter = 2;
                                        resetvoxelladder = 1;
                                    }
                                    else if (resetvoxelladder == 1)
                                    {
                                        MainWindow.usetypeofvoxel = 4; // full chunk cube all 0s for path tracing with path traced with bytes becoming 1s when the player moves around the invisible chunk.
                                        somechunkplayerspatiallocationresetcounter = 0;
                                        somechunkresetcounter = 0;
                                        resetvoxelladdercounter = 2;
                                        resetvoxelladder = 2;
                                    }
                                    else if (resetvoxelladder == 2)
                                    {
                                        MainWindow.usetypeofvoxel = 3; // full chunk cube all 0s for a way to visualize spatial location of objects in a 3d scene.
                                        somechunkplayerspatiallocationresetcounter = 0;
                                        somechunkresetcounter = 0;
                                        resetvoxelladdercounter = 2;
                                        resetvoxelladder = 3;
                                    }
                                    else if (resetvoxelladder == 3)
                                    {
                                        MainWindow.usetypeofvoxel = 2; // full chunk cube all 1s for byte breaking when 1s becomes 0s (and for byte adding when byte 0s become 1s WIP) - using random perlin WIP
                                        somechunkplayerspatiallocationresetcounter = 0;
                                        somechunkresetcounter = 0;
                                        resetvoxelladdercounter = 2;
                                        resetvoxelladder = 4;
                                    }
                                    /*else if (resetvoxelladder == 4)
                                    {
                                        MainWindow.usetypeofvoxel = 1; // WIP TRANSPARENCY GRID LIKE CHUNK WITH MY UPCOMING CODING CHALLENGE TO LEARN RASTERTEK C# TRANSPARENCY.
                                        somecounterresetcounter = 0;
                                        resetvoxelladdercounter = 2;
                                        resetvoxelladder = 5;
                                    }*/
                                    else if (resetvoxelladder == 4)
                                    {
                                        resetvoxelladder = 0;
                                    }
                                }
                                frame_counter_4_buttonY = 0;
                            }
                        }
                    }
                }
                frame_counter_4_buttonY++;
                _has_locked_screen_pos_counter++;






                if (sc_menu_scroller == 2)
                {
                    /////////////LEFT OCULUS TOUCH/////////////////////////////////////////////////////////////////////////////////////
                    if (percentXLeft >= 0 && percentXLeft <= 1920 && percentYLeft >= 0 && percentYLeft <= 1080)
                    {
                        var absoluteMoveX = Convert.ToUInt32((percentXLeft * (65535 - 1)) / SC_console_directx.D3D.SurfaceWidth);
                        var absoluteMoveY = Convert.ToUInt32((percentYLeft * (65535 - 1)) / SC_console_directx.D3D.SurfaceHeight);

                        if (percentXLeft >= 0 && percentXLeft < SC_console_directx.D3D.SurfaceWidth)
                        {

                        }
                        else
                        {
                            percentXLeft = SC_console_directx.D3D.SurfaceWidth;
                            absoluteMoveX = Convert.ToUInt32((percentXLeft * (65535 - 1)) / SC_console_directx.D3D.SurfaceWidth);
                        }

                        if (percentYLeft >= 0 && percentYLeft < SC_console_directx.D3D.SurfaceHeight)
                        {

                        }
                        else
                        {
                            percentYLeft = SC_console_directx.D3D.SurfaceHeight;
                            absoluteMoveY = Convert.ToUInt32((percentYLeft * (65535 - 1)) / SC_console_directx.D3D.SurfaceHeight);
                        }


                        //MOUSE DOUBLE CLICK LOGIC. IF the PLAYER clicked at one location then it stores the location, and if the player re-clicks inside of 20 frames, then click at the first click location.
                        //It's very basic, and at least I should implement also a certain "radius" of distance from the first click and the second click... If the second click is too far from the first click,
                        //then disregard the first click location.
                        if (_frameCounterTouchLeft >= 50)
                        {
                            if (buttonPressedOculusTouchLeft != 0)
                            {
                                if (buttonPressedOculusTouchLeft == 256)
                                {
                                    if (hasClickedBUTTONX == 0)
                                    {
                                        absoluteMoveX = Convert.ToUInt32((percentXLeft * 65535 - 1) / SC_console_directx.D3D.SurfaceWidth);
                                        absoluteMoveY = Convert.ToUInt32((percentYLeft * 65535 - 1) / SC_console_directx.D3D.SurfaceHeight);

                                        //if (_out_of_bounds_left == 0)
                                        //{
                                        //  
                                        //}

                                        SetCursorPos((int)percentXLeft, (int)percentYLeft);
                                        //mouse_event(MOUSEEVENTF_MOVE | MOUSEEVENTF_ABSOLUTE, _lastMousePosXRight, _lastMousePosYRight, 0, 0);
                                        _frameCounterTouchLeft = 0;

                                        //mouse_event(MOUSEEVENTF_MOVE | MOUSEEVENTF_ABSOLUTE, absoluteMoveX, absoluteMoveY, 0, 0);
                                        //mouse_event(MOUSEEVENTF_LEFTDOWN | MOUSEEVENTF_LEFTUP, absoluteMoveX, absoluteMoveY, 0, 0);


                                        MainWindow.mousesim.LeftButtonDown();
                                        //MainWindow.mousesim.MoveMouseToPositionOnVirtualDesktop();
                                        //MainWindow.mousesim.LeftButtonClick();

                                        //_lastMousePosXLeft = absoluteMoveX;
                                        //_lastMousePosYLeft = absoluteMoveY;
                                        _canResetCounterTouchLeftButtonX = true;
                                        hasClickedBUTTONX = 1;
                                    }
                                }
                                /*else if (buttonPressedOculusTouchLeft == 512)
                                {
                                    if (hasClickedBUTTONY == 0)
                                    {
                                        if (_out_of_bounds_right == 0)
                                        {
                                            absoluteMoveX = Convert.ToUInt32((realMousePosX * 65535 - 1) / SC_console_directx.D3D.SurfaceWidth);
                                            absoluteMoveY = Convert.ToUInt32((realMousePosY * 65535 - 1) / SC_console_directx.D3D.SurfaceHeight);
                                        }
                                        mouse_event(MOUSEEVENTF_RIGHTDOWN, 0, 0, 0, 0);
                                        //_lastMousePosX = absoluteMoveX;
                                        //_lastMousePosY = absoluteMoveY;
                                        //_canResetCounterTouchRight = true;
                                        hasClickedBUTTONY = 1;
                                    }
                                }*/

                            }
                        }
                        _out_of_bounds_left = 0;
                    }
                    else
                    {
                        _out_of_bounds_left = 1;
                    }
                    if (hasClickedBUTTONX == 1)
                    {
                        if (_frameCounterTouchLeft >= 10)
                        {
                            hasClickedBUTTONX = 0;
                        }
                    }
                }
                _frameCounterTouchLeft++;




                if (indexTriggerRight[1] > 0.0001f)
                {
                    if (heightmapscale > heightmapscaleMax)
                    {
                        heightmapscale = heightmapscaleMax;
                    }
                    else
                    {
                        heightmapscale += 0.00001f;
                    }
                }

                if (indexTriggerLeft[0] > 0.0001f)
                {
                    if (heightmapscale < heightmapscaleMin)
                    {
                        heightmapscale = heightmapscaleMin;
                    }
                    else
                    {
                        heightmapscale -= 0.00001f;
                    }
                }
                //if (Math.Abs(Math.Abs(indexTriggerRightLastAbs) - Math.Abs(indexTriggerRight[1])) > 0.0001f)
                //if (Math.Abs(Math.Abs(indexTriggerLeftLastAbs) - Math.Abs(indexTriggerLeft[0])) > 0.0001f)
                indexTriggerRightLastAbs = indexTriggerRight[1];
                indexTriggerLeftLastAbs = indexTriggerLeft[0];

















                if (buttonPressedOculusTouchLeft != 0)
                {
                    //MainWindow.MessageBox((IntPtr)0, buttonPressedOculusTouchLeft + "", "sccs message", 0);

                    if (buttonPressedOculusTouchLeft == 1024 && hasClickedBUTTONX == 0)
                    {







                        /*string windowsKeyboard = "osk";

                        foreach (Process clsProcess in Process.GetProcesses())
                        {
                            if (clsProcess.ProcessName.ToLower().Contains(windowsKeyboard.ToLower()))
                            {
                                break;
                            }
                            else
                            {
                                Process proc = new Process();
                                proc.StartInfo.FileName = windowsKeyboard + ".exe";
                                proc.Start();
                                break;
                            }
                        }*/



                        /*string windir = Environment.GetEnvironmentVariable("windir");

                        Process p = new Process();
                        p.StartInfo.FileName = windir + @"\System32\cmd.exe";
                        p.StartInfo.Arguments = "/C " + windir + @"\System32\osk.exe";
                        p.StartInfo.CreateNoWindow = true;
                        p.StartInfo.UseShellExecute = false;
                        p.Start();
                        p.Dispose();*/



                        /*ProcessStartInfo startInfo = new ProcessStartInfo();
                        startInfo.CreateNoWindow = false;
                        startInfo.UseShellExecute = true;
                        startInfo.WorkingDirectory = @"c:\WINDOWS\system32\";
                        startInfo.FileName = "osk.exe";
                        startInfo.Verb = "runas";
                        startInfo.WindowStyle = ProcessWindowStyle.Normal;

                        try
                        {
                            using (Process process = Process.Start(startInfo))
                            {
                                process.WaitForExit();
                            }
                        }
                        catch (Exception)
                        {
                            //throw;
                        }*/



                        //System.Diagnostics.Process.Start("osk.exe");
                        /*string windir = Environment.GetEnvironmentVariable("windir");

                        Process p = new Process();
                        p.StartInfo.FileName = windir + @"\System32\cmd.exe";
                        p.StartInfo.Arguments = "/C " + windir + @"\System32\osk.exe";
                        p.StartInfo.CreateNoWindow = true;
                        p.StartInfo.UseShellExecute = false;
                        p.Start();
                        p.Dispose();*/

                        //var path64 = @"c:\windows\sysnative\osk.exe"; //@"C:\Windows\winsxs\amd64_microsoft-windows-osk_31bf3856ad364e35_6.1.7600.16385_none_06b1c513739fb828\osk.exe";
                        //var path32 = @"c:\windows\sysnative\osk.exe";// @"C:\windows\system32\osk.exe"; 
                        //var path = (Environment.Is64BitOperatingSystem) ? path64 : path32;

                        //string somestr = getOskPath(@"c:\windows\system32\");




                        /*string[] dirs = Directory.GetFiles(@"c:\Windows\System32\", "c*");

                        Console.WriteLine("The number of files starting with c is {0}.", dirs.Length);

                        foreach (string dir in dirs)
                        {

                            Console.WriteLine(dir);
                            if (dir == @"c:\Windows\System32\osk.exe")
                            {
                                MainWindow.MessageBox((IntPtr)0, "", "sccs error", 0);
                                Console.WriteLine(dir);
                                string somestr = getOskPath(dir);

                                MainWindow.MessageBox((IntPtr)0, "" + somestr, "sccs error", 0);
                            }
                        }*/





                        /*string somestr = @"c:\windows\system32\osk.exe";// getOskPath(@"c:\windows\system32\osk.exe");
                        var permissionSet = new PermissionSet(PermissionState.None);
                        var writePermission = new FileIOPermission(FileIOPermissionAccess.Read, somestr); //write
                        permissionSet.AddPermission(writePermission);

                        if (permissionSet.IsSubsetOf(AppDomain.CurrentDomain.PermissionSet))
                        {
                            MainWindow.MessageBox((IntPtr)0, "" + somestr, "sccs error", 0);

                            Process[] p = Process.GetProcessesByName(Path.GetFileNameWithoutExtension(OnScreenKeyboardExe));

                            if (p.Length == 0)
                            {
                                // we must start osk from an MTA thread
                                if (Thread.CurrentThread.GetApartmentState() == ApartmentState.STA)
                                {
                                    ThreadStart start = new ThreadStart(ShowKeyboard);// StartOsk);
                                    Thread thread = new Thread(start);
                                    thread.SetApartmentState(ApartmentState.MTA);
                                    thread.Start();
                                    thread.Join();
                                }
                                else
                                {
                                    ShowKeyboard();//StartOsk();
                                }
                            }
                            else
                            {
                                // there might be a race condition if the process terminated 
                                // meanwhile -> proper exception handling should be added
                                //
                                SendMessage(p[0].MainWindowHandle, WM_SYSCOMMAND, new IntPtr(SC_RESTORE), new IntPtr(0)); //MainWindowHandle
                            }
                        }
                        else
                        {
                          
                        }*/


                        string windowsKeyboard = "osk";

                        foreach (Process clsProcess in Process.GetProcesses())
                        {
                            if (clsProcess.ProcessName.ToLower().Contains(windowsKeyboard.ToLower()))
                            {
                                break;
                            }
                            else
                            {
                                // do your stuff

                                //bool sucessfullyDisabledWow64Redirect = false;

                                //string path = Path.Combine(dir, "osk.exe");



                                /*Process proc = new Process();
                                proc.StartInfo.FileName = windowsKeyboard + ".exe";
                                proc.Start();*/

                                ProcessStartInfo psi = new ProcessStartInfo();
                                //psi.FileName = OnScreenKeyboardExe;// path64;
                                string windir = Environment.GetEnvironmentVariable("windir");
                                psi.WorkingDirectory = @"c:\WINDOWS\system32\";
                                psi.FileName = windir + @"\System32\cmd.exe";
                                psi.Arguments = "/C " + windir + @"\System32\osk.exe";


                                psi.UseShellExecute = false;
                                psi.RedirectStandardOutput = true;
                                psi.RedirectStandardError = true;
                                psi.CreateNoWindow = false;
                                psi.Verb = "runas";

                                //Process p = System.Diagnostics.Process.Start(path);
                                Process proc = new Process();
                                proc.StartInfo = psi;
                                proc.Start();

                                bool sucessfullyDisabledWow64Redirect = false;
                                if (System.Environment.Is64BitOperatingSystem)
                                {
                                    IntPtr ptr = new IntPtr();
                                    sucessfullyDisabledWow64Redirect = Wow64DisableWow64FsRedirection(ref ptr);
                                    path = string.Empty;
                                }



                                //Process proc = new Process();
                                //proc.StartInfo = psi;
                                //proc.Start();





                                break;
                            }
                        }












                        //MainWindow.MessageBox((IntPtr)0, "fuck you", "sccs message", 0);
                        /*string windowsKeyboard = "osk";

                        foreach (Process clsProcess in Process.GetProcesses())
                        {
                            if (clsProcess.ProcessName.ToLower().Contains(windowsKeyboard.ToLower()))
                            {
                                break;
                            }
                            else
                            {
                                Process proc = new Process();
                                proc.StartInfo.FileName = windowsKeyboard + ".exe";
                                proc.Start();
                                break;
                            }
                        }*/
                        //hasClickedBUTTONX = 1;
                    }
                }
                else if (buttonPressedOculusTouchLeft == 0 && hasClickedHomeButtonTouchLeft == 1 || buttonPressedOculusTouchLeft == 0 && hasClickedBUTTONX == 1)
                {
                    if (buttonPressedOculusTouchLeft == 0 && hasClickedHomeButtonTouchLeft == 1)
                    {
                        hasClickedHomeButtonTouchLeft = 0;
                    }
                    else if (buttonPressedOculusTouchLeft == 0 && hasClickedBUTTONX == 1)
                    {
                        hasClickedBUTTONX = 0;
                    }

                }



                /*if (buttonPressedOculusTouchLeft != 0)
                {
                    var yo = _updateFunctionStopwatchLeftThumbstick.Elapsed.Ticks;

                    if (yo >= 100)
                    {
                        if (buttonPressedOculusTouchLeft == 1024)
                        {

                            _updateFunctionBoolLeftThumbStick = true;
                        }
                    }
                }*/
            }

        }

        /*
        static string getOskPath(string dir)
        {
            //ShowKeyboard


            var permissionSet = new PermissionSet(PermissionState.Unrestricted);
            var writePermission = new FileIOPermission(FileIOPermissionAccess.Read, dir); //write
            permissionSet.AddPermission(writePermission);

            if (permissionSet.IsSubsetOf(AppDomain.CurrentDomain.PermissionSet))
            {
                // do your stuff
                IntPtr ptr = new IntPtr(); ;
                bool sucessfullyDisabledWow64Redirect = false;

                string path = Path.Combine(dir, "osk.exe");
                if (File.Exists(path))
                {
                    Process p = System.Diagnostics.Process.Start(path);
                    if (System.Environment.Is64BitOperatingSystem)
                    {
                        sucessfullyDisabledWow64Redirect = Wow64DisableWow64FsRedirection(ref ptr);
                        path = string.Empty;
                    }

                    /*if (p.IsWin64Emulator())
                    {
                        path = string.Empty;
                    }
                    p.Kill();
                    return path;
                }
                DirectoryInfo di = new DirectoryInfo(dir);
                foreach (DirectoryInfo subDir in di.GetDirectories().Reverse())
                {
                    path = getOskPath(Path.Combine(dir, subDir.Name));
                    if (!string.IsNullOrWhiteSpace(path))
                    {
                        return path;
                    }
                }
            }
            else
            {
                // alternative stuff
                return string.Empty;
            }

            return string.Empty;
        }*/






        uint lastbuttonPressedOculusTouchRight = 0;
        uint lastbuttonPressedOculusTouchLeft = 0;
        public int _indexMouseMove = 0;
        bool restartFrameCounterRight = false;

        int hasClickedHomeButtonTouchLeft = 0;
        int hasClickedHomeButtonTouchLeftCounter = 0;

        bool isHoldingBUTTONA = false;
        bool hasClickedBUTTONB = false;
        int hasClickedBUTTONX = 0;
        int hasClickedBUTTONY = 0;
        bool restartFrameCounterLeft = false;

        private void _MicrosoftWindowsMouseRight(double percentXRight, double percentYRight, Vector2f[] thumbStickRight, double percentXLeft, double percentYLeft, Vector2f[] thumbStickLeft, double realMousePosX, double realMousePosY) //, double realOculusRiftCursorPosX, double realOculusRiftCursorPosY
        {
            try
            {
                //MessageBox((IntPtr)0, "percentXRight: " + percentXRight + " percentYRight: " + percentYRight, "mouse move", 0);
                //Console.WriteLine("percentXRight: " + percentXRight + " percentYRight: " + percentYRight);

                if (_indexMouseMove == 0)
                {
                    //MessageBox((IntPtr)0, "test0", "mouse move", 0);
                    /////////////RIGHT OCULUS TOUCH/////////////////////////////////////////////////////////////////////////////////////
                    if (percentXRight >= 0 && percentXRight <= SC_console_directx.D3D.SurfaceWidth && percentYRight >= 0 && percentYRight <= SC_console_directx.D3D.SurfaceHeight &&
                        realMousePosX >= 0 && realMousePosX <= SC_console_directx.D3D.SurfaceWidth && realMousePosY >= 0 && realMousePosY <= SC_console_directx.D3D.SurfaceHeight)
                    {
                        //MessageBox((IntPtr)0, "test1", "mouse move", 0);

                        //var absoluteMoveX = Convert.ToUInt32((percentXRight * 65535) / SC_console_directx.D3D.SurfaceWidth);
                        //var absoluteMoveY = Convert.ToUInt32((percentYRight * 65535) / SC_console_directx.D3D.SurfaceHeight);

                        var yo = _updateFunctionStopwatchRight.Elapsed.Ticks;

                        if (_hasLockedMouse == 0)
                        {
                            if (yo >= 250)
                            {
                                var absoluteMoveX = Convert.ToUInt32((realMousePosX * (65535 - 1)) / SC_console_directx.D3D.SurfaceWidth);
                                var absoluteMoveY = Convert.ToUInt32((realMousePosY * (65535 - 1)) / SC_console_directx.D3D.SurfaceHeight);

                                if (realMousePosX >= 0 && realMousePosX < SC_console_directx.D3D.SurfaceWidth)
                                {

                                }
                                else
                                {
                                    realMousePosX = SC_console_directx.D3D.SurfaceWidth;
                                    absoluteMoveX = Convert.ToUInt32((realMousePosX * (65535 - 1)) / SC_console_directx.D3D.SurfaceWidth);
                                }

                                if (realMousePosY >= 0 && realMousePosY < SC_console_directx.D3D.SurfaceHeight)
                                {

                                }
                                else
                                {
                                    realMousePosY = SC_console_directx.D3D.SurfaceHeight;
                                    absoluteMoveY = Convert.ToUInt32((realMousePosY * (65535 - 1)) / SC_console_directx.D3D.SurfaceHeight);
                                }


                                //mouse_event(MOUSEEVENTF_MOVE | MOUSEEVENTF_ABSOLUTE, absoluteMoveX, absoluteMoveY, 0, 0);
                                if (_frameCounterTouchRight <= 20)
                                {
                                    SetCursorPos((int)realMousePosX, (int)realMousePosY);
                                    //mouse_event(MOUSEEVENTF_MOVE | MOUSEEVENTF_ABSOLUTE, _lastMousePosXRight, _lastMousePosYRight, 0, 0);
                                    _frameCounterTouchRight = 0;
                                }

                                _updateFunctionStopwatchRight.Stop();
                                _updateFunctionBoolRight = true;
                            }
                        }

                        //Console.WriteLine(percentXRight + "_" + percentYRight);
                        //MessageBox((IntPtr)0,  "test", "mouse move", 0);
                        //MOUSE DOUBLE CLICK LOGIC. IF the PLAYER clicked at one location then it stores the location, and if the player re-clicks inside of 20 frames, then click at the first click location.
                        //It's very basic, and at least I should implement also a certain "radius" of distance from the first click and the second click... If the second click is too far from the first click,
                        //then disregard the first click location.

                        if (buttonPressedOculusTouchRight != 0)
                        {
                            if (buttonPressedOculusTouchRight == 1)
                            {
                                if (hasClickedBUTTONA == 0)
                                {
                                    var absoluteMoveX = Convert.ToUInt32((realMousePosX * (65535)) / SC_console_directx.D3D.SurfaceWidth);
                                    var absoluteMoveY = Convert.ToUInt32((realMousePosY * (65535)) / SC_console_directx.D3D.SurfaceHeight);

                                    if (realMousePosX >= 0 && realMousePosX < SC_console_directx.D3D.SurfaceWidth)
                                    {

                                    }
                                    else
                                    {
                                        realMousePosX = SC_console_directx.D3D.SurfaceWidth;
                                        absoluteMoveX = Convert.ToUInt32((realMousePosX * (65535)) / SC_console_directx.D3D.SurfaceWidth);
                                    }

                                    if (realMousePosY >= 0 && realMousePosY < SC_console_directx.D3D.SurfaceHeight)
                                    {

                                    }
                                    else
                                    {
                                        realMousePosY = SC_console_directx.D3D.SurfaceHeight;
                                        absoluteMoveY = Convert.ToUInt32((realMousePosY * (65535)) / SC_console_directx.D3D.SurfaceHeight);
                                    }


                                    if (_frameCounterTouchRight <= 20 && _canResetCounterTouchRightButtonA == true)
                                    {
                                        SetCursorPos((int)realMousePosX, (int)realMousePosY);
                                        //mouse_event(MOUSEEVENTF_MOVE | MOUSEEVENTF_ABSOLUTE, _lastMousePosXRight, _lastMousePosYRight, 0, 0);
                                        _frameCounterTouchRight = 0;
                                    }

                                    //mouse_event(MOUSEEVENTF_LEFTDOWN, 0, 0, 0, 0); //| MOUSEEVENTF_ABSOLUTE

                                    MainWindow.mousesim.LeftButtonDown();

                                    _lastMousePosXRight = absoluteMoveX;
                                    _lastMousePosYRight = absoluteMoveY;

                                    _canResetCounterTouchRightButtonA = true;
                                    hasClickedBUTTONA = 1;
                                }
                            }
                            else if (buttonPressedOculusTouchRight == 2)
                            {
                                if (hasClickedBUTTONB == false)
                                {
                                    var absoluteMoveX = Convert.ToUInt32((realMousePosX * (65535)) / SC_console_directx.D3D.SurfaceWidth);
                                    var absoluteMoveY = Convert.ToUInt32((realMousePosY * (65535)) / SC_console_directx.D3D.SurfaceHeight);

                                    if (realMousePosX >= 0 && realMousePosX < SC_console_directx.D3D.SurfaceWidth)
                                    {

                                    }
                                    else
                                    {
                                        realMousePosX = SC_console_directx.D3D.SurfaceWidth;
                                        absoluteMoveX = Convert.ToUInt32((realMousePosX * (65535)) / SC_console_directx.D3D.SurfaceWidth);
                                    }

                                    if (realMousePosY >= 0 && realMousePosY < SC_console_directx.D3D.SurfaceHeight)
                                    {

                                    }
                                    else
                                    {
                                        realMousePosY = SC_console_directx.D3D.SurfaceHeight;
                                        absoluteMoveY = Convert.ToUInt32((realMousePosY * (65535)) / SC_console_directx.D3D.SurfaceHeight);

                                    }


                                    //mouse_event(MOUSEEVENTF_RIGHTDOWN, 0, 0, 0, 0);
                                    MainWindow.mousesim.RightButtonDown();
                                    hasClickedBUTTONB = true;
                                }
                            }
                        }
                        _out_of_bounds_right = 0;
                    }
                    else
                    {
                        _out_of_bounds_right = 1;
                    }

                    if (hasClickedBUTTONACounter >= 25)
                    {
                        //////////OCULUS TOUCH BUTTONS PRESSED////////////////////////////////////////
                        if (hasClickedBUTTONA == 1 && buttonPressedOculusTouchRight == 0 || hasClickedBUTTONB && buttonPressedOculusTouchRight == 0)
                        {
                            if (hasClickedBUTTONA == 1 && buttonPressedOculusTouchRight == 0)
                            {
                                //mouse_event(MOUSEEVENTF_LEFTUP, 0, 0, 0, 0);
                                MainWindow.mousesim.LeftButtonUp();
                                hasClickedBUTTONACounter = 0;
                                hasClickedBUTTONA = 0;
                            }
                            else if (hasClickedBUTTONB && buttonPressedOculusTouchRight == 0)
                            {
                                //mouse_event(MOUSEEVENTF_RIGHTUP, 0, 0, 0, 0);
                                MainWindow.mousesim.RightButtonUp();
                                hasClickedBUTTONACounter = 0;
                                hasClickedBUTTONB = false;
                            }
                        }
                    }
                    //if (_canResetCounterTouchRightButtonA)
                    //{
                    //  
                    //}
                    _frameCounterTouchRight++;
                    if (_frameCounterTouchRight >= 30)
                    {
                        _frameCounterTouchRight = 0;
                        _canResetCounterTouchRightButtonA = false;
                    }

                    if (_out_of_bounds_oculus_rift == 0)
                    {
                        long test = 80;
                        /////////RIGHT THUMBSTICK///////////
                        var yo6 = _updateFunctionStopwatchRightThumbstickGoLeft.Elapsed.Milliseconds;
                        if (yo6 >= 75)
                        {
                            /*if (thumbStickRight[1].Y <= -0.1f && hasUsedThumbStickRightE == false)
                            {
                                if (test < -0.99)
                                {
                                    test = (long)-0.99;
                                }

                                mouse_event(MOUSEEVENTF_WHEEL, 0, 0, -test, 0);
                                //Console.WriteLine("test");

                                hasUsedThumbStickRightE = true;
                            }
                            else if (hasUsedThumbStickRightE)
                            {
                                hasUsedThumbStickRightE = false;
                            }*/
                            _updateFunctionStopwatchRightThumbstickGoLeft.Stop();
                            _updateFunctionBoolRightThumbStickGoLeft = true;
                        }
                        ///////////////////////////////////////////////////////////////////////////

                        /////////RIGHT THUMBSTICK/////////////////////////////////////////////////////
                        var yo7 = _updateFunctionStopwatchRightThumbstickGoRight.Elapsed.Milliseconds;
                        if (yo7 >= 75)
                        {
                            /*if (thumbStickRight[1].Y >= 0.1f && hasUsedThumbStickRightQ == false)
                            {
                                if (test > 0.99f)
                                {
                                    test = (long)0.99;
                                }

                                mouse_event(MOUSEEVENTF_WHEEL, 0, 0, test, 0);
                                hasUsedThumbStickRightQ = true;
                            }
                            else if (hasUsedThumbStickRightQ)
                            {
                                hasUsedThumbStickRightQ = false;
                            }*/
                            _updateFunctionStopwatchRightThumbstickGoRight.Stop();
                            _updateFunctionBoolRightThumbStickGoRight = true;
                        }
                    }























                    /*//////////OCULUS TOUCH BUTTONS PRESSED////////////////////////////////////////
                    if (hasClickedBUTTONX == 1 && buttonPressedOculusTouchLeft == 0 || hasClickedBUTTONY == 1 && buttonPressedOculusTouchLeft == 0)
                    {
                        if (hasClickedBUTTONX == 1 && buttonPressedOculusTouchLeft == 0)
                        {
                            //mouse_event(MOUSEEVENTF_LEFTUP, 0, 0, 0, 0);
                            hasClickedBUTTONX = 0;
                        }
                        else if (hasClickedBUTTONY == 1 && buttonPressedOculusTouchLeft == 0)
                        {
                            mouse_event(MOUSEEVENTF_RIGHTUP, 0, 0, 0, 0);
                            hasClickedBUTTONY = 0;
                        }
                    }*/

                    //if (_canResetCounterTouchLeftButtonX)
                    //{
                    //
                    //}



                    //if (buttonPressedOculusTouchLeft == 0 && hasClickedHomeButtonTouchLeft)
                    //{
                    //    hasClickedHomeButtonTouchLeft = false;
                    //}
                }
                else if (_indexMouseMove == 100)
                {
                    /*/////////////LEFT OCULUS TOUCH/////////////////////////////////////////////////////////////////////////////////////
                    if (percentXLeft >= 0 && percentXLeft <= 1920 && percentYLeft >= 0 && percentYLeft <= 1080)
                    {
                        var absoluteMoveX = Convert.ToUInt32((percentXLeft * 65535) / 1920);
                        var absoluteMoveY = Convert.ToUInt32((percentYLeft * 65535) / 1080);

                        var yo = _updateFunctionStopwatchLeft.Elapsed.Milliseconds;

                        if (yo >= 10)
                        {
                            mouse_event(MOUSEEVENTF_MOVE | MOUSEEVENTF_ABSOLUTE, absoluteMoveX, absoluteMoveY, 0, 0);
                            _updateFunctionStopwatchLeft.Stop();
                            _updateFunctionBoolLeft = true;
                        }

                        //MOUSE DOUBLE CLICK LOGIC. IF the PLAYER clicked at one location then it stores the location, and if the player re-clicks inside of 20 frames, then click at the first click location.
                        //It's very basic, and at least I should implement also a certain "radius" of distance from the first click and the second click... If the second click is too far from the first click,
                        //then disregard the first click location.

                        if (buttonPressedOculusTouchLeft != 0)
                        {
                            if (buttonPressedOculusTouchLeft == 256)
                            {
                                if (hasClickedBUTTONX == 0)
                                {
                                    if (_frameCounterTouchLeft <= 20 && _canResetCounterTouchLeftButtonX == true)
                                    {
                                        mouse_event(MOUSEEVENTF_MOVE | MOUSEEVENTF_ABSOLUTE, _lastMousePosXLeft, _lastMousePosYLeft, 0, 0);
                                        _frameCounterTouchLeft = 0;
                                    }

                                    mouse_event(MOUSEEVENTF_LEFTDOWN, 0, 0, 0, 0);

                                    _lastMousePosXLeft = absoluteMoveX;
                                    _lastMousePosYLeft = absoluteMoveY;
                                    _canResetCounterTouchLeftButtonX = true;
                                    hasClickedBUTTONX = 1;
                                }
                            }
                            else if (buttonPressedOculusTouchLeft == 512)
                            {
                                if (hasClickedBUTTONY == 0)
                                {
                                    mouse_event(MOUSEEVENTF_RIGHTDOWN, 0, 0, 0, 0);
                                    //_lastMousePosX = absoluteMoveX;
                                    //_lastMousePosY = absoluteMoveY;
                                    //_canResetCounterTouchRight = true;
                                    hasClickedBUTTONY = 1;
                                }
                            }
                        }
                    }*/

                    /*//////////OCULUS TOUCH BUTTONS PRESSED////////////////////////////////////////
                    if (hasClickedBUTTONX == 1 && buttonPressedOculusTouchLeft == 0 || hasClickedBUTTONY == 1 && buttonPressedOculusTouchLeft == 0)
                    {
                        if (hasClickedBUTTONX == 1 && buttonPressedOculusTouchLeft == 0)
                        {
                            mouse_event(MOUSEEVENTF_LEFTUP, 0, 0, 0, 0);
                            hasClickedBUTTONX = 0;
                        }
                        else if (hasClickedBUTTONY == 1 && buttonPressedOculusTouchLeft == 0)
                        {
                            mouse_event(MOUSEEVENTF_RIGHTUP, 0, 0, 0, 0);
                            hasClickedBUTTONY = 0;
                        }
                    }

                    if (_canResetCounterTouchLeftButtonX)
                    {
                        _frameCounterTouchLeft++;
                    }

                    if (_frameCounterTouchLeft >= 30)
                    {
                        _frameCounterTouchLeft = 0;
                        _canResetCounterTouchLeftButtonX = false;
                    }*/

                    /////////////RIGHT OCULUS TOUCH/////////////////////////////////////////////////////////////////////////////////////
                    if (percentXRight >= 0 && percentXRight <= SC_console_directx.D3D.SurfaceWidth && percentYRight >= 0 && percentYRight <= SC_console_directx.D3D.SurfaceHeight)
                    {
                        var absoluteMoveX = Convert.ToUInt32((percentXRight * 65535) / SC_console_directx.D3D.SurfaceWidth);
                        var absoluteMoveY = Convert.ToUInt32((percentYRight * 65535) / SC_console_directx.D3D.SurfaceHeight);

                        /*var yo = _updateFunctionStopwatchRight.Elapsed.Milliseconds;

                        if (yo >= 10)
                        {
                            //mouse_event(MOUSEEVENTF_MOVE | MOUSEEVENTF_ABSOLUTE, absoluteMoveX, absoluteMoveY, 0, 0);
                            _updateFunctionStopwatchRight.Stop();
                            _updateFunctionBoolRight = true;
                        }*/

                        //MOUSE DOUBLE CLICK LOGIC. IF the PLAYER clicked at one location then it stores the location, and if the player re-clicks inside of 20 frames, then click at the first click location.
                        //It's very basic, and at least I should implement also a certain "radius" of distance from the first click and the second click... If the second click is too far from the first click,
                        //then disregard the first click location.
                        if (buttonPressedOculusTouchRight != 0)
                        {
                            if (buttonPressedOculusTouchRight == 1)
                            {
                                if (hasClickedBUTTONA == 0)
                                {
                                    /*if (_frameCounterTouchRight <= 20 && _canResetCounterTouchRightButtonA == true)
                                    {
                                        mouse_event(MOUSEEVENTF_MOVE | MOUSEEVENTF_ABSOLUTE, _lastMousePosXRight, _lastMousePosYRight, 0, 0);
                                        _frameCounterTouchRight = 0;
                                    }*/

                                    //mouse_event(MOUSEEVENTF_MOVE | MOUSEEVENTF_ABSOLUTE, absoluteMoveX, absoluteMoveY, 0, 0);
                                    //mouse_event(MOUSEEVENTF_LEFTDOWN | MOUSEEVENTF_LEFTUP, absoluteMoveX, absoluteMoveY, 0, 0);

                                    SetCursorPos((int)absoluteMoveX, (int)absoluteMoveY);


                                    MainWindow.mousesim.LeftButtonDown();
                                    MainWindow.mousesim.LeftButtonUp();

                                    _lastMousePosXRight = absoluteMoveX;
                                    _lastMousePosYRight = absoluteMoveY;
                                    _canResetCounterTouchRightButtonA = true;
                                    hasClickedBUTTONA = 1;
                                }
                            }
                            else if (buttonPressedOculusTouchRight == 2)
                            {
                                if (hasClickedBUTTONB == false)
                                {
                                    //mouse_event(MOUSEEVENTF_RIGHTDOWN, 0, 0, 0, 0);
                                    MainWindow.mousesim.RightButtonDown();
                                    hasClickedBUTTONB = true;
                                }
                            }
                        }
                    }

                    //////////OCULUS TOUCH BUTTONS PRESSED////////////////////////////////////////
                    if (hasClickedBUTTONA == 1 && buttonPressedOculusTouchRight == 0 || hasClickedBUTTONB && buttonPressedOculusTouchRight == 0)
                    {
                        if (hasClickedBUTTONA == 1 && buttonPressedOculusTouchRight == 0)
                        {
                            //mouse_event(MOUSEEVENTF_LEFTUP, 0, 0, 0, 0);
                            hasClickedBUTTONA = 0;
                        }
                        else if (hasClickedBUTTONB && buttonPressedOculusTouchRight == 0)
                        {
                            //mouse_event(MOUSEEVENTF_RIGHTUP, 0, 0, 0, 0);
                            MainWindow.mousesim.RightButtonUp();
                            hasClickedBUTTONB = false;
                        }
                    }

                    if (_canResetCounterTouchRightButtonA)
                    {
                        _frameCounterTouchRight++;
                    }

                    if (_frameCounterTouchRight >= 30)
                    {
                        _frameCounterTouchRight = 0;
                        _canResetCounterTouchRightButtonA = false;
                    }


                    /*//////////OCULUS TOUCH BUTTONS NOT PRESSED////////////////////////////////////////
                    long test = 80;
                    /////////RIGHT THUMBSTICK///////////
                    var yo6 = _updateFunctionStopwatchRightThumbstickGoLeft.Elapsed.Milliseconds;
                    if (yo6 >= 75)
                    {
                        if (thumbStickRight[1].Y <= -0.1f && hasUsedThumbStickRightE == false)
                        {
                            //Console.WriteLine("test");
                            mouse_event(MOUSEEVENTF_WHEEL, 0, 0, -test, 0);
                            hasUsedThumbStickRightE = true;
                        }
                        else if (hasUsedThumbStickRightE)
                        {
                            hasUsedThumbStickRightE = false;
                        }
                        _updateFunctionStopwatchRightThumbstickGoLeft.Stop();
                        _updateFunctionBoolRightThumbStickGoLeft = true;
                    }
                    ///////////////////////////////////////////////////////////////////////////

                    /////////RIGHT THUMBSTICK/////////////////////////////////////////////////////
                    var yo7 = _updateFunctionStopwatchRightThumbstickGoRight.Elapsed.Milliseconds;
                    if (yo7 >= 75)
                    {
                        if (thumbStickRight[1].Y >= 0.1f && hasUsedThumbStickRightQ == false)
                        {
                            mouse_event(MOUSEEVENTF_WHEEL, 0, 0, test, 0);
                            //hasUsedThumbStickRightQ = true;
                        }
                        else if (hasUsedThumbStickRightQ)
                        {
                            hasUsedThumbStickRightQ = false;
                        }
                        _updateFunctionStopwatchRightThumbstickGoRight.Stop();
                        _updateFunctionBoolRightThumbStickGoRight = true;
                    }*/
                    /////////////RIGHT OCULUS TOUCH////////////////////////////////////////////
                }
            }
            catch (Exception ex)
            {
                //MessageBox((IntPtr)0, ex.ToString(), "mouse move", 0);
            }











            hasClickedBUTTONACounter++;
        }

        int hasClickedBUTTONA = 0;
        int hasClickedBUTTONACounter = 0;

        bool _startOnce02 = true;
        bool _updateFunctionBoolRight = true;
        bool _updateFunctionBoolLeft = true;
        bool _updateFunctionBoolLeftThumbStickGoLeft = true;
        bool _updateFunctionBoolLeftThumbStickGoRight = true;
        bool _updateFunctionBoolRightThumbStickGoLeft = true;
        bool _updateFunctionBoolRightThumbStickGoRight = true;
        bool _updateFunctionBoolLeftHandTrigger = true;
        bool _updateFunctionBoolRightHandTrigger = true;
        bool _updateFunctionBoolLeftIndexTrigger = true;
        bool _updateFunctionBoolRightIndexTrigger = true;
        bool _updateFunctionBoolTouchRightButtonA = true;
        bool _updateFunctionBoolLeftThumbStick = true;
        int _frameCounterTouchRight = 0;

        Plane planer;

        Vector3 centerPosRight;
        SharpDX.Ray someRay;
        Vector3 intersectPointRight;
        bool intersecter;

        Vector3 centerPosLeft;
        Vector3 rayDirLeft;
        SharpDX.Ray someRayLeft;
        Vector3 intersectPointLeft;
        bool intersecterLeft;
        Vector3 stabilizedIntersectionPosLeft;
        Vector3 stabilizedIntersectionPosRight;



        int currentFrameLeft = 0;
        int currentFrameRight = 0;
        double averageXRight = 0;
        double averageYRight = 0;
        double averageZRight = 0;
        double lastRightHitPointXFrameOne = 0;
        double lastRightHitPointYFrameOne = 0;
        double lastRightHitPointZFrameOne = 0;
        double positionXRight = 0;
        double positionYRight = 0;
        double positionZRight = 0;
        double averageXLeft = 0;
        double averageYLeft = 0;
        double averageZLeft = 0;
        double lastLeftHitPointXFrameOne = 0;
        double lastLeftHitPointYFrameOne = 0;
        double lastLeftHitPointZFrameOne = 0;
        double positionXLeft = 0;
        double positionYLeft = 0;
        double positionZLeft = 0;
        double differenceX = 0;
        double differenceY = 0;
        double differenceZ = 0;
        double percentXLeft;
        double percentYLeft;

        float widthLength;
        float heightLength;
        double currentPosWidth;
        double currentPosHeight;

        double percentXRight;
        double percentYRight;

        double currentX;
        double currentY;
        double currentZ;

        int _has_init_ray;
        JMatrix _last_frame_rigid_grab_rot;
        Vector3 _last_frame_rigid_grab_pos;
        Vector3 _last_frame_handPos = Vector3.Zero;
        Vector3 _last_final_hand_pos_right;


        //HERE IS THE MOUSE STABILIZER ARRAYS - THE BIGGER THE ARRAYS THE SLOWER AND MORE STABLE THE MOUSE IS ON THE SCREEN.
        Vector3[] arrayOfStabilizerPosRight = new Vector3[_MaxArraySize0];
        double[] arrayOfStabilizerPosXRight = new double[_MaxArraySize0];
        double[] arrayOfStabilizerPosDifferenceXRight = new double[_MaxArraySize1];
        double[] arrayOfStabilizerPosYRight = new double[_MaxArraySize0];
        double[] arrayOfStabilizerPosDifferenceYRight = new double[_MaxArraySize1];

        double[] arrayOfStabilizerPosZRight = new double[_MaxArraySize0];
        double[] arrayOfStabilizerPosDifferenceZRight = new double[_MaxArraySize1];



        Vector3[] arrayOfStabilizerPosLeft = new Vector3[_MaxArraySize0];
        double[] arrayOfStabilizerPosXLeft = new double[_MaxArraySize0];
        double[] arrayOfStabilizerPosDifferenceXLeft = new double[_MaxArraySize1];
        double[] arrayOfStabilizerPosYLeft = new double[_MaxArraySize0];
        double[] arrayOfStabilizerPosDifferenceYLeft = new double[_MaxArraySize1];

        double[] arrayOfStabilizerPosZLeft = new double[_MaxArraySize0];
        double[] arrayOfStabilizerPosDifferenceZLeft = new double[_MaxArraySize1];

        //
        Vector3[] _arrayOfStabilizerPosRight = new Vector3[_MaxArraySize0];
        double[] _arrayOfStabilizerPosXRight = new double[_MaxArraySize0];
        double[] _arrayOfStabilizerPosDifferenceXRight = new double[_MaxArraySize1];
        double[] _arrayOfStabilizerPosYRight = new double[_MaxArraySize0];
        double[] _arrayOfStabilizerPosDifferenceYRight = new double[_MaxArraySize1];

        Vector3[] _arrayOfStabilizerPosLeft = new Vector3[_MaxArraySize0];
        double[] _arrayOfStabilizerPosXLeft = new double[_MaxArraySize0];
        double[] _arrayOfStabilizerPosDifferenceXLeft = new double[_MaxArraySize1];
        double[] _arrayOfStabilizerPosYLeft = new double[_MaxArraySize0];
        double[] _arrayOfStabilizerPosDifferenceYLeft = new double[_MaxArraySize1];

        int _hasLockedMouse = 0;

        public const int KEY_W = 0x57;
        public const int KEY_A = 0x41;
        public const int KEY_S = 0x53;
        public const int KEY_D = 0x44;
        public const int KEY_SPACE = 0x20; //0x39
        public const int KEY_E = 0x45;
        public const int KEY_Q = 0x51;

        public const int KEYEVENTF_KEYUP = 0x0002;
        public const int KEYEVENTF_EXTENDEDKEY = 0x0001;

        const uint MOUSEEVENTF_ABSOLUTE = 0x8000;
        const uint MOUSEEVENTF_LEFTDOWN = 0x0002;
        const uint MOUSEEVENTF_LEFTUP = 0x0004;
        const uint MOUSEEVENTF_MIDDLEDOWN = 0x0020;
        const uint MOUSEEVENTF_MIDDLEUP = 0x0040;
        const uint MOUSEEVENTF_MOVE = 0x0001;
        const uint MOUSEEVENTF_RIGHTDOWN = 0x0008;
        const uint MOUSEEVENTF_RIGHTUP = 0x0010;
        const uint MOUSEEVENTF_XDOWN = 0x0080;
        const uint MOUSEEVENTF_XUP = 0x0100;
        const uint MOUSEEVENTF_WHEEL = 0x0800;
        const uint MOUSEEVENTF_HWHEEL = 0x01000;
        [DllImport("user32.dll", CharSet = CharSet.Auto, CallingConvention = CallingConvention.StdCall, EntryPoint = "mouse_event")]
        public static extern void mouse_event(uint dwFlags, uint dx, uint dy, long dwData, uint dwExtraInfo);
        [DllImport("user32.dll", CharSet = CharSet.Auto)]
        static extern IntPtr SendMessage(IntPtr hWnd,
                                 UInt32 Msg,
                                 IntPtr wParam,
                                 IntPtr lParam);
        [DllImport("User32.dll")]
        private static extern bool SetCursorPos(int X, int Y);


        [DllImport("kernel32.dll", SetLastError = true)]
        private static extern bool Wow64DisableWow64FsRedirection(ref IntPtr ptr);
        [DllImport("kernel32.dll", SetLastError = true)]
        public static extern bool Wow64RevertWow64FsRedirection(IntPtr ptr);
        private const UInt32 WM_SYSCOMMAND = 0x112;
        private const UInt32 SC_RESTORE = 0xf120;

        private const string OnScreenKeyboardExe = "osk.exe";

        private void ShowKeyboard()
        {
            var path64 = @"c:\windows\sysnative\osk.exe"; //@"C:\Windows\winsxs\amd64_microsoft-windows-osk_31bf3856ad364e35_6.1.7600.16385_none_06b1c513739fb828\osk.exe";
            var path32 = @"c:\windows\sysnative\osk.exe";// @"C:\windows\system32\osk.exe"; 

            var path = (Environment.Is64BitOperatingSystem) ? path64 : path32;
            Process.Start(path);
        }
        void StartOsk()
        {
            IntPtr ptr = new IntPtr(); ;
            bool sucessfullyDisabledWow64Redirect = false;

            // Disable x64 directory virtualization if we're on x64,
            // otherwise keyboard launch will fail.
            if (System.Environment.Is64BitOperatingSystem)
            {
                sucessfullyDisabledWow64Redirect = Wow64DisableWow64FsRedirection(ref ptr);
            }





            /*var path64 = @"c:\windows\sysnative\osk.exe"; //@"C:\Windows\winsxs\amd64_microsoft-windows-osk_31bf3856ad364e35_6.1.7600.16385_none_06b1c513739fb828\osk.exe";
            var path32 = @"c:\windows\sysnative\osk.exe";// @"C:\windows\system32\osk.exe"; 
            var path = (Environment.Is64BitOperatingSystem) ? path64 : path32;
            */

            ProcessStartInfo psi = new ProcessStartInfo();
            //psi.FileName = OnScreenKeyboardExe;// path64;
            string windir = Environment.GetEnvironmentVariable("windir");
            psi.WorkingDirectory = @"c:\WINDOWS\system32\";
            psi.FileName = windir + @"\System32\cmd.exe";
            psi.Arguments = "/C " + windir + @"\System32\osk.exe";



            // We must use ShellExecute to start osk from the current thread
            // with psi.UseShellExecute = false the CreateProcessWithLogon API 
            // would be used which handles process creation on a separate thread 
            // where the above call to Wow64DisableWow64FsRedirection would not 
            // have any effect.

            psi.UseShellExecute = true;
            psi.RedirectStandardOutput = true;
            psi.RedirectStandardError = true;
            psi.CreateNoWindow = true;



            psi.Verb = "runas";

            Process.Start(psi);

            /*// Re-enable directory virtualisation if it was disabled.
            if (System.Environment.Is64BitOperatingSystem)
                if (sucessfullyDisabledWow64Redirect)
                    Wow64RevertWow64FsRedirection(ptr);*/
        }










        SharpDX.Matrix _mouseCursorMatrix = SharpDX.Matrix.Identity;
        int _out_of_bounds_oculus_rift = 0;
        int _out_of_bounds_right = 0;
        int _out_of_bounds_left = 0;
        uint _lastMousePosXRight = 9999;
        uint _lastMousePosYRight = 9999;



        float _delta_timer_frame = 0;
        float _delta_timer_time = 0;
        DateTime time1;
        DateTime time2;
        float deltaTime;
        Stopwatch timeStopWatch00 = new Stopwatch();
        Stopwatch timeStopWatch01 = new Stopwatch();
        int _swtch = 0;
        int _swtch_counter_00 = 0;
        int _swtch_counter_01 = 0;
        int _swtch_counter_02 = 0;
        public async Task DoWork(int timeOut)
        {
            float startTime = (float)(timeStopWatch00.ElapsedMilliseconds);
        _threadLoop:

            if (_swtch == 0 || _swtch == 1)
            {
                if (_swtch == 0)
                {
                    if (_swtch_counter_00 >= 0)
                    {
                        ////////////////////
                        //UPGRADED DELTATIME
                        ////////////////////
                        //IMPORTANT PHYSICS TIME 
                        timeStopWatch00.Start();
                        time1 = DateTime.Now;
                        ////////////////////
                        //UPGRADED DELTATIME
                        ////////////////////
                        _swtch = 1;
                        _swtch_counter_00 = 0;
                    }
                }
                else if (_swtch == 1)
                {
                    if (_swtch_counter_01 >= 0)
                    {
                        ////////////////////
                        //UPGRADED DELTATIME
                        ////////////////////
                        timeStopWatch01.Start();
                        time2 = DateTime.Now;
                        ////////////////////
                        //UPGRADED DELTATIME
                        ////////////////////
                        _swtch = 2;
                        _swtch_counter_01 = 0;
                    }
                }
                else if (_swtch == 2)
                {

                }
            }

            /*//FRAME DELTATIME
            _delta_timer_frame = (float)Math.Abs((timeStopWatch01.Elapsed.Ticks - timeStopWatch00.Elapsed.Ticks)) * 100000000f;

            time2 = DateTime.Now;
            _delta_timer_time = (time2.Ticks - time1.Ticks) * 100000000f; //100000000f
            //time1 = time2;

            deltaTime = (float)Math.Abs(_delta_timer_time - _delta_timer_frame);
            */

            //FRAME DELTATIME
            _delta_timer_frame = (float)Math.Abs((timeStopWatch01.Elapsed.Ticks - timeStopWatch00.Elapsed.Ticks));

            time2 = DateTime.Now;
            _delta_timer_time = (time2.Ticks - time1.Ticks); //100000000f
            //time1 = time2;

            deltaTime = (float)Math.Abs(_delta_timer_frame - _delta_timer_time);

            //time1 = time2;
            await Task.Delay(1);
            Thread.Sleep(timeOut);
            _swtch_counter_00++;
            _swtch_counter_01++;
            _swtch_counter_02++;

            goto _threadLoop;
        }


    }
}





/*
Vector3 current_handposR = new Vector3(_player_rght_hnd[0][0]._arrayOfInstances[0].current_pos.M41, _player_rght_hnd[0][0]._arrayOfInstances[0].current_pos.M42, _player_rght_hnd[0][0]._arrayOfInstances[0].current_pos.M43);

Matrix tempmatter = _player_rght_hnd[0][0]._arrayOfInstances[0].current_pos;
Quaternion quater;
Quaternion.RotationMatrix(ref tempmatter, out quater);

var rayDirForward = sc_maths._getDirection(SharpDX.Vector3.ForwardRH, quater);
rayDirForward.Normalize();
var rayDirUp = sc_maths._getDirection(SharpDX.Vector3.Up, quater);
rayDirUp.Normalize();
var rayDirRight = sc_maths._getDirection(SharpDX.Vector3.Right, quater);
rayDirRight.Normalize();

Vector3 movingPointer = current_handposR + (-rayDirForward * _grab_rigid_data.dirDiffZ);
movingPointer = movingPointer + (rayDirRight * _grab_rigid_data.dirDiffX);
//movingPointer = movingPointer + (-rayDirUp * _grab_rigid_data.dirDiffY);

Matrix tempMat = _grab_rigid_data.position;// translationMatrix;
tempMat.M41 = 0;
tempMat.M42 = 0;
tempMat.M43 = 0;
tempMat.M44 = 1;

Quaternion.RotationMatrix(ref tempmatter, out quater);
JQuaternion _other_quatter = new JQuaternion(quater.X, quater.Y, quater.Z, quater.W);

Matrix anothertempmat = _player_rght_hnd[0][0]._arrayOfInstances[0].current_pos;
anothertempmat.M41 = 0;
anothertempmat.M42 = 0;
anothertempmat.M43 = 0;
anothertempmat.M44 = 1;

var xq = _other_quatter.X;
var yq = _other_quatter.Y;
var zq = _other_quatter.Z;
var wq = _other_quatter.W;

var pitcha = (float)Math.Atan2(2 * yq * wq - 2 * xq * zq, 1 - 2 * yq * yq - 2 * zq * zq);
var yawa = (float)Math.Atan2(2 * yq * wq - 2 * xq * zq, 1 - 2 * yq * yq - 2 * zq * zq);
var rolla = (float)Math.Atan2(2 * yq * wq - 2 * xq * zq, 1 - 2 * yq * yq - 2 * zq * zq);

double currentGrabrotDiffX = (pitcha - grabrotX);
double currentGrabrotDiffY = (yawa - grabrotY);
double currentGrabrotDiffZ =  (rolla - grabrotZ);

tempMatrix = SharpDX.Matrix.RotationYawPitchRoll((float)currentGrabrotDiffY, (float)currentGrabrotDiffX, (float)currentGrabrotDiffZ);

//_grab_rigid_data.position.Invert();

tempMatrix = _grab_rigid_data.position;// tempMatrix * _grab_rigid_data.position;


tempMatrix.M41 = movingPointer.X;
tempMatrix.M42 = movingPointer.Y;
tempMatrix.M43 = movingPointer.Z;

//anothertempmat.Invert();
//Matrix addMat = _grab_rigid_data.position;
//Matrix addresultMat;
//Matrix.Add(ref anothertempmat, ref addMat, out addresultMat);

Quaternion.RotationMatrix(ref tempMatrix, out quater);
body.Position = new JVector(movingPointer.X, movingPointer.Y, movingPointer.Z);
JQuaternion _other_quat = new JQuaternion(quater.X, quater.Y, quater.Z, quater.W);
var matrixIn = JMatrix.CreateFromQuaternion(_other_quat);
body.Orientation = matrixIn;*/





















/*
Matrix grabbedBodyMatrix = _grab_rigid_data.position;

var MOVINGPOINTER = new Vector3(_player_torso[0][0]._arrayOfInstances[0]._ORIGINPOSITION.M41, _player_torso[0][0]._arrayOfInstances[0]._ORIGINPOSITION.M42, _player_torso[0][0]._arrayOfInstances[0]._ORIGINPOSITION.M43);
Matrix someMatRight = _rightTouchMatrix;
someMatRight.M41 = handPoseRight.Position.X + MOVINGPOINTER.X;
someMatRight.M42 = handPoseRight.Position.Y;// + MOVINGPOINTER.Y;
someMatRight.M43 = handPoseRight.Position.Z + MOVINGPOINTER.Z;
var diffNormPosX = (MOVINGPOINTER.X) - someMatRight.M41;
var diffNormPosY = (MOVINGPOINTER.Y) - someMatRight.M42;
var diffNormPosZ = (MOVINGPOINTER.Z) - someMatRight.M43;
MOVINGPOINTER = MOVINGPOINTER + -(current_rotation_of_torso_pivot_right* (diffNormPosX));
MOVINGPOINTER = MOVINGPOINTER + -(current_rotation_of_torso_pivot_up* (diffNormPosY));
MOVINGPOINTER = MOVINGPOINTER + (current_rotation_of_torso_pivot_forward* (diffNormPosZ));
Matrix finalHRMat = _rightTouchMatrix * OriginRot * RotatingMatrix * RotatingMatrixForPelvis;// ; //finalRotationMatrix
MOVINGPOINTER.X += SC_Update.OFFSETPOS.X;
MOVINGPOINTER.Y += SC_Update.OFFSETPOS.Y;
MOVINGPOINTER.Z += SC_Update.OFFSETPOS.Z;
Matrix handMatrix = _rightTouchMatrix;// _rightTouchMatrix * OriginRot * RotatingMatrix * RotatingMatrixForPelvis;
Quaternion quater;
Quaternion.RotationMatrix(ref handMatrix, out quater);
var xq = quater.X;
var yq = quater.Y;
var zq = quater.Z;
var wq = quater.W;
var pitchaHand = (float)Math.Atan2(2 * yq * wq - 2 * xq * zq, 1 - 2 * yq * yq - 2 * zq * zq) * (180 / Math.PI);
var yawaHand = (float)Math.Atan2(2 * yq * wq - 2 * xq * zq, 1 - 2 * yq * yq - 2 * zq * zq) * (180 / Math.PI);
var rollaHand = (float)Math.Atan2(2 * yq * wq - 2 * xq * zq, 1 - 2 * yq * yq - 2 * zq * zq) * (180 / Math.PI);
var pitchTouchR = (float)(Math.PI * (grabrotX - pitchaHand) / 180.0f);
var yawTouchR = (float)(Math.PI * (grabrotY - yawaHand) / 180.0f);
var rollTouchR = (float)(Math.PI * (grabrotZ - rollaHand) / 180.0f);
var rotatingMatrixForTouchR = SharpDX.Matrix.RotationYawPitchRoll(yawTouchR, pitchTouchR, rollTouchR);
var pitch = (float)(Math.PI * (SC_Update.RotationGrabbedX) / 180.0f);
var yaw = (float)(Math.PI * (SC_Update.RotationGrabbedY) / 180.0f);
var roll = (float)(Math.PI * (SC_Update.RotationGrabbedZ) / 180.0f);
var rotatingMatrixForGrabber = SharpDX.Matrix.RotationYawPitchRoll(yaw, pitch, roll);
var matrixerer = _player_rght_hnd[0][0]._arrayOfInstances[0].current_pos * grabbedBodyMatrix; //rotatingMatrixForGrabber
matrixerer.M41 = MOVINGPOINTER.X;
matrixerer.M42 = MOVINGPOINTER.Y;
matrixerer.M43 = MOVINGPOINTER.Z;
matrixerer.M44 = 1;
body.Position = new JVector(MOVINGPOINTER.X, MOVINGPOINTER.Y, MOVINGPOINTER.Z);
Quaternion.RotationMatrix(ref matrixerer, out quater);
JQuaternion _other_quat = new JQuaternion(quater.X, quater.Y, quater.Z, quater.W);
var matrixIn = JMatrix.CreateFromQuaternion(_other_quat);
body.Orientation = matrixIn;
*/



/*
Matrix grabbedBodyMatrix = _grab_rigid_data.position;
var MOVINGPOINTER = new Vector3(_player_torso[0][0]._arrayOfInstances[0]._ORIGINPOSITION.M41, _player_torso[0][0]._arrayOfInstances[0]._ORIGINPOSITION.M42, _player_torso[0][0]._arrayOfInstances[0]._ORIGINPOSITION.M43);
Matrix someMatRight = _rightTouchMatrix;
someMatRight.M41 = handPoseRight.Position.X + MOVINGPOINTER.X;
someMatRight.M42 = handPoseRight.Position.Y;// + MOVINGPOINTER.Y;
someMatRight.M43 = handPoseRight.Position.Z + MOVINGPOINTER.Z;
var diffNormPosX = (MOVINGPOINTER.X) - someMatRight.M41;
var diffNormPosY = (MOVINGPOINTER.Y) - someMatRight.M42;
var diffNormPosZ = (MOVINGPOINTER.Z) - someMatRight.M43;
MOVINGPOINTER = MOVINGPOINTER + -(current_rotation_of_torso_pivot_right * (diffNormPosX));
MOVINGPOINTER = MOVINGPOINTER + -(current_rotation_of_torso_pivot_up * (diffNormPosY));
MOVINGPOINTER = MOVINGPOINTER + (current_rotation_of_torso_pivot_forward * (diffNormPosZ));
Matrix finalHRMat = _rightTouchMatrix * OriginRot * RotatingMatrix * RotatingMatrixForPelvis;// ; //finalRotationMatrix
MOVINGPOINTER.X += SC_Update.OFFSETPOS.X;
MOVINGPOINTER.Y += SC_Update.OFFSETPOS.Y;
MOVINGPOINTER.Z += SC_Update.OFFSETPOS.Z;
Matrix handMatrix = _rightTouchMatrix;// _rightTouchMatrix * OriginRot * RotatingMatrix * RotatingMatrixForPelvis;
Quaternion quater;
Quaternion.RotationMatrix(ref handMatrix, out quater);
var xq = quater.X;
var yq = quater.Y;
var zq = quater.Z;
var wq = quater.W;
var pitchaHand = (float)Math.Atan2(2 * yq * wq - 2 * xq * zq, 1 - 2 * yq * yq - 2 * zq * zq) * (180 / Math.PI);
var yawaHand = (float)Math.Atan2(2 * yq * wq - 2 * xq * zq, 1 - 2 * yq * yq - 2 * zq * zq) * (180 / Math.PI);
var rollaHand = (float)Math.Atan2(2 * yq * wq - 2 * xq * zq, 1 - 2 * yq * yq - 2 * zq * zq) * (180 / Math.PI);
var pitchTouchR = (float)(Math.PI * (grabrotX - pitchaHand) / 180.0f);
var yawTouchR = (float)(Math.PI * (grabrotY - yawaHand) / 180.0f);
var rollTouchR = (float)(Math.PI * (grabrotZ - rollaHand) / 180.0f);
var rotatingMatrixForTouchR = SharpDX.Matrix.RotationYawPitchRoll(yawTouchR, pitchTouchR, rollTouchR);
var pitch = (float)(Math.PI * (SC_Update.RotationGrabbedX) / 180.0f);
var yaw = (float)(Math.PI * (SC_Update.RotationGrabbedY) / 180.0f);
var roll = (float)(Math.PI * (SC_Update.RotationGrabbedZ) / 180.0f);
var rotatingMatrixForGrabber = SharpDX.Matrix.RotationYawPitchRoll(yaw, pitch, roll);
var matrixerer = grabbedBodyMatrix * rotatingMatrixForGrabber* _player_rght_hnd[0][0]._arrayOfInstances[0].current_pos; //rotatingMatrixForGrabber //_player_rght_hnd[0][0]._arrayOfInstances[0].current_pos * 
matrixerer.M41 = MOVINGPOINTER.X;
matrixerer.M42 = MOVINGPOINTER.Y;
matrixerer.M43 = MOVINGPOINTER.Z;
matrixerer.M44 = 1;
body.Position = new JVector(MOVINGPOINTER.X, MOVINGPOINTER.Y, MOVINGPOINTER.Z);
Quaternion.RotationMatrix(ref matrixerer, out quater);
JQuaternion _other_quat = new JQuaternion(quater.X, quater.Y, quater.Z, quater.W);
var matrixIn = JMatrix.CreateFromQuaternion(_other_quat);
body.Orientation = matrixIn;*/






/*
Matrix grabbedBodyMatrix = _grab_rigid_data.position;
Matrix handMatrix = _player_r_hand_grab[0][0]._arrayOfInstances[0]._TEMPPOSITION;// _rightTouchMatrix * OriginRot * RotatingMatrix * RotatingMatrixForPelvis * hmdmatrixRot_;
//_player_rght_hnd[0][0]._arrayOfInstances[0]._TEMPPOSITION; 

handMatrix.M41 = 0;
handMatrix.M42 = 0;
handMatrix.M43 = 0;
handMatrix.M44 = 1;

grabbedBodyMatrix.M41 = 0;
grabbedBodyMatrix.M42 = 0;
grabbedBodyMatrix.M43 = 0;
grabbedBodyMatrix.M44 = 1;

finalRotationMatrix.M41 = 0;
finalRotationMatrix.M42 = 0;
finalRotationMatrix.M43 = 0;
finalRotationMatrix.M44 = 1;

var MOVINGPOINTER = new Vector3(_player_torso[0][0]._arrayOfInstances[0]._ORIGINPOSITION.M41, _player_torso[0][0]._arrayOfInstances[0]._ORIGINPOSITION.M42, _player_torso[0][0]._arrayOfInstances[0]._ORIGINPOSITION.M43);
Matrix someMatRight = _rightTouchMatrix;// * OriginRot * RotatingMatrix * RotatingMatrixForPelvis * hmdmatrixRot_;
someMatRight.M41 = handPoseRight.Position.X + MOVINGPOINTER.X;
someMatRight.M42 = handPoseRight.Position.Y;// + MOVINGPOINTER.Y;
someMatRight.M43 = handPoseRight.Position.Z + MOVINGPOINTER.Z;
var diffNormPosX = (MOVINGPOINTER.X) - someMatRight.M41;
var diffNormPosY = (MOVINGPOINTER.Y) - someMatRight.M42;
var diffNormPosZ = (MOVINGPOINTER.Z) - someMatRight.M43;
MOVINGPOINTER = MOVINGPOINTER + -(current_rotation_of_torso_pivot_right* (diffNormPosX));
MOVINGPOINTER = MOVINGPOINTER + -(current_rotation_of_torso_pivot_up* (diffNormPosY));
MOVINGPOINTER = MOVINGPOINTER + (current_rotation_of_torso_pivot_forward* (diffNormPosZ));

MOVINGPOINTER.X += SC_Update.OFFSETPOS.X;
MOVINGPOINTER.Y += SC_Update.OFFSETPOS.Y;
MOVINGPOINTER.Z += SC_Update.OFFSETPOS.Z;

//Matrix matrixerer = _rightTouchMatrix;
//matrixerer.Invert();

Quaternion quater;
Quaternion.RotationMatrix(ref handMatrix, out quater);
var xq = quater.X;
var yq = quater.Y;
var zq = quater.Z;
var wq = quater.W;

var pitchaHand = (float)Math.Atan2(2 * yq * wq - 2 * xq * zq, 1 - 2 * yq * yq - 2 * zq * zq) * (180 / Math.PI);
var yawaHand = (float)Math.Atan2(2 * yq * wq - 2 * xq * zq, 1 - 2 * yq * yq - 2 * zq * zq) * (180 / Math.PI);
var rollaHand = (float)Math.Atan2(2 * yq * wq - 2 * xq * zq, 1 - 2 * yq * yq - 2 * zq * zq) * (180 / Math.PI);

var pitchTouchR = (float)(Math.PI * (grabrotX - pitchaHand) / 180.0f);
var yawTouchR = (float)(Math.PI * (grabrotY - yawaHand) / 180.0f);
var rollTouchR = (float)(Math.PI * (grabrotZ - rollaHand) / 180.0f);

Matrix rotatingMatrixForTouchR = SharpDX.Matrix.RotationYawPitchRoll((float)yawTouchR, (float)pitchTouchR, (float)rollTouchR);
//Matrix rotatingMatrixForTouchR = Matrix.Scaling(1.0f) * Matrix.RotationX(pitchTouchR) * Matrix.RotationY(yawTouchR) * Matrix.RotationZ(rollTouchR);

var pitch = (float)(Math.PI * (-SC_Update.RotationGrabbedX) / 180.0f);
var yaw = (float)(Math.PI * (SC_Update.RotationGrabbedY) / 180.0f);
var roll = (float)(Math.PI * (SC_Update.RotationGrabbedZ) / 180.0f);

var rotatingMatrixForGrabber = SharpDX.Matrix.RotationYawPitchRoll(yaw, pitch, roll);




handMatrix = _player_r_hand_grab[0][0]._arrayOfInstances[0].current_pos;// * finalRotationMatrix;
//Quaternion quater;
Quaternion.RotationMatrix(ref handMatrix, out quater);

var rayDirForward = sc_maths._getDirection(SharpDX.Vector3.ForwardRH, quater);
rayDirForward.Normalize();
var rayDirUp = sc_maths._getDirection(SharpDX.Vector3.Up, quater);
rayDirUp.Normalize();
var rayDirRight = sc_maths._getDirection(SharpDX.Vector3.Right, quater);
rayDirRight.Normalize();

//handMatrix = _player_rght_hnd[0][0]._arrayOfInstances[0].current_pos;
var current_handposRR = new Vector3(MOVINGPOINTER.X,//_player_r_hand_grab[0][0]._arrayOfInstances[0].current_pos.M41,
MOVINGPOINTER.Y,//_player_r_hand_grab[0][0]._arrayOfInstances[0].current_pos.M42,
MOVINGPOINTER.Z);                //_player_r_hand_grab[0][0]._arrayOfInstances[0].current_pos.M43);

MOVINGPOINTER = current_handposRR + (rayDirForward* _grab_rigid_data.grabHitPointLength);
handMatrix = _player_r_hand_grab[0][0]._arrayOfInstances[0]._TEMPPOSITION* finalRotationMatrix;
var pitchTouchRer = (float)(Math.PI * ((float)SC_Update.RotationX4Pelvis) / 180.0f);
var yawTouchRer = (float)(Math.PI * ((float)SC_Update.RotationY4Pelvis) / 180.0f);
var rollTouchRer = (float)(Math.PI * ((float)SC_Update.RotationZ4Pelvis) / 180.0f);

var rotter = SharpDX.Matrix.RotationYawPitchRoll((float)yawTouchRer, (float)pitchTouchRer, (float)rollTouchRer);
Matrix matrixerer = handMatrix;
matrixerer.M41 = MOVINGPOINTER.X;
matrixerer.M42 = MOVINGPOINTER.Y;
matrixerer.M43 = MOVINGPOINTER.Z;
matrixerer.M44 = 1;

body.Position = new JVector(MOVINGPOINTER.X, MOVINGPOINTER.Y, MOVINGPOINTER.Z);
Quaternion.RotationMatrix(ref matrixerer, out quater);
JQuaternion _other_quat = new JQuaternion(quater.X, quater.Y, quater.Z, quater.W);
var matrixIn = JMatrix.CreateFromQuaternion(_other_quat);
body.Orientation = matrixIn;*/




//Matrix matrixerer = _rightTouchMatrix;
//matrixerer.Invert();





/*Quaternion.RotationMatrix(ref grabbedBodyMatrix, out quater);
xq = quater.X;
yq = quater.Y;
zq = quater.Z;
wq = quater.W;

var pitchaHand1 = (float)Math.Atan2(2 * yq * wq - 2 * xq * zq, 1 - 2 * yq * yq - 2 * zq * zq) * (180 / Math.PI);
var yawaHand1 = (float)Math.Atan2(2 * yq * wq - 2 * xq * zq, 1 - 2 * yq * yq - 2 * zq * zq)  * (180 / Math.PI);
var rollaHand1 = (float)Math.Atan2(2 * yq * wq - 2 * xq * zq, 1 - 2 * yq * yq - 2 * zq * zq)  * (180 / Math.PI);

var pitchTouchR = (float)(Math.PI * (pitchaHand1) / 180.0f); // - (grabrotX- pitchaHand)
var yawTouchR = (float)(Math.PI * (yawaHand1) / 180.0f);
var rollTouchR = (float)(Math.PI * (rollaHand1) / 180.0f); // - (grabrotZ - rollaHand)

Matrix rotatingMatrixForTouchR = SharpDX.Matrix.RotationYawPitchRoll((float)yawTouchR, (float)pitchTouchR, (float)rollTouchR);
//Matrix rotatingMatrixForTouchR = Matrix.Scaling(1.0f) * Matrix.RotationX(pitchTouchR) * Matrix.RotationY(yawTouchR) * Matrix.RotationZ(rollTouchR);
*/
//var pitch = (float)(Math.PI * (-SC_Update.RotationGrabbedX) / 180.0f);
//var yaw = (float)(Math.PI * (SC_Update.RotationGrabbedY) / 180.0f);
//var roll = (float)(Math.PI * (SC_Update.RotationGrabbedZ) / 180.0f);
//var rotatingMatrixForGrabber = SharpDX.Matrix.RotationYawPitchRoll(yaw, pitch, roll);




//handMatrix = _player_r_hand_grab[0][0]._arrayOfInstances[0].current_pos;// * finalRotationMatrix;
//Quaternion quater;






/*float timeSinceStart = (float)(DateTime.Now - SC_Update.startTime).TotalSeconds;


var pitcher = (float)(Math.PI * (pitchaHand - touchRX) / 180.0f);
var yawer = (float)(Math.PI * (yawaHand - touchRY) / 180.0f);
var roller = (float)(Math.PI * (rollaHand - touchRZ) / 180.0f);
var rotatingMatrixF = SharpDX.Matrix.RotationYawPitchRoll(yawer, pitcher, roller);

totalDiffX = pitcher;
totalDiffY = yawer;
totalDiffZ = roller;

//rotatingMatrixF *= RotatingMatrixForPelvis;

var pitch = (float)(Math.PI * (-SC_Update.RotationGrabbedX) / 180.0f);
var yaw = (float)(Math.PI * (SC_Update.RotationGrabbedY) / 180.0f);
var roll = (float)(Math.PI * (SC_Update.RotationGrabbedZ) / 180.0f);
var rotatingMatrixForGrabber = SharpDX.Matrix.RotationYawPitchRoll(yaw, pitch, roll);

///Quaternion.RotationMatrix(ref rotatingMatrixF, out quaterNion);

Quaternion.RotationMatrix(ref handMatrix, out quater);

var rayDirForwardGrab = sc_maths._getDirection(SharpDX.Vector3.ForwardRH, quater);
rayDirForwardGrab.Normalize();
var rayDirUpGrab = sc_maths._getDirection(SharpDX.Vector3.Up, quater);
rayDirUpGrab.Normalize();
var rayDirRightGrab = sc_maths._getDirection(SharpDX.Vector3.Right, quater);
rayDirRightGrab.Normalize();

Vector3 grabPos = new Vector3(grabbedBodyMatrix.M41,
grabbedBodyMatrix.M42,
grabbedBodyMatrix.M43);

Vector3 lookAt = Vector3.TransformCoordinate(Vector3.ForwardRH, rotatingMatrixHand);
Vector3 up = Vector3.TransformCoordinate(Vector3.Up, rotatingMatrixHand);

Quaternion currentRot;
Quaternion.RotationMatrix(ref grabbedBodyMatrix, out currentRot);
matrixerer = Matrix.Scaling(1.0f)* grabbedBodyMatrix * Matrix.RotationY(totalDiffY);
matrixerer.Invert();
*/
/*Quaternion quatYaw = new Quaternion(0, , 0,1);
quatYaw.Normalize();
//quatYaw *= currentRot;
//quatYaw.Normalize();
currentRot *= quatYaw;
currentRot.Normalize();


//Quaternion quatPitch = new Quaternion(pitchaHand, 0, 0, 1);
//currentRot *= quatPitch;
//currentRot.Normalize();
                                                                
Matrix.RotationQuaternion(ref currentRot, out matrixerer);*/

//Vector3 lookAt = Vector3.TransformCoordinate(rayDirForwardGrab, rotatingMatrixHand);
//Vector3 up = Vector3.TransformCoordinate(rayDirUpGrab, rotatingMatrixHand);

//Vector3 positionDisplacement = Vector3.TransformCoordinate(MOVINGPOINTER, rotatingMatrixHand);

// Finally create the view matrix from the three updated vectors.

//matrixerer = Matrix.LookAtRH(MOVINGPOINTER, MOVINGPOINTER + lookAt, up);
//matrixerer.Invert();

/*//https://stackoverflow.com/questions/29571093/sharpdx-vector3-transform-method-doesnt-seem-to-rotate-vector-correctly
Vector3 eyePos = MOVINGPOINTER;// new Vector3(0, 1, 0);
Vector3 target = MOVINGPOINTER + rayDirForward; //Vector3.Zero;



Quaternion lookAt = Quaternion.LookAtRH(eyePos, target, rayDirUp);
lookAt.Normalize();

Vector3 newForward = Vector3.Transform(rayDirForward, lookAt);
newForward.Normalize();

Vector3 newUp = Vector3.Transform(rayDirUp, lookAt);
newUp.Normalize();


//MOVINGPOINTER += newForward;

Matrix matrixerer = Matrix.LookAtRH(MOVINGPOINTER, MOVINGPOINTER + newForward, newUp);*/

//matrixerer *= _rightTouchMatrix * finalRotationMatrix;





//JUNK OF MICROSOFT NOT WORKING - the piece of shits of microsoft.
//https://stackoverflow.com/questions/2929255/unable-to-launch-onscreen-keyboard-osk-exe-from-a-32-bit-process-on-win7-x64
//https://www.dreamincode.net/forums/topic/174949-open-on-screen-keyboard-in-c%23/
/*Process[] p = Process.GetProcessesByName(Path.GetFileNameWithoutExtension(OnScreenKeyboardExe));

if (p.Length == 0)
{
    // we must start osk from an MTA thread
    if (Thread.CurrentThread.GetApartmentState() == ApartmentState.STA)
    {
        ThreadStart start = new ThreadStart(StartOsk);
        Thread thread = new Thread(start);
        thread.SetApartmentState(ApartmentState.MTA);
        thread.Start();
        thread.Join();
    }
    else
    {
        StartOsk();
    }
}
else
{
    // there might be a race condition if the process terminated 
    // meanwhile -> proper exception handling should be added
    //
    SendMessage(p[0].MainWindowHandle, WM_SYSCOMMAND, new IntPtr(SC_RESTORE), new IntPtr(0)); //MainWindowHandle
}*/


//StartOsk();

/*string windowsKeyboard = "osk";

foreach (Process clsProcess in Process.GetProcesses())
{
    if (clsProcess.ProcessName.ToLower().Contains(windowsKeyboard.ToLower()))
    {
        break;
    }
    else
    {
        Process proc = new Process();
        proc.StartInfo.FileName = windowsKeyboard + ".exe";
        proc.Start();
        break;
    }
}*/

/* ProcessStartInfo startInfo = new ProcessStartInfo();
 startInfo.CreateNoWindow = false;
 startInfo.UseShellExecute = true;
 startInfo.WorkingDirectory = @"c:\WINDOWS\system32\";
 startInfo.FileName = "osk.exe";
 startInfo.Verb = "runas";
 startInfo.WindowStyle = ProcessWindowStyle.Normal;

 try
 {
     using (Process process = Process.Start(startInfo))
     {
         process.WaitForExit();
     }
 }
 catch (Exception)
 {
     //throw;
 }*/



//System.Diagnostics.Process.Start("osk.exe");
/*string windir = Environment.GetEnvironmentVariable("windir");

Process p = new Process();
p.StartInfo.FileName = windir + @"\System32\cmd.exe";
p.StartInfo.Arguments = "/C " + windir + @"\System32\osk.exe";
p.StartInfo.CreateNoWindow = true;
p.StartInfo.UseShellExecute = false;
p.Start();
p.Dispose();*/
